{"meta":{"title":"靖待的技术博客","subtitle":"小清新IT旅程 | 为中华之崛起而读书","description":"成长中的工程师|计算机|数据挖掘|软件开发|互联网","author":"靖待","url":"https://hubojing.github.io"},"pages":[{"title":"404 Not Found","date":"2021-05-06T08:52:03.419Z","updated":"2019-09-13T11:15:01.135Z","comments":false,"path":"/404.html","permalink":"https://hubojing.github.io//404.html","excerpt":"","text":"据说只有好看的人才能看到这个网页……\\ (≧▽≦) /~啦啦啦那你就听听音乐吧~喵~ .article-header { padding: 0; padding-top: 26px; border-left: none; text-align: center; } .article-header:hover { border-left: none; } .article-title { font-size: 2.1em; } strong a { color: #747474; } .article-meta { display: none; } .share { display: none; } .ds-meta { display: none; } .player { margin-left: -10px; } .sign { text-align: right; font-style: italic; } #page-visit { display: none; } .center { text-align: center; height: 2.5em; font-weight: bold; } .article-entry hr { margin: 0; } .pic { text-align: center; margin: 0; } .pic br { display: none; } #container .article-info-post.article-info { display: none; } #container .article .article-title { padding: 0; }","raw":null,"content":null},{"title":"推广","date":"2021-05-06T08:52:03.420Z","updated":"2020-09-04T03:51:31.055Z","comments":false,"path":"advertising/index.html","permalink":"https://hubojing.github.io/advertising/index.html","excerpt":"","text":".s{ margin: 0 auto; text-align:center; font-size: 20px; } CPP教程MFC傻瓜式教程C++面向对象程序设计（侯捷）笔记C++程序设计之兼谈对象模型 Java教程再学Java 计算机图形学教程计算机图形学学习笔记计算机图形学实验 数据结构系列栈队列线性表树图 Linux系列一天一点linuxlinux C语言结构体Linux C语言指针与内存Linux C语言编程基本原理与实践 博客系列Hexo多机同步Hexo博客进阶优化Hexo搭建再记录yelee –&gt; hueman主题更换将Hexo+Github博客同步托管至codingHexo优化·年轻就是折腾Hexo+Github博客搭建中出现的问题及解决方法 过去给自己挖的坑计算机图形学实验 DigitalOcean推广注册链接https://m.do.co/c/9d7b9b7b94ba Give \\$50, Get \\$25Everyone you refer gets \\$50 in credit over 30 days. Once they’ve spent \\$25 with us, you’ll get \\$25.通过上述链接注册DigitalOcean，你会得到50美元（30天内使用）。如果你花了25美元，我也会得到25美元，双赢嘿嘿嘿。附上教程：DigitalOcean购买服务器教程","raw":null,"content":null},{"title":"","date":"2021-05-06T08:52:03.420Z","updated":"2019-09-13T11:15:01.564Z","comments":true,"path":"categories/index.html","permalink":"https://hubojing.github.io/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"留言板","date":"2021-05-06T08:52:03.420Z","updated":"2019-09-13T11:15:01.565Z","comments":true,"path":"comment/index.html","permalink":"https://hubojing.github.io/comment/index.html","excerpt":"","text":".note{ margin: 0 auto; text-align:center; font-size: 25px; color: purple; } 欢迎提出您的建议和留言♪(^∇^*)，若希望及时收到回复，请记得填写邮箱哦！","raw":null,"content":null},{"title":"朋友们","date":"2022-06-29T01:54:13.190Z","updated":"2022-06-29T01:54:13.190Z","comments":false,"path":"friends/index.html","permalink":"https://hubojing.github.io/friends/index.html","excerpt":"","text":"我的生活博客: 私戳我发链接（咩哈哈哈哈我就要卖关子）以下是友链。 按添加时间排序Ultron Blog: https://blog.wixy.cn/Airing: http://ursb.me/Hundred: http://txiner.top/二赛君: http://www.ersaijun.cn/邱锦锋: http://blog.qiujinfeng.com/Waydrow: https://blog.zhengzw.me/Jrotty: https://zezeshe.com/Shawn: https://blog.just666.com/早茶月光: http://www.zcmol.com/Linux之路: http://rebootcat.com/王振镇: https://townwang.com/Shawnzeng: https://shawnzeng.com/小柒博客: https://blog.52itstyle.vip/不正经数据科学家: http://frankchen.xyz/秦简: http://nolongerwait.com/小尾巴: http://xiaowiba.com/WangMao’s Blog: https://blog.wangmao.me/马攀: https://mapan.tech/陆恒：https://luheng.site/anlance: http://www.anlan.club/mathor: https://www.wmathor.com/111qqz: https://111qqz.com/辣椒の酱: https://removeif.github.io/宇宙湾: https://www.yuzhouwan.com/王基书: http://www.loveffc.cn/Cheng: https://blog.hce-space.top/CtrlCV博客: https://www.hack-er.cn/itsNekoDeng: https://nekodeng.gitee.io/飞鸿踏雪: https://blog.yuanpei.me/Mengru: https://mengru.space/PatrLean: https://patrlean.github.io/梦中小城: https://www.llh1347.com/anle: https://anlenotes.com/谢的blog: www.jhxie.com/ 停更MOxFIVE: http://moxfive.xyz/ (最近更新日期为2016.06)sopuy: http://sopuy.com/ (最近更新日期为2017.06) 失效小忆: https://blog.ihitun.com/ (博客无法访问 2022.04)太阳尚远: http://blog.yeqianfeng.me/ (域名疑似失效 2022.04)该问: http://theask.cn/ (博客无法访问 2022.04)水番林: http://www.sfantree.com/ (域名已过期 2022.04)梦的小窝: https://rm-rf.moe/ (博客无法访问 2022.04)刘毅: http://www.61mon.com/ (域名疑似失效 2022.04)柚子鬼: http://www.pokerboy.cn/ (博客疑似失效 2022.04)ZeeCoder: http://zcheng.ren/ (博客无法访问 2022.04)技术宅男子: http://itruke.com/ (博客无法访问 2022.04)镜花水月: http://www.5ih5.com.cn/ (博客无法访问 2022.04)PWYQ Space: https://www.yanqing-wu.com/blog/ (博客无法访问 2022.04)刘伟: https://darrenliuwei.com/ (博客无法访问 2022.04)w4ctech: https://i.w4ctech.cn/ (博客无法访问 2022.04)XlnCheng: http://www.wangxc.xyz/ (博客无法访问 2022.04)KlausChan: https://www.klauslaura.com/ (博客无法访问 2022.04)Sato: https://www.mongona.com/ (博客无法访问 2022.04)梦独吟: https://blog.datealive.top/ (博客无法访问 2022.04)猫のレインボー島: https://www.annko.cn/ (博客无法访问 2022.04)","raw":null,"content":null},{"title":"微言","date":"2021-05-06T08:52:03.426Z","updated":"2020-09-04T03:51:42.918Z","comments":true,"path":"littletalk/index.html","permalink":"https://hubojing.github.io/littletalk/index.html","excerpt":"","text":"心情、脑洞、疑问、几句话笔记等，随手记！（您在此页的评论都将转移至留言板中） —&gt;&gt;&gt;曾立过但至今未实现的Flag 写一个博客主题 计算机图形学课程没学完，实验没做完计算机图形学实验 小白学CV系列 数据挖掘十大经典算法复现 我倒要看看哪一年才能把Flag给补完咯","raw":null,"content":null},{"title":"","date":"2021-05-06T08:52:03.426Z","updated":"2019-09-13T11:15:01.886Z","comments":false,"path":"tags/index.html","permalink":"https://hubojing.github.io/tags/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"ABOUT","date":"2021-05-06T08:52:03.420Z","updated":"2020-12-24T03:07:50.926Z","comments":false,"path":"about/English/index.html","permalink":"https://hubojing.github.io/about/English/index.html","excerpt":"","text":".title{ font-size: 22px; font-weight: bold; color: #5F339E; margin:auto; } .nice{ margin: 0 auto; color: green; margin:auto; } .btn{ color: black; border: 2px solid #4CAF50; /* Green */ padding: 15px 32px; text-align: center; text-decoration: none; display: inline-block; font-size: 16px; border-radius: 12px; -webkit-transition-duration: 0.4s; /* Safari */ transition-duration: 0.4s; float:right; } .btn:hover { background-color: #4CAF50; /* Green */ color: white; } &gt;&gt;&gt; About me Communication Engineering==&gt;Software Engineering A girl like IT. &gt;&gt;&gt; About this blog Blog some notes and thinking about my learning. &gt;&gt;&gt; Research Field Spatiotemporal Data Mining, Recommendation System &gt;&gt;&gt; Hobby Computer Absolute Music Sports Writting Reading Animation: Detective Conan, Naruto Just do IT and enjoy IT!","raw":null,"content":null},{"title":"关于","date":"2022-08-09T15:27:03.146Z","updated":"2022-08-09T15:27:03.146Z","comments":false,"path":"about/Chinese/index.html","permalink":"https://hubojing.github.io/about/Chinese/index.html","excerpt":"","text":".title{ font-size: 22px; font-weight: bold; color: #5F339E; margin:auto; } .nice{ margin: 0 auto; color: green; margin:auto; } .btn{ color: black; border: 2px solid #4CAF50; /* Green */ padding: 15px 32px; text-align: center; text-decoration: none; display: inline-block; font-size: 16px; border-radius: 12px; -webkit-transition-duration: 0.4s; /* Safari */ transition-duration: 0.4s; float:right; } .btn:hover { background-color: #4CAF50; /* Green */ color: white; } 自律使人自由 ——致自己2020~2022正确的学习 清醒的头脑 强大的内心 ——致自己2019沉下来补知识，一行行敲代码，带脑子想问题，一步步理清晰。 ——致自己2017~2018学技术要折腾！ ——致自己2015~2016 &gt;&gt;&gt; 关于我 通信工程==&gt;软件工程。 从小对科技有无限向往，对技术人无比敬佩，立志成为一名有为的科技工作者。 我虽不才，愿努力成才。 &gt;&gt;&gt; 关于本博客 一个小白的学习历程。有时候是笔记，有时候是想法，有时候是细枝末节的记录。 希望在不停的撰写中，提升自己的技术水平，也记录一段青春的奋斗之路。 崇敬热爱技术的大神们，希望和各位计算机爱好者交流探讨。 &gt;&gt;&gt; 目前 AI研究算法工程师-NLP方向小萌新一枚 以下是感兴趣的方向： 算法方向：推荐算法、NLP算法、时空数据挖掘 开发方向：数据挖掘、大数据开发、后端开发，对全栈也感兴趣 熟悉的编程语言：C++, Java, Python 未来想成为 算法 + 开发 + 研究 + 工程 的 综合型 研发工程师，最终往 架构师 发展 &gt;&gt;&gt; 榜样 钱学森 &gt;&gt;&gt; 兴趣爱好轻音乐：无词胜有词唱歌：音乐我的生活写作：07年开始写博，记录有感而发。可能骨子里是个追求诗意的人？15年开始写技术博客记录从零栈到全栈的成长（过程也许比较长）运动：球类（羽毛球、乒乓球） &amp; 游泳 &amp; 舞蹈 &amp; 跑步 &amp; …数码：时常关注，折腾不息读书：青春正读书，欢迎荐书（出版书籍）音视频剪辑：水平只能满足本人需求动漫：名侦探柯南 火影忍者游戏：王者荣耀（菜狗一条）等主流游戏、怀旧系：泡泡堂（长期招募队友）、跑跑卡丁车（长期招募队友）等 性格 以前还是个可爱的小清新 自从当了程序员 // talk is cheap 崇尚 真诚待人，坚守原则。 己所不欲，勿施于人。 穷则独善其身，达则兼济天下。 通讯 可直接在文章下方评论区或留言板块留言，我会回复（填写邮箱会收到回复邮件提醒）。 邮箱： hubojing@outlook.com Github主页： Jinger 知乎： 靖待 网易云音乐： 靖待 微博： 靖待小太阳 其它 本人录制的考研英语电台每日一句（现已更新550多期）： 每日一句 博客时间线 @timeline{ 2015@item{ 11月6日博客诞生，采用yilia主题，多说评论系统，极简图床随后不久更换为yelee主题域名为：http://hubojing.github.io } 2016@item{ 4月6日博客同步托管至Coding（现在的腾讯云开发者平台）外网用域名：http://hubojing.github.io内网用域名：http://hubojing.coding.me（已失效） } @item{ 10月博客双语化（给全部博文添加英译）图片丢失，更换为七牛图床 } @item{ 11月博客魔改优化调各种细节 } 2017@item{ 1月3日更换为hueman主题 } @item{ 3月26日更换博客域名为.me域名http://www.hubojing.me （现在已弃用） } @item{ 4月5日多说倒闭，评论系统更换为网易云跟帖 } @item{ 5月27日评论系统更换为Disqus } @item{ 10月8日博客玩崩，重新搭建最早的项目commit被冲掉，github绿点丢失双语化搁置 } @item{ 11月19日实现博客多机同步 } @item{ 12月13日采用github图床 } 2018@item{ 3月更换回域名：https://hubojing.github.io域名加上https每篇文章点击数丢失 } @item{ 3月29日采用Valine评论系统 } @item{ 3月30日再重新搭建，github绿点再丢失更换为indigo主题历史评论（多说、disqus）已导入，但由于LeanCloud限制，之前的评论均显示为导入当天时间（2018-3-30） } @item{ 5月27日原【关于】下的评论已转移到留言板 } 2019@item{ 1月15日填写邮箱，可收到回复邮件 } 2022@item{ 1月14日更换评论系统为Waline系统 } } 微信公众号：玩代码（停更）愿技术改变生活，技术造福人类。愿与大家共同进步。","raw":null,"content":null}],"posts":[{"title":"兴趣点推荐（POI Recommendation）论文泛读","slug":"兴趣点推荐（POI Recommendation）论文泛读","date":"2022-08-14T14:34:04.000Z","updated":"2022-08-14T16:16:24.228Z","comments":true,"path":"2022/08/14/兴趣点推荐（POI Recommendation）论文泛读/","link":"","permalink":"https://hubojing.github.io/2022/08/14/兴趣点推荐（POI Recommendation）论文泛读/","excerpt":"　　论文泛读不定期更新。 ","text":"论文泛读不定期更新。 Hierarchical Multi-Task Graph Recurrent Network for Next POI Recommendation分层多任务图循环网络用于下一个兴趣点推荐阅读时间：2022-08-11 论文概况SIGIR2022Nicholas Lim, Bryan Hooi, See-Kiong Ng,Yong Liang Goh, Renrong Weng, Rui TanPDF 笔记解决问题：数据稀疏（用户-兴趣点矩阵稀疏）提出HMT-GRN算法，该方法通过在多任务设置中学习不同的低稀疏用户区域矩阵来缓解数据稀疏问题，GRN模块同时对顺序依赖关系和全局时空POI-POI关系进行建模，然后对不同的区域和兴趣点分布采用分层束搜索（HBS），随着空间粒度增加来分层减少搜索空间并且预测下一个兴趣点。本文HBS通过减少搜索空间来提高效率，与穷举法相比速度提升5~7倍。本文还提出了一种新颖的选择层来预测下一个兴趣点用户是否曾经访问过，在个性化和探索之间取得平衡。 HMT-GRN 个人备注：把bean search运用在POI推荐中；对于已访问过的POI设置了一个选择概率。","raw":null,"content":null,"categories":[{"name":"论文","slug":"论文","permalink":"https://hubojing.github.io/categories/论文/"}],"tags":[{"name":"POI","slug":"POI","permalink":"https://hubojing.github.io/tags/POI/"},{"name":"兴趣点推荐","slug":"兴趣点推荐","permalink":"https://hubojing.github.io/tags/兴趣点推荐/"}]},{"title":"实体链接（EL）论文泛读","slug":"实体链接（EL）论文泛读","date":"2022-08-14T08:26:09.000Z","updated":"2022-08-14T09:12:54.752Z","comments":true,"path":"2022/08/14/实体链接（EL）论文泛读/","link":"","permalink":"https://hubojing.github.io/2022/08/14/实体链接（EL）论文泛读/","excerpt":"　　论文泛读不定期更新。 ","text":"论文泛读不定期更新。 Entity linking meets deep learning: Techniques and solutions实体链接遇到深度学习：技术和解决方法阅读时间：2022-08-11 论文概况2021年 IEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERINGCCF-AWei Shen, Yuhan Li, Yinan Liu, Jiawei Han,Fellow, IEEE, Jianyong Wang,Fellow, IEEE, Xiaojie YuanPDF 笔记从三个方面展开：嵌入（Embedding）、特征（Feature）、算法（Algorithm）Embedding包括字（word）嵌入、Mention嵌入、实体（entity）嵌入、对齐（aligenment）嵌入。特征包括先验流行度、表面形式相似度、类型相似度、上下文相似度、主题连贯性。算法包括MLP、基于图的算法、强化学习。给出了十种广泛使用的实体链接数据集。未来方向：多源异质文本数据、NER和EL联合、更高级的语言模型、EL模型鲁棒性 Multilingual Autoregressive Entity Linking多语言自回归实体链接阅读时间：2022-08-11 论文概况2022年3月 Transactions of the Association for Computational Linguistics SCI Q1Nicola De Cao, Ledell Wu, Kashyap Popat, Mikel Artetxe,Naman Goyal, Mikhail Plekhanov, Luke Zettlemoyer,Nicola Cancedda, Sebastian Riedel1,6, Fabio PetroniFacebook AIPDFCODE 笔记提出mGENRE系统，它是一个用于多语言实体链接问题的序列到序列的系统，用于解析特定语言mention到多语言知识库。对于特定语言的mention，mGENRE以自回归的方式从左到右逐个（left-to-right, token-by-token）标记预测目标实体的名称。自回归公式有效地交叉编码关于字符串和实体名称，用来捕获比标准点积更多的交互。它还可以在大知识库中进行快速搜索，即使对于没出现在mention表中和不用大规模向量索引的mention也是如此。虽然先前的MEL工作对每个实体使用单一表示，但我们匹配尽可能多的多语言的实体名称，这允许利用源输入和目标名称之间的语言连接。此外，在完全没有训练数据的语言的零样本设置中，mGENRE将目标语言视为在预测时被边缘化的潜在变量。这使平均准确度提高了50%以上。 mGENRE","raw":null,"content":null,"categories":[{"name":"论文","slug":"论文","permalink":"https://hubojing.github.io/categories/论文/"}],"tags":[{"name":"实体链接","slug":"实体链接","permalink":"https://hubojing.github.io/tags/实体链接/"}]},{"title":"BERT","slug":"BERT","date":"2022-08-09T12:59:07.000Z","updated":"2022-08-09T15:22:39.168Z","comments":true,"path":"2022/08/09/BERT/","link":"","permalink":"https://hubojing.github.io/2022/08/09/BERT/","excerpt":"　　笔记 ","text":"笔记 论文背景2019年 谷歌 Jacob DevlinNAACL-HLT会议-NLP顶会PDFCODE 摘要重点 BERT(Bidirectional Encoder Rpresentation from Transformers) BERT 旨在通过联合调节所有层的左右上下文，从未标记的文本中预训练深度双向表示。因此，预训练的 BERT 模型可以通过一个额外的输出层进行微调，从而为各种任务（例如问答和语言推理）创建最先进的模型，而无需大量特定任务架构修改。 问题提出 在下游任务中有两种方法使用预训练语言表示模型，一种是基于特征（feature-based）方法，一种是微调（fine-tuning）。本文认为现有技术限制了预训练表示的能力，尤其是微调方法。主要限制是标准语言模型是单向的，这限制了预训练可以使用的架构。例如，在 OpenAI GPT 中，作者使用从左到右的架构，其中每个标记只能关注Transformer的自注意力层中的先前标记。 这样的限制对于句子级任务来说是次优的，并且在将基于微调的方法应用于令牌级任务（例如问答）时可能非常有害，在这些任务中，从两个方向整合上下文至关重要。 贡献点 我们解释了语言表示中双向预训练的重要性。不像之前的模型在预训练中使用双向语言模型，BERT使用掩码语言模型（masked language model）来预训练深度双向表示。也和以前使用从左到右和从右到左LM独立训练再浅层连结的方法不同。 预训练表示减少了许多特定任务的繁重工程架构。BERT是第一个基于表示模型微调并在一系列句子级别和token级别任务中实现SOTA性能的。 BERT在11个NLP任务中实现SOTA性能，代码开源。 相关工作基于特征的无监督方法（如ELMo）、微调无监督方法（如OpenAI GPT） 模型架构 两阶段：预训练+微调。 预训练阶段，模型在不同的预训练任务中使用未标注数据训练。 微调阶段，首先使用预训练参数初始化，所有的参数使用下游任务中的标注数据进行微调。即使每一个下游任务使用相同的预训练参数初始化，它们还是有单独的微调模型。如图为一个问答示例。 BERT 记层数（Transformer块）为L，隐藏层为H，自注意力头数量为A。实验有两种模型规模：一种是$BERT_{BASE}$（L=12，H=768，A=12，总参数为110M）；另一种是$BERT_{LARGE}$（L=24，H=1024，A=16，总参数为340M）。 为压缩目的，$BERT_{BASE}$选择了和Open AI一样的模型规模。但是BERT Transformer使用了双向自注意力，GPT Transformer使用的是受限的自注意力，它的每个token只能获取它左边的上下文。 每一个token都以[CLS]开头。句子对会一起打包到一个序列中，分割句子使用两种方式。一是使用token[SEP]，二是在每个token中加入一个学习过的embedding表示它属于句子A还是句子B。如图1所示，输入embedding记为E，最后隐藏向量的[CLS]记为C，第i个输入token的最后的隐藏向量记为$T_i$。对于给定的标记，其输入表示是通过对相应的标记、段和位置嵌入求和来构建的。这种结构的可视化可以在图2中看到。 BERT输入表示 预训练BERT任务1：Masked LM 随机掩盖掉部分输入的tokens，然后预测这些被掩盖的tokens。这个过程记为“masked LM”(MLM)，类似于文学里的完形填空。与掩码标记对应的最终隐藏向量被送到词汇表上的softmax输出，就像在标准 LM 中一样。本文选择15%的tokens进行掩盖。由于[MASK] token在微调阶段不存在，所以预训练阶段和微调阶段不匹配。为了减轻影响，当选中第i个token时，按三条规则进行掩码：（1） 80%时间使用[MASK] token（2）10%时间选择随机token（3）10%时间token不变然后，使用交叉熵损失和$T_i$预测原始token。 任务2：下一个句子预测（NSP） 问答QA和自然语言推理（NLI）都是基于对两个句子关系的理解做的，而语言模型不能直接捕捉它。为了训练一个能理解句子关系的模型，我们预先训练一个二值化的下一个句子预测任务，该任务可以从任何单语语料库中轻松生成。在之前的工作中，只有句子嵌入被转移到下游任务， BERT 转移所有参数来初始化最终任务模型参数。 微调BERT 微调很简单，因为Transformer中的自注意力机制允许 BERT 通过交换适当的输入和输出来对许多下游任务进行建模——无论它们涉及单个文本还是文本对。对于涉及文本对的应用程序，一种常见的模式是在应用双向交叉注意力之前独立编码文本对。BERT使用自我注意力机制来统一这两个阶段，因为使用自我注意对连接的文本对进行编码有效地包括了两个句子之间的双向交叉注意力。 对于每个任务，我们只需将任务特定的输入和输出插入BERT，端到端微调所有参数。","raw":null,"content":null,"categories":[{"name":"论文","slug":"论文","permalink":"https://hubojing.github.io/categories/论文/"}],"tags":[{"name":"BERT","slug":"BERT","permalink":"https://hubojing.github.io/tags/BERT/"},{"name":"NLP","slug":"NLP","permalink":"https://hubojing.github.io/tags/NLP/"}]},{"title":"samba映射","slug":"samba映射","date":"2022-07-31T10:02:47.000Z","updated":"2022-07-31T10:43:45.737Z","comments":true,"path":"2022/07/31/samba映射/","link":"","permalink":"https://hubojing.github.io/2022/07/31/samba映射/","excerpt":"　　更方便地使用服务器。 ","text":"更方便地使用服务器。 目的 将服务器资源可通过windows进行管理，很方便。 安装 在ubuntu服务器上12apt-get install sambasamba --version 配置1sudo vim /etc/samba/smb.conf 在文件末尾追加：12345678910111213security = share[share]path = /home/想映射的文件夹/available = yesbrowsealbe = yespublic = yesguest ok = yeswritable = yescreate mask = 0664directory mask = 0664force user =rootvalid users = 用户名 配置samba密码：12sudo touch /etc/samba/smbpasswdsudo smbpasswd -a 用户名 之后输入密码。 配置samba服务：12sudo /etc/init.d/samba restartsudo service smbd restart windows映射操作 此电脑-计算机-映射网络驱动器 填写”\\服务器ip\\文件夹名称”，勾选使用其他凭据连接，输入用户名和密码。 完成。","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"https://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"samba","slug":"samba","permalink":"https://hubojing.github.io/tags/samba/"}]},{"title":"JingSLink","slug":"JingSLink","date":"2022-07-03T13:26:39.000Z","updated":"2022-07-04T06:39:33.468Z","comments":true,"path":"2022/07/03/JingSLink/","link":"","permalink":"https://hubojing.github.io/2022/07/03/JingSLink/","excerpt":"　　简单开发一个截图保存并返回链接的小工具JingSLink　　JingPic迎来重构版JingSLink　　自用简陋小工具系列 ","text":"简单开发一个截图保存并返回链接的小工具JingSLink JingPic迎来重构版JingSLink 自用简陋小工具系列 前言 写markdown文章时，贴图这件事儿真的很麻烦。我需要把图片手动保存到对应文件夹，再手动在文章里引入图片链接。所以很多时候我能不配图就不配图。多年前为了方便插入图床链接，用MFC做了个自用小工具JingPic。但是它是基于保存了的图片进行的操作，将图片转移到需要的位置。后期也没有维护，操作上依然不够简洁。比如我更喜欢直接截图能自动保存到指定位置，这样就减少一步自己保存的操作。 自己定制还是最爽的，我想要什么功能我自己开发好了。而且这个小工具开发起来也很简单，几十行很快就写完了。 首先，要起个名字，以前的叫JingPic，这个重构版就叫JingSLink（Jinger Screenshot for Link）吧。 需求 能够截图 截图能保存到指定文件夹中 截图完成后，自动将图片相对路径复制到剪贴板 有exe可执行文件 技术 语言：Python 用到的库：tkinter, PIL, keyboard, pyperclip 实现 一开始我是想自己实现截图操作的，后来一想，我平日用QQ截图最多，它功能齐全，那我直接调用它的截图不就好了。 所以，大体实现思路如下： 监听键盘，捕捉QQ截图快捷键ctrl+alt+a，并设置一个结束键ctrl。 使用PIL库的ImageGrab读取截图。 弹出一个输入框，输入图片名称。 输入框 拼凑出图片完整链接，将图片保存到该地址。 拼凑出hexo博文中所需的图片插入相对地址，复制到剪贴板。 当然，为了不每次都打开pycharm编译器，得导出一个exe文件。 打包exe： 安装pyinstaller。 在pycharm中，1234pyinstaller -F main.pypyinstaller -F -w main.py#（-w是取消dos窗口）pyinstaller -F -w --icon=ico main.py# (ico为图标的文件名，与dist目录为同目录) 最后生成的exe文件在dist文件夹下。 代码https://github.com/hubojing/JingSLink 后期优化 如有必要： 一些异常情况的提示 右下角有最小化托盘，右键有设置和退出菜单 可扩展性：可以更改文件夹路径 可扩展性：可以更改图片路径格式（绝对路径/相对路径） 换pyqt框架 参考资料http://tkdocs.com/tutorial/index.html","raw":null,"content":null,"categories":[{"name":"软件开发","slug":"软件开发","permalink":"https://hubojing.github.io/categories/软件开发/"}],"tags":[{"name":"截图","slug":"截图","permalink":"https://hubojing.github.io/tags/截图/"},{"name":"链接","slug":"链接","permalink":"https://hubojing.github.io/tags/链接/"},{"name":"markdown","slug":"markdown","permalink":"https://hubojing.github.io/tags/markdown/"},{"name":"软件开发","slug":"软件开发","permalink":"https://hubojing.github.io/tags/软件开发/"}]},{"title":"TEMN","slug":"Paper_TEMN","date":"2022-07-03T05:03:28.000Z","updated":"2022-07-04T09:37:11.387Z","comments":true,"path":"2022/07/03/Paper_TEMN/","link":"","permalink":"https://hubojing.github.io/2022/07/03/Paper_TEMN/","excerpt":"　　陆续上架前几个月写的库存　　主题增强记忆网络个性化兴趣点推荐 ","text":"陆续上架前几个月写的库存 主题增强记忆网络个性化兴趣点推荐 论文背景 Topic-Enhanced Memory Networks for Personalised Point-of-Interest Recommendation 主题增强记忆网络个性化兴趣点推荐 KDD 2019PDFCODE 关键词：推荐系统；神经网络；主题建模 问题提出 现有问题：数据稀疏；现有算法使用一个单一向量刻画用户偏好限制了表达和可解释性。 架构 Topic-Enhanced Memory Network (TEMN) TEMN是一个统一的混合模型，利用TLDA和外部记忆网络以及神经注意机制来捕捉用户的全局和细粒度偏好。 TEMN 三部分组成：记忆网络，TLDA和地理建模部分。 前两部分相互联系，用于建模从基于领域的记忆网络中学到的非线性交互（通过历史记录）以及从主题模型中学到的全局偏好。 每一部分分别对应不同的损失函数，进行联合训练。 实验数据集 微信朋友圈签到数据集（未开源） 数据集 基线 MF BPR LDA CML LRML TEMN(GPR) 保留了记忆模块，将TLDA替换为LDA，去掉了地理模块。 LORE ST-RNN TEMN(SPR) 完整TEMN模型使用微信（SPR）数据 GeoMF TLDA TEMN(CPR) 完整TEMN模型使用微信（GPR）数据性能 性能 贡献点 提出一种融合基于领域和全局的用户偏好的端到端深度学习框架。 在兴趣点推荐中设计了能融合多种上下文信息的灵活架构，并使之能在多种推荐场景应用。 提出一种结合监督和非监督学习的混合模型，并利用了记忆网络和主题模型。通过相互学习机制，模型还能得出用户在受记忆网络影响的主题上的概率分布。 在微信数据集上进行模型验证，超过基线模型。 通过在TEMN中引入神经注意机制和主题模型，POI推荐的可解释性得到了显著提高。","raw":null,"content":null,"categories":[{"name":"论文","slug":"论文","permalink":"https://hubojing.github.io/categories/论文/"}],"tags":[{"name":"推荐算法","slug":"推荐算法","permalink":"https://hubojing.github.io/tags/推荐算法/"},{"name":"兴趣点推荐","slug":"兴趣点推荐","permalink":"https://hubojing.github.io/tags/兴趣点推荐/"}]},{"title":"Office三件套笔记","slug":"office三件套笔记","date":"2022-07-02T01:42:53.000Z","updated":"2022-07-03T14:53:23.000Z","comments":true,"path":"2022/07/02/office三件套笔记/","link":"","permalink":"https://hubojing.github.io/2022/07/02/office三件套笔记/","excerpt":"　　陆续上架前几个月写的库存　　没想到有一天还会写这篇笔记　　记录一些稍高阶的玩法　　写论文后遗症 ","text":"陆续上架前几个月写的库存 没想到有一天还会写这篇笔记 记录一些稍高阶的玩法 写论文后遗症 Word目录样式修改：引用-目录-自定义目录-修改（选项旁边），为不同级别目录进行格式自定义。 域代码快捷键： Alt+F9。 别在百度里搜陈年包浆老帖了，官方文档不香吗官方文档 图注Seq（序列）域图注序号标注 域代码1图&#123;SEQ 图 \\r 1&#125; 即 “图1” 交叉引用交叉引用后要添加或者删除怎么更新： 在要插入的前一行最后的换行符前回车，添加文献 ctrl+A，右键“更新域”。 多引用（形如格式[2, 5]）原域代码：1&#123;REF_Ref56957053 \\r \\h *MERGRFORMAT &#125;&#123;REF_Ref56957053 \\r \\h *MERGRFORMAT &#125; 修改域代码：1&#123;REF_Ref56957053 \\r \\h \\#&quot;[0&quot; \\*MERGRFORMAT &#125;&#123;REF_Ref56957053 \\r \\h \\#&quot;0]&quot; \\*MERGRFORMAT &#125; 手动加中间的逗号。 Excel excel 如何合并相同项并累加https://zhidao.baidu.com/question/75402048.html 如何把2个excel的数据表连起来https://zhidao.baidu.com/question/577259682.html PPT待续..","raw":null,"content":null,"categories":[],"tags":[{"name":"office","slug":"office","permalink":"https://hubojing.github.io/tags/office/"},{"name":"word","slug":"word","permalink":"https://hubojing.github.io/tags/word/"},{"name":"excel","slug":"excel","permalink":"https://hubojing.github.io/tags/excel/"},{"name":"ppt","slug":"ppt","permalink":"https://hubojing.github.io/tags/ppt/"}]},{"title":"毕业","slug":"毕业","date":"2022-06-29T02:29:24.000Z","updated":"2022-08-14T16:23:53.438Z","comments":true,"path":"2022/06/29/毕业/","link":"","permalink":"https://hubojing.github.io/2022/06/29/毕业/","excerpt":"　　一篇六月底就写好、八月中才发布的毕业总结。 ","text":"一篇六月底就写好、八月中才发布的毕业总结。 技术博客只谈学习和技术。每次我在这里写这种总结文的时候，必须时刻提醒自己这句话，否则我的思路一旦打开，就不知道飞到哪里去了。 对比本科结束时写的总结，首先得给自己这三年打个分。 从学习的角度来说，给个65分吧。(其它方面可能要远高于本科时期) 相比于本科时期自己200%投入到学习中的那种专注和疯狂，读研期间的我看起来要“正常”许多。那时候需要用忙碌和疲惫来使自己放松（这句话也许听起来十分奇怪），而读研后的我尝试着逐步和自己和解了。 最大收获 如果说本科期间我的最大收获是学会了自学的话，读研期间的最大收获有二：学会了读书、科研入了门。 本科时，每个学期都会给自己强行列个读书方向，比如这学期重点是推理方面、日本作家系列，下学期重点是历史方面、国内作家系列，再下个学期看点俄国文学、美国文学之类的。书是看了一些，但是往往得到最多的是完成任务的快感，并没有真正得到读书的快乐。 读研时，再没有给自己布置强制性的读书任务。而是在微信读书上凭着兴趣，任意读之。慢慢地，我竟喜欢上了这种读书的感觉，只要是在空隙时间，我都会打开看看书。就这样，我读完了一本又一本书，读完书后的感受各不相同，也许会受主人公的命运而牵绊，也许会通过书籍体验了不同的人生而倍感快乐。我也遇到了一本改变我三观的重要书籍：三体。 读三体完全是因为看新闻说这本书要被改编成影视了，为了防止影视先入为主的剧情，我决定在影视剧开播前把原著给看完了。三体的三大本着实很厚，但是30个小时读下来也一点不亏。从大的角度上，我对整个人类的观点产生了巨大变化，从个人方面，也改变了我对生活的态度。 罗马假日里说，要么读书，要么旅行，身体和心灵总有一个要在路上。(You can either travel or read, but either your body or soul must be on the way.) 我比较宅，对旅游无感，所幸还可以通过读书来认识世界。三年读了几十本书，虽然不多，但是每本都留下了一些笔记和感悟，很多书里的语句也在影响和改变我的行为和看法。当然也有不少技术书，大都是电子版（省钱哈哈哈），希望自己对技术的追求永不停止吧。 学术方面，现在回想起来本科毕业时自己的科研底子很薄弱，是一个科研小白，和现在的学弟学妹们的基础比不了。本科时的学习基本上也都是自己的单打独斗，总体上是一段孤独的旅程。读研给了我一个接触学术和前沿的机会，而三年后的我能够在科研方面入了门，离不开我导的指引、组内的讨论、实习实践和网上大神们的知识共享。 技术 （更新插一句）这篇文章其它部分六月底就写好了，唯独技术这一节我总觉得写地短了浅了点，拖到如今才完善这一段。 从通信转到软工，我终于算个科班出身啦哈哈哈。为了缩小和大家的差距，三年里蹭了些课、看了些书、刷了些题，但总归还是觉得自己水平不咋地。但是一想到自己未来还有一辈子可以去学这些东西就令人神往。 本科关注开发技术，读研关注算法技术。读研之前，在方向的求索问题上，我走了不少弯路，进行过很多简单的尝试。那段时间我依然存在着新手都有的困惑，纠结于编程语言的选择。虽然干着C++开发的活，但因为市场上C++求职岗位比Java岗位数量少，而担忧起C++的未来发展。现在回头来想，还是杞人忧天了些，C++随着AI浪潮的崛起，反而迎来了新的上升期。而我现在也不再纠结于编码语言本身，摆正了对它的看法，终于明白了“编程语言只是工具”这句话的含义。读研之后，由于学术培养，我开始了算法研究之路。科研初期也是跌跌撞撞的，由于比很多同学起步晚，只有自己多看多学才能弥补差距。一开始阅读英文文献也很不习惯很慢，但好在考研期间坚持了几年的英语电台每日一句录制，英语的基础还没有荒废，随着习惯逐渐养成，基本摆脱了中文翻译的操作（其实主要是懒得打开翻译器……所以懒有时候也有帮助哈哈哈哈）。在方向的选择上，研一上学期在看了不多的文献后，大致了解了数据挖掘的基础情况，结合我们组内的具体科研状况、对当时就业市场的观察（CV卷得惨绝人寰、NLP落地尚不明朗、搜广推相对靠近业务且竞争小于前两者，当然，2022年的搜广推已经不是这样了！）以及个人兴趣推动（非常好奇网易云私人FM推荐是如何做的），我鼓足勇气和导师提出了推荐算法方向，没想到的是，我导当场就同意了。结合我们组的特点，我做的是兴趣点推荐算法。想想读研以前，我深感自己没有一个特定的领域导致无法深耕，而现在，我终于拥有了一个自己的研究方向，终于可以在知乎上写上“xxx方向”了哈哈哈。 兴趣点推荐方向本身，隶属于推荐算法大家庭，所以，为了更好地学习推荐算法，我也不断学习机器学习（包括深度学习）的基础知识，积极了解前沿学术和工业界动态。在这里还有个小插曲，当年入学前，有好几个已经读研的同学们纷纷给我提醒：慎入深度学习深坑！（后来我知道了他们都是搞CV的，求职的时候被卷死……后来怒转开发）但是在我心中已经有了这种印象——远离深度学习，否则会变得不幸，哈哈哈哈哈。幸好我当时拉跨的AI基础让我觉得推荐算法和深度学习这个词看起来很远，所以选了推荐算法时还在沾沾自喜我应该没有入坑吧？属实是TOO YOUNG TOO NATIVE，直到后来阅读每一篇顶会论文都是深度学习时，我才明白天下就是深度学习的天下啊……其实现在的我回看这个观点，我不会认为对，但也并没有全错。深度学习本身只是一种方法，它只有结合到某种场景、某个业务或者某个领域才会产生价值。 推荐算法目前来说依然是个不错的方向，至少现在它是一个能够落地、有实际应用的方向。但随着互联网增速放缓进入存量时代，搜广推是否仍和之前一样蕴含巨大价值也许值得讨论。在我秋招的那段日子里，我看到过一句话：“这个世界上最聪明的一些头脑，都在哄骗他人去点击广告。（大意如此）”那天这句话对我还是有不小的触动，也许我们做的这些算法是否已经足够甚至过量了呢？信息茧房的危害正在蚕食互联网中的我们，同质化的算法打着个性化的招牌过分挖掘用户隐私的同时，也使人们沉迷在算法里，渐渐抹杀掉很多的创造力。比如网易云，当初是因为喜欢它去研究推荐算法，可是有一天开始，它的私人FM让我觉得不准了，远远不如18年那会儿了，但去搜它官方公开的技术模型，反而迭代地更加复杂，更加高深了。这件事让我常常想，我们的推荐算法会不会早就“过拟合”了？不过，技术本身是不应该附带偏见的，对推荐算法本身我始终以纯粹的技术观点去分析和学习。 秋招拿的一些offer大都是推荐算法方面的，但是最后我选择了NLP算法。除了一些现实因素的考虑（离家较近）外，选择NLP也是选择了更多的挑战，而我比较享受未知。当然，和推荐算法关联最大的就是NLP算法，两者关联紧密，而NLP算法的应用场景会更大更多，未来总归是NLP的天下（虽然现在是CV的）。所以，打好NLP算法的基础十分重要。我总觉得机器人时代离我们不远了。认知智能在我们这一代一定会实现。另一方面，我选择的领域，让我感觉很有社会价值和意义，这和我建立博客以来就写在副标题上的“为中华之崛起而读书”似乎又贴近了一步。 即将步入工作岗位，希望在工作中能更好地打磨自己的技术水平，提高编码效率。 自律 关于自律这件事，远远比不上当年了。即使挂着“自律使人自由”的标语催促着自己上进，也无法再像原来一样。同样都是我，现在的我卷不过以前的我（哈哈哈哈人老了）。我为此不断地想这到底是为什么。是我现在的学习态度不够端正了吗？应该不是。是我变得更加懒惰了吗？好像也不是。后来我可能知道了答案：自律只是一种实现目标的手段，当缺乏必须高度自律才能做到的目标时，自律本身失去了意义。这可能也和我的学习方法改变有关。 三年里，我尝试了一些新的学习方法。以前我按照要趁早的学习模式，干什么都会在一开始就行动。但是久而久之，我不仅有了些强迫症（比如会反复检查作业、格式、要求之类），这无意义地耗费了大量宝贵的时间，心情也不悦（明知没必要但依然会反复检查），而且由于完成的时间很充沛，慢慢地形成了拖延症，而我在很长的时间里将这归结于我是一个慢性子。所以，我开始尝试要求自己不要一开始就行动，而是要在最短的时间内以最高的效率去学习（俗称DDL学习法，滑稽.jpg）。我知道这样是有风险的，毕竟学渣基本上都是DDL学习法的忠实拥护者。但是幸好，我带着意识地去主动尝试，目的是追求高效率，而不是拖到最后不得不做的被动，两者的自我驱动是不一样的。比如，以前上学七点一刻到校，我总是六点就被闹钟叫醒。可是同学们大都六点半才起。这是我第一次意识到自己效率低下或者说为了保证不迟到过于苛刻了。而这损失的半小时睡眠可能使白天的工作效率更低了。读研时，我经常要求自己不要在规定时间提前太多，我要看看我是否拥有这种弹性。事实证明，这些提前的时间就是没必要的，在现有时间内，我也能有条不紊地完成计划。DDL很好地克制住了我反复检查的毛病，而这多出来的时间，应该去做其它更有意义的事情。当然，这个度是难以把握的，一不小心就堕入学渣之境。我现在更加认可两种方法的结合，根据任务的紧急程度和优先级来合理使用这些方法。 自律应该是自然而然的，当心中有执念时，会主动地做到。如果自律成为一种负担，也许已经是本末倒置了，倒不妨想想自己到底要干什么。 （更新插一句）比如，明天又是周一了，为了早上精力充沛地去上班，我现在就关掉电脑去睡觉了！上班让我作息自律了哈哈哈哈哈哈。","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"毕业","slug":"毕业","permalink":"https://hubojing.github.io/tags/毕业/"},{"name":"总结","slug":"总结","permalink":"https://hubojing.github.io/tags/总结/"}]},{"title":"《推荐系统：原理与实践》笔记","slug":"《推荐系统：原理与实践》笔记","date":"2022-06-15T02:41:55.000Z","updated":"2022-06-15T09:06:01.591Z","comments":true,"path":"2022/06/15/《推荐系统：原理与实践》笔记/","link":"","permalink":"https://hubojing.github.io/2022/06/15/《推荐系统：原理与实践》笔记/","excerpt":"　　砖头书笔记（自用） ","text":"砖头书笔记（自用） 前言 有几本砖头书在图书馆里我不断续借，网上又没有PDF，现在要毕业了，只有勉强把它看完了…… 高级论问题和应用 推荐系统中的冷启动问题太常见不说了。 抗攻击推荐系统只要指恶意评论。 组推荐系统针对一组用户推荐，而不是单一用户。 多标准推荐系统如，用户可以给予情节、音乐、特效等对电影进行评分。在多标准推荐系统中，用户可能根本没有给出整体评分。 推荐系统中的主动学习鼓励用户输入评分以完善系统的机制。例如，用户可能会为某些物品评分获得奖励。因此，必须明智地选择由特定用户进行评分的物品。如，某用户已评价大量动作片，那么要求该用户去评价另一部动作电影对预测其他的动作电影评分帮助不大，并且对预测属于无关种类的电影评分的帮助甚至更少。另一方面，要求用户评价不太热门种类的电影将对预测这种类型的电影评分有显著帮助。当然，如果用户被要求评价无关的电影，他不一定能够提供反馈，因为他可能根本没有看过那部电影。（此处举例我存疑）因此，在推荐系统的主动学习问题中有许多在其他问题领域（如分类问题）没有遇到的有趣权衡问题。 推荐系统中的隐私问题 保护隐私的推荐算法。 应用领域 推荐系统评估评估设计的总体目标 精确性 覆盖率 置信度和信任度 新颖度 惊喜度 多样性 健壮性和稳定性 可扩展性离线评估的精确性指标独立预测评分的精确性 RMSE, MAE RMSE计算时用的是误差的平方，所以它更加显著地被大的误差值或者异常值所影响。一些被预测失败的评分会显著地破坏RMSE方法。在各种评分的预测健壮性非常重要的应用中，RMSE可能是一个更加合适的方法。另一方面，当评估的异常值有限时，MAE能更好地反映精确性。RMSE主要的问题是它不是平均误差的真实反映，而且它又是会导致有误导的结果。通过相关性评估排名 Spearman等级相关系数 肯德尔等级相关系数通过效用评估排名 基于效用方法的总体目标就是给出用户可能找到推荐系统排名的有用程度的简单量化。这种方法下隐含的一个重要准则就是相对于物品的总量而言，推荐列表是简短的。因此一个具体评分的效用大部分情况下应该基于在推荐列表中相关性高的物品。这种情况下，RMSE指标有一个缺点，因为它对低排名物品和那些高排名物品赋予了同样的权重。 NDCG, ARHR（平均逆命中率） ARHR也被称作是平均倒数排名（MRR） 通过ROC曲线评估排名抵抗攻击的推荐系统攻击类型 随机攻击 均值攻击 bandwagon攻击 流行攻击 爱/憎攻击 反向bandwagon攻击 探测攻击 分段攻击健壮推荐设计策略 用CAPTCHA防止自动攻击 使用社会信任 设计健壮的推荐算法 排名学习 pointwise pairwise: BPR, Eigen Rank, pLPA, CR listwise: NDCG, MRR 多臂赌博机算法组推荐系统 协同和基于内容的系统 基于知识的系统多标准推荐系统 基于近邻的方法 基于集成的方法 无整体评分的多标准系统推荐系统中的主动学习 基于异质性的模型 基于性能的模型推荐系统中的隐私 基于冷凝的隐私 高维数据的挑战 应用领域 门户内容个性化 计算广告与推荐系统 互惠推荐系统 基本思想是当考虑多个具有不对称兴趣的利益相关人的推荐的效用时，推荐的任务会发生改变。如在线约会的互惠推荐系统。 用户意识到交易的成功取决于另一方的许可。另一方是互惠环境中的“物品”。 用户和物品在系统中可能只出现一次，在一次成功的事物后它们可能永远不会重现。冷启动问题在互惠场景中更加显著。 方法： 利用混合方法在这些方法中，两个传统的推荐方法被构造出来，分别对应着两个互惠方的喜好。然后，这两个互惠方的预测被组合起来。 利用链路预测方法当冷启动问题不是很严重或者可以用来自类似用户和物品的数据来增加评分数据时，可以在系统中采用链路预测方法。","raw":null,"content":null,"categories":[{"name":"推荐系统","slug":"推荐系统","permalink":"https://hubojing.github.io/categories/推荐系统/"}],"tags":[{"name":"推荐算法","slug":"推荐算法","permalink":"https://hubojing.github.io/tags/推荐算法/"}]},{"title":"2022年最新教程！Hexo + GitLab搭建个人博客详细教程","slug":"Hexo+GitLab搭建个人博客最新教程","date":"2022-06-08T02:19:16.000Z","updated":"2022-06-11T11:19:36.000Z","comments":true,"path":"2022/06/08/Hexo+GitLab搭建个人博客最新教程/","link":"","permalink":"https://hubojing.github.io/2022/06/08/Hexo+GitLab搭建个人博客最新教程/","excerpt":"　　不是标题党，我自己刚写的，保证最新。（2022年6月） ","text":"不是标题党，我自己刚写的，保证最新。（2022年6月） 前言（可不看） 以前生活博客放在Gitee上，每次命令部署后还得登录网页管理端手动更新一下Page服务才能完成一次部署，着实很麻烦。懒人要贯彻到底，为追求效率，弃之转GitLab。 幸好生活博客都是我静悄悄自娱自乐写写东西，没推广，百度也搜不到，基本没人看，损失的点击数不心疼哈哈哈。 但是，全网我竟然搜不到一篇像样的GitLab搭建博客教程（很多都是三四年前的，过时了，都不教GitLab的runners如何自建的。），反观Github搭建博客教程可是满天飞！ 是GitLab，不是GitHub，看错请在下方评论哈哈哈。 不能忍，我只好自己写了。（草稿箱里这几个月堆积的其它文章都还没发……属实是和博客纠纠缠缠多少年） Hexo 前置条件：安装Node.js和Git。12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 本地能运行http://localhost:4000/ ，ok。 GitLab官网指引 看英文版！ 看英文版！ 看英文版！ 重要的事情说三遍！我中途看了一下中文版，被坑了好几次。那个中文网的配置文件不对，部署疯狂报错！！！（中英文文档版本竟然不一致，我也是醉了…） GitLab账户注册。 创建一个username.github.io的项目，或者把已有项目更名为此，可以选择Private。 Settings &gt; CI/CD &gt; Runners &gt; Enable，开启Runners。 重点来了！！！ Pipeline failing? To keep GitLab spam and abuse free we ask that you verify your identity.Until then, shared runners will be unavailable. Validate your account or use your own runners. GitLab要求上传身份证（经评论区指正，是信用卡号）才给用shared runners。Validate是不可能validate的。现有的教程到这里都是直接用共享runners，我猜前几年可能GitLab无需验证这一步吧。 既然还有自建Runners这种方法当然要试一试了。 GitLab自建Runners 首先，这个东西是干什么用的呢？Github部署博客时，是在本地hexo g生成好静态页面，然后把静态页面hexo d部署上去。而GitLab不同，它要把所有源文件push到项目中，当push后，GitLab会自动调用一个叫runners的玩意儿帮项目自动生成页面并部署。它本身是个优化的东西，叫CI/CD，也就是持续集成、持续交付和持续部署，用它可以很好地实现自动化开发。 介绍完毕，开始安装。 安装https://docs.gitlab.com/runner/install/ 以windows为例。https://docs.gitlab.com/runner/install/windows.html 创建一个文件夹，如E:\\GitLab-Runner。 下载二进制文件。 限制文件夹写权限。(我没特地设置) 打开cmd。 注册一个runner。 怎么注册呢？这里也是一个坑巨多的地方。想建博客的小伙伴们就别想那么多了，跟着我一步步走就完事了。 注册Runnerhttps://docs.gitlab.com/runner/register/index.html 在刚才下载好文件的文件夹中打开cmd运行 1.\\gitlab-runner.exe register 输入URL。这个URL在哪找呢？Settings-CI/CD Settings-Runners-Specific runners，里面就有URL。一般是https://gitlab.com/ 。 输入token。 输入描述。可不写。 输入tag。最好不写。否则还得后面还得去设置untag。 输入备注。可不写。 输入runner执行器。我写的shell。结束注册。如果是docker，后面还要输入默认image。 怎么验证我的runner是好的呢？ Settings-Runners-Specific runners下方出现刚才建立的Runner，并且前面有个绿色的圆圈。如果是感叹号，证明上面的过程出现问题。 配置 使用node --version检查Node.js版本，记录下来（比如v16.y.z）。 在项目中增加.gitlab-ci.yml文件，其中将16替换为自己Node.js的版本： 1234567891011121314151617image: node:16-alpinecache: paths: - node_modules/before_script: - npm install hexo-cli -g - npm installpages: script: - npm run build artifacts: paths: - public rules: - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH 将hexo文件夹push到GitLab。一旦push完成，GitLab自动部署开始。 当GitLib CI成功部署，username.gitlab.io就能运行了。 （可选）如果希望检查生成的站点资产(html、css、js等)，可看https://docs.gitlab.com/ee/ci/pipelines/job_artifacts.html 。 注意，网站看起来似乎能运行了，结果把GitLab账号退出后再点击网站就看不到了，而是转到GitLab要登录。这是因为项目本身是Private的，需要把Page页的权限设置为Public！ Settings-&gt;General-&gt;Visibility, project features, permissions，仓库权限保持private，下面的Pages选项改为Everyone。 一些报错解决方法 GitLab push报错。12345cd existing_repogit initgit remote add origin https://gitlab.com/username/username.gitlab.io.gitgit branch -M maingit push -uf origin main 报错：1! [remote rejected] main -&gt; main (pre-receive hook declined) 这是因为main分支默认是protected，需要在Settings-Repository-Protected branch，修改权限。 部署时runner报错。 ERROR: Job failed (system failure): prepare environment: failed to start process: exec: “pwsh”: executable file not found in %PATH%. 转到GitLab运行程序的安装目录，如E:\\GitLab-Runner。记事本打开config.toml文件，并用powershell替换pwsh，如下所示：12[[runners]] shell = &quot;pwsh&quot; 改为：1shell = &quot;powershell&quot; 后记 换到GitLab部署后，总体效率是不错，一次push就完事儿，还把源文件备份的工作一道给解决了，而不是像Github部署那样，项目内只存页面。而且page打开速度似乎也比Gitee快不少。缺点就是GitLab自动部署比自己手动hexo d的速度要慢。 把生活博客切换修好花了我大半天时间，踩了好多坑（之前没咋用过GitLab）。干脆把过程整理出来造福有需要的人吧。知识共享、开源精神yyds！ (难得我还为此博文专门做了一张封面图，虽然很丑)","raw":null,"content":null,"categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://hubojing.github.io/tags/博客/"},{"name":"GitLab","slug":"GitLab","permalink":"https://hubojing.github.io/tags/GitLab/"}]},{"title":"关于TensorFlow和Pytorch的GPU版本配置问题","slug":"关于TensorFlow和Pytorch的GPU版本配置问题","date":"2022-04-18T14:13:41.000Z","updated":"2022-04-19T08:46:49.288Z","comments":true,"path":"2022/04/18/关于TensorFlow和Pytorch的GPU版本配置问题/","link":"","permalink":"https://hubojing.github.io/2022/04/18/关于TensorFlow和Pytorch的GPU版本配置问题/","excerpt":"　　相关安装问题汇总 ","text":"相关安装问题汇总 关于版本是否适配python, cuda, cudnn, tf/torch版本需要适配！组合不是任意的，建议先看好版本再去下载。 下载链接显卡驱动下载https://www.nvidia.com/Download/index.aspx?lang=en-us cuda版本下载https://developer.nvidia.com/cuda-downloadscuda历史版本下载https://developer.nvidia.com/cuda-toolkit-archivecudnn版本下载https://developer.nvidia.com/rdp/cudnn-downloadcudnn历史版本下载https://developer.nvidia.com/rdp/cudnn-archive python+cuda+cudnn+tf版本适配查询https://www.tensorflow.org/install/source_windowspytorch+cuda版本适配查询https://pytorch.org/get-started/previous-versions/ pytorch下载https://pytorch.org/get-started/locally/pytorch历史版本https://pytorch.org/get-started/previous-versions/ 环境分清本地环境和虚拟环境。在cmd直接安装的是在本地环境里，若在虚拟环境中安装，需要在cmd中切换到虚拟环境。12345678# 创建新的conda环境conda create -n poiRec python=3.7# 进入虚拟环境activate poiRec# 退出当前conda环境conda deactivate删除环境（先退出该环境）conda remove -n poiRec --all conda一键配环境12345678# cuda 不写版本自动选择conda install cudatoolkit=10.0# cudnn 不写版本自动选择conda install cudnn=7.0.5# 安装tfconda install tensorflow-gpu==1.15.0# 安装pytorch 复制官方命令 注意版本适配conda install pytorch torchvision torchaudio cudatoolkit=11.3 -c pytorch CUDA查看CUDA版本C:\\Windows\\System32&gt;nvidia-smi.execmd中在C:\\Windows\\System32下1nvidia-smi Tensorflow-gpu查看版本12import tensorflow as tfprint(tf.__version__) 查看设备123456import tensorflow as tfgpus = tf.config.experimental.list_physical_devices(device_type='GPU')cpus = tf.config.experimental.list_physical_devices(device_type='CPU')print(gpus)print(cpus) 查看是否有GPU1234import tensorflow as tf gpu_device_name = tf.test.gpu_device_name()print(gpu_device_name) 查看GPU是否可用1tf.test.is_gpu_available() 12345678from tensorflow.python.client import device_lib # 列出所有的本地机器设备local_device_protos = device_lib.list_local_devices()print(local_device_protos) # 只打印GPU设备[print(x) for x in local_device_protos if x.device_type == &apos;GPU&apos;] 查看GPU是否可用的第二种方法1234567891011121314151617181920import tensorflow as tf# 指定在cpu上运行with tf.device('/cpu:0'): cpu_a = tf.random.normal([10000, 1000]) cpu_b = tf.random.normal([1000, 2000]) cpu_c = tf.matmul(cpu_a, cpu_b)print(\"cpu_a:\", cpu_a.device)print(\"cpu_b:\", cpu_b.device)print(\"cpu_c:\", cpu_c.device)# 查看gpu是否可用print(tf.config.list_physical_devices('GPU'))# 指定在gpu上运行with tf.device('/gpu:0'): gpu_a = tf.random.normal([10000, 1000]) gpu_b = tf.random.normal([1000, 2000]) gpu_c = tf.matmul(gpu_a, gpu_b)print(\"gpu_a:\", gpu_a.device)print(\"gpu_b:\", gpu_b.device)print(\"gpu_c:\", gpu_c.device) 比较CPU和GPU运行时间1234567891011121314151617181920212223import tensorflow as tfimport timeitdef cpu_run(): with tf.device('/cpu:0'): cpu_a = tf.random.normal([10000, 1000]) cpu_b = tf.random.normal([1000, 2000]) c = tf.matmul(cpu_a, cpu_b) return cdef gpu_run(): with tf.device('/gpu:0'): gpu_a = tf.random.normal([10000, 1000]) gpu_b = tf.random.normal([1000, 2000]) c = tf.matmul(gpu_a, gpu_b) return ccpu_time = timeit.timeit(cpu_run, number=10)gpu_time = timeit.timeit(gpu_run, number=10)print(\"cpu:\", cpu_time, \" gpu:\", gpu_time) Pytorch-gpu查看版本1234import torchprint(torch.__version__) #查看pytorch版本print(torch.cuda_version) #查看cuda版本print(torch.cuda.is_available()) #查看cuda是否可用 装pytorch+CUDA1pip3 install torch==1.8.1+cu101 torchvision==0.9.1+cu101 -f https://download.py torch.org/whl/cu101/torch_stable.html 安装特定版本1pip install torch==1.1.0 -f https://download.pytorch.org/whl/torch_stable.html 12# 验证GPU是否能用print(\"torch.cuda.is_available():\", torch.cuda.is_available())","raw":null,"content":null,"categories":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"https://hubojing.github.io/categories/数据挖掘/"}],"tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://hubojing.github.io/tags/TensorFlow/"},{"name":"Pytorch","slug":"Pytorch","permalink":"https://hubojing.github.io/tags/Pytorch/"},{"name":"GPU","slug":"GPU","permalink":"https://hubojing.github.io/tags/GPU/"}]},{"title":"技术博客访问量超过十万","slug":"博客访问量超过十万","date":"2022-04-13T06:30:18.000Z","updated":"2022-04-13T09:27:05.196Z","comments":true,"path":"2022/04/13/博客访问量超过十万/","link":"","permalink":"https://hubojing.github.io/2022/04/13/博客访问量超过十万/","excerpt":"　　随手写之，有感而发。 ","text":"随手写之，有感而发。 这两天，我突然发现这个技术博客总访问量超过十万了。 记录 这个统计值不一定非常准确，它只记录了现在的域名的访问量，以前的域名访问量都丢失了。不过无所谓啦，记录这个访问量本来也就图一乐。 昨天访问友链的时候，不少技术博主都断更很久了。然而我私信一些博主问他们以后是否继续写博时，他们都不约而同的说，会的。我想，这是一个写博爱好者放不下的兴趣爱好吧。 访问量十万，用了七年。数据本身其实我并不在意，只是借着这个数字又可以水一篇博文(滑稽.jpg)。只是这个小小的博客也伴随我走过了七年的青春时光，可以说是我的朋友。 友链说，“一看你的博文都已经一百四五十篇了，我这输出太寒碜了&gt;_&lt;”，我这才自己数了数，还真有这么多。虽然这些文章多半没什么质量和价值，往往是一些零碎的笔记，不过是我相信好记性不如烂笔头而敲键盘又比用笔写字快的一种娱乐方式。我不爱说自己写文章是在“输出”，因为这个词给人一种写文章的人好像刻意要教给他人什么东西一样似的。我仅仅是用来“记录”，这个词似乎更合适一些。在许多时候，往往是我认为自己状态很颓废时，就会要求自己写点技术文章。其它时候大多是有感而发、灵感乍现，或者说，单纯是写出来让自己快乐，并不打算教给任何人什么东西，而且自己写的什么玩意儿心中有数（滑稽.jpg）。当然，如果碰巧有读者点开了某篇我的文章，并且觉得对自己有些帮助，那给我带来的就是双倍的快乐。 现在好多技术博主转型，也许去写公众号，也许去开课，也许去平台写文章，也许去直播写代码等等。或为名，或为利，或为能力提升。我写博呢，曾经是为了玩，现在主要也是为了玩哈哈哈哈。当然，要是玩的时候顺带着让我变强了就更好了（不要秃）！写博客这个事情变得越来越小众，不过还是留下了一些人。我总是会隔一段时间去逛逛，耐心的看看有些朋友在博客上写下的长篇大论，即使下面没有任何的评论，但是大家依然乐此不彼的更新着。只有在这种时候，似乎还能感受到一种互联网上的“慢”，一种即使没有观众也能自娱自乐的闲适。 我的博客是比较幸运的，偶尔能得到一些网友的关注，这些让我觉得我的博客始终活着。感谢一直关注我、随机关注我、默默关注我、误入点击的广大网友们。十万的点击量可能算不了什么，现在一篇公众号爆款文章的点击量随随便便就是十万，不过对于一个默默无闻的小博主来说依然是值得开心的事情，我喜欢这种慢悠悠到来的感觉。（不过要是写一个记录点击量贡献最大之人的功能，我猜结果肯定是我自己……） 最后，显然这篇文章不是在我的计划内，但是我实在压不住我这敲键盘的手上来就是一阵码字，索性就放任它了。","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://hubojing.github.io/tags/博客/"}]},{"title":"LSTPM","slug":"Paper_LSTPM","date":"2022-02-25T07:59:46.000Z","updated":"2022-02-25T13:55:09.816Z","comments":true,"path":"2022/02/25/Paper_LSTPM/","link":"","permalink":"https://hubojing.github.io/2022/02/25/Paper_LSTPM/","excerpt":"\n　　Where to Go Next: Modeling Long- and Short-Term User Preferences for Point-of-Interest Recommendation　　下一步去哪儿：用户长短期偏好建模用于兴趣点推荐\n","text":"Where to Go Next: Modeling Long- and Short-Term User Preferences for Point-of-Interest Recommendation 下一步去哪儿：用户长短期偏好建模用于兴趣点推荐 论文背景 Where to Go Next: Modeling Long- and Short-Term User Preferences for Point-of-Interest Recommendation 下一步去哪儿：用户长短期偏好建模用于兴趣点推荐 AAAI 2020 PDF CODE 问题提出 现有的基于RNN的方法在对用户的短期偏好建模时，要么忽略了用户的长期偏好，要么忽略了最近访问的兴趣点之间的地理关系，从而使得推荐结果不可靠。（所有基于RNN/LSTM的短期偏好建模方法都存在不能对两个非连续兴趣点之间的关系建模的缺点。） 为此，提出LSTPM（Long- and Short-Term Preference Modeling）架构。 架构 架构 它包含三个部分：长期偏好建模、短期偏好建模和预测模块。 长期偏好建模 核心：使用非局部神经操作（nonlocal neural operation）建模长期偏好。 以前的做法是直接用LSTM建模签到序列，但是对时间戳的认识不够深。比如人们会在中午时间去餐馆，在晚上去酒吧。所以本文提出了融合时间戳去捕捉时间敏感的属性。论文将一周分成48个段slot（24个工作日段和24个周末段）。计算每两个时间段之间用户签到的兴趣点集合相似性。重合的兴趣点越多，相似性越高。 所以历史签到轨迹就可以用这些时间段的兴趣点来表示，从而可以给这些时间段加权重。时间越近影响越大。 同时，地理方面计算了各轨迹的中心，计算中心与最近轨迹相似度，得出距离加权公式。 关键理解：非局部神经操作是什么意思呢？ 这个基本想法来自计算机视觉任务，论文Non-local Neural Networks它主张在输入信号的每一个位置的表示都通过全部位置的特征加权求和来对非局部的、长范围的依赖进行建模。$$y_i = \\frac{1}{C(x)}\\sum{_{\\forall j}f(x_i, x_j)g(x_j)}$$ f用来度量输出位置和周围其他位置的尺度（例如相似度），g是在位置j对于输入信号的表示（如卷积操作）。对于non-local behaiver来说，上式中的j是取遍所有可能的邻居，而对于local操作，如3*3的卷积来说，j只是取了周围8个像素点。 所以这里借鉴这个思想，将每个轨迹S都和历史轨迹和当前轨迹进行了分数计算，并除以标准化因素（全部特征求和）。 短期偏好建模 核心：使用联合方式的地理扩张LSTM建模短期偏好。 RNN本身只能用于序列建模，所以有人提出了跳步RNN。但是跳步RNN总是事先定义好和固定好的。所以提出geo-dilated LSTM根据地理和时间因素，来自动决定使用哪些相关输入。 geo-dilated LSTM 直观地，我们的地理扩张LSTM首先从当前轨迹中挑选poi作为输入，其具有由地理相关性确定的不同跳跃长度，然后通过扩展LSTM方案学习短期用户偏好。具体的算法论文给出了伪代码。 关键理解：那它究竟是怎么自动确定跳跃长度的呢？ 如上图所示，标准的LSTM序列是从l1-&gt;l2-&gt;l3-&gt;l4-&gt;l5。但是加入地理距离后发现，对于l3的前面两个兴趣点l1和l2来说，l1到l3的距离比l1到l2的距离要近，所以留下{l1, l2}路径。依次类推，留下{l1, l2}{l2, l5}路径，也就是两跳。所以，将LSTM设计为两跳。 最后的表示，是标准LSTM和geo-dilated LSTM的平均向量。 预测 将长短期偏好联结起来，设置一个W全部兴趣点的可训练投影矩阵参数。预测的是下一个时间段t内目标用户最可能访问的兴趣点。损失函数是负对数似然函数。 实验数据集 Foursqure, Gowalla 数据集 基线 LSTM Time-LSTM ST-RNN TMCA CARA DCRF DeepMove STGN评价指标 召回率Recall NDCG 性能基线对比 性能 消融实验 消融实验 参数分析 参数分析 跳数自动化 LSTM对比 贡献点 提出LSTPM框架解决上述存在的问题。 LSTPM受非局部操作（nonlocal operations）和dilated RNNs的启发，在构建长期偏好时，设计了非局部操作网络结构来探索历史和最近轨迹的时空联系。在克服RNN在短期用户偏好建模的限制时，提出geo-dilated RNN来全面探索非连续兴趣点间的地理联系。 在真实世界数据集上效果超过SOTA模型。 参考资料https://blog.csdn.net/py184473894/article/details/85322937https://zhuanlan.zhihu.com/p/85776086","raw":null,"content":null,"categories":[{"name":"论文","slug":"论文","permalink":"https://hubojing.github.io/categories/论文/"}],"tags":[{"name":"兴趣点推荐","slug":"兴趣点推荐","permalink":"https://hubojing.github.io/tags/兴趣点推荐/"},{"name":"LSTPM","slug":"LSTPM","permalink":"https://hubojing.github.io/tags/LSTPM/"},{"name":"Non-local Neural Networks","slug":"Non-local-Neural-Networks","permalink":"https://hubojing.github.io/tags/Non-local-Neural-Networks/"}]},{"title":"ASGNN","slug":"Paper_ASGNN","date":"2022-01-29T06:27:42.000Z","updated":"2022-02-09T09:22:32.359Z","comments":true,"path":"2022/01/29/Paper_ASGNN/","link":"","permalink":"https://hubojing.github.io/2022/01/29/Paper_ASGNN/","excerpt":"　　Attentive sequential model based on graph neuralnetwork for next poi recommendation　　基于图神经网络的注意力序列模型用于下一个兴趣点推荐 ","text":"Attentive sequential model based on graph neuralnetwork for next poi recommendation 基于图神经网络的注意力序列模型用于下一个兴趣点推荐 论文背景 Attentive sequential model based on graph neuralnetwork for next poi recommendation 基于图神经网络的注意力序列模型用于下一个兴趣点推荐 WWW21PDF 关键词：推荐系统、序列推荐、兴趣点推荐、图神经网络、注意力机制 现有问题 传统推荐方法忽略了用户短时偏好的动态变化。另外，许多现有方法不能完全探索兴趣点签到序列中复杂的联系和转变形式。 架构 提出ASGNN。 架构 ASGNN包括四部分：兴趣点签到序列图构建、特征表示学习、长短时偏好获取、兴趣点推荐 兴趣点签到序列图构建 G(V, E), V = (U, L)，U是用户集，L是兴趣点集。E包括用户-兴趣点边和兴趣点-兴趣点边。 图中边的权重代表用户在兴趣点的签到次数。 特征表示学习 图构建好后，使用GNN学习到用户和兴趣点的低维表示。这避免了马尔科夫决策过程需要的大量状态。 为了提高效率更新节点，使用了GGNN。 矩阵表示 长短时偏好获取 设计了两层注意力机制分别捕获长短时用户偏好。 兴趣点推荐 上一步得到的个性化用户偏好参数和兴趣点特征点乘，得到每个兴趣点分数，通过softmax标准化输出概率值。 训练的损失函数为交叉熵函数。 实验 围绕下列问题展开： ASGNN在序列兴趣点推荐任务上性能如何（基线对比） ASGNN的关键组件效果如何（组件实验） ASGNN的嵌入维度对推荐的影响（维度分析） ASGNN和基线在不同稀疏性的数据集上的性能如何（数据稀疏性影响） ASGNN学习兴趣点嵌入是否有效（可视化说明） 数据集 Gowalla, FourSquare, Brightkitehttps://snap.stanford.edu/data/loc-gowalla.htmlhttps://sites.google.com/site/yangdingqi/home/foursquare-datasethttps://snap.stanford.edu/data/loc-brightkite.html 数据集 基线 POP BPR FPMC HRM CPAM SHAN SRGNN评测指标 召回率Recall MRR 基线对比 性能 组件实验 组件分析 维度分析 维度分析 数据稀疏性影响 不同数据集 可视化说明 可视化 贡献点 提出ASGNN，它将用户签到行为视为图，并使用GNN局部方式学习用户行为模式和他们的偏好用于下一个兴趣点推荐。 设计了一个个性化层级注意力机制捕捉用户长短时偏好，并将它们适应于序列推荐。 实验结果显示ASGNN超过基线和部分SOTA模型。 代码https://github.com/HduDBSI/ASGNN","raw":null,"content":null,"categories":[{"name":"论文","slug":"论文","permalink":"https://hubojing.github.io/categories/论文/"}],"tags":[{"name":"推荐算法","slug":"推荐算法","permalink":"https://hubojing.github.io/tags/推荐算法/"},{"name":"兴趣点推荐","slug":"兴趣点推荐","permalink":"https://hubojing.github.io/tags/兴趣点推荐/"},{"name":"图神经网络","slug":"图神经网络","permalink":"https://hubojing.github.io/tags/图神经网络/"},{"name":"注意力机制","slug":"注意力机制","permalink":"https://hubojing.github.io/tags/注意力机制/"},{"name":"ASGNN","slug":"ASGNN","permalink":"https://hubojing.github.io/tags/ASGNN/"}]},{"title":"STAN","slug":"Paper_STAN","date":"2022-01-24T03:20:37.000Z","updated":"2022-01-27T15:39:58.710Z","comments":true,"path":"2022/01/24/Paper_STAN/","link":"","permalink":"https://hubojing.github.io/2022/01/24/Paper_STAN/","excerpt":"　　STAN: Spatio-Temporal Attention Network for Next Location Recommendation　　STAN：基于时空注意力网络的下一个兴趣点推荐 ","text":"STAN: Spatio-Temporal Attention Network for Next Location Recommendation STAN：基于时空注意力网络的下一个兴趣点推荐 论文背景 STAN: Spatio-Temporal Attention Network for Next Location Recommendation STAN：基于时空注意力网络的下一个兴趣点推荐 WWW 21 PDF 现有问题 引入 0、1、2分别代表家、工作地、商场，3、4、5、6分别代表餐馆。虽然3、4、5、6时间和空间都不连续，但它们是有关联的。现有文献很少关注这种非相邻位置和非连续签到的情况。 说明和定义 用户U=${u_1, u_2, …, u_U}$ 兴趣点L=${l_1, l_2, …, l_L}$ 时间T=${t_1, t_2, …, t_T}$ 用户轨迹$tra(u_i) = (r_1, r_2, …, r_{m_i})$ 架构 架构 STAN包括多模态嵌入模块、一个自注意力聚合层、一个注意力匹配层、一个平衡采样器。 多模态嵌入模块 该模块分为两部分：轨迹嵌入层和时空嵌入层。 用户轨迹嵌入层 使用了用户、地理位置、时间，嵌入向量记为$e^u$、$e^l$、$e^t$。时间戳被分为7*24=168个维度。所以，$e^u$、$e^l$、$e^t$的维度是U，L和168。 输出$e^r = e^u + e^l + e^t$ 时空嵌入层 创造了两种矩阵，轨迹时空关系矩阵$△^{t, s}$和候选关系矩阵$N^{t, s}$。前者将两个轨迹间的时间差和地理距离作为关联信息，后者将轨迹中的兴趣点与候选集中可能的预测兴趣点采用同样的信息关联起来。使用线性插值方法。 这一层将这两种矩阵进行映射和求和，得到最终的嵌入表示E(△)和E(N)。 自注意力聚合层 这一层是用来考虑轨迹中有不同距离和时间间隔的两次兴趣点签到的关联程度的。自注意力层可以捕捉长时依赖并为轨迹中的兴趣点分配不同的权重。将轨迹E(u)和时空关系矩阵E(△)通过自注意力聚合层，计算得到新的序列S表示。 注意力匹配层 这一层的作用是根据用户轨迹的最新表示在L中召回最合适的兴趣点候选。 A(u) = Matching(E(l), S(u), E(N))，得到的是概率。 $Matching(Q, K, N) = Sum(softmax(\\frac{QK^T+N}{\\sqrt{d}}))$ 这个公式减少了其它自注意力模型中的PIF信息。 平衡采样器 因为正负样本不均衡，优化交叉熵损失不再有用。本文修改了交叉熵损失公式中负样本数量，对于每个正样本$a_k$，需要同时计算L-1个负样本，这称为作为平衡采样器。 实验 数据 数据集：Gowalla, SIN, TKY, NYC. 输入：$(u_i, l_k, t_k)$, $(l_k, lon_k, lat_k)$ 输出：候选兴趣点概率值 基线 STRNN DeepMove STGN ARNN LSTPM TiSARec GeoSAN 性能 性能 贡献点 提出STAN，一种时空双向注意力模型，全面考虑了聚合相关联位置的时空效应。第一个将非相邻位置和非相邻签到时间的兴趣点的时空联系应用在兴趣点推荐中。 使用简单的线性插值技术替代GPS网格进行空间离散化，它能恢复空间距离和反映时空偏好，而不仅仅是聚合邻居。 提出了一种双向注意力架构用于PIF（personalized item frequency），第一层聚合了轨迹信息中相关的兴趣点用于更新表示，那么第二层就可以给全部的签到信息匹配目标。 在四个真实世界数据集上性能比SOTA模型超过10%。 代码https://github.com/yingtaoluo/Spatial-Temporal-Attention-Network-for-POI-Recommendation","raw":null,"content":null,"categories":[{"name":"论文","slug":"论文","permalink":"https://hubojing.github.io/categories/论文/"}],"tags":[{"name":"推荐算法","slug":"推荐算法","permalink":"https://hubojing.github.io/tags/推荐算法/"},{"name":"兴趣点推荐","slug":"兴趣点推荐","permalink":"https://hubojing.github.io/tags/兴趣点推荐/"},{"name":"STAN","slug":"STAN","permalink":"https://hubojing.github.io/tags/STAN/"}]},{"title":"CHAML","slug":"Paper_CHAML","date":"2022-01-22T10:02:37.000Z","updated":"2022-01-23T15:37:57.794Z","comments":true,"path":"2022/01/22/Paper_CHAML/","link":"","permalink":"https://hubojing.github.io/2022/01/22/Paper_CHAML/","excerpt":"　　Curriculum Meta-Learning for Next POI Recommendation　　基于课程元学习的下一个兴趣点推荐 ","text":"Curriculum Meta-Learning for Next POI Recommendation 基于课程元学习的下一个兴趣点推荐 论文背景 Curriculum Meta-Learning for Next POI Recommendation 基于课程元学习的下一个兴趣点推荐 KDD 21 PDF 现有问题 在下一个兴趣点推荐的研究中，在有限的用户-兴趣点交互数据下，在冷启动城市中提供满意的推荐是重要问题，这需要许多其它城市丰富数据下隐含的知识进行迁移。现有文献没有考虑到城市转移的问题或者不能同时处理数据稀疏和用户在多个城市的模式多样性的问题。 问题描述 问题描述如图所示。 该问题关键是提出一个合适的迁移算法，但难点有二： 1. 不同城市的数据太少 2. 用户在不同城市下有不同的多样性表达 现有算法不能同时解决这两个问题。传统的预训练和微调技术不能解决问题2，跨域推荐不能解决问题1。 架构 提出 Curriculum Hardness Aware Meta-Learning (CHAML) 框架。 架构 架构分为两部分，一部分是基础推荐器，另一部分是MAML扩展。后者用于将元学习引入到POI推荐中。 两种采用策略组件，一种是硬意识元学习(hardness aware meta-learning)，另一种是城市级别采样课程(city-level sampling curriculum)。这用于细致思考采样多样性问题。 一些概念： Curriculum Learning，主张让模型先从容易的样本开始学习，并逐渐进阶到复杂的样本和知识。 meta-learning，又叫learning to learn，即学习如何学习，元学习围绕任务（task）展开。元学习是要去学习任务中的特征表示，从而在新的任务上泛化。 基础推荐器 使用DIN作为基础推荐器，由三部分组成，嵌入模块（Embedding module）、注意力模块（Attention module）和输出模块（Output module）。 元学习 使用MAML策略。 MAML论文：Model-agnostic meta-learning for fast adaptation of deep networks 每轮MAML包括两步骤：局部更新和全局更新。见图中左上部分。 每一次元学习任务都有支持训练集$D^{spt}$用于训练，query训练集$D^{qry}$用于测试。 元学习目标就是学习一个选学习器F，F可以预测推荐器f中的参数$\\theta$，使损失函数最小化。 硬意识元学习 Hardness Aware Meta-Learning 这里的”hardness”是模型在query样本上的现有性能自判的。 分为两个阶段，hard_city阶段和hard_user阶段。两个任务交替循环。对应图右上。 城市级别采样课程 City-level Sampling Curriculum 见图下方。 分为两阶段，一是困难度测量，使用诸如AUC指标来衡量。二是调度器用于城市pool，定义了一个函数g。课程学习使模型有更大的概率在优化过程中选择容易的梯度步骤。 实验 数据集：百度地图MapSmall、MapLarge（未开源） 输入：POI ID, POI category, time, user-POI dist 输出：POI预测分数$y^{hat}_i$ 基线 针对POI推荐： NeuMF HGN ATST-LSTM PLSPL iMTL DIN 针对迁移策略： No transfer Pretrain and Fine-Tune(FT) MAML $s^2$Meta HAML 贡献点 第一个探索城市迁移的下一个兴趣点推荐，并将元学习用于该问题。 提出CHAML框架，通过使用用户和城市级别的硬采样挖掘以及城市级别的课程学习（curriculum learning）增强元学习器，达到同时解决数据稀疏和冷启动城市的样本多样性的问题。 在两个真实世界地图查找数据集中性能超越SOTA方法。该框架已在百度地图上进行过A/B测试。 代码https://github.com/PaddlePaddle/Research/tree/master/ST_DM/KDD2021-CHAMLhttps://github.com/victorsoda/chaml","raw":null,"content":null,"categories":[{"name":"论文","slug":"论文","permalink":"https://hubojing.github.io/categories/论文/"}],"tags":[{"name":"推荐算法","slug":"推荐算法","permalink":"https://hubojing.github.io/tags/推荐算法/"},{"name":"兴趣点推荐","slug":"兴趣点推荐","permalink":"https://hubojing.github.io/tags/兴趣点推荐/"},{"name":"CHAML","slug":"CHAML","permalink":"https://hubojing.github.io/tags/CHAML/"},{"name":"元学习","slug":"元学习","permalink":"https://hubojing.github.io/tags/元学习/"},{"name":"课程学习","slug":"课程学习","permalink":"https://hubojing.github.io/tags/课程学习/"}]},{"title":"博客更换为Waline评论系统","slug":"博客更换为Waline评论系统","date":"2022-01-14T13:18:13.000Z","updated":"2022-05-22T03:26:35.654Z","comments":true,"path":"2022/01/14/博客更换为Waline评论系统/","link":"","permalink":"https://hubojing.github.io/2022/01/14/博客更换为Waline评论系统/","excerpt":"　　数据安全挺重要的　　2022-05-22更新 解决评论模块无法访问的问题-CDN更换 ","text":"数据安全挺重要的 2022-05-22更新 解决评论模块无法访问的问题-CDN更换 更换缘由 博客诞生以来，折腾最多的板块就是评论系统，多说–&gt;网易云跟帖–&gt;Disqus–&gt;Valine，一路换换换，经历了一些数据丢失，直到2018年3月更换到Valine评论系统后，至今平稳运行了快四年时间，除了偶尔有些广告以外，没有出过大问题。 但是从安装Valine起，我明了作为一款无后端的评论系统的安全性是很难保证的。由于那段时间折腾到心累，加上Valine是当时颜值最高且简洁的评论系统，同时觉得应该没有谁会去费精力黑一个没多少人看的小博客，所以就默默躺平了。中间也看到过有博主被攻击，不过总觉得自己应该不会这么倒霉吧，懒得管。没想到能撑四年也是不容易（从侧面说明我的博客确实没人看，叹气.jpg）。 今天更新博客时间线的时候看到博客上次大调整还是19年，究竟是我变懒了还是indigo主题确实满足了我大部分需求呢，肯定是后者哈哈。 为什么现在突然要换呢？主要是上次这篇博文解决Valine评论不显示的问题下面的评论让我再次想起Valine系统的这个隐患。 秉持着最小化修改的精神，我很快决定换成Waline系统。看这个名字吧，Valine和Waline，感觉上就相差肯定不多。Waline其实就是一个带后端的Valine，可以进行一些反垃圾和校验操作。其实早就看好了Waline，只是一直没有动力换它。现在是时候把它换了。也希望各位黑客大佬们手下留情，不要难为我这小小博客。 更换步骤 以下步骤基于原有系统为Valine系统的简单迁移方法。 Vercel 部署（服务端） 免费的就是最好的！（本穷狗如是说）deploy 点击上方跳转至Vercel部署。 未登录需要注册或登录，使用Github快捷登录。 输入名称创建项目，Vercel会根据Waline模板新建并初始化仓库。 几分钟后，满屏烟花部署成功。 转到Dashboard-Setting-Environment Variables，进行环境变量配置。 环境变量配置必备 新增/对应于 LEAN_ID —— LeanCloud中获得的APP ID LEAN_KEY —— LeanCloud中获得的APP KEY LEAN_MASTER_KEY —— LeanCloud中获得的Master Key 以上默认LeanCloud国际版，如果是LeanCloud国内版，还要配置LEAN_SERVER环境变量，值为绑定好的域名。 点击Deployments-Redeploy重新部署。当STATUS变为Ready后，点击Visit跳转的地址即为服务端地址。 邮件提醒 SMTP_SERVICE: SMTP 邮件发送服务提供商。支持的服务提供商列表(如果运营商不受支持，必须填写 SMTP_HOST 和 SMTP_PORT。SMTP_HOST: SMTP 服务器地址，一般可以在邮箱的设置中找到。SMTP_PORT: SMTP 服务器端口，一般可以在邮箱的设置中找到。) SMTP_USER: SMTP 邮件发送服务的用户名，一般为登录邮箱。 SMTP_PASS: SMTP 邮件发送服务的密码，一般为邮箱登录密码，部分邮箱(例如 163)是单独的 SMTP 密码。 SITE_NAME: 网站名称，用于在消息中显示。 SITE_URL: 网站地址，用于在消息中显示。 AUTHOR_EMAIL: 博主邮箱，用来接收新评论通知。如果是博主发布的评论则不进行提醒通知。 选填: SENDER_NAME: 自定义发送邮件的发件人 SENDER_EMAIL: 自定义发送邮件的发件地址 MAIL_SUBJECT: 自定义评论回复邮件标题 MAIL_TEMPLATE: 自定义评论回复邮件内容 MAIL_SUBJECT_ADMIN: 自定义新评论通知邮件标题 MAIL_TEMPLATE_ADMIN: 自定义新评论通知邮件内容 HTML 引入 (客户端)在indigo主题中，需要修改\\hexo\\themes\\indigo\\layout_partial\\plugins\\valine.ejs文件。去掉12&lt;script src=\"//code.bdstatic.com/npm/leancloud-storage@4.12.0/dist/av-min.js\"&gt;&lt;/script&gt;&lt;script src=\"//unpkg.com/valine@latest/dist/Valine.min.js\"&gt;&lt;/script&gt; 加上1&lt;script src=\"//cdn.jsdelivr.net/npm/@waline/client\"&gt;&lt;/script&gt; 去掉123456789101112new Valine(&#123; el: '#comments', notify: '&lt;%= theme.valine.notify %&gt;' == 'true', verify: '&lt;%= theme.valine.verify %&gt;' == 'true', appId: \"&lt;%= theme.valine.appId %&gt;\", appKey: \"&lt;%= theme.valine.appKey %&gt;\", avatar: \"&lt;%= theme.valine.avatar %&gt;\", placeholder: \"&lt;%= theme.valine.placeholder %&gt;\", guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info, pageSize: \"&lt;%= theme.valine.pageSize %&gt;\", serverURLs: '&lt;%= theme.valine.serverURLs %&gt;' // 增加这一行！！！&#125;) 更换为1234Waline(&#123; el: '#comments', serverURL: '此处为你的服务端地址'//注意此处是serverURL，Valine里的是serverURLs &#125;); 此时评论服务已能在博客成功运行。 评论管理（管理端） 部署完成后，在&lt;serverURL&gt;/ui/register进行注册。第一个注册的人被设定为管理员。 管理员可管理评论。 用户可通过评论框注册账号，登录后可跳转至自己的评论页。 其它 如果无法发布评论，比如报错说格式不对（要求Number结果是String）之类的，建议查看LeanCloud数据中的单元格式是否正确。 参考资料Waline官网 2022-05-22更新 解决评论模块无法访问的问题-CDN更换查找问题12GET https://cdn.jsde1ivr.net/npm/@waline/clientnet::ERR_CONNECTION_TIMED_OUT 该CDN链接超时，需要更换。 解决方法将1&lt;script src=\"//cdn.jsdelivr.net/npm/@waline/client\"&gt;&lt;/script&gt; 更换为12345&lt;script src=\"https://unpkg.com/@waline/client@v2/dist/waline.js\"&gt;&lt;/script&gt;&lt;link rel=\"stylesheet\" href=\"https://unpkg.com/@waline/client@v2/dist/waline.css\"/&gt; 另外，waline版本更新后更改了方法入口，需要将1234Waline(&#123; el: '#comments', serverURL: 'https://your-domain.vercel.app', &#125;); 更改为1234Waline.init(&#123; el: '#comments', serverURL: 'https://your-domain.vercel.app', &#125;); 问题解决。","raw":null,"content":null,"categories":[{"name":"博客","slug":"博客","permalink":"https://hubojing.github.io/categories/博客/"}],"tags":[{"name":"Waline","slug":"Waline","permalink":"https://hubojing.github.io/tags/Waline/"},{"name":"Valine","slug":"Valine","permalink":"https://hubojing.github.io/tags/Valine/"},{"name":"评论","slug":"评论","permalink":"https://hubojing.github.io/tags/评论/"}]},{"title":"2021年终总结","slug":"2021年终总结","date":"2021-12-31T05:00:59.000Z","updated":"2021-12-31T07:45:56.126Z","comments":true,"path":"2021/12/31/2021年终总结/","link":"","permalink":"https://hubojing.github.io/2021/12/31/2021年终总结/","excerpt":"　　白天写的年终总结！ ","text":"白天写的年终总结！ 打分 技术博客只谈技术。2021年给自己在技术方面打分：60分。 自律使人自由 ——致自己2020~2021 这句话大概要延续到2022年了…… 总结 去年的总结上写着“一晃，研究生生涯已经走完一半了。” 现在，我就要写上： 一晃，研究生生涯几乎快要走完了。 真快呀。 这一年里围绕的主要是两件事： 科研 秋招 科研带来的是日复一日读论文做实验的平静的心态，小论文被接收时也是一种平和的欣喜，作为对自己的一份鼓励。 秋招带来的是对未知的迷茫和跃跃欲试的憧憬，每天笔试面试虽辛苦疲累，但一想收到offer时的快乐，这些努力都很值得。 本来洋洋洒洒写了一大段，又觉得没有必要在技术博客里写长篇大论去叙述这些过程，也许我在总结生活的时候，可以再加上。每个走过这段路的人都有类似的体会，我在走前人走过的路，而后来的人又即将走我走过的路。 去年定的目标只是简单的一句进大厂。但是在几乎贯穿全年的找工作话题中，在说服自己和迷茫不断循环中，我发现我竟想不明白我到底要什么，致使我的想法有几次很大的转变。也许是我第一次真正地参与秋招，这着实是自己在选择今后的人生，我要为我的选择负责。要感谢所有发给我offer的公司，我非常幸运能被你们看中。我想，无论选择哪一个，也许我都会遐想另一条路会怎样，但总归人只能选择一条路。所幸这几个月的不断思考，或者说不得不思考，让我渐渐地得出了模糊的答案。 关于技术 读研后拥有了自己的研究方向，我很珍惜这种归属感，而不是和从前一样学得广而杂。这几年的科研做的都是推荐算法相关的研究，所以找工作多半也是这方面。倒是想提一提为什么我会选择推荐算法，说来有些搞笑，我曾经非常喜欢网易云音乐的私人FM功能，十分好奇为什么私人FM的推歌功能可以如此抓住人心。当我研一选择研究方向的时候，毫不犹豫地选择了推荐算法，只是希望有一天我能知道到底是什么算法能实现这个功能。现在我大概知道了是如何实现的，可是就和魔术一样，当你知道它是怎么变的后，就有些不过如此的感觉。 现在我除了推荐算法的研究外，也在往NLP算法拓展。或者说，推荐算法是NLP算法的一种应用算法也可以。NLP算法现在的研究依然充满了挑战，毕竟现在还处于感知智能，要升级到认知智能，还得靠NLP算法。（突然就高大上了起来哈哈） 当然，我对开发技术也始终保持乐趣，我总是希望自己能利用业余时间设计出好玩或者有用的软件。 学技术的路上，我感觉和玩游戏升级打怪差不多，并不感觉自己是在费劲地强迫学习，只是玩。其实秋招也给我这种感觉，虽然是找工作，也会有累和压力，但我后期笔试面试已经麻了（逐 渐 变 态），只觉得自己是在玩，单纯获得一份人生经历罢了。 另外，这几年对技术博客疏于管理，回看自己写的文章也不多，水平也很菜，对于这一点我对自己很不满意。这种时候就挺想念本科时自己的学习状态。 新的一年 2022年应该是生活方式改变的一年，如果顺利的话我应该工作了。那么前半年和后半年的生活也许完全不同。 还剩下的最后一个学期，也许是我人生中最后的学生生活吧。 还有哪些事情需要做以至于以后想起学生时代的遗憾能够少一点呢？ 我打算默默地写一个列表，然后用最后一个学期尽可能地去完成它。 当然，认真写毕业论文，这个是TOP1级别的。 后半年的工作，也许会有很多新的期待，但是现在的我无法预料。希望能够在工作中有所收获，技术和研究能力能得到提升。剩下的，享受未知吧。 最后，为了表明2022年不熬夜的决心，不像前几年凌晨写总结，这次我白天写好了！（倔强.jpg） 2021年12月31日下午 于实验室","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"年终总结","slug":"年终总结","permalink":"https://hubojing.github.io/tags/年终总结/"}]},{"title":"解决Valine评论不显示的问题","slug":"解决Valine评论不显示的问题","date":"2021-12-07T06:49:31.000Z","updated":"2021-12-09T05:29:00.000Z","comments":true,"path":"2021/12/07/解决Valine评论不显示的问题/","link":"","permalink":"https://hubojing.github.io/2021/12/07/解决Valine评论不显示的问题/","excerpt":"　　今天认真排查了一下　　附上解决方案 ","text":"今天认真排查了一下 附上解决方案 背景博客大概有十多天无法显示评论也无法提交新评论，而我这段时间并未对博客评论进行过修改。（不是我的锅） 我寻思着该不会是Valine更新了什么把自己给更没了吧？（强行背锅） 后来在Valine的官方群中，有部分网友表示最近遇到相同问题，共性是都使用的LeanCloud国际版。 哦，原来是LeanCloud的锅。 具体排查查看网页控制台，我发现，123Failed to load resource: net::ERR_EMPTY_RESPONSEus-api.leancloud.cn/后面还有一长串 或者123Failed to load resource: net::ERR_NAME_NOT_RESOLVEDus-api.leancloud.cn/后面还有一长串 调试过程中还报过别的错，我没有记录，但总之，都是围绕这个域名解析的问题。反正就是这个域名无法正确得到结果。 那怎么办呢？根据群里大佬讨论可得，似乎是现在国际版对这个域名不再支持了，也有人说是不稳定，推荐自定义服务器URL。 那就换呗。 解决方法法一：导出数据，更换到国内节点，快准狠。 法二：懒得换（比如我），那就改代码吧。如果主题中已配置的Valine有severURLs字段，直接设置即可。1serverURLs: https://xxxxxxxx.api.lncldglobal.com # 把xxxxxxxx替换为自己AppID的前8位字符 如果主题未配置该参数，就需要找到valine的js文件，比如我这里的\\hexo\\themes\\indigo\\layout\\_partial\\plugins\\valine.ejs123456789101112new Valine(&#123; el: '#comments', notify: '&lt;%= theme.valine.notify %&gt;' == 'true', verify: '&lt;%= theme.valine.verify %&gt;' == 'true', appId: \"&lt;%= theme.valine.appId %&gt;\", appKey: \"&lt;%= theme.valine.appKey %&gt;\", avatar: \"&lt;%= theme.valine.avatar %&gt;\", placeholder: \"&lt;%= theme.valine.placeholder %&gt;\", guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info, pageSize: \"&lt;%= theme.valine.pageSize %&gt;\", serverURLs: '&lt;%= theme.valine.serverURLs %&gt;' // 增加这一行！！！&#125;) 然后再配置上面的serverURLs。 然而我在配置完这一步后，仍然不能显示正确的评论。群里大佬已经撤了，剩下一个前端菜狗在风中凌乱。 为什么不行呢？ 我认真地排查后发现评论这块并没有跳转到我设定的serverURLs，还是us-api.leancloud.cn啊。 为什么呢？ 我开始翻Valine的Github的Issues区，从一个大佬提出的Issue中发现了端倪。详见：https://github.com/xCss/Valine/issues/376 这个大佬提问说这个av.js是不是有bug啊？ 看了大佬的截图，我懂了。 这个cdn是版本不对了吧？ 于是我找到LeadClond官网手册，查询最新的CDN链接。https://leancloud.cn/docs/sdk_setup-js.html 将这一行1&lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt; 替换为1&lt;script src=&quot;//code.bdstatic.com/npm/leancloud-storage@4.12.0/dist/av-min.js&quot;&gt;&lt;/script&gt; 再重新部署，评论已经能成功显示了。 回顾三部曲： 设置serverURLs。 若Valine的js文件未定义，需增加定义serverURLs。 更新av-min.js文件。 完成。 参考资料https://github.com/xCss/Valine/issues/340https://github.com/xCss/Valine/issues/376","raw":null,"content":null,"categories":[{"name":"博客","slug":"博客","permalink":"https://hubojing.github.io/categories/博客/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hubojing.github.io/tags/Hexo/"},{"name":"Valine","slug":"Valine","permalink":"https://hubojing.github.io/tags/Valine/"},{"name":"评论","slug":"评论","permalink":"https://hubojing.github.io/tags/评论/"}]},{"title":"迟到四年的评测——一加5T","slug":"迟到四年的评测——一加5T","date":"2021-11-16T13:06:00.000Z","updated":"2021-11-16T15:44:01.382Z","comments":true,"path":"2021/11/16/迟到四年的评测——一加5T/","link":"","permalink":"https://hubojing.github.io/2021/11/16/迟到四年的评测——一加5T/","excerpt":"　　啊，纪念我逝去的青春 ","text":"啊，纪念我逝去的青春 废话文学 作为一个性价比爱好者（穷的代名词），我向来喜欢买性能最高但价格最低的手机。 18年，我斥巨资（三千）买了当时周围没人听过的这款手机——一加5T。那年OnePlus这个牌子还只是在国外比较火，国内没什么水花。现在，OnePlus也算是有很高的知名度啦。 用了多年，一加手机给我的感觉都是非常好的。 这并不是一篇软广，因为一加没有给我打钱。 （如果一加官方看到了，非常欢迎联系我给我打钱^_^） 当时我其实就打算写一篇评测文，当然也不专业，只是写给零基础想买一加的朋友们看看的。手机买回来当天，就拍了照，跑了安兔兔、鲁大师等等，还保存了截图，但我，额—— 懒了一下…… 嗯，这篇文章就难产了。 今年六月去上海实习，到上海的第一天，本人第一次把手机带进了洗浴室……之后它就进水了……后置摄像头就坏了…… 在度过了艰难的没有后置摄像头的六个月的生活后，终于迎来双十一，买了新手机。（感叹一句我的忍耐力max） 但是我的一加5T陪我度过了这么多年，不把这篇文章写出来给它证明存在过实在是对不起它。 外观 美就一个字！ 正面 背面 基本参数 星辰黑 尺寸：156.1757.25mm 重量：162g 材质：铝合金金属 操作系统：H2OS 3.7.0 基于 Android™ Nougat 开发 CPU：高通骁龙 835 (8 核，10nm工艺，最高主频 2.45GHz) GPU：Adreno 540 RAM：6GB LPDDR4X 存储：64GB UFS 2.1 双通道 传感器：指纹传感器、霍尔感应器、加速度传感器、陀螺仪、距离感应器、RGB光线感应器、电子罗盘、Sensor Hub 接口：USB 2.0, Type-C，支持主流 Type-C 耳机 双 Nano-SIM 卡，双卡双待 3.5 mm 耳机插孔 电池：3300mAh (不可拆卸) Dash 闪充技术 (5V/4A) 按键：触摸按键：多任务、Home、返回（支持左右按键功能切换）、三段式开关：静音、勿扰、响铃、支持支付宝、微信指纹支付 音频：高保真扬声器、支持 3-Mic 降噪、支持 AANC 通话主动降噪、支持 Dirac HD Sound® 屏幕 尺寸：6.01英寸 分辨率 2160 x 1080 pixels 401 ppi 比例: 18:9 材质：Optic AMOLED 支持 sRGB，DCI-P3 显示，自适应模式显示 玻璃: 2.5D Corning® Gorilla® Glass 5 功能：自适应模式、阅读模式、夜间模式、抬手亮屏 摄像头后置摄像头 后置摄像头 广角 传感器 Sony IMX 398 像素: 1600 万像素 像素尺寸 1.12 µm EIS 电子防抖：支持 对焦技术： DCAF 双核对焦 光圈: f/1.7 大光圈 后置摄像头 广角 传感器: Sony IMX 376k 像素：2000 万像素 像素尺寸: 1.0µm 对焦技术: PDAF 相位对焦 光圈: f/1.7 大光圈 闪光灯：双 LED 闪光灯 视频拍摄 4K 视频拍摄，30fps 1080p 视频拍摄，30fps 720p 视频拍摄，60fps 720p 慢动作视频，120fps 延时摄影 功能：人像模式，专业模式，全景模式，像素精选，HDR，RAW 格式 前置摄像头 前置摄像头 前置摄像头 广角 传感器: Sony IMX 371 像素: 1600 万像素 像素尺寸: 1.0 µm EIS 电子防抖：支持 光圈: f/2.0 功能：面部解锁，屏幕补光，微笑快门，HDR，美颜 视频拍摄 1080p 视频拍摄，30fps 720p 视频拍摄，30fps 延时摄影 网络与连接性 LTE 4G+，支持下行 3xCA， 上行 CA，支持高阶调制 最高支持下行 Cat.12， 上行 Cat.13 (600Mbps /150Mbps)（需运营商支持） 频段 FDD LTE: Band 1/2/3/4/5/7/8/12/17/18/19/20/25/26/28/29/30/66 TDD LTE: Band 34/38/39/40/41 TD-SCDMA: Band 34/39 UMTS(WCDMA): Band 1/2/4/5/8 CDMA: BC0 GSM: 850/900/1800/1900 MHz 双卡使用介绍 全网通 单卡使用：任意卡槽均可支持移动、联通、电信 4G+/4G/3G/2G 网络 双卡使用：可设置任意卡为主卡（默认流量卡）； 主卡支持任意运营商的 4G+/4G/3G/2G 网络， 副卡则使用 2G 网络（联通作副卡可支持 3G 网络通话）； 两张卡均为电信卡时，主卡可使用4G网络，副卡无服务。 多媒体 多媒体 音频 播放: MP3, AAC, AAC+, WMA, AMR-NB, AMR-WB, WAV, FLAC, APE, OGG, MID, M4A, IMY 录制: WAV, AAC, AMR 视频 播放: MKV, MOV, MP4, H.265(HEVC), AVI, WMV, TS, 3GP, FLV, WEBM 录制: MP4 图片 浏览: JPEG, PNG, BMP, GIF 输出: JPEG 手机存图 上图！ 鲁大师测评 整体评测 排名第八有木有，当年真的性能神机有木有！ AI性能排名 华为Mate10、苹果8，嗯，有点年代感了。 还有三星可还行，三星这些年在手机领域占的份额越来越少了。 VR评分1 VR评分2 整体 安兔兔测评 整体评测 手机排名 谁看了不说我一加5T是三千元档的性能神机！看看排行上下的手机都要多少钱，没5000+买不到呢~ 四年后 使用不卡顿，很流畅，运行游戏（如王者荣耀）无压力，画质很棒。 三段式开关好评，后置指纹好用，有3.5mm耳机孔，快充。 四年后由于摔了几次，掉电开始有一点点快。 我自己试图拆机修后置摄像头，但卡在了第一步，后盖打不开（从白天撬到黑夜…）…我把边都快撬烂了也没能打开，电吹风加热也试过，无解。可能真的需要热风枪才行吧。 主要是64G的空间实在是扛不住了，微信+QQ两个巨无霸各20G就占据了40G空间，基本上应用在52G左右已经没有多余空间了。再加上后置摄像头坏了着实影响生活，不能扫码，不能登录微信（微信只能扫码登录简直反人类！）等等。 如果不是这两个原因，我的一加5T再顶几年应该问题不大。 是我没保护好你嗷。 如今的一加5T 最后，作为一加手机的爱好者，我也喜欢一加的标语： NEVER SETTLE 相关资料一加5T","raw":null,"content":null,"categories":[{"name":"数码","slug":"数码","permalink":"https://hubojing.github.io/categories/数码/"}],"tags":[{"name":"评测","slug":"评测","permalink":"https://hubojing.github.io/tags/评测/"},{"name":"OnePlus","slug":"OnePlus","permalink":"https://hubojing.github.io/tags/OnePlus/"}]},{"title":"设计模式笔记","slug":"设计模式笔记","date":"2021-11-02T01:18:50.000Z","updated":"2021-11-02T03:07:21.990Z","comments":true,"path":"2021/11/02/设计模式笔记/","link":"","permalink":"https://hubojing.github.io/2021/11/02/设计模式笔记/","excerpt":"　　23种设计模式总结 ","text":"23种设计模式总结 刚好最近在看一本技术书，随手记录。 总览设计模式可分为创建型模式、结构型模式和行为型模式。 创建型模式：抽象工厂模式（Abstract Factory），构建器模式（Builder)，工厂方法模式（Factory Method），原型模式（Prototype），单例模式（Singleton） 结构型模式：适配器模式（Adapter），桥接模式（Bridge），组合模式（Composite），装饰模式（Decorator），外观模式（Facade），享元模式（Flyweight），代理模式（Proxy）。 行为型模式：责任链模式（Chain of Responsibility），命令模式（Command），迭代器模式（Iterator），解释器模式（Interpreter），中介者模式（Mediator），备忘录模式（Memento），观察者模式（Observer），状态模式（State），策略模式（Strategy），模板方法模式（Template Method），访问者模式（Visitor） 设计模式的六大原则 单一职责原则 里氏代换原则 依赖倒置原则 接口隔离原则 迪米特原则 开闭原则 创建型模式创建型模式：对对象实例化过程的抽象，通过采用抽象类所定义的接口，封装了系统中对象如何创建、组合等信息。 抽象工厂模式 Abstract Factory提供创建一组或者一系列相关的或相互依赖对象的接口。优点： 分离了具体类 更容易在产品系列中进行转换 提高了产品间一致性缺点： 难以支持新的产品等级结构，支持新的产品等级结构就要扩展抽象工厂接口适用场景： 系统独立于产品的创建、组成以及表示 系统配置成具有多个产品的系列 当要强调一系列相关的产品对象的设计以便于进行联合使用时 当提供一个产品类库，而只想显示它们的接口而不是实现时应用举例：在很多软件系统中需要更换界面主题，要求界面中的按钮、文本框、背景色等一起发生改变时，可以使用抽象工厂模式进行设计。构建器模式 Builder将复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。优点： 产品的内部表象可以独立地变化 将构造代码与表示代码相分离，可以使客户端不必知道产品内部组成的细节缺点： 构建器模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用构造器模式 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大适用场景： 创建复杂对象的算法独立于组成对象的部分以及这些部分的集合方式 构造过程必须允许已构造对象有不同表示应用举例：在很多游戏软件中，地图包括天空、地面、背景等组成部分，人物角色包括人体、服装、装备等组成部分，可以使用建造者模式对其进行设计，通过不同的具体建造者创建不同类型的地图或人物。工厂方法模式 Factory Method定义一个用于创建对象（产品）的接口，由子类决定实例化哪个类的对象（产品）。优点： 没有了将应用程序类绑定到代码中的要求，代码只处理接口，因此可以使用任何实现了接口的类 允许子类提供对象的扩展版本 符合迪米特法则、依赖倒置原则、里式替换原则缺点： 需要Creator和相应的子类作为工厂方法的载体，如果应用模式确实需要creator和子类存在，则很好；否则，需要增加一个类层次。适用场景： 当一个类不知道它所创建的产品的具体是哪个子类时 当创建的对象的过程希望延缓到子类中进行时 类希望子类指定它要创建的对象应用举例：Windows的COM组件与MFC。原型模式 Prototype指定创建对象的种类，并且通过拷贝这些原型创建新的对象。以一个已有的对象作为原型，通过它来创建新的对象。优点： 可以在运行时添加或删除产品 原型模式提供简化的创建结构 具有给一个应用软件加载新功能的能力 产品类不需要非得有任何事先确定的等级结构缺点： 每一个类必须配备一个克隆方法适用场景： 在运行时，指定需要例化的类，例如动态载入 避免构建与产品的类层次结构相似的工厂类层次结构 当类的实例是仅有的一些不同状态组合单例模式 Singleton一个类只有一个实例。优点： 对单个实例的受控制访问 名称空间减少 允许改进操作和表示 允许可变数目的实例 比类操作更灵活缺点： 单例类的扩展有很大的困难，且职责过重，在一定程度上违背了“单一职责原则”适用场景：只有一个类实例。应用举例：主键生成器。结构型模式结构型模式：主要用于如何组合已有的类和对象以获得更大的结构，它采用继承机制赖组合接口或实现，以提供统一的外部视图或新的功能。适配器模式 Adapter将一个类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。优点： 允许两个或多个不兼容的对象进行交互和通信 提高已有功能的重复使用性 增加了类的透明度 灵活性好缺点： 过多地使用适配器会让系统非常零乱，不易整体进行把握适用场景： 要使用已有的类，而该类接口与所需的接口并不匹配 要创建可重复的类，该类可以与不相干或未知类进行协助，即类之间不需要兼容接口 要在一个不同于已知对象接口的接口环境中使用对象 必须要进行多个源之间的接口转换的时候应用举例：在.NET中有一个类库已经实现的、非常重要的适配器——Data Adapter。桥接模式 Bridge将一个辅助的组件分成两个独立的但又相关的继承层次结构：功能性的抽象和内部实现。优点： 可以将接口与实现相分离 提高可扩展性 对客户端隐藏了实现的细节缺点： 增加了系统的理解和设计难度 要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性适用场景： 想避免在抽象及其实现之间存在永久的绑定 抽象及其实现可以使用子类进行扩展 抽象的实现被改动应该对客户端没有影响 组合模式 Composite将对象组合成树型结构以表示“部分-整体”的层次结构。优点： 清楚地定义分层次的复杂对象，表示对象的全部或部分层次 使得增加新构件更容易 提高了结构的灵活性和可管理的接口缺点： 使设计变得更加抽象，如果对象的业务规则很复杂，则实现组合模式具有很大的挑战性，而且不是所有的方法都与叶子对象子类有关联。适用场景： 想表示对象的部分-整体层次结构 希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象 结构可以具有任何级别的复杂性，而且是动态的应用举例：部分、整体场景，如树形菜单，文件、文件夹的管理。装饰模式 Decorator动态的给对象添加一些额外的责任，就增加功能来说，装饰比生成子类更为灵活。优点： 比静态继承具有更大的灵活性 简化代码 改进对象扩展性，用户可以通过编写新的类来作出改变 装饰类和被装饰类可以独立发展，不会相互耦合缺点： 多层装饰比较复杂适用场景： 想要在单个对象中动态并且透明地添加责任，而这样不会影响其他对象 想要在以后可能要修改的对象中添加责任 当无法通过静态子类化实现扩展时外观模式 Facade为子系统中的一组接口提供一个统一的接口，外观模式通过提供一个高层接口，隔离了外部系统与子系统间复杂的交互过程，使得复杂系统的子系统更易使用。优点： 在不减少系统所提供的选项的情况下，为复杂系统提供了简单的接口 对客户端屏蔽了子系统组件 提高了子系统与其客户端之间的弱耦合度 将客户端请求转换后发送给能够处理这些请求的子系统缺点： 不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制，则减少了可变性和灵活性 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”适用场景： 为一个复杂子系统提供一个简单接口时 客户程序与抽象类的实现部分之间存在着很大的依赖性 构建一个层次结构的子系统时，使用Facade模式定义子系统中每层的入口点，如果子系统之间是相互依赖的，则可以让它们仅通过Facede进行通信，从而简化了它们之间的依赖关系。享元模式 Flyweight通过共享对象减少系统中低等级的、详细的对象数目。优点： 减少了要处理的对象数目 如果对象能够持续，可以减少内存和存储设备缺点： 使得应用程序在某种程度上来说更加复杂化了 为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长适用场景： 应用程序使用大量的对象 由于对象数目巨大，导致很高的存储开销 应用程序不依赖于对象的身份代理模式 Proxy为控制对初始对象的访问，提供了一个代理或者占位符对象。优点： 远程代理可以隐藏对象位于不同的地址空间的事实 虚拟代理可以执行优化操作缺点： 请求的处理速度变慢 实现代理模式需要额外的工作，从而增加了系统实现的复杂度适用场景： 当需要为一个对象在不同的地址空间提供局部的代表时 当需要创建开销非常大的对象时应用举例：防火墙代理——保护目标不让恶意用户靠近。 行为型模式行为型模式：从大量实际行动中概括处理作为行为的理论抽象、基本框架和标准。该类模式主要用于对象之间的职责及其提供的服务的分配，它不仅描述对象或类的模式，还描述它们之间的通信模式。 责任链模式 Chain of Responsibility在系统中建立一个链，消息可以首先被接收到它的级别处理，或者定位到可以处理它的对象。优点： 降低耦合度 增加向对象指定责任的灵活性适用场景： 多个对象可以处理一个请求，而其处理器却是未知的 可以动态指定能够处理请求的对象集命令模式 Command在对象中封装请求，保存命令并传递给方法以及像任何其他对象一样返回该命令。优点： 添加新命令不用修改已有类 将操作对象与知道如何完成操作的对象相分离适用场景： 想要通过要执行的动作来参数化对象 在不同的时间指定、排序以及执行请求解释器模式 Interpreter解释定义其语法表示的语言。优点： 容易修改并扩展语法 容易实现语法适用场景： 语言的语法比较简单 效率并不是最主要的问题迭代器模式 Iterator提供一方法顺序地访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。优点： 支持集合的不同遍历 简化集合接口适用场景： 在不开放集合对象内部表示的前提下，访问集合对象内容 支持集合对象的多重遍历 为遍历集合中的不同结构提供了统一的接口备忘录模式 Memento保持对象状态的“快照”，在不向外界公开其内容的情况下返回到它的最初状态。优点： 保持封装完整 简化了返回到初始状态所需的操作适用场景： 必须保存对象的快照 使用直接接口来获得状态可能会公开对象的实现细节，从而破坏对象的封装性观察者模式 Observer为组件向相关接受方广播消息提供了灵活的方法。优点： 抽象了主体与Observer之间的耦合关系 支持广播方式的通信适用场景： 对一个对象修改涉及其他对象修改，而不知道有多少对象需进行修改 对象应该能够在不用假设对象标识的前提下通知其他对象状态模式 State运行对象在内部状态变化时变更其行为，并且修改其类。优点： 定位指定状态的行为，并根据不同状态来划分行为适用场景： 对象行为依赖于其状态，且对象必须在运行时根据其状态修改行为 操作具有大量以及多部分组成的取决于对象状态的条件语句策略模式 Strategy定义了一组用来表示可能行为集合的类。优点： 另一种子类化方法 在类自身中定义行为，减少条件语句 更容易扩展模型适用场景： 许多相关类只是在行为方面有所区别 需要算法的不同变体 算法使用客户端未知的数据模板方法模式 Template Method提供了在不重写方法的前提下运行子类重载部分方法的方法。优点： 代码使用适用场景： 想要一次实现算法的不变部分，使用子类实现算法的可变部分 子类间通用行为需要分解，定位到通用类，可以避免代码重复问题访问者模式 Visitor提供了一种方便的、可维护的方法来表示在对象结构元素上进行的操作。该模式允许在不改变操作元素的类的前提下定义一个新操作。优点： 容易添加新操作 集中相关操作并且排除不相关操作适用场景： 定义对象结构的类很少被修改，但想要在此结构上定义新的操作 对象结构包含许多具有不同接口的对象类，并且想要对这些依赖于具体类的对象进行操作中介者模式 Mediater通过引入一个能够管理对象间消息分布的对象，简化了系统中对象的通信。优点： 去除对象间的影响 简化对象间的协议 集中化了控制适用场景： 对象集合需要以一个定义规范但复杂的方式进行通信 想要在不使用子类的情况下自定义分布在几个对象之间的行为","raw":null,"content":null,"categories":[{"name":"软件开发","slug":"软件开发","permalink":"https://hubojing.github.io/categories/软件开发/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://hubojing.github.io/tags/设计模式/"},{"name":"软件架构","slug":"软件架构","permalink":"https://hubojing.github.io/tags/软件架构/"}]},{"title":"靖靖的脑洞大开（3）——元宇宙","slug":"元宇宙","date":"2021-10-28T07:01:45.000Z","updated":"2021-10-28T07:53:01.067Z","comments":true,"path":"2021/10/28/元宇宙/","link":"","permalink":"https://hubojing.github.io/2021/10/28/元宇宙/","excerpt":"　　有点科幻哦 ","text":"有点科幻哦 最近Facebook宣布五年内成为元宇宙公司，让元宇宙的概念迅速火了起来，有人说2021年是元宇宙元年。 刚好我在半个月前看到一份清华大学关于元宇宙的研究报告，当时就对这个概念挺感兴趣的。 元宇宙最开始是科幻小说《Snow Crash》提出的概念，书中是指现实人类通过VR设备与虚拟人类共同生活在虚拟空间中的设定。 概念 元宇宙（Metaverse），Meta(超越) + Universe(宇宙)。 元宇宙是融合现实与虚拟，超越现实宇宙的存在。是一种新的互联网应用和社会形态，基于VR等设备提供沉浸式体验，基于数字孪生技术生成现实世界的镜像，基于区块链技术搭建经济体系，将细腻和现实世界的经济系统、社交系统和身份系统相关联，并允许用户进行内容生产和世界编辑。 元宇宙构建三个阶段：数字孪生 —&gt; 虚拟原生 —&gt; 虚实融生 综合环境的结构 相关技术 基建：VR, AR, 云计算， 数字孪生， 大数据， 物联网， 人工智能， 智能硬件等 行业：智慧城市，智慧园区，智能汽车，电子商务，数字旅游，教育类游戏，心理治疗，老人陪伴，国潮时尚等 从底层往上层依次是： 网络环境：5G 虚实界面：拓展现实，机器人，脑机接口 数字处理：人工智能，云计算 认证机制：区块链 内容生产：人工智能、数字孪生 元宇宙生态版图 感想 感慨于计算机技术的发展如此迅速，科幻故事中的场景都快要实现了，想想还有点小激动呢，三体里写的还会远吗！ 虽然这个技术似乎处于起步阶段，但是每一步似乎都有很好技术铺垫，实现似乎只是时间问题。也许，新的风口又出现了呢。 但随之而来的除了技术问题，还有道德伦理问题，甚至会出现新的社会结构。 而这些，都会出现在我这代人的生活里。突然觉得活在这个时代，好酷。 脑洞 前不久看了本1989年的科幻小说《克莱因壶》（推荐大家看！），讲的就是研发出了能进入元宇宙的设备，最后开放式结局，主人公是否回到了现实世界，全屏作者想想象。如果有一天，人类在元宇宙呆太久，会不会开始模糊现实与虚拟的界限，甚至无法知晓其实自己在虚拟之中？比如孩子出生在虚拟宇宙，要怎么知道自己是虚拟的呢？ 沿着第一个脑洞，万一现在的世界就是一个比人类更高等的生物实现的元宇宙呢？ 人对永生的想法似乎永远着迷，如果在现实世界无法实现，在元宇宙中，是否就可以？ 参考资料2020-2021年元宇宙发展研究报告 脑洞系列靖靖的脑洞大开（2）靖靖的脑洞大开（1）","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"元宇宙","slug":"元宇宙","permalink":"https://hubojing.github.io/tags/元宇宙/"}]},{"title":"写在实习之后","slug":"写在实习之后","date":"2021-09-26T08:17:17.000Z","updated":"2021-10-10T08:24:59.400Z","comments":true,"path":"2021/09/26/写在实习之后/","link":"","permalink":"https://hubojing.github.io/2021/09/26/写在实习之后/","excerpt":"　　一些关于技术的小小思考。 ","text":"一些关于技术的小小思考。 前言 实习返校已经有一个月啦，但是返校后实在是太忙了。最近也在调整状态中，顺手写一下技术的复盘（复盘 拉通 对齐 ~ 互联网黑话学废了（狗头保命））。 能够得到算法实习机会，还是我读研后一直在研究的推荐算法岗，我非常幸运。 回忆三个月的实习生活，短暂又充实。还记得拿到实习offer时发现竟是在全上海最繁华的地段工作，感觉捡到宝了哈哈哈哈。 感受了一把互联网企业的作息时间10-8-5（感谢mentor没有让我周六加班），了解了真正的算法工程师每天是怎么干活的，和开发岗还是有很多不一样的地方。 实习前幻想中的算法工程师的日常： 天天看顶会paper，复现模型，科研工程两手抓，Python代码玄学魔改，工程师个个头发茂密穿着最常见的格子衬衣带着眼镜研讨模型应该再加个什么类型的注意力机制（雾），IT精英的代表，算法人上人（滑稽）！ 现实中的算法工程师的日常： 开会拉通对齐（雾），和产品经理沟通需求和指标（吵架bushi），洗数据，特征选择，模型训练，玄学调参，分析badcase，分析离线上线各种指标，甚至还要标数据选数据等等。这样说来，写代码的时长似乎反而是最短的（知道真相的我不禁流下了我太年轻的泪水）。 数据——不想当优秀数据清洁工的算法工程师不是合格的程序员。 模型——先上简单的，能用再说。后期可以慢慢调。 指标——人工评估yyds。 以上多少带点开玩笑的语气，大佬们看了不要拍我呀（嘻嘻） 下面是正经地技术思考贴！ 算法 vs 开发 算法分为很多种的，比如通信算法、机械算法、人工智能向算法，我这里主要说的是人工智能向的算法。人工智能向的算法，粗略地说往往称为机器学习算法，里面又包括深度学习算法。按不同方向有两大类需求最多，一类是视觉CV算法，一类是NLP算法，这是根据要实现的任务进行分类。还有根据场景进行分类的，比如推荐算法、广告算法、搜索算法。我谈谈推荐算法岗。 搜广推在很多方面是有共通之处的，所以我们常常说搜广推是一家，当然，具体还是有业务差异的。推荐算法在几年是得到了飞速发展的，尤其是深度学习时代来临以后，各种在DNN上的魔改开始广泛出现在业务上，而不再是LR一把梭。 可能每个在学校做科研的学生都把模型视作解决问题的关键，毕竟顶会里介绍模型的彩色图片制作精美，结构复杂，高端大气上档次，让人看了都要感叹一声这就是前沿技术的魅力吗？我在实习前，也天天想着怎么魔改我论文里的模型，让它看上去再高级一点，跟得上AI时代一些，即使我导已经点出了模型的创新是比较难的，而我依然执着于此，妄想创造个如同bert一样惊世骇俗的模型出来。 实习中给我最大的收获是，算法工程师最核心的能力除了对各种模型的熟练以外，在数据侧的研究也要捻熟于心。 数据！数据！数据！ 事实就是，想破脑袋去魔改模型或者玄学调参，很有可能不如认真检查数据问题对结果提升来得快。我现在可以理解，为什么很多人把算法工程师划分到数据科学里了。现在的机器学习工程师，狭隘地说，就是借工具来挖掘数据的规律，进而实现一定的预测能力。 开发则更偏向于具体实现。如果说开发是一个人的躯干，那么算法则是一个人的灵魂。灵魂不能脱离躯干，所以算法离不开开发。但是很多小公司不需要算法，正如只需要工具人干活就好了，工具人不需要灵魂。大厂想做有理想的产品，能改变世界的产品，就会需要灵魂去创新，也就需要算法。 开发和算法的成就感也截然不同。开发的成就感更多来自于模块或者系统编写成功，能够运行带来的快感。想着成千上万的用户正在使用我写的软件，这种存在感是成就感的来源。算法的成就感往往来自指标的提升，比如广告部门赚钱更多了，点击率更多了，转化率更多了，从而推测我们的算法起作用了。开发很多时候是在重复造轮子，而算法有时候是在寻找一个没有经验可循的新方法，这时脑洞和经验齐飞，创新不再是空谈。 这几年来，我对算法和开发都有了若干的尝试，这对于我曾经向往的全栈有了很好的打底，想必未来在分析一个问题的时候，从开发和算法不同的角度想方案，会有不一样的思索。 编程语言之争 一直以来，关于到底学什么编程语言好的争论从未停止过。我自己从接触开发开始，也经历过很多次摇摆。本科时最早学习的Java，毕设做的安卓app，结果第一份工作阴差阳错做的C++软件开发。后来读研，又开始做算法科研，用的Python。为了接触大数据，又重新学习Java。 曾经我也不断问自己，到底选C++还是Java？C++偏底层，更适合于服务器开发、游戏开发、算法引擎等，Java更适合于Web、企业级应用等。我到底喜欢哪个？ 直到在实习过程中，我发现即使我是算法工程师，写Python为主，可是要上线的时候，我还是要写Java的。 突然就真正地意识到，编程语言只是工具，面对什么场景，什么语言合适就用什么语言，而不是我喜欢什么语言写什么语言。我为什么不能既会Java又会C++还能写Python呢？ 其实只要学会一种编译语言，再学会一种脚本语言，基本上要迁移到其它语言是不难的。甚至现在刷题的时候，看到一个问题，可能也不一定限制于用某一种语言写，而是会考虑哪一种语言最适合这道题，就用哪种语言做。 啊，我悟了。 总结 最近一两年纠结的两大问题：选算法还是选开发，选C++还是选Java，在上面复盘了一遍，说了又好像没有完全说，哈哈哈哈哈。 总之，写代码的活就是最好的！ 闭环了。","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/tags/杂谈/"}]},{"title":"浅析Pandas中append方法的效率问题","slug":"浅析Pandas中append方法的效率问题","date":"2021-09-16T09:08:06.000Z","updated":"2021-09-16T14:04:31.030Z","comments":true,"path":"2021/09/16/浅析Pandas中append方法的效率问题/","link":"","permalink":"https://hubojing.github.io/2021/09/16/浅析Pandas中append方法的效率问题/","excerpt":"　　效率在大数据量下是非常重要的。 ","text":"效率在大数据量下是非常重要的。 定位问题：for循环下使用df.append添加数据（数据量几十万级）效率：非常低下，macbook pro跑8h跑不完。解决方法：先将df转为list，再使用.append()。原因：Pandas的.append方法不改变原有对象，而是创建一个新的对象。而列表则不会如此。具体官方代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141def append(self, other, ignore_index=False, verify_integrity=False, sort=None): \"\"\" Append rows of `other` to the end of caller, returning a new object. Columns in `other` that are not in the caller are added as new columns. Parameters ---------- other : DataFrame or Series/dict-like object, or list of these The data to append. ignore_index : boolean, default False If True, do not use the index labels. verify_integrity : boolean, default False If True, raise ValueError on creating index with duplicates. sort : boolean, default None Sort columns if the columns of `self` and `other` are not aligned. The default sorting is deprecated and will change to not-sorting in a future version of pandas. Explicitly pass ``sort=True`` to silence the warning and sort. Explicitly pass ``sort=False`` to silence the warning and not sort. .. versionadded:: 0.23.0 Returns ------- DataFrame See Also -------- concat : General function to concatenate DataFrame or Series objects. Notes ----- If a list of dict/series is passed and the keys are all contained in the DataFrame's index, the order of the columns in the resulting DataFrame will be unchanged. Iteratively appending rows to a DataFrame can be more computationally intensive than a single concatenate. A better solution is to append those rows to a list and then concatenate the list with the original DataFrame all at once. Examples -------- &gt;&gt;&gt; df = pd.DataFrame([[1, 2], [3, 4]], columns=list('AB')) &gt;&gt;&gt; df A B 0 1 2 1 3 4 &gt;&gt;&gt; df2 = pd.DataFrame([[5, 6], [7, 8]], columns=list('AB')) &gt;&gt;&gt; df.append(df2) A B 0 1 2 1 3 4 0 5 6 1 7 8 With `ignore_index` set to True: &gt;&gt;&gt; df.append(df2, ignore_index=True) A B 0 1 2 1 3 4 2 5 6 3 7 8 The following, while not recommended methods for generating DataFrames, show two ways to generate a DataFrame from multiple data sources. Less efficient: &gt;&gt;&gt; df = pd.DataFrame(columns=['A']) &gt;&gt;&gt; for i in range(5): ... df = df.append(&#123;'A': i&#125;, ignore_index=True) &gt;&gt;&gt; df A 0 0 1 1 2 2 3 3 4 4 More efficient: &gt;&gt;&gt; pd.concat([pd.DataFrame([i], columns=['A']) for i in range(5)], ... ignore_index=True) A 0 0 1 1 2 2 3 3 4 4 \"\"\" if isinstance(other, (Series, dict)): if isinstance(other, dict): other = Series(other) if other.name is None and not ignore_index: raise TypeError( \"Can only append a Series if ignore_index=True\" \" or if the Series has a name\" ) if other.name is None: index = None else: # other must have the same index name as self, otherwise # index name will be reset index = Index([other.name], name=self.index.name) idx_diff = other.index.difference(self.columns) try: combined_columns = self.columns.append(idx_diff) except TypeError: combined_columns = self.columns.astype(object).append(idx_diff) other = other.reindex(combined_columns, copy=False) other = DataFrame( other.values.reshape((1, len(other))), index=index, columns=combined_columns, ) other = other._convert(datetime=True, timedelta=True) if not self.columns.equals(combined_columns): self = self.reindex(columns=combined_columns) elif isinstance(other, list) and not isinstance(other[0], DataFrame): other = DataFrame(other) if (self.columns.get_indexer(other.columns) &gt;= 0).all(): other = other.reindex(columns=self.columns) from pandas.core.reshape.concat import concat if isinstance(other, (list, tuple)): to_concat = [self] + other else: to_concat = [self, other] return concat( to_concat, ignore_index=ignore_index, verify_integrity=verify_integrity, sort=sort, ) 该函数下的官方注释也特地强调了效率问题： Iteratively appending rows to a DataFrame can be more computationally intensive than a single concatenate. A better solution is to append those rows to a list and then concatenate the list with the original DataFrame all at once. 将行迭代地附加到df比单次连接计算量更大。更好的解决方案是将这些行追加到一个列表中，然后一次性将该列表与原始df连接起来。 这样是低效的：123df = pd.DataFrame(columns=['A'])for i in range(5): df = df.append(&#123;'A': i&#125;, ignore_index=True) 1234567df A0 01 12 23 34 4 下面这样比较高效：12pd.concat([pd.DataFrame([i], columns=['A']) for i in range(5)], ... ignore_index=True) 123456 A0 01 12 23 34 4","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hubojing.github.io/categories/编程语言/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hubojing.github.io/tags/Python/"},{"name":"Pandas","slug":"Pandas","permalink":"https://hubojing.github.io/tags/Pandas/"}]},{"title":"Pandas自用笔记","slug":"Pandas杂记","date":"2021-07-11T08:02:53.000Z","updated":"2021-07-11T15:23:31.580Z","comments":true,"path":"2021/07/11/Pandas杂记/","link":"","permalink":"https://hubojing.github.io/2021/07/11/Pandas杂记/","excerpt":"　　代码不写就会忘　　笔记不整理就会乱 ","text":"代码不写就会忘 笔记不整理就会乱 读取文件12345678910111213141516import osimport pandas as pdabs_path = os.path.abspath(__file__)proj_path = os.path.abspath(f\"&#123;abs_path&#125;/../\")data_path = os.path.join(proj_path, 'data.pkl')# 读取pkldf = pd.read_pickle(data_path)# 按列读取pkldf = pd.read_pickle(data_path)[['id'] + ['name'] + ['location']]# 保存pkldf.to_pickle(data_path)# 保存csvdf.to_csv('data.csv', index=False, encoding='utf-8-sig') 更多见https://pandas.pydata.org/docs/user_guide/io.html 显示完整df1234pd.set_option('display.width', None)pd.set_option('display.max_rows', None)pd.set_option('display.max_colwidth', None)print(df) groupby该函数是基于行的操作。 1df[](指输出数据的结果属性名称).groupby([df[属性],df[属性])(指分类的属性，数据的限定定语，可以有多个).mean()(对于数据的计算方式——函数名称) 例： 1df['score'].groupby([df[\"id\"],df[\"name\"]]).mean() 单分组123df.groupby(\"id\")df.groupby(\"id\").describe().unstack()df.groupby(\"id\")[\"location\"].describe().unstack()#用id分组，只看location 多分组1df.groupby([\"id\",\"name\"]).mean() agg该函数是基于列的聚合操作。 1A.groupby(A[\"生日\"].apply(lambda x:x.year)).count() 更多例子： 1234info_df = df. groupby([\"id\", \"name\"], sort=False).count()[[\"city\"]]#根据id和name分组统计city个数info_df = df.groupby([\"id\", \"name\"], as_index=False, sort=True).agg(&#123;\"city\": lambda x: len(set(list(x)))&#125;).reset_index(drop=True).rename(columns=&#123;\"city\": \"city_cnt\"&#125;)#根据id和name分组统计city的个数并重命名city列为city_cnt merge1pd.merge(left, right, how='inner', on=None, left_on=None, right_on=None, left_index=False, right_index=False, sort=True, suffixes=('_x', '_y'), copy=True, indicator=False, validate=None) 例： 12345678import pandas as pddf1 = pd.DataFrame(&#123;'key':list('bbaca'), 'data1':range(5)&#125;)print(df1)df2 = pd.DataFrame(&#123;'key':['a','b','d'], 'data2':range(3)&#125;)print(df2)print(pd.merge(df1, df2))print(pd.merge(df2, df1)) 1234567891011121314151617181920 key data10 b 01 b 12 a 23 c 34 a 4 key data20 a 01 b 12 d 2 key data1 data20 b 0 11 b 1 12 a 2 03 a 4 0 key data2 data10 a 0 21 a 0 42 b 1 03 b 1 1 更多见https://pandas.pydata.org/docs/user_guide/merging.html 参考文献pandas官方文档 python中groupby函数详解（非常容易懂） [Python3]pandas.merge用法详解","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hubojing.github.io/categories/编程语言/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hubojing.github.io/tags/Python/"},{"name":"Pandas","slug":"Pandas","permalink":"https://hubojing.github.io/tags/Pandas/"}]},{"title":"CRF++","slug":"CRF++","date":"2021-06-16T14:31:37.000Z","updated":"2021-06-16T15:13:02.950Z","comments":true,"path":"2021/06/16/CRF++/","link":"","permalink":"https://hubojing.github.io/2021/06/16/CRF++/","excerpt":"　　CRF++笔记。 ","text":"CRF++笔记。 NLP引入 NLP流程 句法分析是NLP任务的核心，NER是句法分析的基础。NER任务用于识别文本中的人名（PER）、地名（LOC）等具有特定意义的实体。非实体用O来表示。 CRF Conditional Random Field，条件随机场，一种机器学习模型，广泛用于NLP文本标注领域。 应用场景：分词、词性标注、命名实体识别（NER，Named Entity Recognition）等。 命名实体识别的任务是识别出待处理文本中三大类（实体类、时间类和数字类）、七小类（人名、机构名、地名、时间、日期、货币和百分比）命名实体。 NER是个分类任务,具体称为序列标注任务，即文本中不同的实体对应不同的标签，人名-PER，地名-LOC，等等，相似的序列标注任务还有词性标注、语义角色标注。 传统解决方法：（1）基于规则（2）基于统计学 隐马尔可夫（HMM）、条件随机场（CRF）模型和Viterbi算法（3）神经网络 LSTM+CRF模型 CRF的基础是马尔科夫随机场（概率无向图）。 CRF可以理解为在给定随机变量X的条件下，随机变量Y的马尔可夫随机场。其中，线性链CRF（一种特殊的CRF）可以用于序列标注问题。CRF模型在训练时，给定训练序列样本集(X,Y)，通过极大似然估计、梯度下降等方法确定CRF模型的参数；预测时，给定输入序列X，根据模型，求出P(Y|X)最大的序列y。 CRF分词原理 CRF把分词当做字的词位分类问题，通常定义字的词位信息如下： 词首，常用B表示 词中，常用M表示 词尾，常用E表示 单子词，常用S表示 例： 原始例句：他爱上海陆家嘴 CRF标注后：他/S 爱/S 上/B 海/E 陆/B 家/M 嘴/E 分词结果：他/爱/上海/陆家嘴 用CRF进行命名实体识别属于有监督学习。需要大批已标注的语料对模型参数进行训练。 CRF++ 目前常见的CRF工具包有pocket crf, flexcrf 和CRF++。 CRF++是著名的条件随机场的开源工具，也是目前综合性能最佳的CRF工具。 CRF++官网http://taku910.github.io/crfpp/ 安装 解压 cd 进入解压后的目录，执行‘./configure’命令 make 编译 make install （需先执行“su”获取root用户权限） make clean 删除安装时产生的临时文件（可不执行） 使用 两个过程：训练、测试。 数据格式 训练和测试文件必须包含多个tokens，每个token又包含多个列。token的定义可根据具体的任务，如词、词性等。每个token必须写在一行，且各列之间用空格或制表格间隔。一个token的序列可构成一个sentence，每个sentence之间用一个空行间隔。注意最后一列将是被CRF用来训练的最终标签。 特征模板 CRF++训练的时候，要求我们自己提供特征模板。 模板文件中的每一行是一个模板。每个模板都是由%x[row,col]来指定输入数据中的一个token。row指定到当前token的行偏移，col指定列位置。 参考文献用CRF做命名实体识别(三)NLP之CRF++安装及使用","raw":null,"content":null,"categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://hubojing.github.io/categories/人工智能/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"https://hubojing.github.io/tags/NLP/"},{"name":"CRF","slug":"CRF","permalink":"https://hubojing.github.io/tags/CRF/"},{"name":"CRF++","slug":"CRF","permalink":"https://hubojing.github.io/tags/CRF/"}]},{"title":"【Paper】DIN模型","slug":"DIN","date":"2021-05-06T02:55:35.000Z","updated":"2021-10-21T09:03:21.000Z","comments":true,"path":"2021/05/06/DIN/","link":"","permalink":"https://hubojing.github.io/2021/05/06/DIN/","excerpt":"　　阿里DIN模型　　10.21总算写完了…… ","text":"阿里DIN模型 10.21总算写完了…… 论文背景论文：Deep Interesting Network for Click-Through Rate Prediction下载地址2018年 阿里 现有问题 目前的深度学习模型都是先将稀疏输入特征映射为低维嵌入向量，再转换为固定长度的向量，最后联结起来送入MLP。这个固定长度的向量会成为瓶颈，无法从历史行为中捕获用户不同的兴趣。因此，本文提出深度兴趣网络Deep Interest Network（DIN）。它设计了一个局部激活单元从用户历史行为中自适应学习用户兴趣。另外，本文提出了两大技术：小批量感知正则化（mini-batch aware regularization）和数据自适应激活函数（data adaptive activation function）。 关键词点击率预测（Click-Through Rate Prediction）、展示广告（Display Advertising），线上贸易（E-commerce） 引言 INTRODUCTION Embedding &amp; MLP方法通过将用户行为嵌入向量转换为一个固定长度的向量来学习用户所有兴趣的表示，所有的表示向量是欧式空间。换言之，将用户不同的兴趣压缩到一个固定长度的向量，限制了表达能力。为了更好地表达用户不同兴趣，就要扩展向量长度。这会增多学习参数，并且增加过拟合的风险。也加重了计算和存储的压力，对于工业线上系统来说很困难。 另一方面，没有必要把用户全部兴趣压缩到同一个向量里，因为只有部分兴趣会影响用户下一个动作（点击或不点击）。 训练的问题： 基于SGD的优化方法只更新出现在每个小批量中的稀疏特征的参数。然而，加上传统的ℓ2正则化，计算变得不可接受，这需要为每个小批量计算整个参数的L2范数(在阿里的场景，大小按比例增加到数十亿)。本文提出了一种新的小批量正则化方法，在L2范数的计算中，每个小批量正则化中只出现非零特征参数，使得计算是可接受的。另外，设计了一个数据自适应激活函数，推广到常用的PReLU，它通过自适应地调整输入的校正点，也就是输入的分布，并被证明有助于训练具有稀疏特征的工业网络。 贡献点 指出了使用固定长度向量来表达用户不同兴趣的局限性，并设计了一种新的深度兴趣网络(DIN)，它引入了一个局部激活单元来自适应地从给定广告的历史行为中学习用户兴趣的表示。DIN可以大大提高模型的表达能力，更好地捕捉用户兴趣的多样性特征。 开发了两种新的技术来帮助训练工业深度网络:I)一种小批量感知正则化器，这种正则化器在具有大量参数的深度网络上节省了大量的正则化计算，并且有助于避免过拟合；ii)一种数据自适应激活函数，这种函数通过考虑输入的分布来推广PReLU，并且表现出良好的性能。 在公共数据集和AI-ibaba数据集上进行了大量实验。结果验证了所提出的DIN和训练技术的有效性。所提出的方法已经在全球最大的广告平台之一阿里巴巴的商业展示广告系统中得到了应用，为业务的发展做出了重大贡献。 代码：https://github.com/zhougr1993/DeepInterestNetwork 背景 BACKGROUND 图1 - 阿里广告系统 预测每个给定广告的点击率，然后选择排名最高的广告。 深度兴趣网络 DEEP INTEREST NETWORK特征表示 Feature Representation 表1 - 特征处理 特征表示 表中描述了我们系统中使用的全部特征集，它由四类组成，其中用户行为特征是典型的多热点编码向量，包含丰富的用户兴趣信息。注意，在我们的设置中，没有组合特性。我们利用深度神经网络捕获特征的交互作用。 基线模型 Base Model(Embedding&amp;MLP) 基础架构 vs DIN架构 嵌入层（Embedding layer) 池化层和连接层（Pooling layer and Concat layer） 得到定长向量：$e_i = pooling(e_{i_1}, e_{i_2}, …, e_{i_k})$ 最常用的是sum pooling和average pooling。 MLP Loss $$L = - \\frac{1}{N}\\sum_{(x,y)∈S}(ylogp(x) + (1 - y)log(1 - p(x)))$$ S是尺寸为N的训练集，x是输入，y是标签。p(x)是经过softmax层后的输出，代表样本x被点击的概率。 DIN架构 The structure of Deep Interest Network 基线模型对一个用户使用定长向量表示，无论候选广告是什么。 为了表示用户兴趣多样化，一种简单的方法是扩展嵌入维度，但这会增加学习参数规模。有过拟合的风险，并且增加了计算和存储的负担。 DIN模拟了关于给定广告的用户局部激活兴趣。 DIN引入了一个用于用户行为特征的局部激活单元，使用了加权求和池化（weighted sum pooling）来自适应计算当给定一个候选广告A时，用户的表示$V_U$。 局部激活单元公式：$$v_U = f(v_A, e_1, e_2, …, e_H) = \\sum_{j=1}^{H}a(e_j, v_A)e_j = \\sum_{j = 1}^{H}w_je_j$$ 其中，${e_1, e_2, …, e_H}$是用户U的行为嵌入向量（长度为H），$v_U(A)$是广告A的嵌入向量。 在这种方式下，$v_U(A)$在不同的广告下，a(·)是一个带有激活权重输入的前向反馈网络。除了这两部分输入嵌入向量，a(·)将它们的外积喂入后续网络。a(·)softmax输出后的标准化被舍弃。 训练方法 TRAINING TECHNIQUES小批量感知正则化 Mini-batch Aware Regularization 工业训练网络面临过拟合的问题。模型训练在第一轮训练后（不加正则化）性能迅速下降。传统的正则策略在面对稀疏输入和成千上万的参数时并不适用（比如l2和l1正则化)。 为此，提出小批量感知正则化，即只在每次小批量中对稀疏特征的参数计算$L_2-norm$。 $$L_2(W)=||W||_{2}^{2}$$ $$= \\sum_{j = 1}^{K}||w_j||_{2}^{2}$$ $$= \\sum_{(x,y)∈S}\\sum_{j = 1}^{K}\\frac{I(x_j≠0)}{n_j}||w_j||_2^2$$ $I(x_j≠0)$表示x有特征j，$n_j$表示特征id j出现的数量。上述公式可以被转换为下面的小批量感知形式： $$L_2(W) = \\sum_{j = 1}^{K}\\sum_{m = 1}^{B}\\sum_{(x,y)∈B_m}\\frac{I(x_j≠0)}{n_j}||w_j||_2^2$$ 其中，B表示小批量的数量，$B_m$表示第m次小批量。定义$α{mj} = max{(x,y)∈B_m}I(x_j ≠ 0)$为小批量$B_m$中至少有一次有特征id j。 上述近似为 $$L_2(W) ≈ \\sum_{j = 1}^{K}\\sum_{m = 1}^{B}\\frac{α_{mj}}{n_j}||w_j||_2^2$$ 通过这种方式，推导出了一种$l_2$正则化的近似小批量感知形式。 对于第m次小批量，关于特征j的嵌入权重的梯度为 $$w_j\\leftarrow w_j - \\eta[\\frac{1}{|B_m|}\\sum_{(x,y)∈B_m}\\frac{\\partial L(p(x), y)}{\\partial w_j} + \\lambda \\frac{α_{mj}}{n_j}w_j]$$ 在这里只有出现在第m次小批量的特征参数才会参与正则计算。 数据自适应激活函数 Data Adaptive Activation Function PReLU是常用的激活函数。 PReLU和Dice 如图所示，PReLU在0附近有一个固定的转折点，这对于每层不同分布的输入是不合适的。于是，本文设计了一个自适应激活函数Dice。$$f(s) = p(s)·s + (1-p(s))·αs, p(s) = \\frac{1}{1 + e^{-\\frac{s-E[s]}{\\sqrt{Var[s] + \\epsilon}}}}$$ E[s]和Var[s]代表每次小批量输入的均值和方差。$\\epsilon$是一个常量，此处设为$10^{-8}$。 Dice的主要思想是根据输入数据分布自适应调整转折点，值设置为输入的平均值。另外，Dice在两个函数间切换很顺滑。当E(s) = 0且Var[s] = 0时，Dice退化到PReLU。 实验 EXPERIMENTS数据集和实验步骤 Datasets and Experimental Setup 数据集三个：Amazon Dataset， MovieLens Dataset和Alibaba Dataset。 Amazon Dataset：http://jmcauley.ucsd.edu/data/amazon/ MovieLens Dataset：https://grouplens.org/datasets/movielens/20m/ 数据集情况如图。 数据 基线实验 LR BaseModel Wide&amp;Deep PNN DeepFM策略$$AUC = \\frac{\\sum_{i = 1}^{n}impression_i \\times AUC_i}{\\sum_{i = 1}^{n}impression_i}$$ $$RelaImpr = (\\frac{AUC(measured model) - 0.5}{AUC(base model) - 0.5} - 1) \\times 100\\%$$ RelaImpr用来衡量模型间的相对提升。 亚马逊数据集和MovieLens数据集模型对比结果 Result from model comparison on Amazon Dataset and MovieLens Dataset 如图所示。 图4 表3 正则化性能 Performance of regularization 对比试验： Dropout Filter Regularization in DiFacto MBA 表4 阿里巴巴数据集模型对比结果 Result from model comparison on Alibaba Dataset 表5 DIN可视化 Visualization of DIN 图5 图6 总结 CONCLUSIONS 传统CTR模型适用定长向量代表用户兴趣是有缺陷的。为了提高用户兴趣多样性，提出DIN模型来激活相关的用户行为，并且针对不同的广告有一个自适应用户兴趣表示向量。另外，提出两种技术帮助训练工业深度网络，并提升了DIN性能。DIN已被部署到阿里巴巴的在线广告展示系统。","raw":null,"content":null,"categories":[{"name":"论文","slug":"论文","permalink":"https://hubojing.github.io/categories/论文/"}],"tags":[{"name":"推荐算法","slug":"推荐算法","permalink":"https://hubojing.github.io/tags/推荐算法/"},{"name":"DIN","slug":"DIN","permalink":"https://hubojing.github.io/tags/DIN/"}]},{"title":"【Paper】Entire Space Multi-Task Model-An Effective Approach for Estimating Post-Click Conversion Rate","slug":"ESMM","date":"2021-04-27T02:23:10.000Z","updated":"2021-05-06T09:39:02.875Z","comments":true,"path":"2021/04/27/ESMM/","link":"","permalink":"https://hubojing.github.io/2021/04/27/ESMM/","excerpt":"　　多任务学习之ESMM ","text":"多任务学习之ESMM 论文背景2018年 阿里巴巴 摘要 ABSTRACT传统的CVR建模应用流行的深度学习方法，并实现最先进的性能。遇到的问题：传统的CVR模型用点击曝光的样本进行训练，同时用所有曝光的样本对整个空间进行推断。这导致样本选择偏差（sample selection bias）问题。另外还有数据稀疏的问题。本文提出ESMM(Entire Space Multi-task Model)，通过用户行为序列模式对CVR建模，比如，曝光(impression)–&gt;点击(click)–&gt;转换(conversion)。该模型直接在整个空间建模CVR，并使用了一种特征表示转移学习策略。数据集采用淘宝推荐系统，显示ESMM效果显著。本文还发布了第一个包含点击和转化标签用于CVR建模的时序样本数据集。 关键词：CVR(post-click conversion rate), 多任务学习(multi-task learning), 样本选择偏差(sample selection bias), 数据稀疏(data sparsity), 全空间建模(entire-space modeling) 介绍 INTRODUCTION ESMM 1）传统的CVR模型在由impression组成的数据集上训练，同时利用所有impression的样本在整个空间上进行推断。该问题（SSB）会影响训练模型的泛化性能。2）数据稀疏问题。在实践中，为训练CVR模型而收集的数据通常比CTR任务少得多。训练数据的稀疏性使得CVR模型拟合相当困难。 以前的研究试图解决这些问题。在[5]中，建立了不同特征的分层估计量，并结合逻辑回归模型来解决直接序列问题。然而，它依赖于先验知识来构建层次结构，这在拥有数千万用户和项目的推荐系统中很难应用。过采样方法[11]复制了罕见的类别样本，这有助于减轻数据的稀疏性，但对采样率敏感。全部缺失为阴性(AMAN)应用随机抽样策略选择未点击的impression作为负样本[6]。通过引入未观察到的例子，它可以在一定程度上消除SSB问题，但会导致始终被低估的预测。无偏方法[10]通过剔除抽样从观测值中拟合真实的潜在分布，解决了CTR建模中的SSB问题。然而，当用拒绝概率划分来加权样本时，可能会遇到数值不稳定性。总之，无论是SSB还是DS问题都没有在CVR建模的场景中得到了很好的解决，上述方法都没有利用序列动作信息。 pCVR = p(conversion|click, impression) ESMM可以同时解决SSB和DS问题。它引入了CTR和CTCVR的两个辅助任务。ESMM没有直接用曝光的样本来训练CVR模型，而是把pCVR作为一个中间变量，乘以pCTR等于pCTCVR。PCTCVR和pCTR都是在整个空间上用所有曝光的样本来估计的，因此导出的pCVR也适用于整个空间。这表明SSB问题已经消除。此外，CVR网络特征表示的参数与CTR网络共享。后者是用更丰富的样本训练的。这种参数迁移学习有助于显著缓解DS问题。 对于这项工作，我们从淘宝的推荐系统中收集流量日志。整个数据集由89亿个样本组成，并带有点击和转换的序列标签。ESMM的表现始终优于其它模型，这证明了所提出方法的有效性。 数据集开源：https://tianchi.aliyun.com/datalab/dataSet.html?dataId=408 提出的方法 THE PROPOSED APPROACH注释 Notation$S = {(x_i, y_i -&gt; z_i)}|^N_{i=1}$，x代表已观察曝光的特征向量，它通常是一个有多域(field)的高维稀疏向量，比如用户域，物品域等。y和z是二分标签，y = 1或者z = 1代表各自被点击或转化事件发生。y-&gt;z代表点击和转化标签的序列依赖，即转化事件发生时总会有前序点击。pCVR = p(z = 1|y = 1, x)pCTR = p(y = 1|x)pCTCVR = p(y = 1, z = 1|x)p(y = 1, z = 1|x) = p(y = 1|x) × p(z = 1|y = 1, x)—–pCTCVR————pCTR———–pCVR——– CVR建模和挑战 CVR Modeling and Challenges ESMM架构 图2左边的DNN CVR建模作为基线模型，传统的CVR模型直接建模p(z = 1|y = 1, x)，使用点击的曝光样本训练模型。比如，$S_c = {(x_j, z_j)|y_j = 1}|^M_{j=1}$，M是所有曝光样本数。$S_c$是S的子集。在$S_c$中，被点击但没有被转化的样本作为负样本，被转化也被点击的样本作为正样本。Sample selection bias(SSB)通过引入一个辅助特征向量$x_c$，传统CVR做了一个近似：$p(z = 1|y = 1, x) ≈ q(z = 1|x_c)$。推理阶段，p(z = 1|y = 1, x)在整个X空间将近似为q(z = 1|x)。传统的CVR训练数据是曝光和点击的数据，然而预测时又要在整个样本空间。点击事件只是整个曝光样本空间的一个子集，在子集中提取的特征在完整集中使用是有偏的，且数据分布也不一致，违背了机器学习算法有效训练的前提（iid），减弱模型的泛化能力。 Data sparsity (DS)一般CVR比关联的CTR任务少1-3个数量级，CTR任务是在全印象的S的数据集上训练的。表1显示了我们的实验数据集的统计数据，其中CVR任务的样本数量仅为CTR任务的4%。值得一提的是，CVR建模还存在其他挑战，例如延迟反馈。本文不涉及。 多任务全空间模型 Entire Space Multi-Task Model在整个空间建模。$p(z = 1|y = 1, x) = \\frac{p(y = 1, z = 1|x)}{p(y = 1|x)}$ 这里p(y = 1，z = 1|x)和p(y = 1|x)是在具有所有曝光的S的数据集上建模的。 损失函数：$L(θ{cvr}, θ{ctr}) = \\sum_{i=1}^N{l(y_i,f(x_i; θ{ctr}))} + \\sum{i=1}^N{l(y_i \\&amp; z_i,f(x_i; θ_{ctr}) × f(x_i;θ_{cvr}))}$l(·)是交叉熵损失函数。 特征表征转移。嵌入层将大规模稀疏输入映射到低维表示向量中。它贡献了深层网络的大部分参数，而深层网络的学习需要大量的训练样本。在ESMM，CVR网络的嵌入式词典与CTR的嵌入式词典是共享的。它遵循特征表征迁移学习范式。CTR任务的全曝光训练样本相对比CVR任务丰富得多。这种参数共享机制使ESMM的CVR网络能够借鉴未点击的曝光，为缓解数据稀疏问题提供了很大的帮助。请注意，ESMM的子网络可以用一些最近开发的模型来代替，这可能会获得更好的性能。由于篇幅有限，我们省略了它，而把重点放在解决CVR建模在实际实践中遇到的挑战上。","raw":null,"content":null,"categories":[{"name":"论文","slug":"论文","permalink":"https://hubojing.github.io/categories/论文/"}],"tags":[{"name":"ESMM","slug":"ESMM","permalink":"https://hubojing.github.io/tags/ESMM/"},{"name":"推荐算法","slug":"推荐算法","permalink":"https://hubojing.github.io/tags/推荐算法/"}]},{"title":"多机共用一套键鼠方案","slug":"多机共用一套键鼠方案","date":"2021-03-05T03:35:43.000Z","updated":"2021-03-05T04:33:54.016Z","comments":true,"path":"2021/03/05/多机共用一套键鼠方案/","link":"","permalink":"https://hubojing.github.io/2021/03/05/多机共用一套键鼠方案/","excerpt":"　　零成本 半小时内 极速解决问题 ","text":"零成本 半小时内 极速解决问题 由现实问题引发的思考（可不看） 日常在实验室学习，目前在实验室常用四台设备：台式电脑、笔记本、ipad、手机。 受限： 1. 台式电脑鼠标坏了。 2. 笔记本键盘舒适度不如机械键盘。 3. 实验室桌子小，除了设备还有一堆书籍纸张，已经放置不下更多的键盘鼠标。 4. 校园网只能同时在线三个设备。 5. 懒惰（滑稽），不愿意在两个设备间用U盘拷来拷去。 之前的痛：一个鼠标发射器每日从台式主机插拔换到笔记本上，伸手去够笔记本键盘敲，来回反复。 简直了，受够了，买新的键鼠是不可能买的（穷），就一套键鼠在两台电脑中游走还可以勉强办公的样子。 改造方案 双机下载软件无界鼠标，在副机上填写主机显示的主机名和密码即可。 注意：前提是在同一局域网下！ 如果连上了，下文都不用看了！ 可能遇到的问题 不在同一局域网 是我遇到的问题没错了，明明两台电脑都连的校园wifi啊，它怎么连不上呢？遂查看各自ip。怎么是公网ip… 解决方案：用一台电脑给另一台开热点，即可保证在同一网络内。 引申问题： 1. 台式如何连wifi？ 解决方案：买个无线网卡。 2. 老旧电脑连不上5G频段wifi？ 又是我遇到的问题没错了。 网上有方法说更改网络属性-配置-适配器设置-高级，更改信道到1~11，可以解决。但我没成功。主要原因是我可怜的2013年买的笔记本，不配5G wifi，压根就没有首选频段设置。只能曲线救国了，用笔记本给台式开热点，委屈台式连2.4G wifi了。 改造后 懒人表示极其舒适… 不仅一套键鼠用两台设备，鼠标键盘自动跨屏，还可以在两台设备间自由拷贝文件。 手机和ipad也刚好能连上校园网了。 还省了一套键鼠的钱… 嗯，懒是程序员的第一生产力。","raw":null,"content":null,"categories":[{"name":"数码","slug":"数码","permalink":"https://hubojing.github.io/categories/数码/"}],"tags":[{"name":"多机协作","slug":"多机协作","permalink":"https://hubojing.github.io/tags/多机协作/"}]},{"title":"【Paper】Wide & Deep Learning for Recommender Systems","slug":"【Paper】Wide & Deep Learning for Recommender Systems","date":"2021-03-02T01:20:00.000Z","updated":"2021-03-02T08:57:55.000Z","comments":true,"path":"2021/03/02/【Paper】Wide & Deep Learning for Recommender Systems/","link":"","permalink":"https://hubojing.github.io/2021/03/02/【Paper】Wide & Deep Learning for Recommender Systems/","excerpt":"　　推荐系统 + 深度学习 2　　谷歌著名的Wide &amp; Deep模型 ","text":"推荐系统 + 深度学习 2 谷歌著名的Wide &amp; Deep模型 论文背景 题目：Wide &amp; Deep Learning for Recommender Systems 作者：Heng-Tze Cheng, Levent Koc, Jeremiah Harmsen, Tal Shaked, Tushar Chandra, Hrishi Aradhye, Glen Anderson, Greg Corrado, Wei Chai, Mustafa Ispir, Rohan Anil, Zakaria Haque, Lichan Hong, Vihan Jain, Xiaobing Liu, Hemal Shah, Google Inc. 会议信息：DLRS ’16 September 15-15, 2016, Boston, MA, USA 谷歌引用数量：1324（截至2021年3月2日） 引言 INTRODUCTION 推荐系统可视为搜索排序系统，输入是用户和上下文信息的查询，输出是物品列表。类似于一般的搜索排序问题，推荐系统中的一大挑战是同时实现记忆（memorization）和泛化（generalization）。 Memorization可以宽泛地定义为学习物品或特征的共现频率并探索历史数据的相关关系。 Generalization是基于相关性的传递性并探索过去从未出现过的新的特征组合。 基于memorization的推荐系统通常更局限于和直接与用户曾有过行为的物品相关。 基于generalization的推荐系统试图增强推荐物品的多样性。 例子：如果用户安装了netflix，特征”user_installed_app=netflix”的值为1。 Memorization：通过使用稀疏特征的跨物品转换实现，例如AND(user_installed_app=netflix, impression_app=pandora”)，如果用户安装了netflix，然后显示pandora, AND的值为1。 Generalization：可以通过使用粒度更小的特性来添加，例如AND(user_installed_category=video，impression_category=music)，但是通常需要手动的特征工程。 叉积变换（cross-product transformations）的一个限制是它们不能推广到没有出现在训练数据中的查询项特征对。基于嵌入的模型，例如FM或者DNN跨域解决这个问题。但是当底层的查询项矩阵是稀疏且高阶的（例如用户具有特定的偏好或小范围的吸引力）时，很难学习查询和项的有效低维表示。在这种情况下，大多数查询项对之间应该没有交互，但密集嵌入将导致所有查询项对的预测非零，因此导致过拟合而产生不相干的推荐。具有叉积特征转换的线性模型可以用更少的参数记住这些“例外规则”。 在本文中提出了Wide&amp;Deep模型，通过联合训练一个线性模型组件和一个神经网络组件，实现在一个模型中记忆和泛化。 Wide&Deep模型 贡献点 带有嵌入和带有特征转换的线性模型的前馈神经网络联合训练的Wide&amp;Deep学习框架，用于具有稀疏输入的通用推荐系统。 在谷歌Play上实施和评估，谷歌Play是一个拥有超过10亿活跃用户和超过百万应用的移动应用商店。 在TensorFlow中有开源代码。 推荐系统概述 RECOMMENDER SYSTEM OVERVIEW 概述 推荐系统一般分为召回（Retrieval）层，排序（Ranking）层。本文在排序层使用Wide &amp; Deep学习框架。 宽 &amp; 深度学习框架 WIDE &amp; DEEP LEARNING宽度组件 The Wide Component 宽度组件是广义线性模型$y = w^Tx + b$，y是预测值，$x = [x_1, x_2, …, x_d]$是d维特征，$w = [w_1, w_2, …, w_d]$是模型参数，b是偏置项。特征集包括原始输入特征和转换后的特征。其中最重要的一种变换是叉积变换，定义为:$$\\phi_k(x) = \\prod_{i=1}^d{x_i}^{c_{ki}}, c_{ki}∈{0,1}$$ 其中，$c_{ki}$是一个布尔变量，如果第i个特征是第k个变换$\\phi_k$的一部分，则为1，否则为0。 对于二进制特征，一个叉积变换“AND(gender=female, language=en)，只有当(“gender=female” and “language=en”)时才为1。 这捕获了二元特征之间的相互作用，并为广义线性模型增加了非线性。 深度组件 The Deep Component 深度组件是一个前馈神经网络。对于分类特征，原始输入是特征字符串(例如 “language=en”)，这些稀疏的、高维的分类特征首先被转换成一个低维的、稠密的实值向量，通常被称为嵌入向量。嵌入的维数通常在O(10)到O(100)之间。在模型训练过程中，先对嵌入向量进行随机初始化，然后对其值进行训练，使最终损失函数最小。这些低维密集嵌入向量然后被馈入前向传递的神经网络的隐藏层。具体来说，每个隐含层计算：$$\\alpha^{l+1} = f(W^{(l)}a^{(l)}) + b^{(l)})$$ 模型联合训练 Joint Training of Wide &amp; Deep Model 将宽度组件和深度组件以其输出对数概率的加权和进行组合作为预测值，然后将其输入一个通用的logistic损失函数进行联合训练。 Joint training和ensemble是有区别的。 ensemble：在一个整体中，个体模型在不相互了解的情况下被单独训练，并且它们的预测只在预测时组合，而不是在训练时。由于训练是不连贯的，每个单独的模型尺寸通常需要更大(例如，有更多的特征和转换)，以达到一个集成工作的合理精度。 Joint training：联合训练通过在训练时同时考虑深度和宽度部分以及它们和的权重来同时优化所有参数。另外，宽度部分只需要用少量的叉积特征转换来弥补深度部分的弱点，而不需要一个全量的宽度模型。 采用小批量随机优化方法，将梯度从输出部分同时反向传播到模型的宽、深部分，从而实现宽、深模型的联合训练。在实验中，本文使用L1正则化的Follow-the-regularization-leader(FTRL)算法作为模型宽度部分的优化算法，使用AdaGrad作为模型深度部分的优化算法。 对于逻辑回归问题，模型的预测为：$$P(Y=1|x) = \\sigma(w^T_{wide}[x,\\phi(x)]+w^T_{deep}a^{(l_f)}+b)$$ 其中Y是二分类标签，$\\sigma(·)$是sigmoid函数，$\\phi(x)$是原始特征x的叉积变换，b是偏置项。$w_{wide}$是所有宽度模型权重的向量，$w_{deep}$是应用在最终激活$a^{(l_f)}$的权重。 系统实现 SYSTEM IMPLEMENTATION 系统实现 数据产生 Data Generation 通过将一个特征值x映射到其累积分布函数P(X≤x)，将连续实值特征归一化为[0,1]，并分成$n_q$分位数。对于第i个分位数的值，规范化值为$\\frac{i-1}{n_q-1}$。分位数边界i−1在数据生成时计算。 模型训练 Model Training 模型训练 在训练过程中，输入层接收训练数据和词汇，并生成稀疏和密集特征以及标签。宽度组件包括用户安装应用和印象应用的叉积。对于模型的深层部分，每个分类特征学习一个32维的嵌入向量。将所有的嵌入与密集特征连接在一起，得到一个大约1200维的密集向量。然后将连接的矢量送入3个ReLU层，最后送入logistic输出单元。 Wide &amp; Deep模型训练了超过5000亿个例子。每当一组新的训练数据到达时，模型就需要重新训练。然而，每次重新训练在计算上都是昂贵的，并且延迟了服务时间。为了解决这一挑战，本文实现了一个暖启动系统，该系统使用先前模型的嵌入和线性模型权值来初始化一个新的模型。在将模型加载到模型服务器之前，需要对模型进行一次演练，以确保在服务实时流量时不会出现问题。本文根据经验来验证模型的质量，作为一个完整的检查。 模型服务 Model Serving 一旦模型经过训练和验证，就把它加载到模型服务器中。对于每个请求，服务器都会从应用程序检索系统和用户特性中接收一组应用程序候选项来为每个应用程序评分。然后，应用程序从最高分到最低分进行排名，并按照这个顺序向用户展示这些应用程序。分数是通过运行一个采用Wide &amp; Deep模型的正向推理来计算的。 为了为每个请求提供10毫秒量级的服务，使用多线程并行来优化性能，通过并行运行较小的批处理，来代替在单个批处理推理步骤中对所有候选应用程序进行评分。 实验 EXPERIMENT RESULTSApp Acquisitions 本文在A/B测试框架下进行了为期3周的在线实时实验。对于对照组，随机选择1%的用户，并向他们展示由上一个版本的排名模型生成的推荐，该模型是一个高度优化的广泛性logistic回归模型，具有丰富的叉积特征转换。在实验组中，1%的用户使用了由相同的一组特征进行训练的Wide &amp; Deep模型生成的推荐。 性能对比 Wide &amp; Deep模式使app store主登陆页面的应用获取率比对照组提高了+3.9%。结果还与另1%组仅使用具有相同特征和神经网络结构的模型的深度部分进行了比较，Wide &amp; deep模式比deep-only模型有+1%的增益。 除了在线实验，还展示了AUC。Wide &amp; Deep的线下AUC略高，但对线上流量的影响更显著。一个可能的原因是离线数据集中的印象和标签是固定的，而在线系统可以通过混合归纳和记忆生成新的探索性推荐，并从新的用户反应中学习。 服务性能 Serving Performance 面对我们的商业移动应用商店所面临的高流量，高吞吐量和低延迟的服务具有挑战性。在高峰流量时，我们的推荐服务器每秒可以获得超过1000万个应用。使用单个线程，在一次批处理中为所有候选人打分需要31毫秒。我们实现了多线程，并将每个批处理分成更小的部分，这显著地将客户端延迟减少到14毫秒（包括服务开销），如表所示。 服务性能 相关工作 RELATED WORK 结合带叉积转换的广义线性模型与深层神经网络嵌入的灵感来自以前的工作，比如FM，通过在两个低维嵌入向量之间使用点积分解两个变量间的相互作用，将线性模型了进行推广。在本文中，通过神经网络代替点积来学习嵌入之间高度非线性的相互作用，从而扩展了模型容量。 在语言模型中，通过学习输入和输出之间的直接权值，提出了使用n元特征的递归神经网络(RNNs)和最大熵模型联合训练，以显著降低RNN的复杂性(例如，隐藏层大小)。在计算机视觉中，深度残差学习已被用于降低训练更深层次模型的难度，并通过跳过一个或多个层次的捷径连接提高准确性。 神经网络与图形模型的联合训练还被应用于基于图像的人体姿态估计。在这项工作中，探讨了前馈神经网络和线性模型的联合训练，在稀疏特征和输出单元之间直接连接，用于输入数据稀疏的通用推荐和排序问题。 在推荐系统文献中，将内容信息的深度学习与评分矩阵的协同过滤(CF)相结合来探索协同深度学习。以前的工作也曾致力于手机应用推荐系统，如AppJoy在用户的应用使用记录上使用CF。不同于之前工作中基于cf或基于内容的方法，我们在app推荐系统中，基于用户和印象数据使用Wide &amp; Deep模型联合训练。 总结 CONCLUSION 宽度线性模型可以通过叉积特征变换有效地记忆稀疏特征交互，而深度神经网络可以通过低维嵌入来泛化之前未见过的特征交互。在线实验结果表明，与Wide-only和Deep-only模型相比，Wide &amp; Deep模型有显著提高。 代码https://github.com/tensorflow/tensorflow/blob/r1.11/tensorflow/python/estimator/canned/dnn_linear_combined.py","raw":null,"content":null,"categories":[{"name":"论文","slug":"论文","permalink":"https://hubojing.github.io/categories/论文/"}],"tags":[{"name":"推荐算法","slug":"推荐算法","permalink":"https://hubojing.github.io/tags/推荐算法/"},{"name":"深度学习","slug":"深度学习","permalink":"https://hubojing.github.io/tags/深度学习/"},{"name":"Wide & Deep","slug":"Wide-Deep","permalink":"https://hubojing.github.io/tags/Wide-Deep/"}]},{"title":"【paper】AutoRec - Autoencoders Meet Collaborative Filtering","slug":"【Paper】AutoRec","date":"2021-02-04T02:19:03.000Z","updated":"2021-02-05T08:26:07.708Z","comments":true,"path":"2021/02/04/【Paper】AutoRec/","link":"","permalink":"https://hubojing.github.io/2021/02/04/【Paper】AutoRec/","excerpt":"　　推荐系统 + 深度学习 1 ","text":"推荐系统 + 深度学习 1 论文背景WWW’15作者：Suvash Sedhain, Aditya Krishna Menon, Scott Patrick Sanner, Lexing Xie 谷歌学术引用次数580（截至2021年2月4日） 关键词：Recommender Systems; Collaborative Filtering; Autoencoders INTRODUCTION 引言本文提出一种新的基于自动编码器范例的CF模型，思路来自于针对视觉和语音任务的深度神经网络模型。和CF相比，具有表示和计算的优越性。 THE AUTOREC MODEL 模型每个用户U={1,…,m}可表示为$r^{(i)} = (R_{u1},…,R_{un})∈\\mathbb{R}^n$。每个物品I={1,…,n}可表示为$r^{(i)} = (R_{1i},…,R_{mi})∈\\mathbb{R}^m$，评分矩阵R。目标：设计一种基于物品（用户）的自动编码器，可以输入部分显式$r_{(i)}$($r_{(u)}$)，将其映射到低维潜在空间，然后在输出空间重建$r_{(i)}$($r_{(u)}$)来预测缺失的评分用于推荐。自动编码器解决$$min_{\\theta}\\sum_{r∈S}||r - h(r;\\theta)||^2_2$$$h(r;\\theta)$是输入r的重构$$h(r;\\theta) = f(W · g(Vr + μ) + b)$$f、g是激活函数。$\\theta = {W, V, μ, b}$$W∈\\mathbb{R}^{d×k}$, $V∈\\mathbb{R}^{k×d}$, $μ∈\\mathbb{R}^k$, $b∈\\mathbb{R}^d$该目标对应于具有单个k维隐藏层的自连接神经网络。使用反向传播来学习参数θ。 基于物品的AutoRec模型I-AutoRec${r^{(i)}}^n_{i=1}$ 基于物品的AutoRec 两点改变： 每个$r^{(i)}$通过反向传播更新和输入有关的权重得到，这在矩阵分解和RBM策略中常用。 设计了学习参数正则化防止过拟合。 I-AutoRec需要估计2mk + m + k个参数。对于给定的已学习参数$\\theta$，对于用户u和物品i的预测评分为$$\\hat{R}_{ui} = (h(r^{(i)};\\hat{\\theta}))_u$$ 目标函数：$$min_{\\theta}||r^{(i)}-h(r^{(i)};\\theta)||^2_o + \\frac{\\lambda}{2}·(||W||^2_F + ||V||^2_F)$$$||||^2_o$代表只考虑可观测评分的贡献。 基于用户的AutoRec模型U-AutoRec${r^{(u)}}^m_{u=1}$ 和CF策略的区别：对比基于RBM的CF模型（RBM-CF） RBM-CF是基于限制玻尔兹曼机的生成概率模型，AutoRec是一个基于自动编码器的判别模型。 RBM-CF通过最大化似然log函数估计参数，AutoRec直接最小化RMSE。 训练RBM-CF需要使用对比散度，训练AutoRec需要相对更快的基于梯度的反向传播。 RBM-CF只使用于离散评分，并对每个评分估计一个分散的参数集。对r个可能的评分，它使用了基于RBM的nkr或者mkr个参数用于用户（物品）。AutoRec与r无关，因此需要较少的参数。 较少的参数使AutoRec的内存占用量更少，更不容易过度拟合。 对比矩阵分解（MF）MF学习线性潜在表示，AutoRec可以通过激活函数学习非线性潜在表示。 EXPERIMENTAL EVALUATION 实验评估基线：RBM-CF, BiasedMF, LLORMA.数据集：Movielens 1M, 10M 和Nerflix数据集没有训练数据的测试集默认评分为3。训练集：测试集=9：1将训练集10%作为验证集。重复划分步骤5次并记录平均RMSE。每次实验95%在RMSE偶然的间隔在±0.003之间。正则化参数λ∈{0.001, 0.01, 0.1, 1, 100, 1000}潜在维度k∈{10, 20, 40, 80, 100, 200, 300, 400, 500} 三种实验 和RBM对比 激活函数选取对比 隐藏单元k的数量 k 基线性能对比 基线 深度扩展对Auto的帮助 代码https://github.com/mesuvash/NNRec 总结AutoRec是最简单的深度学习推荐系统。它是一种单隐层神经网络推荐模型，将自动编码器与协同过滤相结合。","raw":null,"content":null,"categories":[{"name":"论文","slug":"论文","permalink":"https://hubojing.github.io/categories/论文/"}],"tags":[{"name":"推荐算法","slug":"推荐算法","permalink":"https://hubojing.github.io/tags/推荐算法/"},{"name":"Autoencoder","slug":"Autoencoder","permalink":"https://hubojing.github.io/tags/Autoencoder/"},{"name":"CF","slug":"CF","permalink":"https://hubojing.github.io/tags/CF/"}]},{"title":"打脸现场——2020年终总结","slug":"2020年终总结","date":"2020-12-31T07:51:31.000Z","updated":"2020-12-31T08:24:50.620Z","comments":true,"path":"2020/12/31/2020年终总结/","link":"","permalink":"https://hubojing.github.io/2020/12/31/2020年终总结/","excerpt":"　　2020年我到底在干嘛之年终总结。 ","text":"2020年我到底在干嘛之年终总结。 前言 技术博客只谈技术相关。今年年底新搭建了生活博客，所以非技术方面的总结将放在那边。不过由于前几年的年终总结关于学习方面都放在了技术博客上，因此今年依然还是把所有和学习有关的总结放在这边。 如果说今年我给自己在技术方面的评价打分的话，大概只能打个50分，反正不及格。 此为前言。 2020致自己完成情况 自律使人自由 ——致自己2020 今年对自己的要求最核心的一条：自律 自己Flag立得飞起，2020年反而是自律最糟糕的一年…… 这两天突然有人给我以前在知乎上的匿名发言点了个赞，我点进去一看，好家伙，我直呼好家伙，这是曾经的我？ε=(´ο｀*)))唉，现在为什么做不到了呢？ 今年年中时，我曾一度警觉到这个问题，为此写了篇年中总结。可惜并没有取得好的效果，甚至感觉下半年自律做的更糟糕了。 为此我去知乎看看大神们是如何看待自律的。 有一条我认为说得在理： 自律是手段，而不是结果。 如果我把自律当做一个目标去实现它，那么可能永远做不到，就像今年这样。 自律应该是在我追逐其它目标的过程中，不自觉形成的自动行为。 可惜看到这条回答时，已经接近年终了。 所以2021年的致自己依然是 自律使人自由 ——致自己2021 但有些想法已发生改变。 突然穿插的总结 一晃，研究生生涯已经走完一半了。 真快呀。去年调剂的时候，从两年研究生变成三年研究生，一开始觉得亏，一年少挣几十万啊。 刚开学时，时常期盼着早点毕业。结果现在突然就只剩一半的读研生活了，竟然开始留恋这美好的学生生活了。我想，我确实是渐渐喜欢这样的生活了吧。我甚至有了深深的感激。一是感谢爸爸的坚决。在那段时间里，我一直徘徊在再战考研和调剂中，差一点点我就选择放弃了。在做决定上，只要是我深思熟虑后，父母一直都是支持我的。但这件事上，爸爸表现得非常坚决，强烈反对我再战，坚持调剂上岸。事实证明他是对的，最近这些年，每过一年，考研大军就以50~100万的速度递增，考研也在内卷。考研这件事请，已经占用了我太多的时间，确实应该放手了。不过我一直欠考研一篇长文，每次提笔，却觉得还应该再等等。二是感谢收留我的学校。调剂那段时间太痛苦了，了解了全国所有大大小小985/211/研究所还有各种从前没听过的学校，每天收集各种调剂信息，到最后精神几近崩溃边缘。我甚至把简历都写好了，准备找工作去了。没想到就在我决定明天开始投简历的当天傍晚，收到了这所学校的复试通知。这就是缘分吧。三是感谢收留我的导师。被调剂的学生可能就和被抛弃的孩子一样，是有一种被抛弃感和无助感的，那时只希望有个人愿意收留我，而不用害怕自己又被丢掉了。幸运的是我导收留了我，并且支持我目前的研究方向。这也是缘分吧。 这一年半，大概只有两件成果还行： 1. 数模美赛F奖 2. 加权成绩班级第一 其它的都是一团浆糊…… 研一上时，大部分时间被课程占据。那时很爽，毕竟我从通信跨考过来，终于成为了科班出身。坐在教室里听那些机器学习啊大数据啊什么的，身边都是计算机软工的同学，反正就是开心。那时我以为我的前途大概就是老老实实写代码刷题，看看开源项目，然后出去实习，最后能找份大厂开发的工作就很好了，所以整个研一定的目标是多参加比赛，争取拿奖。然后误打误撞入了数模的坑，真的是误打误撞，本来想多参加开发方面的比赛，但当时刚好有个数模比赛就随手参加了。之前我完全没有数模比赛经历，研究生才开始玩数模着实很晚。不过我比较幸运，第一次比赛得了一个亚太数模的三等奖，而后又得到了美赛数模的特等奖提名奖（F奖）。后来再参加数模更多关注的是自我全方位的锻炼（后来就飘了，飘了就会被打脸）。数模三个人一般是一个建模，一个写代码，一个写论文。我想每个位置都试试，现在已经全部尝试了一遍，估计就到此为止吧。数模给我的思维锻炼还有写论文的速度和技巧锻炼可能是最有用的。（如何在四天内快速地水一篇论文） 另一方面，读研后，万万没想到我竟然拥有了搞学术的机会，之前我是真的以为这辈子不可能有条件再沾和学术有关的东西了。搞学术啊……突然就让人想起一些曾经不切实际的梦。还想起刚开始工作时对部门领导说，“我喜欢那些高精尖的东西”，然后把领导和老大都给整笑了的经典场景……那学术是什么啊？那不就是研究高精尖的东西最好的渠道？ 所以从研一上的末尾我开始慢慢转换思路，我开始有了也许我可以试试学术的想法（危）。我开始在知乎上看有关学术的问题，装备学术资源，提高学术姿势，希望自己能科学的入门学术。然后也在那时渐渐把研究方向定了下来。（当初幸好没入CV的坑，看看现在CV就业卷成什么样……） 新想法不停地冲击我原有的规划。走学术几乎代表我就业应该选择算法岗。算法岗啊，我原来想都不会去想。但算法岗的竞争之激烈，我倒是从17年开始就有不断关注。什么一片红海啊，诸神黄昏啊，灰飞烟灭啊……内卷这个词我在知乎上已经看吐了。什么双985才过得了简历关，没有顶会顶刊、竞赛top就不要想了…… 选择算法岗，仿佛就像换了一波竞争对手一样。大厂的开发似乎尚且能够一搏，但大厂的算法岗？似乎总有痴人说梦的味道。这样的纠结，持续了整个2020。 疫情在家，本来是一个弯道超车的好机会。 确实是，我就是那辆被别人超过的车……[苦涩] 本来年初的计划，我是真心认为自己可以完成的。可是有些事情真是无法预料……元月底朋友的一条朋友圈，直接把我情绪拉到崩溃边缘，我开始反思生命中的其它事情，足足失眠了四个月有余。扯远了，总之，当你专注在另一些事情时，总会搁置其它的事情。也让我明白了，所谓的平衡但平庸和专注但极致，永远只能选一个。 越努力越幸运是真的。相反，越不努力就会越不幸也是真的。 研一下在我漫长的失眠时光中稀里糊涂地过去了。终于回到了学校，研二上。怎么就研二了？我对校园的认知还停留在研一上的阶段啊。脑袋里想着，要把心思放到学习上。行动上却不是这么做的。然后一连串不幸就来了。 六级考出了历史最低分。虽然我总是美其名曰参加六级只是为了保持英语语感顺便检测下目前英语水平，每次都裸考去考试，完全不复习。看到分数后，我还能自我安慰一下说过了还行。但现实就是英语水平真的退步了，可我又做了什么提升措施呢？除了恢复了一阵子背单词以外，似乎就无计可施。 英语竞赛差2分得奖。其实做题时感觉还行，但这个结果还是让人失望。 数模国赛名落孙山。由于找队友只能找通过校内选拔的同学，我当时也比较随意，重心已不在数模比赛上，所以临时和两位不认识的校友组队。但可惜他们并非工科背景，选题时非常受限，整个比赛几乎是我数据处理，代码和论文全包，他们做一些辅助性工作。后来反思，我感觉论文本身还是可以的，但可能预测的结果与正确结果偏离较远吧。 国奖落选。和我一起拿F奖的队友，已经成功得到了国奖。评奖过程存在质疑，或许本来只有我是唯一有资格参评的人。可能我自己也觉得还不配，虽然本科已经得过，但国奖依然是我心中最神圣的存在。我还是希望，如果是我，是因为我百分百值得。但目前实力还没有到无可挑剔的地步。其实在我决定把时间分到其它方面时，我就有想到这个后果，但我还是低估了得到认可在我心中的重要性。我试图去降低学习占比，让我看起来平衡。我也高估了自己的调节能力，我以为我能潇洒地对这些评奖云淡风轻，但没想到带给我的后劲还是十足强烈。无论如何，我可能错过了读研阶段离国奖最近的一次机会。没想到有一天，我又想起这句鸡汤：最难过的事情是我本可以。 生活上的不幸，此处不展开。 亲人离世，外婆走得是那么突然，让我至今有有些不敢相信这是真的。 结束了短暂的感情。如果两个人不能相互促进，共同进步，那可能不是好的感情。 这些种种不幸一直持续到导师通知我坐飞机参加会议。我当时甚至觉得这阵子我实在是太惨了，以至于我真的认为我坐飞机都会掉下来。 我想，也许越努力越幸运是真的。越不努力也可能真的越不幸。 我开始重新整理自己，把有些过多陷入感性的自己再次拉回来。“我试图去降低学习占比”，我为什么要降低学习占比？？？我才发现追求平衡这种事情多少有些可笑，读研不代表真正地上岸，如果读研了就降低学习占比，那是否对得起之前那些年舍弃那么多去考研？我想我已经受到了足够多的警示了，这些事情无一不在告诉我，学生不始终把学习放第一位，等于自我毁灭。 幸运的是，飞机没有掉下来。从那刻起，我感觉自己如获新生。我想，我可能要开始转运了。 首先是教资成绩下来，预想能过一门就值了报名费，没想到三过二，超过预期。然后是软考，只复习几天竟然有惊无险地过了。爸爸身体抱恙，但医生说无大碍。 划水划到最后总会还的。当我重新整理我的代码，搜集的论文，我的博客，都无一不在说，你慢了。我终于开始为前途担忧，为进度焦虑，为找工作考虑，开始新一轮的失眠。 去年年初立下的Flag完成度情况点击下方跳转打脸现场2020——新的启航 科研方面 多看论文，完成导师任务。 多了解工业届具体应用情况，了解就业市场需求。 对推荐系统，乃至NLP，以及相关传统机器学习、深度学习的代码实操，技术路线搭建。 不达标。进度慢了。 基本达标。还行，经常有关注。 不达标。代码方面还是非常不够，需要加强。 完成度：50% 技术方面 Leetcode一周三题，一年156题。 纸质书五本。 至少细致分析一个开源项目代码。 Java学习。 不达标。远远不够，才做20题左右。 基本达标。勉强够吧，如果把应考的书也算上的话。 不达标。细致分析达不到。 不达标。后半年几乎停滞。 完成度：10% 日常学习方面 微信读书一周2h，一年104h。（截止今日：73h11min） 纸质书（非技术类）两月一本，一年六本。今年读书重点依然在推理、历史类，可辅看经济入门书。 英语电台更新大于100期。 达标。今年读了109h（来自官方报告）。（截至2020年12月31日：181h10min） 不达标。纸质书非技术类一本没读…… 不达标。只更新了58期。 完成度： 60% 健身方面 不熬夜。熬夜则自动领取加读论文一篇的奖励，需在博客上有记录。 Keep 3000min。一周至少三次Keep，运动量大于30min，一年需运动4680min（然而截止2019年底也才2530min），所以折中一下。 不达标。今年熬夜是前二十几年最凶猛的，不仅熬夜，还失眠……补论文估算了一下至少得补100篇…… 不达标。856min。 完成度：0% 这样一看，给自己总评打50分似乎打高了…… 2021年的目标 今年突然意识到，这个年纪还能有人跟你说“要好好学习哦”，是多么幸福的事情。 立Flag一时爽，可是做不到的Flag就是打脸现场。比如现在，脸已经肿了…… 2021年不再立一大堆花里胡哨的目标了。 2021年的目标，ONLY ONE： 闭关学习，拿到大厂Offer！ 少说话，多做事。Talk is cheap, show me the code.","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"年终总结","slug":"年终总结","permalink":"https://hubojing.github.io/tags/年终总结/"},{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/tags/杂谈/"}]},{"title":"【Paper】Deep Neural Networks for YouTube Recommendations","slug":"【Paper】Deep Neural Networks for YouTube Recommendations","date":"2020-12-15T06:24:54.000Z","updated":"2020-12-16T13:56:05.000Z","comments":true,"path":"2020/12/15/【Paper】Deep Neural Networks for YouTube Recommendations/","link":"","permalink":"https://hubojing.github.io/2020/12/15/【Paper】Deep Neural Networks for YouTube Recommendations/","excerpt":"　　YouTube经典推荐论文。 ","text":"YouTube经典推荐论文。 论文背景 RecSys’16 谷歌学术引用次数为1201（截至2020年12月15日） 作者：Paul Covington, Jay Adams, Emre Sargin Google Mountain View, CA 关键词：recommender system; deep learning; scalability PDF Introduction 引言YouTube推荐系统的三大挑战： Scale 大规模 Freshness 新鲜度 Noise 噪声-数据往往是隐式反馈 System Overview 系统概述 系统架构 系统由两部分组成：候选生成部分和排序部分。 候选生成部分输入是用户历史活动事件，使用协同过滤从大数据集中输出小子集。 排序部分根据目标函数对每个视频精排打分，最高分视频推荐给用户。 优点：从大数据集中选出的小数据集依然具有个性化特征，并且候选生成部分可以添加别的数据源。 评价指标：精确率、召回率、排序损失等 最后通过A/B测试在线实验（A/B测试结果不总是和离线实验结果相一致）。 Candidate Generation 候选生成 这种方法可以看作矩阵分解的非线性推广，它早期的神经网络迭代只嵌入用户过去观看记录来模拟这种因子分解行为。 Recommendation as Classification 作为分类推荐 推荐视为极端多分类问题，在时间t时，结合用户U和上下文C，从数亿的数据库V中选择一个视频i记为特定的视频$w_t$。$$P(w_t = i|U,C) = \\frac{e^{v_iu}}{\\sum_{j∈V}e^{v_ju}}$$ 其中$u∈\\mathbb{R}^N$代表了用户高维嵌入（embedding），上下文数据对和$V_j∈\\mathbb{R}^N$代表了每个候选视频的嵌入（embedding）。 在这样的设定中，一个嵌入就从稀疏实体转为了稠密向量（$\\mathbb{R}^N$）。 深度神经网络的任务是学习用户嵌入u，作为用户历史记录和上下文的函数，这有助于使用softmax分类器从海量视频中进行识别。 Effcient Extreme Multiclass 高效极端多分类 为了有效地训练这样一个拥有数百万分类的模型，需要依赖于一种技术，从背景分布(“候选抽样”)中抽取负类，然后通过重要性加权对该抽样进行修正。对于每一个实例，真标签和抽样的负样本的交叉熵损失都最小。 在严格的服务延迟为几十毫秒的情况下为百万个物品打分需要一个近似亚线性的方案。以前的YouTube系统依赖于hashing，分类采用相似方法。 由于服务时不需要softmax输出层校准可能性（？有些不解），评分问题简化为在点积空间的最近邻搜索，在这个空间中，通用库可以使用。A/B结果对最近邻搜索算法的选择不是特别敏感。 Model Architecture 模型架构 学习每个视频的高维嵌入到固定词汇中，并将这些嵌入输入到前馈神经网络中。用户的观看历史记录由稀疏视频id的可变长度序列表示，该序列通过嵌入映射到稠密向量表示。该网络需要固定规模的密集输入，并简单地平均在不同策略中表现最好的嵌入。通过梯度下降反向传播更新，嵌入与所有其他模型参数联合学习。特征被连接成一个宽的第一层，然后是几层全连接的线性单元(ReLU)。如下图所示。 候选生成架构 Heterogeneous Signals 混合信号 使用深度神经网络作为矩阵分解的推广的一个关键优点是任意连续和分类特征可以很容易地添加到模型中。 “Example Age” Feature “示例年龄”特征 用户往往喜欢新鲜的内容。除了简单地推荐用户想看的新视频的一级效应，还有一个重要的二级现象，即引导和传播病毒式内容。视频受欢迎程度是会变化的，但推荐系统反映的是几周内的平均观看可能性。为了纠正这一点，在训练期间将训练示例的年龄作为一个特征输入。在服务时间，这个特征被设置为零(或者稍微负一点)，以反映模型正在训练窗口的最后进行预测。 With Example Age Label and Context Selection 标签和上下文选择 替代学习问题的选择对A/B测试的性能有很大的影响，但很难用离线实验来衡量。 训练示例是从所有YouTube视频中生成的而不是仅仅依靠推荐。否则新内容的出现将会非常困难，而且推荐器会有过度偏向。如果用户是通过推荐以外的方式发现视频，希望能够通过协同过滤快速传播这个发现给其他人。改进实时指标的另一个关键见解是，为每个用户生成固定数量的训练样例，有效平等地在损失函数中权衡我们的用户。这避免了一小部分高活跃用户主导损失。 必须非常小心地对分类器隐瞒信息，以防止模型利用站点的结构和过度拟合代理问题。 预测用户下一个观看的性能要比预测随机留出的观看好得多。许多协同过滤系统隐式地选择标签和上下文，方法是取出一个随机的物品，并从用户历史记录中的其他物品中预测它。这泄露了未来信息并忽视了非对称消费模式。相反，本文“回滚”用户的历史记录，通过选择一个随机的观看记录，并且只输入用户留出的有标签的观看记录之前采取的动作。 Predicting future watch Experiments with Features and Depth 特征和深度实验 添加特征和深度可以显著改善保持数据的精度，如图6所示。在这些实验中，一个包含100万个视频和100万个搜索令牌的词汇表中嵌入了256个浮点数，每个浮点数的最大包尺寸为50个最近的观看和50个最近的搜索。softmax层在相同的1M视频类上输出多项分布，维数为256(可以认为是单独的输出视频嵌入)。网络结构遵循一个常见的“塔”模式，其中网络的底部是最宽的，每个后续隐藏层的单位数量减半。 Ranking 排序 排序架构 使用与候选生成结构相似的深度神经网络，使用逻辑回归为每个视频印象分配一个独立的分数。如图所示。然后，视频列表将根据这个分数进行排序并返回给用户。最终排名目标是根据实时A/B测试结果不断调整，但通常是每个印象的预期观看时间的简单函数。通过点击率排名通常会促进欺骗性视频，用户没有完成(“点击诱饵”)，而观看时间能够更好地捕捉用户粘性。 Feature Representation 特征表示 用的类别或特征在基数上差别很大——有些是二进制的（例如用户是否登录），而其他有数百万个可能的值（例如用户的最后一次搜索查询）。根据功能是仅贡献单个值(“univalent”)还是一组值(“multivalent”)，进一步划分功能。 univalent例子：被评分的视频ID，multivalent例子：用户最近观看的N个视频ID的bag。还根据特性是描述物品的属性（”impression”）还是描述用户/上下文的属性（”query”）对特性进行分类。查询特征为每个请求计算一次，而印象特征为每个物品项计算一次。 Feature Engineering 特征工程 描述过去视频输入频率的特性对于在推荐中引入“churn”(连续的请求不返回相同的列表)也是至关重要的。如果一个用户最近被推荐了一个视频，但没有看过它，那么模型自然会在下一次加载页面时降低这种印象。 Embedding Categorical Features 嵌入分类特征 类似于候选生成，使用嵌入将稀疏分类特征映射到适合于神经网络的稠密表示。 同一ID空间中的分类特性也共享底层的嵌入。共享嵌入对于提高泛化性能、加快训练速度和减少内存需求具有重要意义。 Normalizing Continuous Features 归一化连续特征 神经网络对其输入的尺度和分布非常敏感，而其他方法，如决策树的集合，对单个特征的尺度是不变的。 对于连续特征x，其分布为f，使用公式$\\tilde{x} = \\int_{-\\infty}^xdf$进行归一化操作到[0,1)。除了该方法，也使用了$\\tilde{x}^2$和$\\sqrt{\\tilde{x}}$。 Modeling Expected Watch Time 预期观看时间建模 预期观看时间使用加权逻辑回归方法。 模型在交叉熵损失下用逻辑回归进行训练。积极的（点击）印象是由视频上观察的观看时间加权的。负面（未点击的）印象全部获得单位权重。 逻辑回归学到的概率为$\\frac{\\sum{T_i}}{N-k}$，N是训练集数量，k是正例数量，$T_i$是第i个印象的观看时间。 最终本文使用指数函数$e^x$作为最后激活函数来产生预估概率。 Experiments with Hidden Layers隐藏层实验 这些结果表明，增加隐藏层的宽度可以改善结果，同时也可以增加它们的深度。但是，需要权衡的是推荐所需的服务器CPU时间。 Conclusions 总结 将YouTube推荐问题划分为两个部分：候选生成部分和排序部分。 通过捕捉不对称的协同观看行为和防止未来信息泄漏，对未来观看进行分类，可以很好地执行实时指标。从分类器中截取不同信号对于取得良好的结果也是至关重要的——否则模型会过度拟合代理问题而不能很好地转移到主页。 使用训练样例的年龄作为输入特征，消除了对过去的固有偏见，并允许模型表示流行视频的时间依赖性行为。这提高了离线保持精度结果，并在A/B测试中显著增加了观看最近上传的视频的时间。 排序是一个比较经典的机器学习问题，然而本文深度学习方法在观看时间预测方面优于以往的线性和基于树的方法。推荐系统尤其受益于描述用户关于物品的历史行为的特定特征。深度神经网络需要分类特征和连续特征的特殊表示，分别用嵌入和分位数规范化进行变换。层的深度显示有效地模拟了非线性交互之间的数百个特征。 逻辑回归通过加权训练样例修正了正例，统一了负例，使之能学习预期观看时间的概率。与直接预测点击率相比，该方法在观看时间加权排序评价指标上表现得更好。","raw":null,"content":null,"categories":[{"name":"论文","slug":"论文","permalink":"https://hubojing.github.io/categories/论文/"}],"tags":[{"name":"推荐算法","slug":"推荐算法","permalink":"https://hubojing.github.io/tags/推荐算法/"}]},{"title":"【Paper】Factorization Machines","slug":"【Paper】Factorization Machines","date":"2020-12-09T03:18:31.000Z","updated":"2020-12-14T12:08:40.000Z","comments":true,"path":"2020/12/09/【Paper】Factorization Machines/","link":"","permalink":"https://hubojing.github.io/2020/12/09/【Paper】Factorization Machines/","excerpt":"　　FM算法原文。 ","text":"FM算法原文。 论文背景 2010 IEEE International Conference on Data Mining Steffen Rendle Department of Reasoning for Intelligence The Institute of Scientific and Industrial Research Osaka University, Japan 谷歌学术被引用次数1396（截至2020年12月14日） 论文关键词：factorization machine; sparse data; tensor factorization; support vector machine PDF Introduction 引言 FM优点： 1. FM能在很稀疏的数据上进行参数估计，但SVM不行。 2. FM是线性复杂度，不需要类似于SVM中的支持向量。 3. FM是通用预测方法，适用于任何特征向量。其它的因子分解方法都受限于特定的输入。（对比biased MF, SVD++, PITF和FPMC） Prediction under sparsity 稀疏情况下的预测 feature x Factorization machines(FM) 因子分解机Factorization machine model 因子分解机模型 degree d = 2$$\\hat{y}(x):=w_0 + \\sum_{i=1}^nw_ix_i + \\sum_{i=1}^n\\sum_{j=i+1}^n&lt;v_i,v_j&gt;x_ix_j$$ 其中$w_0∈R$，$w∈R^n$,$V∈R^{n×k}$，&lt;·,·&gt;表示点乘。$$&lt;v_i,v_j&gt;:=\\sum_{f=1}^kv_{i,f}·v_{j,f}$$ V中的$v_i$描述k个因素中的第i个变量。$Ks∈N_0^+$是定义因子分解的维度的超参数。 2-way FM捕捉所有变量的单个和成对交互： $w_0$是全局偏置，$w_i$模拟了第i个变量的程度。 $\\hat{w}_{i,j}:=&lt;v_i, v_j&gt;$模拟了第i和第j个变量间的交互。这个在高阶交互时（d &gt; 2）高质量估计的关键。 时间复杂度O($kn^2$)，因为所有的交互对都要被计算。但可以变形使之化为O(kn)。 Factorization machines as predictors FM作为预测器 可用于回归、二分类和排序问题。 Learning factorization machines FM学习策略 使用随机梯度下降（SGD）来学习。 d-way factorization machine 多维FM 同时2-way FM可以拓展为d-way。 Summary 总结 FM优点： 1. 在高稀疏下可估计特征交互，尤其是不可观测的交互。 2. 预测和学习的时间复杂度是线性的。使SGD优化可行，并允许多种损失函数优化。 FMs vs. SVMs 因子分解机对比支持向量机SVM model 支持向量机模型 SVM等式$$\\hat{y}(x) = &lt;\\Phi(x), w&gt;$$ 其中$\\Phi$是从空间$R^n$到F的映射。$\\Phi$和下式的核相关：$$K:R^n × R^n → R, K(x, z) = &lt;\\Phi(x), \\Phi(z)&gt;$$1) 线性核 $K_l(x, z) = 1 + &lt;x, z&gt;$，对应$\\Phi(x) := (1, x_1, … , x_n)$ SVM等式为$$\\hat{y}(x) = w_0 + \\sum^n_{i=1}w_ix_i, w_0∈R, w∈R^n$$ 这等价于FM中d = 1的情况。 2) 多项式核 多项式核使SVM能模拟变量间的高阶交互。$K(x, z) := (&lt;x, z&gt; + 1)^d$，对于d = 2有$\\Phi(x) := (1, \\sqrt{2}x_1, … , \\sqrt{2}x_n, x_1^2, … , x_n^2, \\sqrt{2} x_1x_2, … , \\sqrt{2}x_1x_n, \\sqrt{2}x_2x_3, … , \\sqrt{2}x_{n-1}x_n$ SVM等式为$$\\hat{y}(x) = w_0 + \\sqrt{2}\\sum^n_{i=1}w_ix_i + \\sum^n_{i = 1}w_{i,i}^{(2)}x_i^2 + \\sqrt{2}\\sum^n_{i=1}\\sum^n_{j=i+1}w_{i,j}^{(2)}x_ix_j$$ 其中$w_0∈R, w∈R^n, w^(2)∈R^{n×n}$。 d = 2时，FM和SVM的区别在于SVM中$w_{i,j}$是完全独立的，而FM中参数是因子分解的，所以$&lt;v_i, v_j&gt;$依赖于彼此。 Parameter Estimation Under Sparsity 在稀疏情况下的参数估计 举例：使用协同过滤（上图中蓝色和红色部分数据）。1) 线性SVM$$\\hat{y}(x) = w_0 + w_u + w_i$$ 只有j = u 或 j = i时$x_j$ = 1，即只有用户和物品偏好被选中时才有用。由于模型简单，在稀疏情况也能进不错的参数估计，但预测质量低。2) 多项式SVM$$\\hat{y}(x) = w_0 + \\sqrt{2}(w_u + w_i) + w_{u,u}^{(2)} + w_{i,i}^{(2)} + \\sqrt{2}w_{u,i}^{(2)}$$ $w_u$和$w_{u,u}^{(2)}$是一样的。该等式除了一个额外的$w_{u,i}$，等价于线性SVM。在训练集中，对于每一个$w_{u,i}$最多只有一条记录，在测试集中通常没有。因此，2-way的SVM效果也不比线性SVM好。 Summary 总结1) SVM需要直接观测交互数据，但稀疏数据集经常没有。FM参数可以在系数情况下进行不错的参数估计。2) FM可以一开始就直接学习，但非线性SVM需要成对学习。3) FM是独立于训练集的，SVM的预测是基于部分训练数据的。 FMs VS. Other Factorization Models 其它因子分解方法对比 改写FM公式形式，分别与Matrix and Tensor Factorization矩阵和张量分解、SVD++、PITF for Tag Recommendation、Factorized Personalized Markov Chains(FPMC)方法对比，FM改写后性能与这些方法实现效果类似。 Summary 总结1) 标准因子分解模型（比如PARAFAC或者MF）不像FM一样是通用预测模型。2) 修改特征提取部分，FM可以模拟在特定任务下的成功模型（比如MF,PARAFAC,SVD++,PITF,FPMC)。 Conclusion and Future Work 总结和展望 与SVM对比，1) 在数据稀疏情况下，FM可以进行参数估计。2) 模型时间复杂度是线性的，并且只依赖于模型参数。3) 从最开始就能直接优化。","raw":null,"content":null,"categories":[{"name":"论文","slug":"论文","permalink":"https://hubojing.github.io/categories/论文/"}],"tags":[{"name":"推荐算法","slug":"推荐算法","permalink":"https://hubojing.github.io/tags/推荐算法/"},{"name":"FM","slug":"FM","permalink":"https://hubojing.github.io/tags/FM/"}]},{"title":"【Paper】Matrix Factorization Techniques for Recommender Systems","slug":"【Paper】Matrix Factorization Techniques for Recommender Systems","date":"2020-12-07T07:12:57.000Z","updated":"2020-12-09T03:23:00.422Z","comments":true,"path":"2020/12/07/【Paper】Matrix Factorization Techniques for Recommender Systems/","link":"","permalink":"https://hubojing.github.io/2020/12/07/【Paper】Matrix Factorization Techniques for Recommender Systems/","excerpt":"　　矩阵分解算法原文。 ","text":"矩阵分解算法原文。 论文背景 2009年发表于IEEE旗下的Computer期刊。 谷歌学术引用数为7954（截至2020年12月7日）。 作者：Yehuda Koren, Yahoo Research Robert Bell and Chris Volinsky, AT&amp;T Labs—Research DOI: 10.1109/MC.2009.263 PDF Recommender System Stratrgies 推荐系统策略 两种策略：content filtering approach和collaborative filtering 前者需要收集外部信息，但这不容易得到。后者聚焦于用户过去的行为，相比前者精确度更高，但它有冷启动问题。相反，在冷启动问题方面，前者更优越。 协同过滤又分为neighborhood methods和latent factor models。 基于领域的策略又可分为基于用户和基于物品。 基于物品的策略基于同一个用户对相邻物品的评分对用户偏好进行评估。同一个用户给一件物品的相邻物品会打相似的评分。 基于用户的方法鉴定相似的用户，他们可以互相补充对方的评分信息。 LFM隐语义模型 意思是把特征刻画分为k个维度。如图，将刻画特征设为性别和题材类别（serious/escapist），形成一个坐标空间，每个用户和物品都在这个空间中，如果在坐标系中距离越近则说明越相似。 Matrix Factorization Methods 矩阵分解策略 一些最成功的隐语义模型是基于矩阵分解实现的。 矩阵分解通过从评分矩阵推断出的因子向量来刻画物品和用户。 优势：当显式反馈无法得到时，可以添加其它信息（比如使用隐式反馈推断用户偏好）。 A Basic Matrix Factorization Model 基本矩阵分解模型 矩阵分解模型将用户和物品映射到维度f的联合潜在因素空间，用户-物品交互在空间中使用内积建模。 每一个item的向量设为$q_i$，每一个用户的向量设为$p_u$。$q_i$表示item拥有的积极或消极的因子，$p_u$表示用户拥有的积极或消极的因子。两者内积可以捕捉用户u和item i之间的交互，即用户在这个item上的整体兴趣。设评分为$r_{ui}$，$$\\hat{r}_{ui} = {q_i}^T{p_u}$$ 这个模型和SVD（singular value decomposition）很接近。但在协同过滤中使用SVD要用到用户-物品评分矩阵，这个矩阵稀疏性太大。如果数据不完整，SVD不能被确定。并且用少数数据尝试容易过拟合。 早期系统都在填补缺失评分和使评分矩阵更稠密上下功夫。但是这个运算很昂贵。因此，更多的工作聚焦在直接观察现有评分数据，并通过正则化来避免过拟合。为了学习${p_u}$和${q_i}$，使用下述公式$$min_{q*,p*}\\sum_{(u,i)∈k}({r_ui} - {p_u}^Tq_i)^2 + \\lambda(||p_u||^2 + ||q_i||^2)$$ 其中，k是(u,i)对的集合。${r_{ui}}$是未知的（训练集）。 Learning Algorithms 学习算法 使上述式子最小化的两种方法是随机梯度下降和交替最小二乘法。 Stochastic gradient descent 随机梯度下降 计算error$$\\begin{equation}{e_{ui}}\\overset{def}{=} {r_{ui}} - {q_i}^T{p_u}\\end{equation}$$ 调参$${q_i} \\leftarrow q_i + \\gamma·({e_ui}·{p_u} - \\lambda · {q_i})$$$${p_u} \\leftarrow p_u + \\gamma·({e_ui}·{q_i} - \\lambda · {p_u})$$ 该方法运行速度较快。不过在有些场景下，使用ALS优化更好。 Alternating least squares 交替最小二乘法 一般随机梯度下降比ALS简单且快。但ALS适用于两个场景，一是系统可以并行化。ALS可独立计算${q_i}$和${p_u}$。二是隐式数据情况下使用。 Adding Biases 每个用户评价严格度不同，因此引入偏置项。$${b_{ui}} = μ + {b_i} + {b_u}$$ 加了偏置项后，公式改为$$\\hat{r}_{ui} = μ + {b_i} + {b_u} + {q_i}^T{p_u}$$ 四部分：全局均值、item偏置、user偏置和user-item交互。 系统通过最小化平方误差函数来学习：$$min_{p*,q*,b*}\\sum_{(u,i)∈k}({r_ui} - μ - {b_u}- {b_i}-{p_u}^Tq_i)^2 + \\lambda(||p_u||^2 + ||q_i||^2 + b_u^2 + b_i^2)$$ Additional Input Sources 额外输入资源$$\\hat{r}_{ui} = μ + {b_i} + {b_u} + {q_i}^T[{p_u} + |N(u)|^{-0.5} \\sum_{i∈N(u)}{x_i} + \\sum_{a∈A(u)}{y_a}]$$ N(u)指用户u有过隐式反馈的若干个item集合。x是和item i相关的因素。$\\sum_{i∈N(u)}{x_i}$表示一个用户对N(u)中的若干item的偏好刻画向量。系数代表规范化。 用户属性用A(u)表示，每一个用户的每一个属性对应的因素向量用$y_a$表示。$\\sum_{a∈A(u)}{y_a}表示每个用户的属性集。 Temporal dynamics 时空动态 用户兴趣会发生兴趣漂移，即随着时间而变化。$$\\hat{r}_{ui}(t) = μ + b_i(t) + b_u(t) + q_i^Tp_u(t)$$ $b_i(t)$表示物品随时间变化的流行程度，$b_u(t)$表示用户评分随时间变化的严格程度，$p_u(t)$表示用户偏好随时间变化的改变程度。物品是静态的，所以$q_i$也是静态的。 Inputs with varying confidence levels 各种信任级别的输入 不是每一条评分数据的权重和信任都是一样的。为了给不同的评分以不同的信任程度，修改损失函数为$$min_{p*,q*,b*}\\sum_{(u,i)∈k}c_{ui}({r_ui} - μ - {b_u}- {b_i}-{p_u}^Tq_i)^2 + \\lambda(||p_u||^2 + ||q_i||^2 + b_u^2 + b_i^2)$$ $c_{ui}$为评分的信任程度。 Netflix prize competition Netflix大奖竞赛 使用矩阵分解的方法取得了第一名的成绩。 精确度 加的因素越多，精确度越高。 阅后总结 本文主要介绍了矩阵分解的具体算法。","raw":null,"content":null,"categories":[{"name":"论文","slug":"论文","permalink":"https://hubojing.github.io/categories/论文/"}],"tags":[{"name":"推荐算法","slug":"推荐算法","permalink":"https://hubojing.github.io/tags/推荐算法/"},{"name":"MF","slug":"MF","permalink":"https://hubojing.github.io/tags/MF/"}]},{"title":"【Paper】Amazon.com Recommendations Item-to-Item Collaborative Filtering","slug":"【Paper】Amazon.com Recommendations Item-to-Item Collaborative Filtering","date":"2020-12-02T06:40:23.000Z","updated":"2020-12-03T07:45:24.264Z","comments":true,"path":"2020/12/02/【Paper】Amazon.com Recommendations Item-to-Item Collaborative Filtering/","link":"","permalink":"https://hubojing.github.io/2020/12/02/【Paper】Amazon.com Recommendations Item-to-Item Collaborative Filtering/","excerpt":"　　ItemCF原文。 ","text":"ItemCF原文。 论文背景 22 January 2003 谷歌学术被引用次数：6769（截至2020年12月2日） 期刊：IEEE Internet Computing DOI: 10.1109/MIC.2003.1167344 作者：Greg Linden,Brent Smith,and Jeremy York • Amazon.com PDF 引言 电子商务推荐算法面临的挑战： 一家大型零售商可能拥有大量数据、数千万客户和数百万不同的物品 要求在不超过半秒钟的时间内实时返回结果集，同时能产生高质量的推荐 新客户通常只有非常有限的信息，仅有少量购买信息和产品评分 基于成千上万次的购买和评分，老用户可能拥有大量信息 客户数据是不稳定的：每次交互都提供有价值的客户数据，算法必须对新信息立即做出响应 Recommendation Algorithms 推荐算法 三种常规方法： 传统协同过滤、聚类模型和基于搜索的策略 traditional collaborative filtering, cluster models, and search-based methods Traditional Collaborative Filtering 传统协同过滤 传统协同过滤，这里指基于用户的协同过滤方法。 相似度计算： 使用该方法时间复杂度最差为O(MN)，由于用户向量稀疏，时间复杂度更接近于O(M + N)。（大部分用户只涉及很少的物品，每个用户是O(M)，但一小部分用户买了很多物品，需要O(N)时间。） M为用户数，N为物品数 解决方法是降低数据规模。 通过随机采样用户或者忽视只有少数购买记录的用户，来减少M。 通过忽视非常流行或不流行的物品，来减少N。 还可以通过产品类别或或客观分类来分割物品成为小向量来减少物品数量。 维度减少，比如聚类或主成分分析可以减少M或N的大量因素。 但是上述方法会降低推荐质量。 Cluster Models 聚类模型 该算法的目标是将用户分配到包含最相似用户的簇。然后，它使用该簇中用户的购买和评级信息来推荐。 一旦该算法生成了簇，它就计算用户与每个簇的向量的相似性，然后选择具有最大相似性的簇，并相应地对用户进行分类。一些算法将用户分为多个簇，并描述每个关系的强度。 优点：比上述协同过滤具有更好的在线可扩展性和性能，复杂且昂贵的聚类计算是离线运行的。 缺点：推荐效果差。通过使用大量细粒度的聚类来提高质量是可能的，但是线上用户细分聚类变得几乎和使用协同过滤寻找相似客户一样昂贵。 Search-Based Methods 基于搜索的策略 基于搜索或基于内容的方法将推荐问题视为对相关项目的搜索。对于给定用户购买和评级信息的物品，该算法构建搜索查询来查找由相同作者、艺术家或导演或具有相似关键字或主题的其他流行项目。例如，如果一位顾客购买了《教父》系列影碟，系统可能会推荐其他犯罪题材的电影、其他由影星马龙·白兰度主演的电影或其他由弗朗西斯·福特·科波拉执导的电影。 优点：用户购买和评分记录少时，性能不错。 缺点：推荐质量低，推荐的物品太一般（general)或太狭窄（narrow）。 Item-to-Item Collaborative Filtering 基于物品的协同过滤How It Works 如何工作 Item-to-item collaborative filtering matches each of the user’s purchased and rated items to similar items, then combines those similar items into a recommendation list. 基于物品的协同过滤将用户购买的和评分的每个物品与相似的物品进行匹配，然后将这些相似的物品组合成推荐列表。 为了确定给定物品的最相似匹配，该算法通过查找用户倾向于一起购买的物品来构建相似物品表。可通过遍历所有物品并为每一对计算相似性来构建物品矩阵。然而，许多产品对没有共同的用户，因此这种方法在处理时间和内存使用方面效率低下。以下迭代算法通过计算单个物品和所有相关物品之间的相似性提供了更好的措施： 伪代码123456For each item in product catalog, I1 For each customer C who purchased I1 For each item I2 purchased by customer C Record that a customer purchased I1 and I2 For each item I2 Compute the similarity between I1 and I2 计算两个物品之间的相似性有多种方法，一种常见的方法是使用前面描述的余弦度量，其中每个向量对应于一个物品而不是一个客户，并且向量的多维度对应于已经购买该物品的用户。相似物品表的这种离线计算非常耗时，最糟糕的情况是O($N^2M$)。然而，在实践中，它更接近于零，因为大多数客户只有很少的购买记录。对购买畅销物品的用户进行采样会进一步减少运行时间，而质量几乎没有下降。 给定相似物品表，该算法找到与每个用户的购买和评分相似的物品，汇总这些物品，然后推荐最受欢迎或相关的物品。这种计算非常快速，仅取决于用户购买或评分的物品数量。 Scalability: A Comparison 可扩展性 Amazon.com有超过2900万的顾客和数百万的商品目录。对于非常大的数据集，可扩展的推荐算法必须离线执行最昂贵的计算。 现有算法的缺点： 传统的协同过滤很少或没有离线计算，其在线计算随着用户和物品目录的数量而变化。该算法在大数据集上是不切实际的，除非它使用降维、采样或分区——所有这些都会降低推荐质量。 聚类模型可以离线执行大部分计算，但是推荐质量相对较差。为了改善这一点，可以增加细分簇的数量，但这使得在线用户细分分类变得昂贵。 基于搜索的模型离线构建关键字、类别和作者索引，但无法提供有趣的、有针对性的主题推荐。对于有大量购买和评分的用户来说，它们的可扩展性也很小。 可扩展性和性能的关键是它离线创建昂贵的相似物品表。该算法的在线组件——为用户的购买和评分物品查找相似的物品——独立于物品目录大小或客户总数，它只取决于用户购买或评分物品。因此，即使对于非常大的数据集，该算法也是快速的。因为该算法推荐高度相关的相似物品，所以推荐质量很好。与传统的协作过滤不同，该算法在有限的用户数据下也表现良好，仅基于两三个物品就能产生高质量的推荐。 Conclusion 总结 主要是介绍了基于物品的协同过滤思想。 耗时昂贵的操作放在线下离线进行，使线上达到实时要求。","raw":null,"content":null,"categories":[{"name":"论文","slug":"论文","permalink":"https://hubojing.github.io/categories/论文/"}],"tags":[{"name":"推荐算法","slug":"推荐算法","permalink":"https://hubojing.github.io/tags/推荐算法/"},{"name":"CF","slug":"CF","permalink":"https://hubojing.github.io/tags/CF/"}]},{"title":"关于RSS订阅","slug":"关于RSS订阅","date":"2020-12-02T01:57:14.000Z","updated":"2020-12-02T02:35:09.510Z","comments":true,"path":"2020/12/02/关于RSS订阅/","link":"","permalink":"https://hubojing.github.io/2020/12/02/关于RSS订阅/","excerpt":"　　感谢订阅博客的各位　　热爱可抵岁月漫长 ","text":"感谢订阅博客的各位 热爱可抵岁月漫长 昨天有位朋友私信我说要RSS订阅我的博客，突然就想起这些年写博，遇到好些朋友都这样说。 然而我自己却从来没有订阅过自己的博客（滑稽表情：大概是太烂看不下去吧） 每次魔改博客后，文章tag什么的都改过好多次，甚至有的文章内容都更新过好多次。突然想看看RSS推送我的博客会是什么样子，是否会对关注我的朋友造成困扰。 上次用RSS聚合软件还是好多年前了，那时用的什么我已经不太记得了，可能是深蓝阅读？ 在知乎成为我的搜索引擎后，我熟练地打开它就是一顿暴搜“2020年还有什么好用的RSS APP”？ 答案是：没有。 这就离谱有木有？ 推荐系统把人都给控制得舒舒服服的，人们都不愿意自己主动订阅了？ 幸好…… 幸好我就是研究推荐系统的（再次滑稽） 那么这篇文章到底想说什么呢？ 就是…… 我最后选择了轻芒杂志作为我的RSS阅读器。 不过这个破软件还得要开会员才能订阅RSS。 好在我去网上随便搜了个邀请码获得了会员权限。（免费的快乐） 然后我也有了自己的邀请码。 你们需要的话，输入：靖待小太阳 就可以获取永久会员啦~ ……写的像软文一样，这公司应该给我打钱。 所以，有什么更好的RSS软件吗？ 主要是稳定，别用一阵子就垮了，资料白收藏了。然后是免费！穷人的字典里充满了免费二字。其它的功能，就随缘吧，2020年了，似乎都没人用RSS了，还要什么自行车。 最后，感谢订阅博客的朋友们，你们的点评和关注助我前行。博客会一直写下去，热爱可抵岁月漫长。","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/tags/杂谈/"}]},{"title":"深度学习常用数学知识","slug":"深度学习数学知识","date":"2020-08-15T03:00:19.000Z","updated":"2020-08-15T03:00:19.000Z","comments":true,"path":"2020/08/15/深度学习数学知识/","link":"","permalink":"https://hubojing.github.io/2020/08/15/深度学习数学知识/","excerpt":"　　编辑这些公式给我累si了　　同样适合考研狗收藏　　非常欢迎纠错 ","text":"编辑这些公式给我累si了 同样适合考研狗收藏 非常欢迎纠错 高等数学导数定义导数和微分的概念 $f’({x_0})=\\underset{\\Delta x\\to 0}{\\mathop{\\lim }}\\,\\frac{f({x_0}+\\Delta x)-f({x_0})}{\\Delta x}$ （1） 或者： $f’({x_0})=\\underset{x\\to {x_0}}{\\mathop{\\lim }}\\,\\frac{f(x)-f({x_0})}{x-{x_0}}$ （2） 左右导数导数的几何意义和物理意义函数$f(x)$在$x_0$处的左、右导数分别定义为： 左导数：$f’_{-}(x_0)=\\underset{\\Delta x\\to {0^{-}}}{\\mathop{\\lim }}\\,\\frac{f({x_0}+\\Delta x)-f({x_0})}{\\Delta x}=\\underset{x\\to x_{0}^{-}}{\\mathop{\\lim }}\\,\\frac{f(x)-f({x_0})}{x-{x_0}},(x={x_0}+\\Delta x)$ 右导数：$f’_{+}(x_0)=\\underset{\\Delta x\\to {0^{+}}}{\\mathop{\\lim }}\\,\\frac{f({x_0}+\\Delta x)-f({x_0})}{\\Delta x}=\\underset{x\\to x_0^{+}}{\\mathop{\\lim }}\\,\\frac{f(x)-f({x_0})}{x-{x_0}}$ 函数的可导性与连续性之间的关系Th1: 函数$f(x)$在$x_0$处可微$\\Leftrightarrow f(x)$在$x_0$处可导 Th2: 若函数在点$x_0$处可导，则$y=f(x)$在点$x_0$处连续，反之则不成立。即函数连续不一定可导。 Th3: $f’(x_0)$存在$\\Leftrightarrow f’_{-}(x_0)=f’_{+}(x_0)$ 平面曲线的切线和法线切线方程 : $y-{y_0}=f’({x_0})(x-x_0)$法线方程：$y-{y_0}=-\\frac{1}{f’({x_0})}(x-{x_0}),f’({x_0})\\ne 0$ 四则运算法则设函数$u=u(x)，v=v(x)$在点$x$可导则(1) $(u\\pm v)’={u}’\\pm {v}’$$d(u\\pm v)=du\\pm dv$(2)$(uv)’=uv’+vu’$$d(uv)=udv+vdu$(3) $(\\frac{u}{v})’=\\frac{vu’-uv’}{v^{2}}(v\\ne 0)$$d(\\frac{u}{v})=\\frac{vdu-udv}{v^{2}}$ 基本导数与微分表(1) $y=c$（常数）${y}’=0$$dy=0$ (2) $y={x^{\\alpha }}$($\\alpha$为实数)${y}’=\\alpha {x^{\\alpha -1}}$$dy=\\alpha {x^{\\alpha -1}}dx$ (3) $y={a^x}$${y}’={a^x}\\ln a$$dy={a^x}\\ln adx$特例:$({e^{x}}’={e^{x}}$$d({e^{x}})={e^{x}}dx$ (4) $y={\\log_{a}}x$ ${y}’=\\frac{1}{x\\ln a}$$dy=\\frac{1}{x\\ln a}dx$ 特例:$y=\\ln x$ $(\\ln x)’=\\frac{1}{x}$ $d(\\ln x)=\\frac{1}{x}dx$ (5) $y=\\sin x$${y}’=\\cos x$ $d(\\sin x)=\\cos xdx$ (6) $y=\\cos x$${y}’=-\\sin x$ $d(\\cos x)=-\\sin xdx$ (7) $y=\\tan x$${y}’=\\frac{1}{\\cos^{2}x}=\\sec^{2}x$$d(\\tan x)=\\sec^{2}xdx$ (8) $y=\\cot x$${y}’=-\\frac{1}{\\sin^{2}x}=-\\csc^{2}x$$d(\\cot x)=-\\csc^{2}xdx$ (9) $y=\\sec x$ ${y}’=\\sec x\\tan x$ $d(\\sec x)=\\sec x\\tan xdx$(10) $y=\\csc x$ ${y}’=-\\csc x\\cot x$ $d(\\csc x)=-\\csc x\\cot xdx$(11) $y=\\arcsin x$ ${y}’=\\frac{1}{\\sqrt{1-{x^{2}}}}$ $d(\\arcsin x)=\\frac{1}{\\sqrt{1-x^{2}}}dx$(12) $y=\\arccos x$ ${y}’=-\\frac{1}{\\sqrt{1-x^{2}}}$$d(\\arccos x)=-\\frac{1}{\\sqrt{1-x^{2}}}dx$ (13) $y=\\arctan x$${y}’=\\frac{1}{1+x^{2}}$$d(\\arctan x)=\\frac{1}{1+x^{2}}dx$ (14) $y=\\operatorname{arc}\\cot x$${y}’=-\\frac{1}{1+x^{2}}$$d(\\operatorname{arc}\\cot x)=-\\frac{1}{1+x^{2}}dx$ (15) $y=shx$${y}’=chx$$d(shx)=chxdx$ (16) $y=chx$${y}’=shx$$d(chx)=shxdx$ 复合函数，反函数，隐函数以及参数方程所确定的函数的微分法(1) 反函数的运算法则: 设$y=f(x)$在点$x$的某邻域内单调连续，在点$x$处可导且$f’(x)\\ne 0$，则其反函数在点$x$所对应的$y$处可导，并且有$\\frac{dy}{dx}=\\frac{1}{\\frac{dx}{dy}}$ (2) 复合函数的运算法则:若 $\\mu =\\varphi(x)$ 在点$x$可导,而$y=f(\\mu)$在对应点$\\mu$($\\mu =\\varphi (x)$)可导,则复合函数$y=f(\\varphi (x))$在点$x$可导,且$y’=f’(\\mu )\\cdot {\\varphi }’(x)$ (3) 隐函数导数$\\frac{dy}{dx}$的求法一般有三种方法： 1)方程两边对$x$求导，要记住$y$是$x$的函数，则$y$的函数是$x$的复合函数.例如$\\frac{1}{y}$，${y^{2}}$，$ln y$，${e^{y}}$等均是$x$的复合函数.对$x$求导应按复合函数连锁法则做. 2)公式法.由$F(x,y)=0$知 $\\frac{dy}{dx}=-\\frac{F’{x}(x,y)}{F’{y}(x,y)}$,其中，${F’{x}}(x,y)$，${F’{y}}(x,y)$分别表示$F(x,y)$对$x$和$y$的偏导数 3)利用微分形式不变性 常用高阶导数公式（1）$(a^{x}){\\,}^{(n)}=a^{x}{\\ln }^{n}a\\quad (a&gt;{0})\\quad \\quad (e^{x}){\\,}^{(n)}=e{\\,}^{x}$ （2）$(\\sin kx)\\,^{(n)}=k^{n}\\sin (kx+n\\cdot \\frac{\\pi }2)$ （3）$(\\cos kx)\\,^{(n)}={k^{n}}\\cos (kx+n\\cdot \\frac{\\pi }2)$ （4）$(x^{m})\\,^{(n)}=m(m-1)\\cdots (m-n+1){x^{m-n}}$ （5）$(\\ln x)\\,^{(n)}={(-1)^{(n-1)}}\\frac{(n-1)!}{x^{n}}$ （6）莱布尼兹公式：若$u(x)\\,,v(x)$均$n$阶可导，则 ${(uv)^{(n)}}=\\sum\\limits_{i=0}^{n}{c_{n}^{i}{u^{(i)}}{v^{(n-i)}}}$，其中${u^{({0})}}=u$，${v^{({0})}}=v$ 微分中值定理，泰勒公式Th1:(费马定理)若函数$f(x)$满足条件：(1)函数$f(x)$在${x_{0}}$的某邻域内有定义，并且在此邻域内恒有$f(x)\\le f(x_{0})$或$f(x)\\ge f(x_{0})$, (2) $f(x)$在${x_{0}}$处可导,则有 ${f}’(x_{0})=0$ Th2:(罗尔定理)设函数$f(x)$满足条件：(1)在闭区间$[a,b]$上连续；(2)在$(a,b)$内可导；(3)$f(a)=f(b)$；则在$(a,b)$内一存在个$\\xi$，使 ${f}’(\\xi )=0$ Th3: (拉格朗日中值定理)设函数$f(x)$满足条件：(1)在$[a,b]$上连续；(2)在$(a,b)$内可导；则在$(a,b)$内一存在个$\\xi$，使 $\\frac{f(b)-f(a)}{b-a}={f}’(\\xi )$ Th4: (柯西中值定理) 设函数$f(x)$，$g(x)$满足条件：(1) 在$[a,b]$上连续；(2) 在$(a,b)$内可导且$f’(x)$，$g’(x)$均存在，且$g’(x)\\ne 0$则在$(a,b)$内存在一个$\\xi$，使 $\\frac{f(b)-f(a)}{g(b)-g(a)}=\\frac{f’(\\xi )}{g’(\\xi )}$ 洛必达法则法则Ⅰ ($\\frac{0}{0}$型)设函数$f\\left( x \\right),g\\left( x \\right)$满足条件： $\\underset{x\\to {x_{0}}}{\\mathop{\\lim }}\\,f\\left( x \\right)=0,\\underset{x\\to {x_{0}}}{\\mathop{\\lim }}\\,g\\left( x \\right)=0$; $f\\left( x \\right),g\\left( x \\right)$在${x_{0}}$的邻域内可导，(在${x_{0}}$处可除外)且${g}’\\left( x \\right)\\ne 0$; $\\underset{x\\to {x_{0}}}{\\mathop{\\lim }}\\,\\frac{f’\\left( x \\right)}{g’\\left( x \\right)}$存在(或$\\infty$)。 则:$\\underset{x\\to {x_{0}}}{\\mathop{\\lim }}\\,\\frac{f\\left( x \\right)}{g\\left( x \\right)}=\\underset{x\\to {x_{0}}}{\\mathop{\\lim }}\\,\\frac{f’\\left( x \\right)}{g’\\left( x \\right)}$。法则${I’}$ ($\\frac{0}{0}$型)设函数$f\\left( x \\right),g\\left( x \\right)$满足条件：$\\underset{x\\to \\infty }{\\mathop{\\lim }}\\,f\\left( x \\right)=0,\\underset{x\\to \\infty }{\\mathop{\\lim }}\\,g\\left( x \\right)=0$; 存在一个$X&gt;0$,当$\\left| x \\right|&gt;X$时,$f\\left( x \\right),g\\left( x \\right)$可导,且$g’\\left( x \\right)\\ne 0$;$\\underset{x\\to {x_{0}}}{\\mathop{\\lim }}\\,\\frac{f’\\left( x \\right)}{g’\\left( x \\right)}$存在(或$\\infty$)。 则$\\underset{x\\to {x_{0}}}{\\mathop{\\lim }}\\,\\frac{f\\left( x \\right)}{g\\left( x \\right)}=\\underset{x\\to {x_{0}}}{\\mathop{\\lim }}\\,\\frac{f’\\left( x \\right)}{g’\\left( x \\right)}$法则Ⅱ( $\\frac{\\infty }{\\infty }$ 型) 设函数 $f\\left( x \\right),g\\left( x \\right)$ 满足条件：$\\underset{x\\to {x_{0}}}{\\mathop{\\lim }}\\,f\\left( x \\right)=\\infty,\\underset{x\\to {x_{0}}}{\\mathop{\\lim }}\\,g\\left( x \\right)=\\infty$;$f\\left( x \\right),g\\left( x \\right)$ 在 ${x_{0}}$ 的邻域内可导(在${x_{0}}$处可除外)且$g’\\left( x \\right)\\ne 0$;$\\underset{x\\to {x_{0}}}{\\mathop{\\lim }}\\,\\frac{f’\\left( x \\right)}{g’\\left( x \\right)}$ 存在(或$\\infty$)。则$\\underset{x\\to {x_{0}}}{\\mathop{\\lim }}\\,\\frac{f\\left( x \\right)}{g\\left( x \\right)}=\\underset{x\\to {x_{0}}}{\\mathop{\\lim }}\\,\\frac{f’\\left( x \\right)}{g’\\left( x \\right)}$ 同理法则${II’}$ ( $\\frac{\\infty }{\\infty }$ 型)仿法则 $I’}$ 可写出。 泰勒公式设函数$f(x)$在点${x_{0}}$处的某邻域内具有$n+1$阶导数，则对该邻域内异于${x_{0}}$的任意点$x$，在${x_{0}}$与$x$之间至少存在一个$\\xi$，使得：$f(x)=f(x_{0})+f’(x_{0})(x-x_{0})+\\frac{1}{2!}f’’(x_{0})(x-x_{0})^{2}+\\cdots +\\frac{f^{(n)}(x_{0})}{n!}(x-x_{0})^{n}+R_{n}(x)$其中 $R_{n}(x)=\\frac{f^{(n+1)}(\\xi )}{(n+1)!}{(x-x_{0})^{n+1}}$称为$f(x)$在点$x_{0}$处的$n$阶泰勒余项。 令$x_{0}=0$，则$n$阶泰勒公式$f(x)=f(0)+f’(0)x+\\frac{1}{2!}f’’(0){x^{2}}+\\cdots +\\frac{f^{(n)}(0)}{n!}x^{n}+R_{n}(x)$……(1)其中 $R_{n}(x)=\\frac{f^{(n+1)}(\\xi )}{(n+1)!}x^{n+1}$，$\\xi$在0与$x$之间.(1)式称为麦克劳林公式 常用五种函数在${x_{0}}=0$处的泰勒公式(1) $e^{x}=1+x+\\frac{1}{2!}x^{2}+\\cdots +\\frac{1}{n!}x^{n}+\\frac{x^{n+1}}{(n+1)!}e^{\\xi }$ 或 $e^{x}=1+x+\\frac{1}{2!}x^{2}+\\cdots +\\frac{1}{n!}x^{n}+o(x^{n})$ (2) $\\sin x=x-\\frac{1}{3!}x^{3}+\\cdots +\\frac{x^{n}}{n!}\\sin \\frac{n\\pi }{2}+\\frac{x^{n+1}}{(n+1)!}\\sin (\\xi +\\frac{n+1}{2}\\pi )$ 或 $\\sin x=x-\\frac{1}{3!}{x^{3}}+\\cdots +\\frac{x^{n}}{n!}\\sin \\frac{n\\pi }{2}+o(x^{n})$ (3) $\\cos x=1-\\frac{1}{2!}x^{2}+\\cdots +\\frac{x^{n}}{n!}\\cos \\frac{n\\pi }{2}+\\frac{x^{n+1}}{(n+1)!}\\cos (\\xi +\\frac{n+1}{2}\\pi )$ 或 $\\cos x=1-\\frac{1}{2!}x^{2}+\\cdots +\\frac{x^{n}}{n!}\\cos \\frac{n\\pi }{2}+o(x^{n})$ (4) $\\ln (1+x)=x-\\frac{1}{2}x^{2}+\\frac{1}{3}x^{3}-\\cdots +(-1)^{n-1}\\frac{x^{n}}{n}+\\frac{(-1)^{n}x^{n+1}}{(n+1)(1+\\xi )^{n+1}}$或 $\\ln (1+x)=x-\\frac{1}{2}x^{2}+\\frac{1}{3}x^{3}-\\cdots +(-1)^{n-1}\\frac{x^{n}}{n}+o(x^{n})$ (5) $(1+x)^{m}=1+mx+\\frac{m(m-1)}{2!}x^{2}+\\cdots +\\frac{m(m-1)\\cdots (m-n+1)}{n!}x^{n}$$+\\frac{m(m-1)\\cdots (m-n+1)}{(n+1)!}x^{n+1}{(1+\\xi )}^{m-n-1}$ 或$(1+x)^{m}=1+mx+\\frac{m(m-1)}{2!}x^{2}+\\cdots +\\frac{m(m-1)\\cdots (m-n+1)}{n!}x^{n}+o(x^{n})$ 函数单调性的判断Th1: 设函数$f(x)$在$(a,b)$区间内可导，如果对$\\forall x\\in (a,b)$，都有$f\\,’(x)&gt;0$（或$f\\,’(x)&lt;0$），则函数$f(x)$在$(a,b)$内是单调增加的（或单调减少） Th2: （取极值的必要条件）设函数$f(x)$在$x_{0}$处可导，且在$x_{0}$处取极值，则$f\\,’(x_{0})=0$。 Th3: （取极值的第一充分条件）设函数$f(x)$在$x_{0}$的某一邻域内可微，且$f\\,’(x_{0})=0$（或$f(x)$在$x_{0}$处连续，但$f\\,’(x_{0})$不存在。）(1)若当$x$经过$x_{0}$时，$f\\,’(x)$由“+”变“-”，则$f(x_{0})$为极大值；(2)若当$x$经过$x_{0}$时，$f\\,’(x)$由“-”变“+”，则$f(x_{0})$为极小值；(3)若$f\\,’(x)$经过$x={x_{0}}$的两侧不变号，则$f(x_{0})$不是极值。 Th4: (取极值的第二充分条件)设$f(x)$在点${x_{0}}$处有$f’’(x)\\ne 0$，且$f\\,’(x_{0})=0$，则 当$f’\\,’(x_{0})&lt;0$时，$f({x_{0}})$为极大值；当$f’\\,’(x_{0})&gt;0$时，$f({x_{0}})$为极小值。注：如果$f’\\,’(x_{0})=0$，此方法失效。 渐近线的求法(1)水平渐近线若$\\underset{x\\to +\\infty }{\\mathop{\\lim }}\\,f(x)=b$，或$\\underset{x\\to -\\infty }{\\mathop{\\lim }}\\,f(x)=b$，则 $y=b$称为函数$y=f(x)$的水平渐近线。 (2)铅直渐近线若$\\underset{x\\to x_{0}^{-}}{\\mathop{\\lim }}\\,f(x)=\\infty$，或$\\underset{x\\to x_{0}^{+}}{\\mathop{\\lim }}\\,f(x)=\\infty$，则 $x={x_{0}}$称为$y=f(x)$的铅直渐近线。 (3)斜渐近线若$a=\\underset{x\\to \\infty }{\\mathop{\\lim }}\\,\\frac{f(x)}{x},\\quad b=\\underset{x\\to \\infty }{\\mathop{\\lim }}\\,[f(x)-ax]$，则$y=ax+b$称为$y=f(x)$的斜渐近线。 函数凹凸性的判断Th1: (凹凸性的判别定理）若在I上$f’’(x)&lt;0$（或$f’’(x)&gt;0$），则$f(x)$在I上是凸的（或凹的）。 Th2: (拐点的判别定理1)若在${x_{0}}$处$f’’(x)=0$，（或$f’’(x)$不存在），当$x$变动经过${x_{0}}$时，$f’’(x)$变号，则$({x_{0}},f({x_{0}}))$为拐点。 Th3: (拐点的判别定理2)设$f(x)$在${x_{0}}$点的某邻域内有三阶导数，且$f’’(x)=0$，$f’’’(x)\\ne 0$，则$({x_{0}},f({x_{0}}))$为拐点。 弧微分$dS=\\sqrt{1+y’^{2}}dx$ 曲率曲线$y=f(x)$在点$(x,y)$处的曲率$k=\\frac{\\left| y’’ \\right|}{(1+y’^{2})^{\\tfrac{3}{2}}}$。对于参数方程$\\left{\\begin{matrix}x=\\varphi(t) \\ y=\\psi (t) \\end{matrix}\\right.,$$k=\\frac{\\left| \\varphi ‘(t)\\psi ‘’(t)-\\varphi ‘’(t)\\psi ‘(t) \\right|}{[\\varphi ‘^{2}(t)+\\psi ‘^{2}(t)]^{\\tfrac{3}{2}}}$。 曲率半径曲线在点$M$处的曲率$k(k\\ne 0)$与曲线在点$M$处的曲率半径$\\rho$有如下关系：$\\rho =\\frac{1}{k}$。 线性代数行列式行列式按行（列）展开定理(1) 设$A = ( a_ ){n \\times n}$，则：$a{i1}A_{j1} +a_{i2}A_{j2} + \\cdots + a_A_ = \\begin{cases}|A|,i=j\\ 0,i \\neq j\\end{cases}$ 或$a_{1i}A_{1j} + a_{2i}A_{2j} + \\cdots + a_A_ = \\begin{cases}|A|,i=j\\ 0,i \\neq j\\end{cases}$即 $AA^{} = A^{}A = \\left| A \\right|E,$其中：$A^{*} = \\begin{pmatrix} A_{11} &amp; A_{12} &amp; \\ldots &amp; A_{1n} \\ A_{21} &amp; A_{22} &amp; \\ldots &amp; A_{2n} \\ \\ldots &amp; \\ldots &amp; \\ldots &amp; \\ldots \\ A_{n1} &amp; A_{n2} &amp; \\ldots &amp; A_ \\ \\end{pmatrix} = (A_) = {(A_)}^{T}$ $D_{n} = \\begin{vmatrix} 1 &amp; 1 &amp; \\ldots &amp; 1 \\ x_{1} &amp; x_{2} &amp; \\ldots &amp; x_{n} \\ \\ldots &amp; \\ldots &amp; \\ldots &amp; \\ldots \\ x_{1}^{n - 1} &amp; x_{2}^{n - 1} &amp; \\ldots &amp; x_{n}^{n - 1} \\ \\end{vmatrix} = \\prod_{1 \\leq j &lt; i \\leq n}^{}\\,(x_{i} - x_{j})$ (2) 设$A,B$为$n$阶方阵，则$\\left| {AB} \\right| = \\left| A \\right|\\left| B \\right| = \\left| B \\right|\\left| A \\right| = \\left| {BA} \\right|$，但$\\left| A \\pm B \\right| = \\left| A \\right| \\pm \\left| B \\right|$不一定成立。 (3) $\\left| {kA} \\right| = k^{n}\\left| A \\right|$,$A$为$n$阶方阵。 (4) 设$A$为$n$阶方阵，$|A^{T}| = |A|;|A^{- 1}| = |A|^{- 1}$（若$A$可逆），$|A^{*}| = |A|^{n - 1}$ $n \\geq 2$ (5) $\\left| \\begin{matrix} &amp; {A\\quad O} \\ &amp; {O\\quad B} \\ \\end{matrix} \\right| = \\left| \\begin{matrix} &amp; {A\\quad C} \\ &amp; {O\\quad B} \\ \\end{matrix} \\right| = \\left| \\begin{matrix} &amp; {A\\quad O} \\ &amp; {C\\quad B} \\ \\end{matrix} \\right| =| A||B|$，$A,B$为方阵，但$\\left| \\begin{matrix} {O} &amp; A_{m \\times m} \\ B_{n \\times n} &amp; { O} \\ \\end{matrix} \\right| = ({- 1)}^|A||B|$ 。 (6) 范德蒙行列式$D_{n} = \\begin{vmatrix} 1 &amp; 1 &amp; \\ldots &amp; 1 \\ x_{1} &amp; x_{2} &amp; \\ldots &amp; x_{n} \\ \\ldots &amp; \\ldots &amp; \\ldots &amp; \\ldots \\ x_{1}^{n - 1} &amp; x_{2}^{n 1} &amp; \\ldots &amp; x_{n}^{n - 1} \\ \\end{vmatrix} = \\prod_{1 \\leq j &lt; i \\leq n}^{}\\,(x_{i} - x_{j})$ 设$A$是$n$阶方阵，$\\lambda_{i}(i = 1,2\\cdots,n)$是$A$的$n$个特征值，则$|A| = \\prod_{i = 1}^{n}\\lambda_{i}$ 矩阵矩阵：$m \\times n$个数$a_$排成$m$行$n$列的表格$\\begin{bmatrix} a_{11}\\quad a_{12}\\quad\\cdots\\quad a_{1n} \\ a_{21}\\quad a_{22}\\quad\\cdots\\quad a_{2n} \\ \\quad\\cdots\\cdots\\cdots\\cdots\\cdots \\ a_{m1}\\quad a_{m2}\\quad\\cdots\\quad a_ \\ \\end{bmatrix}$ 称为矩阵，简记为$A$，或者$\\left( a_ \\right)_{m \\times n}$ 。若$m = n$，则称$A$是$n$阶矩阵或$n$阶方阵。 矩阵的线性运算矩阵的加法设$A = (a_),B = (b_)$是两个$m \\times n$矩阵，则$m \\times n$ 矩阵$C = c_) = a_ + b_$称为矩阵$A$与$B$的和，记为$A + B = C$ 。 矩阵的数乘设$A = (a_)$是$m \\times n$矩阵，$k$是一个常数，则$m \\times n$矩阵$(ka_)$称为数$k$与矩阵$A$的数乘，记为${kA}$。 矩阵的乘法设$A = (a_)$是$m \\times n$矩阵，$B = (b_)$是$n \\times s$矩阵，那么$m \\times s$矩阵$C = (c_)$，其中$c_ = a_{i1}b_{1j} + a_{i2}b_{2j} + \\cdots + a_b_ = \\sum_{k =1}^{n}{a_b_}$称为${AB}$的乘积，记为$C = AB$ 。 $\\mathbf{A}^{\\mathbf{T}}$、$\\mathbf{A}^{\\mathbf{-1}}$、$\\mathbf{A}^{\\mathbf{*}}$三者之间的关系(1) ${(A^{T})}^{T} = A,{(AB)}^{T} = B^{T}A^{T},{(kA)}^{T} = kA^{T},{(A \\pm B)}^{T} = A^{T} \\pm B^{T}$ (2) $\\left( A^{- 1} \\right)^{- 1} = A,\\left( {AB} \\right)^{- 1} = B^{- 1}A^{- 1},\\left( {kA} \\right)^{- 1} = \\frac{1}{k}A^{- 1},$ 但 ${(A \\pm B)}^{- 1} = A^{- 1} \\pm B^{- 1}$不一定成立。 (3) $\\left( A^{} \\right)^{} = |A|^{n - 2}\\ A\\ \\ (n \\geq 3)$，$\\left({AB} \\right)^{} = B^{}A^{},$ $\\left( {kA} \\right)^{} = k^{n -1}A^{*}{\\ \\ }\\left( n \\geq 2 \\right)$ 但$\\left( A \\pm B \\right)^{} = A^{} \\pm B^{*}$不一定成立。 (4) ${(A^{- 1})}^{T} = {(A^{T})}^{- 1},\\ \\left( A^{- 1} \\right)^{} ={(AA^{})}^{- 1},{(A^{})}^{T} = \\left( A^{T} \\right)^{}$ 有关$\\mathbf{A}^{\\mathbf{*}}$的结论**(1) $AA^{} = A^{}A = |A|E$ (2) $|A^{}| = |A|^{n - 1}\\ (n \\geq 2),\\ \\ \\ \\ (kA)^{} = k^{n -1}A^{},{\\ \\ }\\left( A^{} \\right)^{*} = |A|^{n - 2}A(n \\geq 3)$ (3) 若$A$可逆，则$A^{} = |A|A^{- 1},(A^{})^{*} = \\frac{1}{|A|}A$ (4) 若$A$为$n$阶方阵，则： $r(A^*)=\\begin{cases}n,\\quad r(A)=n\\ 1,\\quad r(A)=n-1\\ 0,\\quad r(A)&lt;n-1\\end{cases}$ 有关$\\mathbf{A}^{\\mathbf{- 1}}$的结论**$A$可逆$\\Leftrightarrow AB = E; \\Leftrightarrow |A| \\neq 0; \\Leftrightarrow r(A) = n;$ $\\Leftrightarrow A$可以表示为初等矩阵的乘积；$\\Leftrightarrow Ax = 0$只有零解。 有关矩阵秩的结论**(1) 秩$r(A)$=行秩=列秩； (2) $r(A_{m \\times n}) \\leq \\min(m,n);$ (3) $A \\neq 0 \\Rightarrow r(A) \\geq 1$； (4) $r(A \\pm B) \\leq r(A) + r(B);$ (5) 初等变换不改变矩阵的秩 (6) $r(A) + r(B) - n \\leq r(AB) \\leq \\min(r(A),r(B)),$特别若$AB = O$则：$r(A) + r(B) \\leq n$ (7) 若$A^{- 1}$存在$\\Rightarrow r(AB) = r(B);$ 若$B^{- 1}$存在$\\Rightarrow r(AB) = r(A);$ 若$r(A_{m \\times n}) = n \\Rightarrow r(AB) = r(B);$ 若$r(A_{m \\times s}) = n\\Rightarrow r(AB) = r\\left( A \\right)$。 (8) $r(A_{m \\times s}) = n \\Leftrightarrow Ax = 0$只有零解 分块求逆公式**$\\begin{pmatrix} A &amp; O \\ O &amp; B \\ \\end{pmatrix}^{- 1} = \\begin{pmatrix} A^{-1} &amp; O \\ O &amp; B^{- 1} \\ \\end{pmatrix}$； $\\begin{pmatrix} A &amp; C \\ O &amp; B \\\\end{pmatrix}^{- 1} = \\begin{pmatrix} A^{- 1}&amp; - A^{- 1}CB^{- 1} \\ O &amp; B^{- 1} \\ \\end{pmatrix}$； $\\begin{pmatrix} A &amp; O \\ C &amp; B \\ \\end{pmatrix}^{- 1} = \\begin{pmatrix} A^{- 1}&amp;{O} \\ - B^{- 1}CA^{- 1} &amp; B^{- 1} \\\\end{pmatrix}$； $\\begin{pmatrix} O &amp; A \\ B &amp; O \\ \\end{pmatrix}^{- 1} =\\begin{pmatrix} O &amp; B^{- 1} \\ A^{- 1} &amp; O \\ \\end{pmatrix}$ 这里$A$，$B$均为可逆方阵。 向量有关向量组的线性表示(1)$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$线性相关$\\Leftrightarrow$至少有一个向量可以用其余向量线性表示。 (2)$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$线性无关，$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$，$\\beta$线性相关$\\Leftrightarrow \\beta$可以由$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$唯一线性表示。 (3) $\\beta$可以由$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$线性表示$\\Leftrightarrow r(\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}) =r(\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s},\\beta)$ 。 有关向量组的线性相关性(1)部分相关，整体相关；整体无关，部分无关. (2) ① $n$个$n$维向量$\\alpha_{1},\\alpha_{2}\\cdots\\alpha_{n}$线性无关$\\Leftrightarrow \\left|\\left\\lbrack \\alpha_{1}\\alpha_{2}\\cdots\\alpha_{n} \\right\\rbrack \\right| \\neq0$， $n$个$n$维向量$\\alpha_{1},\\alpha_{2}\\cdots\\alpha_{n}$线性相关$\\Leftrightarrow |\\lbrack\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{n}\\rbrack| = 0$。 ② $n + 1$个$n$维向量线性相关。 ③ 若$\\alpha_{1},\\alpha_{2}\\cdots\\alpha_{S}$线性无关，则添加分量后仍线性无关；或一组向量线性相关，去掉某些分量后仍线性相关。 有关向量组的线性表示(1) $\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$线性相关$\\Leftrightarrow$至少有一个向量可以用其余向量线性表示。 (2) $\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$线性无关，$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$，$\\beta$线性相关$\\Leftrightarrow\\beta$ 可以由$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$唯一线性表示。 (3) $\\beta$可以由$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$线性表示$\\Leftrightarrow r(\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}) =r(\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s},\\beta)$ 向量组的秩与矩阵的秩之间的关系设$r(A_{m \\times n}) =r$，则$A$的秩$r(A)$与$A$的行列向量组的线性相关性关系为： (1) 若$r(A_{m \\times n}) = r = m$，则$A$的行向量组线性无关。 (2) 若$r(A_{m \\times n}) = r &lt; m$，则$A$的行向量组线性相关。 (3) 若$r(A_{m \\times n}) = r = n$，则$A$的列向量组线性无关。 (4) 若$r(A_{m \\times n}) = r &lt; n$，则$A$的列向量组线性相关。 $\\mathbf{n}$**维向量空间的基变换公式及过渡矩阵若$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{n}$与$\\beta_{1},\\beta_{2},\\cdots,\\beta_{n}$是向量空间$V$的两组基，则基变换公式为： $(\\beta_{1},\\beta_{2},\\cdots,\\beta_{n}) = (\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{n})\\begin{bmatrix} c_{11}&amp; c_{12}&amp; \\cdots &amp; c_{1n} \\ c_{21}&amp; c_{22}&amp;\\cdots &amp; c_{2n} \\ \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\ c_{n1}&amp; c_{n2} &amp; \\cdots &amp; c_ \\\\end{bmatrix} = (\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{n})C$ 其中$C$是可逆矩阵，称为由基$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{n}$到基$\\beta_{1},\\beta_{2},\\cdots,\\beta_{n}$的过渡矩阵。 坐标变换公式若向量$\\gamma$在基$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{n}$与基$\\beta_{1},\\beta_{2},\\cdots,\\beta_{n}$的坐标分别是$X = {(x_{1},x_{2},\\cdots,x_{n})}^{T}$， $Y = \\left( y_{1},y_{2},\\cdots,y_{n} \\right)^{T}$ 即： $\\gamma =x_{1}\\alpha_{1} + x_{2}\\alpha_{2} + \\cdots + x_{n}\\alpha_{n} = y_{1}\\beta_{1} +y_{2}\\beta_{2} + \\cdots + y_{n}\\beta_{n}$，则向量坐标变换公式为$X = CY$ 或$Y = C^{- 1}X$，其中$C$是从基$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{n}$到基$\\beta_{1},\\beta_{2},\\cdots,\\beta_{n}$的过渡矩阵。 向量的内积$(\\alpha,\\beta) = a_{1}b_{1} + a_{2}b_{2} + \\cdots + a_{n}b_{n} = \\alpha^{T}\\beta = \\beta^{T}\\alpha$ 8.Schmidt正交化若$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$线性无关，则可构造$\\beta_{1},\\beta_{2},\\cdots,\\beta_{s}$使其两两正交，且$\\beta_{i}$仅是$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{i}$的线性组合$(i= 1,2,\\cdots,n)$，再把$\\beta_{i}$单位化，记$\\gamma_{i} =\\frac{\\beta_{i}}{\\left| \\beta_{i}\\right|}$，则$\\gamma_{1},\\gamma_{2},\\cdots,\\gamma_{i}$是规范正交向量组。其中$\\beta_{1} = \\alpha_{1}$， $\\beta_{2} = \\alpha_{2} -\\frac{(\\alpha_{2},\\beta_{1})}{(\\beta_{1},\\beta_{1})}\\beta_{1}$ ， $\\beta_{3} =\\alpha_{3} - \\frac{(\\alpha_{3},\\beta_{1})}{(\\beta_{1},\\beta_{1})}\\beta_{1} -\\frac{(\\alpha_{3},\\beta_{2})}{(\\beta_{2},\\beta_{2})}\\beta_{2}$ ， ………… $\\beta_{s} = \\alpha_{s} - \\frac{(\\alpha_{s},\\beta_{1})}{(\\beta_{1},\\beta_{1})}\\beta_{1} - \\frac{(\\alpha_{s},\\beta_{2})}{(\\beta_{2},\\beta_{2})}\\beta_{2} - \\cdots - \\frac{(\\alpha_{s},\\beta_{s - 1})}{(\\beta_{s - 1},\\beta_{s - 1})}\\beta_{s - 1}$ 正交基及规范正交基向量空间一组基中的向量如果两两正交，就称为正交基；若正交基中每个向量都是单位向量，就称其为规范正交基。 线性方程组克莱姆法则线性方程组$\\begin{cases} a_{11}x_{1} + a_{12}x_{2} + \\cdots +a_{1n}x_{n} = b_{1} \\ a_{21}x_{1} + a_{22}x_{2} + \\cdots + a_{2n}x_{n} =b_{2} \\ \\quad\\cdots\\cdots\\cdots\\cdots\\cdots\\cdots\\cdots\\cdots\\cdots \\ a_{n1}x_{1} + a_{n2}x_{2} + \\cdots + a_x_{n} = b_{n} \\ \\end{cases}$，如果系数行列式$D = \\left| A \\right| \\neq 0$，则方程组有唯一解，$x_{1} = \\frac{D_{1}}{D},x_{2} = \\frac{D_{2}}{D},\\cdots,x_{n} =\\frac{D_{n}}{D}$，其中$D_{j}$是把$D$中第$j$列元素换成方程组右端的常数列所得的行列式。 规律$n$阶矩阵$A$可逆$\\Leftrightarrow Ax = 0$只有零解。$\\Leftrightarrow\\forall b,Ax = b$总有唯一解，一般地，$r(A_{m \\times n}) = n \\Leftrightarrow Ax= 0$只有零解。 非奇次线性方程组有解的充分必要条件，线性方程组解的性质和解的结构(1) 设$A$为$m \\times n$矩阵，若$r(A_{m \\times n}) = m$，则对$Ax =b$而言必有$r(A) = r(A \\vdots b) = m$，从而$Ax = b$有解。 (2) 设$x_{1},x_{2},\\cdots x_{s}$为$Ax = b$的解，则$k_{1}x_{1} + k_{2}x_{2}\\cdots + k_{s}x_{s}$当$k_{1} + k_{2} + \\cdots + k_{s} = 1$时仍为$Ax =b$的解；但当$k_{1} + k_{2} + \\cdots + k_{s} = 0$时，则为$Ax =0$的解。特别$\\frac{x_{1} + x_{2}}{2}$为$Ax = b$的解；$2x_{3} - (x_{1} +x_{2})$为$Ax = 0$的解。 (3) 非齐次线性方程组${Ax} = b$无解$\\Leftrightarrow r(A) + 1 =r(\\overline{A}) \\Leftrightarrow b$不能由$A$的列向量$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{n}$线性表示。 奇次线性方程组的基础解系和通解，解空间，非奇次线性方程组的通解(1) 齐次方程组${Ax} = 0$恒有解(必有零解)。当有非零解时，由于解向量的任意线性组合仍是该齐次方程组的解向量，因此${Ax}= 0$的全体解向量构成一个向量空间，称为该方程组的解空间，解空间的维数是$n - r(A)$，解空间的一组基称为齐次方程组的基础解系。 (2) $\\eta_{1},\\eta_{2},\\cdots,\\eta_{t}$是${Ax} = 0$的基础解系，即： 1) $\\eta_{1},\\eta_{2},\\cdots,\\eta_{t}$是${Ax} = 0$的解； 2) $\\eta_{1},\\eta_{2},\\cdots,\\eta_{t}$线性无关； 3) ${Ax} = 0$的任一解都可以由$\\eta_{1},\\eta_{2},\\cdots,\\eta_{t}$线性表出.$k_{1}\\eta_{1} + k_{2}\\eta_{2} + \\cdots + k_{t}\\eta_{t}$是${Ax} = 0$的通解，其中$k_{1},k_{2},\\cdots,k_{t}$是任意常数。 矩阵的特征值和特征向量矩阵的特征值和特征向量的概念及性质(1) 设$\\lambda$是$A$的一个特征值，则 ${kA},{aA} + {bE},A^{2},A^{m},f(A),A^{T},A^{- 1},A^{*}$有一个特征值分别为${kλ},{aλ} + b,\\lambda^{2},\\lambda^{m},f(\\lambda),\\lambda,\\lambda^{- 1},\\frac{|A|}{\\lambda},$且对应特征向量相同（$A^{T}$ 例外）。 (2)若$\\lambda_{1},\\lambda_{2},\\cdots,\\lambda_{n}$为$A$的$n$个特征值，则$\\sum_{i= 1}^{n}\\lambda_{i} = \\sum_{i = 1}^{n}a_,\\prod_{i = 1}^{n}\\lambda_{i}= |A|$ ,从而$|A| \\neq 0 \\Leftrightarrow A$没有特征值。 (3)设$\\lambda_{1},\\lambda_{2},\\cdots,\\lambda_{s}$为$A$的$s$个特征值，对应特征向量为$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$， 若: $\\alpha = k_{1}\\alpha_{1} + k_{2}\\alpha_{2} + \\cdots + k_{s}\\alpha_{s}$ , 则: $A^{n}\\alpha = k_{1}A^{n}\\alpha_{1} + k_{2}A^{n}\\alpha_{2} + \\cdots +k_{s}A^{n}\\alpha_{s} = k_{1}\\lambda_{1}^{n}\\alpha_{1} +k_{2}\\lambda_{2}^{n}\\alpha_{2} + \\cdots k_{s}\\lambda_{s}^{n}\\alpha_{s}$ 。 相似变换、相似矩阵的概念及性质(1) 若$A \\sim B$，则 1) $A^{T} \\sim B^{T},A^{- 1} \\sim B^{- 1},,A^{} \\sim B^{}$ 2) $|A| = |B|,\\sum_{i = 1}^{n}A_ = \\sum_{i =1}^{n}b_,r(A) = r(B)$ 3) $|\\lambda E - A| = |\\lambda E - B|$，对$\\forall\\lambda$成立 矩阵可相似对角化的充分必要条件(1)设$A$为$n$阶方阵，则$A$可对角化$\\Leftrightarrow$对每个$k_{i}$重根特征值$\\lambda_{i}$，有$n-r(\\lambda_{i}E - A) = k_{i}$ (2) 设$A$可对角化，则由$P^{- 1}{AP} = \\Lambda,$有$A = {PΛ}P^{-1}$，从而$A^{n} = P\\Lambda^{n}P^{- 1}$ (3) 重要结论 1) 若$A \\sim B,C \\sim D$，则$\\begin{bmatrix} A &amp; O \\ O &amp; C \\\\end{bmatrix} \\sim \\begin{bmatrix} B &amp; O \\ O &amp; D \\\\end{bmatrix}$. 2) 若$A \\sim B$，则$f(A) \\sim f(B),\\left| f(A) \\right| \\sim \\left| f(B)\\right|$，其中$f(A)$为关于$n$阶方阵$A$的多项式。 3) 若$A$为可对角化矩阵，则其非零特征值的个数(重根重复计算)＝秩($A$) 实对称矩阵的特征值、特征向量及相似对角阵(1)相似矩阵：设$A,B$为两个$n$阶方阵，如果存在一个可逆矩阵$P$，使得$B =P^{- 1}{AP}$成立，则称矩阵$A$与$B$相似，记为$A \\sim B$。 (2)相似矩阵的性质：如果$A \\sim B$则有： 1) $A^{T} \\sim B^{T}$ 2) $A^{- 1} \\sim B^{- 1}$ （若$A$，$B$均可逆） 3) $A^{k} \\sim B^{k}$ （$k$为正整数） 4) $\\left| {λE} - A \\right| = \\left| {λE} - B \\right|$，从而$A,B$有相同的特征值 5) $\\left| A \\right| = \\left| B \\right|$，从而$A,B$同时可逆或者不可逆 6) 秩$\\left( A \\right) =$秩$\\left( B \\right),\\left| {λE} - A \\right| =\\left| {λE} - B \\right|$，$A,B$不一定相似 二次型$\\mathbf{n}$个变量$\\mathbf{x}{\\mathbf{1}}\\mathbf{,}\\mathbf{x}{\\mathbf{2}}\\mathbf{,\\cdots,}\\mathbf{x}_{\\mathbf{n}}$**的二次齐次函数$f(x_{1},x_{2},\\cdots,x_{n}) = \\sum_{i = 1}^{n}{\\sum_{j =1}^{n}{a_x_{i}y_{j}}}$，其中$a_ = a_(i,j =1,2,\\cdots,n)$，称为$n$元二次型，简称二次型. 若令$x = \\ \\begin{bmatrix}x_{1} \\ x_{1} \\ \\vdots \\ x_{n} \\ \\end{bmatrix},A = \\begin{bmatrix} a_{11}&amp; a_{12}&amp; \\cdots &amp; a_{1n} \\ a_{21}&amp; a_{22}&amp; \\cdots &amp; a_{2n} \\ \\cdots &amp;\\cdots &amp;\\cdots &amp;\\cdots \\ a_{n1}&amp; a_{n2} &amp; \\cdots &amp; a_ \\\\end{bmatrix}$,这二次型$f$可改写成矩阵向量形式$f =x^{T}{Ax}$。其中$A$称为二次型矩阵，因为$a_ =a_(i,j =1,2,\\cdots,n)$，所以二次型矩阵均为对称矩阵，且二次型与对称矩阵一一对应，并把矩阵$A$的秩称为二次型的秩。 惯性定理，二次型的标准形和规范形(1) 惯性定理 对于任一二次型，不论选取怎样的合同变换使它化为仅含平方项的标准型，其正负惯性指数与所选变换无关，这就是所谓的惯性定理。 (2) 标准形 二次型$f = \\left( x_{1},x_{2},\\cdots,x_{n} \\right) =x^{T}{Ax}$经过合同变换$x = {Cy}$化为$f = x^{T}{Ax} =y^{T}C^{T}{AC}$ $y = \\sum_{i = 1}^{r}{d_{i}y_{i}^{2}}$称为 $f(r \\leq n)$的标准形。在一般的数域内，二次型的标准形不是唯一的，与所作的合同变换有关，但系数不为零的平方项的个数由$r(A)$唯一确定。 (3) 规范形 任一实二次型$f$都可经过合同变换化为规范形$f = z_{1}^{2} + z_{2}^{2} + \\cdots z_{p}^{2} - z_{p + 1}^{2} - \\cdots -z_{r}^{2}$，其中$r$为$A$的秩，$p$为正惯性指数，$r -p$为负惯性指数，且规范型唯一。 用正交变换和配方法化二次型为标准形，二次型及其矩阵的正定性设$A$正定$\\Rightarrow {kA}(k &gt; 0),A^{T},A^{- 1},A^{*}$正定；$|A| &gt;0$,$A$可逆；$a_ &gt; 0$，且$|A_| &gt; 0$ $A$，$B$正定$\\Rightarrow A +B$正定，但${AB}$，${BA}$不一定正定 $A$正定$\\Leftrightarrow f(x) = x^{T}{Ax} &gt; 0,\\forall x \\neq 0$ $\\Leftrightarrow A$的各阶顺序主子式全大于零 $\\Leftrightarrow A$的所有特征值大于零 $\\Leftrightarrow A$的正惯性指数为$n$ $\\Leftrightarrow$存在可逆阵$P$使$A = P^{T}P$ $\\Leftrightarrow$存在正交矩阵$Q$，使$Q^{T}{AQ} = Q^{- 1}{AQ} =\\begin{pmatrix} \\lambda_{1} &amp; &amp; \\ \\begin{matrix} &amp; \\ &amp; \\ \\end{matrix} &amp;\\ddots &amp; \\ &amp; &amp; \\lambda_{n} \\ \\end{pmatrix},$ 其中$\\lambda_{i} &gt; 0,i = 1,2,\\cdots,n.$正定$\\Rightarrow {kA}(k &gt;0),A^{T},A^{- 1},A^{*}$正定； $|A| &gt; 0,A$可逆；$a_ &gt;0$，且$|A_| &gt; 0$ 。 概率论和数理统计随机事件和概率事件的关系与运算(1) 子事件：$A \\subset B$，若$A$发生，则$B$发生。 (2) 相等事件：$A = B$，即$A \\subset B$，且$B \\subset A$ 。 (3) 和事件：$A\\bigcup B$（或$A + B$），$A$与$B$中至少有一个发生。 (4) 差事件：$A - B$，$A$发生但$B$不发生。 (5) 积事件：$A\\bigcap B$（或${AB}$），$A$与$B$同时发生。 (6) 互斥事件（互不相容）：$A\\bigcap B$=$\\varnothing$。 (7) 互逆事件（对立事件）：$A\\bigcap B=\\varnothing ,A\\bigcup B=\\Omega ,A=\\bar{B},B=\\bar{A}$ 运算律(1) 交换律：$A\\bigcup B=B\\bigcup A,A\\bigcap B=B\\bigcap A$(2) 结合律：$(A\\bigcup B)\\bigcup C=A\\bigcup (B\\bigcup C)$(3) 分配律：$(A\\bigcap B)\\bigcap C=A\\bigcap (B\\bigcap C)$ 德$\\centerdot$摩根律$\\overline{A\\bigcup B}=\\bar{A}\\bigcap \\bar{B}$ $\\overline{A\\bigcap B}=\\bar{A}\\bigcup \\bar{B}$ 完全事件组$A_{1}A_{2}\\cdots A_{n}$两两互斥，且和事件为必然事件，即${A_{i}}\\bigcap {A_{j}}=\\varnothing, i\\ne j ,\\underset{i=1}{\\overset{n}{\\mathop {\\bigcup }}}\\,=\\Omega$ 概率的基本公式(1)条件概率: $P(B|A)=\\frac{P(AB)}{P(A)}$,表示$A$发生的条件下，$B$发生的概率。 (2)全概率公式：$P(A)=\\sum\\limits_{i=1}^{n}{P(A|{B_{i}})P({B_{i}}),{B_{i}}{B_{j}}}=\\varnothing ,i\\ne j,\\underset{i=1}{\\overset{n}{\\mathop{\\bigcup }}}\\,{B_{i}}=\\Omega$ (3) Bayes公式： $P({B_{j}}|A)=\\frac{P(A|{B_{j}})P({B_{j}})}{\\sum\\limits_{i=1}^{n}{P(A|{B_{i}})P({B_{i}})}},j=1,2,\\cdots ,n$注：上述公式中事件${B_{i}}$的个数可为可列个。 (4)乘法公式：$P({A_{1}}{A_{2}})=P({A_{1}})P({A_{2}}|{A_{1}})=P({A_{2}})P({A_{1}}|{A_{2}})$$P({A_{1}}{A_{2}}\\cdots {A_{n}})=P({A_{1}})P({A_{2}}|{A_{1}})P({A_{3}}|{A_{1}}{A_{2}})\\cdots P({A_{n}}|{A_{1}}{A_{2}}\\cdots {A_{n-1}})$ 事件的独立性(1)$A$与$B$相互独立$\\Leftrightarrow P(AB)=P(A)P(B)$ (2)$A$，$B$，$C$两两独立$\\Leftrightarrow P(AB)=P(A)P(B)$;$P(BC)=P(B)P(C)$ ;$P(AC)=P(A)P(C)$; (3)$A$，$B$，$C$相互独立$\\Leftrightarrow P(AB)=P(A)P(B)$; $P(BC)=P(B)P(C)$ ;$P(AC)=P(A)P(C)$ ; $P(ABC)=P(A)P(B)P(C)$ 独立重复试验将某试验独立重复$n$次，若每次实验中事件A发生的概率为$p$，则$n$次试验中$A$发生$k$次的概率为：$P(X=k)=C_{n}^{k}{p^{k}}{(1-p)^{n-k}}$ 重要公式与结论$(1)P(\\bar{A})=1-P(A)$ $(2)P(A\\bigcup B)=P(A)+P(B)-P(AB)$ $P(A\\bigcup B\\bigcup C)=P(A)+P(B)+P(C)-P(AB)-P(BC)-P(AC)+P(ABC)$ $(3)P(A-B)=P(A)-P(AB)$ $(4)P(A\\bar{B})=P(A)-P(AB),P(A)=P(AB)+P(A\\bar{B}),$ $P(A\\bigcup B)=P(A)+P(\\bar{A}B)=P(AB)+P(A\\bar{B})+P(\\bar{A}B)$ (5)条件概率$P(\\centerdot |B)$满足概率的所有性质，例如：. $P({\\bar{A}{1}}|B)=1-P({A{1}}|B)$$P({A_{1}}\\bigcup {A_{2}}|B)=P({A_{1}}|B)+P({A_{2}}|B)-P({A_{1}}{A_{2}}|B)$$P({A_{1}}{A_{2}}|B)=P({A_{1}}|B)P({A_{2}}|{A_{1}}B)$ (6)若${A_{1}},{A_{2}},\\cdots ,{A_{n}}$相互独立，则$P(\\bigcap\\limits_{i=1}^{n}A_{i})=\\prod\\limits_{i=1}^{n}{P({A_{i}})},$ $P(\\bigcup\\limits_{i=1}^{n}A_{i})=\\prod\\limits_{i=1}^{n}{(1-P(A_{i}))}$ (7)互斥、互逆与独立性之间的关系：$A$与$B$互逆$\\Rightarrow$ $A$与$B$互斥，但反之不成立，$A$与$B$互斥（或互逆）且均非零概率事件$\\Rightarrow$$A$与$B$不独立. (8)若${A_{1}},{A_{2}},\\cdots ,{A_{m}},{B_{1}},{B_{2}},\\cdots ,{B_{n}}$相互独立，则$f({A_{1}},{A_{2}},\\cdots ,{A_{m}})$与$g({B_{1}},{B_{2}},\\cdots ,{B_{n}})$也相互独立，其中$f(\\centerdot ),g(\\centerdot )$分别表示对相应事件做任意事件运算后所得的事件，另外，概率为1（或0）的事件与任何事件相互独立. 随机变量及其概率分布随机变量及概率分布取值带有随机性的变量，严格地说是定义在样本空间上，取值于实数的函数称为随机变量，概率分布通常指分布函数或分布律 分布函数的概念与性质定义： $F(x) = P(X \\leq x), - \\infty &lt; x &lt; + \\infty$ 性质：(1)$0 \\leq F(x) \\leq 1$ (2) $F(x)$单调不减 (3) 右连续$F(x + 0) = F(x)$ (4) $F( - \\infty) = 0,F( + \\infty) = 1$ 离散型随机变量的概率分布$P(X = x_{i}) = p_{i},i = 1,2,\\cdots,n,\\cdots\\quad\\quad p_{i} \\geq 0,\\sum_{i =1}^{\\infty}p_{i} = 1$ 连续型随机变量的概率密度概率密度$f(x)$;非负可积，且: (1)$f(x) \\geq 0,$ (2)$\\int_{- \\infty}^{+\\infty}{f(x){dx} = 1}$ (3)$x$为$f(x)$的连续点，则: $f(x) = F’(x)$分布函数$F(x) = \\int_{- \\infty}^{x}{f(t){dt}}$ 常见分布(1) 0-1分布:$P(X = k) = p^{k}(1 - p)^{1 - k},k = 0,1$ (2) 二项分布:$B(n,p)$： $P(X = k) = C_{n}^{k}p^{k}(1 - p)^{n - k},k =0,1,\\cdots,n$ (3) Poisson分布:$p(\\lambda)$： $P(X = k) = \\frac{\\lambda^{k}}{k!}e^{-\\lambda},\\lambda &gt; 0,k = 0,1,2\\cdots$ (4) 均匀分布$U(a,b)$：$f(x) = { \\begin{matrix} &amp; \\frac{1}{b - a},a &lt; x&lt; b \\ &amp; 0, \\ \\end{matrix}$ (5) 正态分布:$N(\\mu,\\sigma^{2}):$ $\\varphi(x) =\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{- \\frac{(x - \\mu)^{2}}{2\\sigma^{2}}},\\sigma &gt; 0,\\infty &lt; x &lt; + \\infty$ (6)指数分布:$E(\\lambda):f(x) ={ \\begin{matrix} &amp; \\lambda e^{-{λx}},x &gt; 0,\\lambda &gt; 0 \\ &amp; 0, \\ \\end{matrix}$ (7)几何分布:$G(p):P(X = k) = {(1 - p)}^{k - 1}p,0 &lt; p &lt; 1,k = 1,2,\\cdots.$ (8)超几何分布: $H(N,M,n):P(X = k) = \\frac{C_{M}^{k}C_{N - M}^{n -k}}{C_{N}^{n}},k =0,1,\\cdots,min(n,M)$ 随机变量函数的概率分布(1)离散型：$P(X = x_{1}) = p_{i},Y = g(X)$ 则: $P(Y = y_{j}) = \\sum_{g(x_{i}) = y_{i}}^{}{P(X = x_{i})}$ (2)连续型：$X\\tilde{\\ }f_{X}(x),Y = g(x)$ 则:$F_{y}(y) = P(Y \\leq y) = P(g(X) \\leq y) = \\int_{g(x) \\leq y}^{}{f_{x}(x)dx}$， $f_{Y}(y) = F’_{Y}(y)$ 重要公式与结论(1) $X\\sim N(0,1) \\Rightarrow \\varphi(0) = \\frac{1}{\\sqrt{2\\pi}},\\Phi(0) =\\frac{1}{2},$ $\\Phi( - a) = P(X \\leq - a) = 1 - \\Phi(a)$ (2) $X\\sim N\\left( \\mu,\\sigma^{2} \\right) \\Rightarrow \\frac{X -\\mu}{\\sigma}\\sim N\\left( 0,1 \\right),P(X \\leq a) = \\Phi(\\frac{a -\\mu}{\\sigma})$ (3) $X\\sim E(\\lambda) \\Rightarrow P(X &gt; s + t|X &gt; s) = P(X &gt; t)$ (4) $X\\sim G(p) \\Rightarrow P(X = m + k|X &gt; m) = P(X = k)$ (5) 离散型随机变量的分布函数为阶梯间断函数；连续型随机变量的分布函数为连续函数，但不一定为处处可导函数。 (6) 存在既非离散也非连续型随机变量。 多维随机变量及其分布二维随机变量及其联合分布由两个随机变量构成的随机向量$(X,Y)$， 联合分布为$F(x,y) = P(X \\leq x,Y \\leq y)$ 二维离散型随机变量的分布(1) 联合概率分布律 $P{ X = x_{i},Y = y_{j}} = p_;i,j =1,2,\\cdots$ (2) 边缘分布律 $p_{i \\cdot} = \\sum_{j = 1}^{\\infty}p_,i =1,2,\\cdots$ $p_{\\cdot j} = \\sum_{i}^{\\infty}p_,j = 1,2,\\cdots$ (3) 条件分布律 $P{ X = x_{i}|Y = y_{j}} = \\frac{p_}{p_{\\cdot j}}$$P{ Y = y_{j}|X = x_{i}} = \\frac{p_}{p_{i \\cdot}}$ 二维连续性随机变量的密度(1) 联合概率密度$f(x,y):$ 1) $f(x,y) \\geq 0$ 2) $\\int_{- \\infty}^{+ \\infty}{\\int_{- \\infty}^{+ \\infty}{f(x,y)dxdy}} = 1$ (2) 分布函数：$F(x,y) = \\int_{- \\infty}^{x}{\\int_{- \\infty}^{y}{f(u,v)dudv}}$ (3) 边缘概率密度： $f_{X}\\left( x \\right) = \\int_{- \\infty}^{+ \\infty}{f\\left( x,y \\right){dy}}$ $f_{Y}(y) = \\int_{- \\infty}^{+ \\infty}{f(x,y)dx}$ (4) 条件概率密度：$f_{X|Y}\\left( x \\middle| y \\right) = \\frac{f\\left( x,y \\right)}{f_{Y}\\left( y \\right)}$ $f_{Y|X}(y|x) = \\frac{f(x,y)}{f_{X}(x)}$ 常见二维随机变量的联合分布(1) 二维均匀分布：$(x,y) \\sim U(D)$ ,$f(x,y) = \\begin{cases} \\frac{1}{S(D)},(x,y) \\in D \\ 0,其他 \\end{cases}$ (2) 二维正态分布：$(X,Y)\\sim N(\\mu_{1},\\mu_{2},\\sigma_{1}^{2},\\sigma_{2}^{2},\\rho)$,$(X,Y)\\sim N(\\mu_{1},\\mu_{2},\\sigma_{1}^{2},\\sigma_{2}^{2},\\rho)$ $f(x,y) = \\frac{1}{2\\pi\\sigma_{1}\\sigma_{2}\\sqrt{1 - \\rho^{2}}}.\\exp\\left{ \\frac{- 1}{2(1 - \\rho^{2})}\\lbrack\\frac{(x - \\mu_{1})^{2}}{\\sigma_{1}^{2}} - 2\\rho\\frac{(x - \\mu_{1})(y - \\mu_{2})}{\\sigma_{1}\\sigma_{2}} + \\frac{(y - \\mu_{2})^{2}}{\\sigma_{2}^{2}}\\rbrack \\right}$ 随机变量的独立性和相关性$X$和$Y$的相互独立:$\\Leftrightarrow F\\left( x,y \\right) = F_{X}\\left( x \\right)F_{Y}\\left( y \\right)$: $\\Leftrightarrow p_ = p_{i \\cdot} \\cdot p_{\\cdot j}$（离散型）$\\Leftrightarrow f\\left( x,y \\right) = f_{X}\\left( x \\right)f_{Y}\\left( y \\right)$（连续型） $X$和$Y$的相关性： 相关系数$\\rho_ = 0$时，称$X$和$Y$不相关，否则称$X$和$Y$相关 两个随机变量简单函数的概率分布离散型： $P\\left( X = x_{i},Y = y_{i} \\right) = p_,Z = g\\left( X,Y \\right)$ 则： $P(Z = z_{k}) = P\\left{ g\\left( X,Y \\right) = z_{k} \\right} = \\sum_{g\\left( x_{i},y_{i} \\right) = z_{k}}^{}{P\\left( X = x_{i},Y = y_{j} \\right)}$ 连续型： $\\left( X,Y \\right) \\sim f\\left( x,y \\right),Z = g\\left( X,Y \\right)$则： $F_{z}\\left( z \\right) = P\\left{ g\\left( X,Y \\right) \\leq z \\right} = \\iint_{g(x,y) \\leq z}^{}{f(x,y)dxdy}$，$f_{z}(z) = F’_{z}(z)$ 重要公式与结论(1) 边缘密度公式： $f_{X}(x) = \\int_{- \\infty}^{+ \\infty}{f(x,y)dy,}$$f_{Y}(y) = \\int_{- \\infty}^{+ \\infty}{f(x,y)dx}$ (2) $P\\left{ \\left( X,Y \\right) \\in D \\right} = \\iint_{D}^{}{f\\left( x,y \\right){dxdy}}$ (3) 若$(X,Y)$服从二维正态分布$N(\\mu_{1},\\mu_{2},\\sigma_{1}^{2},\\sigma_{2}^{2},\\rho)$则有： 1) $X\\sim N\\left( \\mu_{1},\\sigma_{1}^{2} \\right),Y\\sim N(\\mu_{2},\\sigma_{2}^{2}).$ 2) $X$与$Y$相互独立$\\Leftrightarrow \\rho = 0$，即$X$与$Y$不相关。 3) $C_{1}X + C_{2}Y\\sim N(C_{1}\\mu_{1} + C_{2}\\mu_{2},C_{1}^{2}\\sigma_{1}^{2} + C_{2}^{2}\\sigma_{2}^{2} + 2C_{1}C_{2}\\sigma_{1}\\sigma_{2}\\rho)$ 4) ${\\ X}$关于$Y=y$的条件分布为： $N(\\mu_{1} + \\rho\\frac{\\sigma_{1}}{\\sigma_{2}}(y - \\mu_{2}),\\sigma_{1}^{2}(1 - \\rho^{2}))$ 5) $Y$关于$X = x$的条件分布为： $N(\\mu_{2} + \\rho\\frac{\\sigma_{2}}{\\sigma_{1}}(x - \\mu_{1}),\\sigma_{2}^{2}(1 - \\rho^{2}))$ (4) 若$X$与$Y$独立，且分别服从$N(\\mu_{1},\\sigma_{1}^{2}),N(\\mu_{1},\\sigma_{2}^{2}),$则：$\\left( X,Y \\right)\\sim N(\\mu_{1},\\mu_{2},\\sigma_{1}^{2},\\sigma_{2}^{2},0),$ $C_{1}X + C_{2}Y\\tilde{\\ }N(C_{1}\\mu_{1} + C_{2}\\mu_{2},C_{1}^{2}\\sigma_{1}^{2} C_{2}^{2}\\sigma_{2}^{2}).$ (5) 若$X$与$Y$相互独立，$f\\left( x \\right)$和$g\\left( x \\right)$为连续函数， 则$f\\left( X \\right)$和$g(Y)$也相互独立。 随机变量的数字特征数学期望离散型：$P\\left{ X = x_{i} \\right} = p_{i}$$E(X) = \\sum_{i}^{}{x_{i}p_{i}}$ 连续型： $X\\sim f(x),E(X) = \\int_{- \\infty}^{+ \\infty}{xf(x)dx}$ 性质： (1) $E(C) = C,E\\lbrack E(X)\\rbrack = E(X)$ (2) $E(C_{1}X + C_{2}Y) = C_{1}E(X) + C_{2}E(Y)$ (3) 若$X$和$Y$独立，则$E(XY) = E(X)E(Y)$ (4)$\\left\\lbrack E(XY) \\right\\rbrack^{2} \\leq E(X^{2})E(Y^{2})$ 方差$D(X) = E\\left\\lbrack X - E(X) \\right\\rbrack^{2} = E(X^{2}) - \\left\\lbrack E(X) \\right\\rbrack^{2}$ 标准差$\\sqrt{D(X)}$， 离散型$D(X) = \\sum_{i}^{}{\\left\\lbrack x_{i} - E(X) \\right\\rbrack^{2}p_{i}}$ 连续型$D(X) = {\\int_{- \\infty}^{+ \\infty}\\left\\lbrack x - E(X) \\right\\rbrack}^{2}f(x)dx$ 性质： (1)$\\ D(C) = 0,D\\lbrack E(X)\\rbrack = 0,D\\lbrack D(X)\\rbrack = 0$ (2) $X$与$Y$相互独立，则$D(X \\pm Y) = D(X) + D(Y)$ (3)$\\ D\\left( C_{1}X + C_{2} \\right) = C_{1}^{2}D\\left( X \\right)$ (4) 一般有 $D(X \\pm Y) = D(X) + D(Y) \\pm 2Cov(X,Y) = D(X) + D(Y) \\pm 2\\rho\\sqrt{D(X)}\\sqrt{D(Y)}$ (5)$\\ D\\left( X \\right) &lt; E\\left( X - C \\right)^{2},C \\neq E\\left( X \\right)$ (6)$\\ D(X) = 0 \\Leftrightarrow P\\left{ X = C \\right} = 1$ 随机变量函数的数学期望(1) 对于函数$Y = g(x)$ $X$为离散型：$P{ X = x_{i}} = p_{i},E(Y) = \\sum_{i}^{}{g(x_{i})p_{i}}$； $X$为连续型：$X\\sim f(x),E(Y) = \\int_{- \\infty}^{+ \\infty}{g(x)f(x)dx}$ (2) $Z = g(X,Y)$;$\\left( X,Y \\right)\\sim P{ X = x_{i},Y = y_{j}} = p_$; $E(Z) = \\sum_{i}^{}{\\sum_{j}^{}{g(x_{i},y_{j})p_}}$ $\\left( X,Y \\right)\\sim f(x,y)$;$E(Z) = \\int_{- \\infty}^{+ \\infty}{\\int_{- \\infty}^{+ \\infty}{g(x,y)f(x,y)dxdy}}$ 协方差$Cov(X,Y) = E\\left\\lbrack (X - E(X)(Y - E(Y)) \\right\\rbrack$ 相关系数 $\\rho_ = \\frac{Cov(X,Y)}{\\sqrt{D(X)}\\sqrt{D(Y)}}$,$k$阶原点矩 $E(X^{k})$;$k$阶中心矩 $E\\left{ {\\lbrack X - E(X)\\rbrack}^{k} \\right}$ 性质： (1)$\\ Cov(X,Y) = Cov(Y,X)$ (2)$\\ Cov(aX,bY) = abCov(Y,X)$ (3)$\\ Cov(X_{1} + X_{2},Y) = Cov(X_{1},Y) + Cov(X_{2},Y)$ (4)$\\ \\left| \\rho\\left( X,Y \\right) \\right| \\leq 1$ (5) $\\ \\rho\\left( X,Y \\right) = 1 \\Leftrightarrow P\\left( Y = aX + b \\right) = 1$ ，其中$a &gt; 0$ $\\rho\\left( X,Y \\right) = - 1 \\Leftrightarrow P\\left( Y = aX + b \\right) = 1$，其中$a &lt; 0$ 重要公式与结论(1)$\\ D(X) = E(X^{2}) - E^{2}(X)$ (2)$\\ Cov(X,Y) = E(XY) - E(X)E(Y)$ (3) $\\left| \\rho\\left( X,Y \\right) \\right| \\leq 1,$且 $\\rho\\left( X,Y \\right) = 1 \\Leftrightarrow P\\left( Y = aX + b \\right) = 1$，其中$a &gt; 0$ $\\rho\\left( X,Y \\right) = - 1 \\Leftrightarrow P\\left( Y = aX + b \\right) = 1$，其中$a &lt; 0$ (4) 下面5个条件互为充要条件： $\\rho(X,Y) = 0$ $\\Leftrightarrow Cov(X,Y) = 0$ $\\Leftrightarrow E(X,Y) = E(X)E(Y)$ $\\Leftrightarrow D(X + Y) = D(X) + D(Y)$ $\\Leftrightarrow D(X - Y) = D(X) + D(Y)$ 注：$X$与$Y$独立为上述5个条件中任何一个成立的充分条件，但非必要条件。 数理统计的基本概念基本概念总体：研究对象的全体，它是一个随机变量，用$X$表示。 个体：组成总体的每个基本元素。 简单随机样本：来自总体$X$的$n$个相互独立且与总体同分布的随机变量$X_{1},X_{2}\\cdots,X_{n}$，称为容量为$n$的简单随机样本，简称样本。 统计量：设$X_{1},X_{2}\\cdots,X_{n},$是来自总体$X$的一个样本，$g(X_{1},X_{2}\\cdots,X_{n})$）是样本的连续函数，且$g()$中不含任何未知参数，则称$g(X_{1},X_{2}\\cdots,X_{n})$为统计量。 样本均值：$\\overline{X} = \\frac{1}{n}\\sum_{i = 1}^{n}X_{i}$ 样本方差：$S^{2} = \\frac{1}{n - 1}\\sum_{i = 1}^{n}{(X_{i} - \\overline{X})}^{2}$ 样本矩：样本$k$阶原点矩：$A_{k} = \\frac{1}{n}\\sum_{i = 1}^{n}X_{i}^{k},k = 1,2,\\cdots$ 样本$k$阶中心矩：$B_{k} = \\frac{1}{n}\\sum_{i = 1}^{n}{(X_{i} - \\overline{X})}^{k},k = 1,2,\\cdots$ 分布$\\chi^{2}$分布：$\\chi^{2} = X_{1}^{2} + X_{2}^{2} + \\cdots + X_{n}^{2}\\sim\\chi^{2}(n)$，其中$X_{1},X_{2}\\cdots,X_{n},$相互独立，且同服从$N(0,1)$ $t$分布：$T = \\frac{X}{\\sqrt{Y/n}}\\sim t(n)$ ，其中$X\\sim N\\left( 0,1 \\right),Y\\sim\\chi^{2}(n),$且$X$，$Y$ 相互独立。 $F$分布：$F = \\frac{X/n_{1}}{Y/n_{2}}\\sim F(n_{1},n_{2})$，其中$X\\sim\\chi^{2}\\left( n_{1} \\right),Y\\sim\\chi^{2}(n_{2}),$且$X$，$Y$相互独立。 分位数：若$P(X \\leq x_{\\alpha}) = \\alpha,$则称$x_{\\alpha}$为$X$的$\\alpha$分位数 正态总体的常用样本分布(1) 设$X_{1},X_{2}\\cdots,X_{n}$为来自正态总体$N(\\mu,\\sigma^{2})$的样本， $\\overline{X} = \\frac{1}{n}\\sum_{i = 1}^{n}X_{i},S^{2} = \\frac{1}{n - 1}\\sum_{i = 1}^{n}{(X_{i} - \\overline{X})^{2},}$则： 1) $\\overline{X}\\sim N\\left( \\mu,\\frac{\\sigma^{2}}{n} \\right){\\ \\ }$或者$\\frac{\\overline{X} - \\mu}{\\frac{\\sigma}{\\sqrt{n}}}\\sim N(0,1)$ 2) $\\frac{(n - 1)S^{2}}{\\sigma^{2}} = \\frac{1}{\\sigma^{2}}\\sum_{i = 1}^{n}{(X_{i} - \\overline{X})^{2}\\sim\\chi^{2}(n - 1)}$ 3) $\\frac{1}{\\sigma^{2}}\\sum_{i = 1}^{n}{(X_{i} - \\mu)^{2}\\sim\\chi^{2}(n)}$ 4)${\\ \\ }\\frac{\\overline{X} - \\mu}{S/\\sqrt{n}}\\sim t(n - 1)$ 重要公式与结论(1) 对于$\\chi^{2}\\sim\\chi^{2}(n)$，有$E(\\chi^{2}(n)) = n,D(\\chi^{2}(n)) = 2n;$ (2) 对于$T\\sim t(n)$，有$E(T) = 0,D(T) = \\frac{n}{n - 2}(n &gt; 2)$； (3) 对于$F\\tilde{\\ }F(m,n)$，有 $\\frac{1}{F}\\sim F(n,m),F_{a/2}(m,n) = \\frac{1}{F_{1 - a/2}(n,m)};$ (4) 对于任意总体$X$，有 $E(\\overline{X}) = E(X),E(S^{2}) = D(X),D(\\overline{X}) = \\frac{D(X)}{n}$","raw":null,"content":null,"categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://hubojing.github.io/categories/人工智能/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://hubojing.github.io/tags/深度学习/"},{"name":"数学","slug":"数学","permalink":"https://hubojing.github.io/tags/数学/"}]},{"title":"Hulu AI Class Quiz","slug":"Hulu AI Class Quiz","date":"2020-07-23T08:00:29.000Z","updated":"2020-09-04T03:51:41.754Z","comments":true,"path":"2020/07/23/Hulu AI Class Quiz/","link":"","permalink":"https://hubojing.github.io/2020/07/23/Hulu AI Class Quiz/","excerpt":"　　Quiz for traditional recommendation models. ","text":"Quiz for traditional recommendation models. Quiz1 从基于用户的协同过滤和基于物品的协同过滤的原理思考，下列场景中使用哪种协同过滤算法更加合适？为什么？(1)新闻资讯推荐(2)电商网站推荐 参考答案（1）在新闻推荐的场景中，我们更推荐使用基于用户的协同过滤。 主要原因在于： 1.新闻推荐通常具有一定的社交属性，通过User-based CF，用户能够通过朋友的浏览行为更新自己的推荐列表。 2.新闻推荐的实时性和热点性往往比较重要，使用User-based CF能够快速发现热点，跟踪热点趋势。 （2）在电商推荐的场景中，我们更推荐使用基于物品的协同过滤，主要原因在于: 1.用户在短时间内的兴趣点往往比较稳定，利用Item-CF推荐相似商品比较符合用户的动机，也方便用户进行物品之间的比较。 2.电商网站的物品列表相对来讲比较稳定，通过积累大量的历史数据更容易准确地反映物品之间的相似性。 3.电商网站中通常用户数量远远大于商品的数量，进行Item-based CF的计算量更小。 为什么逻辑回归模型在工业界受到的了广泛应用？LR相对于其他的模型，尤其是GBOT模型，突出的优点是什么？ 参考答案 逻辑回归模型形式比较简单，可解释性强，模型训练的速度快，适合线上学习。相对于GBDT模型，其突出的优点在于可以支持并行化训练以及线上学习。 点评: 设计这个问题的目的是复习课程中所讲的逻辑回归算法，强化逻辑回归可以用于线上学习的概念。所谓“天下武功，无坚不破，唯快不破”，希望大家能够意识到模型实时性的重要性。 为什么说提升树模型(GBOT)难以并行化？从Boosting方法的原理上给出简单的解释。 参考答案 Boosting方法的本质上是构建一系列的弱学习器去不断逼近目标，每个弱学习器的训练目标是修正之前学习器的错误，需要依赖于前面学习器的结果，是一个串行训练过程。 点评： 设计这个问题的目的是复习课程中所讲的提升算法原理，并加深大家对于Boosting串行训练的理解与思考。 Quiz2 在一个机器学习项目中，特征工程是否对模型效果起到决定性作用？A.是 B.否 参考答案 B数据决定算法的上限，特征工程帮助算法逼近上限。 2.一个算法工程师面对一个分类问题，打算将花10天时间来清洗数据，花10天时间来做特征工程，最后花1天的时间简单的训练出一个逻辑回归模型，请问他的时间安排是否合理？A.合理B.不合理，他应该花10天时间来调优模型 参考答案 A 不必纠结于具体的天数，本题着重强调数据的重要性，在实践中可以发现，同样的数据，交替不同的模型(例如lr或者gbdt) , 在效果上提升和下降有限。相反，数据和特征的不同对预测的结果有巨大的意义。 深度学习模型具备了自动特征工程的能力，算法工程师只需将数据输入模型，模型会自动寻找最优特征工程，请问是否还有必要做特征工程？请给出理由。 参考答案 有必要: 1)更好的特征工程可以减弱噪声的影响，提高数据表达能力，提升效果; 2) 如果特征工程足够好，可使用更简单的模型，快速训练快速部署，这对实际生产具有重要的意义 3)特征工程往往具有很强的业务意义，可以提高模型解释性。 芒果台最新综艺《乘风破浪的姐姐》吸粉无数，作为一名学过hulu AI Class 的优秀学员，请你思考一个利用人工智能来更好的帮助节目的方案。 参考答案 本题为开放问题，强调算法工程师需要有将业务需求抽象成算法问题的能力。下面是示例答案。 1) 以不同的姐姐分cluster, 筛选用户特征 2)对微博的相关的话题做文本挖掘，舆情分析，以便更好提前制作爆点。 3)第一个点是本节目的修音有点过于失真了，可以引入一个基于GAN的声音修正技术提高现场的真实感；第二在广告投放上，可以利用look-alike等技术对潜在的节目目标人群进行筛选，提高广告投放的效率，减少对用户的打扰，提升用户体验。 Quiz31.对于-系列电影，如果有以下几种类型的数据，想要为每个电影生成嵌入(Embdding)表示，你会选用何种算法/模型，为什么？(1)每个电影的标题、描述文本、风格类型(提示:如何建模纯文本信息？) 参考答案 这道题涉及的知识点是如何对文本类信息进行嵌入表示。我们拥有三个数据源:标题、描述文本和风格类型，其中前两个数据源是纯文本，最后一个数据源可以理解为纯文本，也可以解读为类别信息，因为电影的风格类型是共享且有限的。 对于建模标题和描述文本这类纯文本信息，最简单的方法是使用Word2Vec或者其它预训练的词向量模型对文本中每个词查到一个嵌入表示（词向量），再通过一些聚合方法聚合得到标题和描述文本的整体嵌入表示。最简单且容易想到的聚合方法就是把句子中所有单词的词向量计算其平均向量作为句子的嵌入表示，更复杂的聚合方法也可考虑如Word mover embedding等等。在得到电影的标题/描述文本的嵌入表示之后，我们就可以选择加权或者拼接加PCA降维的方式得到最后的电影的嵌入表示。 相对于以上通过词向量聚合得到句子嵌入表示的方法，我们也可以选择利用文本序列建模方法端到端地生成标题/描述文本的句子表示，进而得到电影的嵌入表示。此类方法有本课中提到的BERT，也包含Seq2Seq等经典方法。值得一提的是，这类方法为句子生成表示时往往需要一些标签信息如句子和词的类别（当然BERT这类模型我们可以使用一一些无监督的伪任务），这时我们就可以利用第三个数据源:电影的风格类型，来作为训练句子嵌入表示的标签。使用这类方法，我们既可以得到电影的标题和描述文本的单独的表示，也可以将它们串联成一一个句子得到一个整体表示，最后就可以使用这个表示作为电影的嵌入表示啦。 (2)电影和电影间的相关度矩阵，大小为M * M, M为电影的数目，矩阵值为-1.0到1.0间的浮点数 参考答案 这道题的数据源是电影间的相关度矩阵，不难理解矩阵分解是最直观的方法:我们为每个电影初始化一一个嵌入表示，然后进一步学习和调整这些表示，使不同电影间嵌入表示的相关度(如余弦相关度)能和给定的相关度矩阵保持一致。 (3)用户一周内的观影历史，一共有N个用户， 每个用户的观影历史为一长度不定的向量，向量值为0到M-1范围内的整数，表示电影的ID。 参考答案 首先，这道题的数据源是序列信息，每个用户的观影序列可以理解为一个一个的句子，句子中的单词(Word)就是电影，因此首先想到的方法应该是使用Word2Vec直接学习每个电影的嵌入表示。另一方面，既然有用户的观影序列，我们就可以进一步统计以上信息得到用户-电影的交互矩阵，这样就可以参照(2)中的方法就行矩阵分解得到电影的嵌入表示。 点评: 这道题的目的是考察大家对不同的嵌入表示生成方法对数据的要求的理解。在算法研发过程中，除了目标指标，影响算法选型的另外一个重要因素往往是我们有什么类型、多大体量以及多高质量的数据，了解这些算法的适用条件是在工作中正确应用它们的重要前提。 基于深度神经网络的排序模型相对于传统的逻辑回归模型(LR)有什么优劣，试从模型准确度、推断效率和工程代价进行分析。 参考答案 模型准确度上，深度神经网络由于模型复杂、自由度大，从而拥有更强的理论建模能力，其准确度往往优于逻辑回归。但是由于用户的个体差异性，其准确度领先幅度并不特别显著，在近年的学术论文上看，目标数据集上，基于深度神经网络的排序模型在离线AUC这个指标上领先逻辑回归通常不超过1%-2%。 推断效率上，深度神经网络明显劣于逻辑回归模型。深度神经网络的理论计算量巨大，比逻辑回归高几个量级，且网络内部各层计算量均一性差，因此单次推断的并行效率也劣于逻辑回归，最终体现在模型推断时延较高且对计算资源需求较大。 工程代价上，深度神经网络更大的计算复杂度会在多个环节带来问题，如如何及时地完成模型的离线训练和高效地进行在线推断等。这对推荐系统框架在部署、任务和资源调度、运行效率优化等多个方面都会带来额外复杂度。一个例子是，有的深度神经网络模型由于计算复杂度大，无法直接在线部署，而需要将部分计算离线/近线(Nearline)化以减轻线上的计算压力，以空间换时间，同时还需付出更多额外的努力对在线推断部分进行效率优化，这就是典型的模型复杂度升高对工程框架的挑战。 点评： 这道题的目的是考察大家对深度神经网络的优劣的整体认识，在工程实践中，模型准确度只是决定选型的部分因素，计算量和实现框架的约束，以及复杂度的增加和准确度提升间的取舍也是非常重要的。 在推荐模型中，为什么有的连续的特征，如年龄，要按范围被离散化(把用户年龄分成互不交叉的几组)？这样做的好处是什么？ 参考答案 简单而言，是为了平滑特征。用户之间存在个体差异，像年龄值这样的涉及用户属性的连续特征有时会过于“精确”， 从而不利于提升模型的泛化能力。 具体来说，首先在推荐的场景下，年龄一定是影响用户兴趣的重要因素，但是这种影响通常是来自于“年龄段”而非具体的“年龄值”。在“年轻人比老年人更喜欢看恐怖片”的假设下，“18-26岁的用户比大于56岁的用户更喜欢看恐怖片”往往比“X岁的用户A比(X+1)岁的用户B更喜欢看恐怖片”这样的推论更加准确和鲁棒。 更进一步而言，年龄值和兴趣之间的关联性存在个体差异，这种差异远比年龄段和兴趣的关联的个体差异大的多。如用户A可能在18-26岁间爱看恐怖片，但是用户B可能在30岁才发展出看恐怖片的兴趣。这种关联的强个体差异意味着模型的学习没有统一且有效的ground truth，从而导致训练过程的震荡和推断能力的退化。 点评： 这道题的目的是考察对推荐模型输入特征的一个细节理解，也是检验同学们是否有仔细听课。模型的准确度不仅仅取决于模型结构数据，输入特征的属性和表示方式也是非常重要的。","raw":null,"content":null,"categories":[{"name":"推荐系统","slug":"推荐系统","permalink":"https://hubojing.github.io/categories/推荐系统/"}],"tags":[{"name":"推荐算法","slug":"推荐算法","permalink":"https://hubojing.github.io/tags/推荐算法/"},{"name":"Hulu","slug":"Hulu","permalink":"https://hubojing.github.io/tags/Hulu/"}]},{"title":"【Paper】Using Collaborative Filtering to Weave an Information Tapestry","slug":"【Paper】Using Collaborative Filtering to Weave an Information Tapestry","date":"2020-07-15T08:44:25.000Z","updated":"2020-11-15T09:35:26.000Z","comments":true,"path":"2020/07/15/【Paper】Using Collaborative Filtering to Weave an Information Tapestry/","link":"","permalink":"https://hubojing.github.io/2020/07/15/【Paper】Using Collaborative Filtering to Weave an Information Tapestry/","excerpt":"　　“协同过滤”词汇来源。 ","text":"“协同过滤”词汇来源。 论文情况 COMMUN ACM, 1992. David Goldberg, David Nichols, Brian M.Oki, and Douglas Terry 10页 题目直译：使用协同过滤去构造一个信息tapestry 截至2020年11月15日，该论文在谷歌学术上被引用次数为5239次。 论文内容 文章提出了协同过滤（Collaborative filtering）这个词，最早是用于邮件系统Tapestry。 文章对协同过滤的定义是：Collaborative filtering simply means that people collaborate to help one another perform filtering by recording their reactions to documents they read. 协同过滤的亮点在于，它不仅仅是一个过滤邮件的机制，还是过去发送邮件的存储库。Tapestry将对这个存储库的临时查询与对传入数据的过滤统一起来。文章提到不仅可以处理邮件，也可以处理类似流数据，比如新闻。 不过该文重点还是在邮件系统本身上，用户可以对邮件进行注解，这些注解可以用来进行协同过滤。本文设计了两种类型的阅读器。一种eager readers可以获取全部文件，另一种casual readers会进行注解，并且阅读基于此的文件。文章用了大量篇幅介绍了邮件系统本身的各个部件和查询语言（TQL），和推荐系统相关的不太多，因此本文属于浏览，未细致阅读。但毕竟是协同过滤鼻祖，所以记录一下。","raw":null,"content":null,"categories":[{"name":"论文","slug":"论文","permalink":"https://hubojing.github.io/categories/论文/"}],"tags":[{"name":"推荐算法","slug":"推荐算法","permalink":"https://hubojing.github.io/tags/推荐算法/"},{"name":"CF","slug":"CF","permalink":"https://hubojing.github.io/tags/CF/"}]},{"title":"新的迷茫","slug":"新的迷茫","date":"2020-06-30T00:30:28.000Z","updated":"2020-06-30T09:16:26.000Z","comments":true,"path":"2020/06/30/新的迷茫/","link":"","permalink":"https://hubojing.github.io/2020/06/30/新的迷茫/","excerpt":"　　不算总结的年中总结。 ","text":"不算总结的年中总结。 昨晚突然发现知乎关注的问题已经高达1800+了，决定清理一下。 整理的过程正好回顾了我这几年来曾经关注过的领域： 云计算、大数据、数据挖掘 计算机视觉、图像处理、图像识别-OpenCV 三维重建、计算机图形学、3D-WebGL 人工智能、机器学习、深度学习 边缘计算 Web开发 后端开发、服务器端开发 游戏开发 音视频解码 Go语言 Python系列-爬虫、Django Java编程 网络编程 C++编程 安卓开发 可以看出来，我见一个爱一个(不是)，应该说我对计算机领域爱的深沉！这些年写的博文涉猎的领域也很多，但同时暴露了问题，就是技术栈乱点，深度不够。 这半年由于疫情原因，从寒假一直宅家至今，有一些成长的感悟（此处不表）。 今年致自己的话语中心词是自律，正好在家科研着实是需要的。 和去年刚接触时的新奇、兴奋不同，现在科研带给我的更多的是沉浸，在阅读论文时的静心、复现实验的耐心，思考idea的创新等等的考验。 回看年初立的Flag……截至目前完成度并不是很好。 嗯，Flag这种东西还是在心里列比较好。（毕竟打脸时就没人知道） 博客草稿里也堆积了一篇又一篇没写完或者刚开头甚至只写了个标题的文章。 下半年需要调整一下学习状态。 研究生生涯转眼就要过一年了，压力逐步增大。我对未来的规划也必须要开始明确一些。 近来看2020年的算法岗校招一片红海，不得不说让我曾打足的气又给泄了。 我一直在想，我应该选择什么。 一般来说，喜欢什么就做什么。但我目前好像对开发与算法具有同等热情。 如果说是想去一线互联网企业，似乎开发竞争相对小一些。 但结合我目前所做的研究，又似乎推荐算法岗是最合适的。虽说毕业后的方向可能和读书期间不一致，但如若一致当然更佳吧。 其实两者也并不矛盾，本来也打算未来走算法 + 开发的复合型研发工程师路线。但时间有限，现在的学习还是得有先有后。 想来想去，选择Hard模式，可能比较有挑战性吧。 一切的担忧，都是源于实力不够。 //TO DO","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/tags/杂谈/"}]},{"title":"【询问帖】","slug":"询问帖","date":"2020-06-14T09:28:21.000Z","updated":"2020-06-14T09:28:21.000Z","comments":true,"path":"2020/06/14/询问帖/","link":"","permalink":"https://hubojing.github.io/2020/06/14/询问帖/","excerpt":"　　请问本博客的封面图以及文中插图是否存在无法显示的现象？　　　　　　 ","text":"请问本博客的封面图以及文中插图是否存在无法显示的现象？ 测试博文1：Python开发简单爬虫 测试博文2：词的向量表示方法 或选择其它博文。望留言以帮助本博客改进，非常感谢。","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/categories/杂谈/"}],"tags":[]},{"title":"靖靖的脑洞大开（2）","slug":"靖靖的脑洞大开二","date":"2020-05-13T05:28:28.000Z","updated":"2020-05-13T05:28:28.000Z","comments":true,"path":"2020/05/13/靖靖的脑洞大开二/","link":"","permalink":"https://hubojing.github.io/2020/05/13/靖靖的脑洞大开二/","excerpt":"　　万一有一个实现了，我就是预言家哈哈哈　　随脑洞灵光一现而更新 ","text":"万一有一个实现了，我就是预言家哈哈哈 随脑洞灵光一现而更新 衣服变色器——2020.5.13 未来的人们只需要一件衣服！ 根据编辑器，自行选定样式，衣服就能按要求变化……还可以随机生成…… 好吧，其实就是懒…… “对方正在输入”探测器——2020.5.13 前段时间看知乎，有个回答说朋友之间什么是默契的。写的是有一天他打开微信要给朋友发消息，发现“对方正在输入”。让他感慨默契就是这样。 然而，我却想着，如果开发一个“对方正在输入”探测器，所有人都能拥有这种“默契”（好像也不难实现…）。正所谓“你以为的巧合都是精心安排”，哈哈哈我在想什么… 众所周知，这是一篇水文 … To be continued 上一篇脑洞靖靖的脑洞大开（1）","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"idea","slug":"idea","permalink":"https://hubojing.github.io/tags/idea/"}]},{"title":"ECharts笔记","slug":"Echarts笔记","date":"2020-04-08T05:42:38.000Z","updated":"2020-04-30T09:55:35.000Z","comments":true,"path":"2020/04/08/Echarts笔记/","link":"","permalink":"https://hubojing.github.io/2020/04/08/Echarts笔记/","excerpt":"　　备忘 ","text":"备忘 浏览器画图原理 Canvas基于像素单个html，类似于画笔在画布上画画Echarts基于canvas画图 Svg基于对象模型多个图形元素高保真 下载安装官网 在线定制下载echarts.min.js 快速上手12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;ECharts&lt;/title&gt; &lt;!-- 引入 echarts.js --&gt; &lt;script src=\"echarts.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt; &lt;div id=\"main\" style=\"width: 600px;height:400px;\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); // 指定图表的配置项和数据 var option = &#123; title: &#123; text: 'ECharts 入门示例' &#125;, tooltip: &#123;&#125;, legend: &#123; data:['销量'] &#125;, xAxis: &#123; data: [\"衬衫\",\"羊毛衫\",\"雪纺衫\",\"裤子\",\"高跟鞋\",\"袜子\"] &#125;, yAxis: &#123;&#125;, series: [&#123; name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Echarts.init()初始化Echarts实例setOption用指定数据绘图 Option对象标题：title图例：legendX轴：xAxis数据：series:[{name:’xx’, type:’xx’, data:[xxx]}] 折线图123456789series: [&#123; name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] &#125;,&#123; name: '产量', type: 'line', data: [7, 30, 50, 11, 40, 80] &#125;] 常用图标题12345678title: &#123; show: true, text: 'ECharts 入门示例', subtext: '这是副标题知道不', left: 100, //或者center left这种 borderColor: 'red', borderWidth: 5 &#125;, 工具箱1234567891011121314151617181920toolbox: &#123; show: true, feature: &#123; dataView: &#123; show: true &#125;, restore: &#123; //还原 show: true &#125;, dataZoom: &#123; show: true &#125;, saveAsImage: &#123; show: true &#125;, magicType: &#123; type: ['line', 'bar'] &#125; &#125; &#125;, 弹窗123tooltip: &#123; trigger: 'axis'&#125;, 标记线和标记点1234567891011121314151617 series: [&#123; name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20], markPoint: &#123; data: [ &#123;type: 'max', name: '最大值'&#125;, &#123;type: 'min', name: '最小值', symbol:'arrow'&#125; ] &#125;, markLine: &#123; data: [ &#123;type: 'average',name: '平均值'&#125; ] &#125; &#125;]&#125;; 饼图123456789101112131415series: [&#123; name: '访问来源', type: 'pie', radius:'55%', center:['50%', '60%'], data: [ &#123;value:335, name:'直接访问'&#125;, &#123;value:310, name:'邮件营销'&#125;, &#123;value:234, name:'联盟广告'&#125;, &#123;value:135, name:'视频广告'&#125;, &#123;value:1548, name:'搜索引擎'&#125; ] &#125; ] &#125;; 仪表图12345678series: [ &#123; name: '业务指标', type: 'gauge', detail: &#123;formatter:'&#123;value&#125;%'&#125;, data: [&#123;value: 32, name:'完成率'&#125;] &#125; ] 123456// 使用刚指定的配置项和数据显示图表。myChart.setOption(option);setInterval(function ()&#123; option.series[0].data[0].value = (Math.random() * 100).toFixed(2) - 0; myChart.setOption(option, true);&#125;,2000); 地图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;ECharts&lt;/title&gt; &lt;!-- 引入 echarts.js --&gt; &lt;script src=\"echarts.min.js\"&gt;&lt;/script&gt; &lt;script src=\"china.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt; &lt;div id=\"main\" style=\"width: 900px;height:600px;\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); var geoCoordMap = &#123; '上海': [121.4648, 31.2891], '东莞': [113.8953, 22.901], '东营': [118.7073, 37.5513], '中山': [113.4229, 22.478], '临汾': [111.4783, 36.1615], '临沂': [118.3118, 35.2936], '丹东': [124.541, 40.4242], '丽水': [119.5642, 28.1854], '乌鲁木齐': [87.9236, 43.5883], '佛山': [112.8955, 23.1097], '保定': [115.0488, 39.0948], '兰州': [103.5901, 36.3043], '包头': [110.3467, 41.4899], '北京': [116.4551, 40.2539], '北海': [109.314, 21.6211], '南京': [118.8062, 31.9208], '南宁': [108.479, 23.1152], '南昌': [116.0046, 28.6633], '南通': [121.1023, 32.1625], '厦门': [118.1689, 24.6478], '台州': [121.1353, 28.6688], '合肥': [117.29, 32.0581], '呼和浩特': [111.4124, 40.4901], '咸阳': [108.4131, 34.8706], '哈尔滨': [127.9688, 45.368], '唐山': [118.4766, 39.6826], '嘉兴': [120.9155, 30.6354], '大同': [113.7854, 39.8035], '大连': [122.2229, 39.4409], '天津': [117.4219, 39.4189], '太原': [112.3352, 37.9413], '威海': [121.9482, 37.1393], '宁波': [121.5967, 29.6466], '宝鸡': [107.1826, 34.3433], '宿迁': [118.5535, 33.7775], '常州': [119.4543, 31.5582], '广州': [113.5107, 23.2196], '廊坊': [116.521, 39.0509], '延安': [109.1052, 36.4252], '张家口': [115.1477, 40.8527], '徐州': [117.5208, 34.3268], '德州': [116.6858, 37.2107], '惠州': [114.6204, 23.1647], '成都': [103.9526, 30.7617], '扬州': [119.4653, 32.8162], '承德': [117.5757, 41.4075], '拉萨': [91.1865, 30.1465], '无锡': [120.3442, 31.5527], '日照': [119.2786, 35.5023], '昆明': [102.9199, 25.4663], '杭州': [119.5313, 29.8773], '枣庄': [117.323, 34.8926], '柳州': [109.3799, 24.9774], '株洲': [113.5327, 27.0319], '武汉': [114.3896, 30.6628], '汕头': [117.1692, 23.3405], '江门': [112.6318, 22.1484], '沈阳': [123.1238, 42.1216], '沧州': [116.8286, 38.2104], '河源': [114.917, 23.9722], '泉州': [118.3228, 25.1147], '泰安': [117.0264, 36.0516], '泰州': [120.0586, 32.5525], '济南': [117.1582, 36.8701], '济宁': [116.8286, 35.3375], '海口': [110.3893, 19.8516], '淄博': [118.0371, 36.6064], '淮安': [118.927, 33.4039], '深圳': [114.5435, 22.5439], '清远': [112.9175, 24.3292], '温州': [120.498, 27.8119], '渭南': [109.7864, 35.0299], '湖州': [119.8608, 30.7782], '湘潭': [112.5439, 27.7075], '滨州': [117.8174, 37.4963], '潍坊': [119.0918, 36.524], '烟台': [120.7397, 37.5128], '玉溪': [101.9312, 23.8898], '珠海': [113.7305, 22.1155], '盐城': [120.2234, 33.5577], '盘锦': [121.9482, 41.0449], '石家庄': [114.4995, 38.1006], '福州': [119.4543, 25.9222], '秦皇岛': [119.2126, 40.0232], '绍兴': [120.564, 29.7565], '聊城': [115.9167, 36.4032], '肇庆': [112.1265, 23.5822], '舟山': [122.2559, 30.2234], '苏州': [120.6519, 31.3989], '莱芜': [117.6526, 36.2714], '菏泽': [115.6201, 35.2057], '营口': [122.4316, 40.4297], '葫芦岛': [120.1575, 40.578], '衡水': [115.8838, 37.7161], '衢州': [118.6853, 28.8666], '西宁': [101.4038, 36.8207], '西安': [109.1162, 34.2004], '贵阳': [106.6992, 26.7682], '连云港': [119.1248, 34.552], '邢台': [114.8071, 37.2821], '邯郸': [114.4775, 36.535], '郑州': [113.4668, 34.6234], '鄂尔多斯': [108.9734, 39.2487], '重庆': [107.7539, 30.1904], '金华': [120.0037, 29.1028], '铜川': [109.0393, 35.1947], '银川': [106.3586, 38.1775], '镇江': [119.4763, 31.9702], '长春': [125.8154, 44.2584], '长沙': [113.0823, 28.2568], '长治': [112.8625, 36.4746], '阳泉': [113.4778, 38.0951], '青岛': [120.4651, 36.3373], '韶关': [113.7964, 24.7028] &#125;; var BJData = [ [&#123; name: '北京' &#125;, &#123; name: '上海', value: 95 &#125;], [&#123; name: '北京' &#125;, &#123; name: '广州', value: 90 &#125;], [&#123; name: '北京' &#125;, &#123; name: '大连', value: 80 &#125;], [&#123; name: '北京' &#125;, &#123; name: '南宁', value: 70 &#125;], [&#123; name: '北京' &#125;, &#123; name: '南昌', value: 60 &#125;], [&#123; name: '北京' &#125;, &#123; name: '拉萨', value: 50 &#125;], [&#123; name: '北京' &#125;, &#123; name: '长春', value: 40 &#125;], [&#123; name: '北京' &#125;, &#123; name: '包头', value: 30 &#125;], [&#123; name: '北京' &#125;, &#123; name: '重庆', value: 20 &#125;], [&#123; name: '北京' &#125;, &#123; name: '常州', value: 10 &#125;] ]; var SHData = [ [&#123; name: '上海' &#125;, &#123; name: '包头', value: 95 &#125;], [&#123; name: '上海' &#125;, &#123; name: '昆明', value: 90 &#125;], [&#123; name: '上海' &#125;, &#123; name: '广州', value: 80 &#125;], [&#123; name: '上海' &#125;, &#123; name: '郑州', value: 70 &#125;], [&#123; name: '上海' &#125;, &#123; name: '长春', value: 60 &#125;], [&#123; name: '上海' &#125;, &#123; name: '重庆', value: 50 &#125;], [&#123; name: '上海' &#125;, &#123; name: '长沙', value: 40 &#125;], [&#123; name: '上海' &#125;, &#123; name: '北京', value: 30 &#125;], [&#123; name: '上海' &#125;, &#123; name: '丹东', value: 20 &#125;], [&#123; name: '上海' &#125;, &#123; name: '大连', value: 10 &#125;] ]; var GZData = [ [&#123; name: '广州' &#125;, &#123; name: '福州', value: 95 &#125;], [&#123; name: '广州' &#125;, &#123; name: '太原', value: 90 &#125;], [&#123; name: '广州' &#125;, &#123; name: '长春', value: 80 &#125;], [&#123; name: '广州' &#125;, &#123; name: '重庆', value: 70 &#125;], [&#123; name: '广州' &#125;, &#123; name: '西安', value: 60 &#125;], [&#123; name: '广州' &#125;, &#123; name: '成都', value: 50 &#125;], [&#123; name: '广州' &#125;, &#123; name: '常州', value: 40 &#125;], [&#123; name: '广州' &#125;, &#123; name: '北京', value: 30 &#125;], [&#123; name: '广州' &#125;, &#123; name: '北海', value: 20 &#125;], [&#123; name: '广州' &#125;, &#123; name: '海口', value: 10 &#125;] ]; var planePath = 'path://M1705.06,1318.313v-89.254l-319.9-221.799l0.073-208.063c0.521-84.662-26.629-121.796-63.961-121.491c-37.332-0.305-64.482,36.829-63.961,121.491l0.073,208.063l-319.9,221.799v89.254l330.343-157.288l12.238,241.308l-134.449,92.931l0.531,42.034l175.125-42.917l175.125,42.917l0.531-42.034l-134.449-92.931l12.238-241.308L1705.06,1318.313z'; var convertData = function(data) &#123; var res = []; for (var i = 0; i &lt; data.length; i++) &#123; var dataItem = data[i]; var fromCoord = geoCoordMap[dataItem[0].name]; var toCoord = geoCoordMap[dataItem[1].name]; if (fromCoord &amp;&amp; toCoord) &#123; res.push([&#123; name: dataItem[0].name, coord: fromCoord &#125;, &#123; name: dataItem[1].name, coord: toCoord &#125;]); &#125; &#125; return res; &#125;; var color = ['#a6c84c', '#ffa022', '#46bee9']; var series = []; [ ['北京', BJData], ['上海', SHData], ['广州', GZData] ].forEach(function(item, i) &#123; series.push(&#123; name: item[0] + ' Top10', type: 'lines', zlevel: 1, effect: &#123; show: true, period: 6, trailLength: 0.7, color: '#fff', symbolSize: 3 &#125;, lineStyle: &#123; normal: &#123; color: color[i], width: 0, curveness: 0.2 &#125; &#125;, data: convertData(item[1]) &#125;, &#123; name: item[0] + ' Top10', type: 'lines', zlevel: 2, effect: &#123; show: true, period: 6, trailLength: 0, symbol: planePath, symbolSize: 15 &#125;, lineStyle: &#123; normal: &#123; color: color[i], width: 1, opacity: 0.4, curveness: 0.2 &#125; &#125;, data: convertData(item[1]) &#125;, &#123; name: item[0] + ' Top10', type: 'effectScatter', coordinateSystem: 'geo', zlevel: 2, rippleEffect: &#123; brushType: 'stroke' &#125;, label: &#123; normal: &#123; show: true, position: 'right', formatter: '&#123;b&#125;' &#125; &#125;, symbolSize: function(val) &#123; return val[2] / 8; &#125;, itemStyle: &#123; normal: &#123; color: color[i] &#125; &#125;, data: item[1].map(function(dataItem) &#123; return &#123; name: dataItem[1].name, value: geoCoordMap[dataItem[1].name].concat([dataItem[1].value]) &#125;; &#125;) &#125;); &#125;); option = &#123; backgroundColor: '#404a59', title: &#123; text: '模拟迁徙', subtext: '数据纯属虚构', left: 'center', textStyle: &#123; color: '#fff' &#125; &#125;, tooltip: &#123; trigger: 'item' &#125;, legend: &#123; orient: 'vertical', top: 'bottom', left: 'right', data: ['北京 Top10', '上海 Top10', '广州 Top10'], textStyle: &#123; color: '#fff' &#125;, selectedMode: 'single' &#125;, geo: &#123; map: 'china', label: &#123; emphasis: &#123; show: false &#125; &#125;, roam: true, itemStyle: &#123; normal: &#123; areaColor: '#323c48', borderColor: '#404a59' &#125;, emphasis: &#123; areaColor: '#2a333d' &#125; &#125; &#125;, series: series &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; china.js123456789101112131415161718192021222324252627(function (root, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) &#123; // AMD. Register as an anonymous module. define(['exports', 'echarts'], factory); &#125; else if (typeof exports === 'object' &amp;&amp; typeof exports.nodeName !== 'string') &#123; // CommonJS factory(exports, require('echarts')); &#125; else &#123; // Browser globals factory(&#123;&#125;, root.echarts); &#125;&#125;(this, function (exports, echarts) &#123; var log = function (msg) &#123; if (typeof console !== 'undefined') &#123; console &amp;&amp; console.error &amp;&amp; console.error(msg); &#125; &#125; if (!echarts) &#123; log('ECharts is not Loaded'); return; &#125; if (!echarts.registerMap) &#123; log('ECharts Map is not loaded') return; &#125; echarts.registerMap('china', &#123;\"type\":\"FeatureCollection\",\"features\":[&#123;\"id\":\"710000\",\"geometry\":&#123;\"type\":\"MultiPolygon\",\"coordinates\":[[\"@@°Ü¯Û\",\"@@ƛĴÕƊÉɼģºðʀ\\\\ƎsÆNŌÔĚänÜƤɊĂǀĆĴĤǊŨxĚĮǂƺòƌâÔ®ĮXŦţƸZûÐƕƑGđ¨ĭMó·ęcëƝɉlÝƯֹÅŃ^Ó·śŃǋƏďíåɛGɉ¿IċããF¥ĘWǬÏĶñÄ\",\"@@\\\\p|WoYG¿¥Ij@\",\"@@¡@V^RqBbAnTXeQr©C\",\"@@ÆEEkWqë I\"]],\"encodeOffsets\":[[[122886,24033],[123335,22980],[122375,24193],[122518,24117],[124427,22618]]]&#125;,\"properties\":&#123;\"cp\":[121.509062,25.044332],\"name\":\"台湾\",\"childNum\":5&#125;&#125;,&#123;\"id\":\"130000\",\"geometry\":&#123;\"type\":\"MultiPolygon\",\"coordinates\":[[\"@@\\\\aM`Ç½ÓnUKĜēs¤­©yrý§uģcJ»eIP]ªrºc_ħ²G¼s`jÎŸnüsÂľP\",\"@@U`Ts¿mÄ\",\"@@FOhđ©OiÃ`ww^ÌkÑH«ƇǤŗĺtFu&#123;Z&#125;Ö@U´ʚLg®¯Oı°Ãw ^VbÉsmAê]]w§RRl£ŭuwNÁ`ÇFēÝčȻuT¡Ĺ¯Õ¯sŗő£YªhVƍ£ƅnëYNgq¼ś¿µı²UºÝUąąŖóxV@tƯJ]eR¾fe|rHA|h~Ėƍl§ÏjVë` ØoÅbbx³^zÃĶ¶Sj®AyÂhðk`«PËµEFÛ¬Y¨Ļrõqi¼Wi°§Ð±²°`[À|ĠO@ÆxO\\\\ta\\\\p_Zõ^û&#123;ġȧXýĪÓjùÎRb^Î»j&#123;íděYfíÙTymńŵōHim½éŅ­aVcř§ax¹XŻácWU£ôãºQ¨÷Ñws¥qEHÙ|šYQoŕÇyáĂ£MÃ°oťÊP¡mWO¡v&#123;ôvîēÜISpÌhp¨ jdeŔQÖjX³àĈ[n`Yp@UcM`RKhEbpŞlNut®EtqnsÁgAiúoHqCXhfgu~ÏWP½¢G^&#125;¯ÅīGCÑ^ãziMáļMTÃƘrMc|O_¯Ŏ´|morDkO\\\\mĆJfl@cĢ¬¢aĦtRıÒXòë¬WP&#123;ŵǫƝīÛ÷ąV×qƥV¿aȉd³BqPBmaËđŻģmÅ®V¹d^KKonYg¯XhqaLdu¥Ípǅ¡KąÅkĝęěhq&#125;HyÃ]¹ǧ£Í÷¿qágPmoei¤o^á¾ZEY^Ný&#123;nOl±Í@Mċèk§daNaÇį¿]øRiiñEūiǱàUtėGyl&#125;ÓM&#125;jpEC~¡FtoQiHkk&#123;ILgĽxqÈƋÄdeVDJj£J|ÅdzÂFt~KŨ¸IÆv|¢r&#125;èonb&#125;`RÎÄn°ÒdÞ²^®lnÐèĄlðÓ×]ªÆ&#125;LiĂ±Ö`^°Ç¶p®đDcŋ`ZÔ¶êqvFÆN®ĆTH®¦O¾IbÐã´BĐɢŴÆíȦpĐÞXR·nndO¤OÀĈƒ­QgµFo|gȒęSWb©osx|hYhgŃfmÖĩnºTÌSp¢dYĤ¶UĈjlǐpäðëx³kÛfw²Xjz~ÂqbTÑěŨ@|oMzv¢ZrÃVw¬ŧĖ¸f°ÐTªqs&#123;S¯r æÝl¼ÖĞ ǆiGĘJ¼lr&#125;~K¨ŸƐÌWö¼Þ°nÞoĦL|C~D©|q]SvKÑcwpÏÏĿćènĪWlĄkT&#125;¬Tp~®Hgd˒ĺBVtEÀ¢ôPĎƗè@~kü\\\\rÊĔÖæW_§¼F´©òDòjYÈrbĞāøŀG&#123;ƀ|¦ðrb|ÀH`pʞkvGpuARhÞÆǶgĘTǼƹS£¨¡ù³ŘÍ]¿ÂyôEP xX¶¹ÜO¡gÚ¡IwÃé¦ÅBÏ|Ç°N«úmH¯âbęU~xĈbȒ&#123;^xÖlD¸dɂ~\"]],\"encodeOffsets\":[[[120023,41045],[121616,39981],[122102,42307]]]&#125;,\"properties\":&#123;\"cp\":[114.502461,38.045474],\"name\":\"河北\",\"childNum\":3&#125;&#125;,&#123;\"id\":\"140000\",\"geometry\":&#123;\"type\":\"Polygon\",\"coordinates\":[\"@@ħÜ_ªlìwGkÛÃǏokćiµVZģ¡coTSË¹ĪmnÕńehZg&#123;gtwªpXaĚThȑp&#123;¶Eh®RćƑP¿£PmcªaJyý&#123;ýȥoÅîɡųAďä³aÏJ½¥PG­ąSM­sWz½µÛYÓŖgxoOkĒCo­Èµ]¯_²ÕjāK~©ÅØ^ÔkïçămÏk]­±cÝ¯ÑÃmQÍ~_apm~ç¡qu&#123;JÅŧ·Ls&#125;EyÁÆcI&#123;¤IiCfUcƌÃp§]ě«vD@¡SÀµMÅwuYY¡DbÑc¡h×]nkoQdaMç~eDÛtT©±@¥ù@É¡ZcW|WqOJmĩl«ħşvOÓ«IqăV¥D[mI~Ó¢cehiÍ]Ɠ~ĥqX·eƷn±&#125;v[ěďŕ]_œ`¹§ÕōIo©b­s^&#125;Ét±ū«³p£ÿ¥WÑxçÁ«h×u×¥ř¾dÒ&#123;ºvĴÎêÌɊ²¶ü¨|ÞƸµȲLLúÉƎ¤ϊęĔV`_bªS^|dzY|dz¥pZbÆ£¶ÒK&#125;tĦÔņƠPYznÍvX¶Ěn ĠÔzý¦ª÷ÑĸÙUȌ¸dòÜJð´ìúNM¬XZ´¤ŊǸ_tldI&#123;¦ƀðĠȤ¥NehXnYGR° ƬDj¬¸|CĞKqºfƐiĺ©ª~ĆOQª ¤@ìǦɌ²æBÊTĞHƘÁĪËĖĴŞȀÆÿȄlŤĒötÎ½î¼ĨXh|ªM¤ÐzÞĩÒSrao³\"],\"encodeOffsets\":[[117016,41452]]&#125;,\"properties\":&#123;\"cp\":[112.549248,37.857014],\"name\":\"山西\",\"childNum\":1&#125;&#125;,&#123;\"id\":\"150000\",\"geometry\":&#123;\"type\":\"MultiPolygon\",\"coordinates\":[[\"@@ǪƫÌÛMĂ[`ÕCn&#125;¶Vcês¯PqFB|S³C|kñHdiÄ¥sŉÅPóÑÑE^ÅPpy_YtShQ·aHwsOnŉÃs©iqjUSiº]ïW«gW¡ARëśĳĘů`çõh]y»ǃǛҤxÒm~zf&#125;pf|ÜroÈzrKÈĵSƧż؜Ġu~è¬vîS¼ĂhĖMÈÄw\\\\fŦ°W ¢¾luŸDw\\\\Ŗĝ\",\"@@GVu»Aylßí¹ãe]Eāò³C¹ð¾²iÒAdkò^P²CǜңǄ z¼g^èöŰ_Ĳĕê&#125;gÁnUI«m]jvV¼euhwqAaW_µj»çjioQR¹ēÃßt@r³[ÛlćË^ÍÉáGOUÛOB±XkÅ¹£k|e]olkVÍ¼ÕqtaÏõjgÁ£§U^RLËnX°ÇBz^~wfvypV ¯ƫĉ˭ȫƗŷɿÿĿƑ˃ĝÿÃǃßËőó©ǐȍŒĖM×ÍEyxþp]ÉvïèvƀnÂĴÖ@V~Ĉ³MEĸÅĖtējyÄDXÄxGQuv_i¦aBçw˛wD©&#123;tāmQ&#123;EJ§KPśƘƿ¥@sCTÉ&#125;ɃwƇy±gÑ&#125;T[÷kÐç¦«SÒ¥¸ëBX½HáÅµÀğtSÝÂa[ƣ°¯¦Pï¡]£ġÒk®G²èQ°óMq&#125;EóƐÇ\\\\@áügQÍu¥FTÕ¿Jû]|mvāÎYua^WoÀa·­ząÒot×¶CLƗi¯¤mƎHǊ¤îìɾŊìTdåwsRÖgĒųúÍġäÕ&#125;Q¶¿A[¡&#123;d×uQAMxVvMOmăl«ct[wº_ÇÊjbÂ£ĦS_éQZ_lwgOiýe`YYJq¥IÁǳ£ÙË[ÕªuƏ³ÍTs·bÁĽäė[b[ŗfãcn¥îC¿÷µ[ŏÀQ­ōĉm¿Á^£mJVmL[&#123;Ï_£F¥Ö&#123;ŹA&#125;×Wu©ÅaųĳƳhB&#123;·TQqÙIķËZđ©Yc|M¡LeVUóK_QWk_ĥ¿ãZ»X\\\\ĴuUèlG®ěłTĠğDŃGÆÍz]±ŭ©Å]ÅÐ&#125;UË¥©TċïxgckfWgi\\\\ÏĒ¥HkµEë&#123;»ÏetcG±ahUiñiWsɁ·cCÕk]wȑ|ća&#125;wVaĚá G°ùnM¬¯&#123;ÈÐÆA¥ÄêJxÙ¢hP¢ÛºµwWOóFÁz^ÀŗÎú´§¢T¤ǻƺSėǵhÝÅQgvBHouʝl_o¿Ga&#123;ïq&#123;¥|ſĿHĂ÷aĝÇqZñiñC³ª»E`¨åXēÕqÉû[l&#125;ç@čƘóO¿¡FUsAʽīccocÇS&#125;£IS~ălkĩXçmĈŀÐoÐdxÒuL^T&#123;r@¢ÍĝKén£kQyÅõËXŷƏL§~&#125;kq»IHėǅjĝ»ÑÞoå°qTt|r©ÏS¯·eŨĕx«È[eM¿yupN~¹ÏyN£&#123;©għWí»Í¾səšǅ_ÃĀɗ±ąĳĉʍŌŷSÉA±åǥɋ@ë£R©ąP©&#125;ĹªƏj¹erLDĝ·&#123;i«ƫC½ÉshVzGS|úþXgp&#123;ÁX¿ć&#123;ƱȏñZáĔyoÁhA&#125;ŅĆfdŉ_¹Y°ėǩÑ¡H¯¶oMQqð¡Ë|Ñ`ƭŁX½·óÛxğįÅcQs«tȋǅFù^it«Č¯[hAi©á¥ÇĚ×l|¹y¯Kȝqgů&#123;ñǙµïċĹzŚȭ¶¡oŽäÕG\\\\ÄT¿Òõr¯LguÏYęRƩɷŌO\\\\İÐ¢æ^Ŋ ĲȶȆbÜGĝ¬¿ĚVĎgª^íu½jÿĕęjık@Ľ]ėl¥ËĭûÁėéV©±ćn©­ȇÍq¯½YÃÔŉÉNÑÅÝy¹NqáʅDǡËñ­ƁYÅy̱os§ȋµʽǘǏƬɱàưN¢ƔÊuľýľώȪƺɂļxZĈ&#125;ÌŉŪĺœĭFЛĽ̅ȣͽÒŵìƩÇϋÿȮǡŏçƑůĕ~Ç¼ȳÐUfdIxÿ\\\\G zâɏÙOº·pqy£@qþ@Ǟ˽IBäƣzsÂZÁàĻdñ°ŕzéØűzșCìDȐĴĺf®Àľưø@ɜÖÞKĊŇƄ§͑těï͡VAġÑÑ»d³öǍÝXĉĕÖ&#123;þĉu¸ËʅğU̎éhɹƆ̗̮ȘǊ֥ड़ࡰţાíϲäʮW¬®ҌeרūȠkɬɻ̼ãüfƠSצɩςåȈHϚÎKǳͲOðÏȆƘ¼CϚǚ࢚˼ФÔ¤ƌĞ̪Qʤ´¼mȠJˀƲÀɠmɆǄĜƠ´ǠN~ʢĜ¶ƌĆĘźʆȬ˪ĚĒ¸ĞGȖƴƀj`ĢçĶāàŃºēĢĖćYÀŎüôQÐÂŎŞǆŞêƖoˆDĤÕºÑǘÛˤ³̀gńƘĔÀ^ªƂ`ªt¾äƚêĦĀ¼ÐĔǎ¨Ȕ»͠^ˮÊȦƤøxRrŜH¤¸ÂxDÄ|ø˂˜ƮÐ¬ɚwɲFjĔ²Äw°ǆdÀÉ_ĸdîàŎjÊêTĞªŌŜWÈ|tqĢUB~´°ÎFCU¼pĀēƄN¦¾O¶łKĊOjĚj´ĜYp&#123;¦SĚÍ\\\\T×ªV÷Ší¨ÅDK°ßtŇĔK¨ǵÂcḷ̌ĚǣȄĽFlġUĵŇȣFʉɁMğįʏƶɷØŭOǽ«ƽū¹Ʊő̝Ȩ§ȞʘĖiɜɶʦ&#125;¨֪ࠜ̀ƇǬ¹ǨE˦ĥªÔêFxúQEr´Wrh¤Ɛ \\\\talĈDJÜ|[Pll̚¸ƎGú´P¬W¦^¦H]prRn|or¾wLVnÇIujkmon£cX^Bh`¥V¦U¤¸&#125;xRj[^xN[~ªxQ[`ªHÆÂExx^wN¶Ê|¨ìMrdYpoRzNyÀDs~bcfÌ`L¾n|¾T°c¨È¢ar¤`[|òDŞĔöxElÖdHÀI`Ď\\\\Àì~ÆR¼tf¦^¢ķ¶eÐÚMptgjɡČÅyġLûŇV®ÄÈƀĎ°P|ªVVªj¬ĚÒêp¬E|ŬÂ_~¼rƐK f&#123;ĘFĒƌXưăkÃĄ&#125;nµo×q£ç­kX&#123;uĩ«āíÓUŅÝVUŌ]Ť¥lyň[oi&#123;¦LĸĦ^ôâJ¨^UZðÚĒL¿Ìf£K£ʺoqNwğc`uetOj×°KJ±qÆġmĚŗos¬qehqsuH&#123;¸kH¡ÊRǪÇƌbȆ¢´äÜ¢NìÉʖ¦â©Ɨؗ\"]],\"encodeOffsets\":[[[128500,52752],[127089,51784]]]&#125;,\"properties\":&#123;\"cp\":[111.670801,40.818311],\"name\":\"内蒙古\",\"childNum\":2&#125;&#125;,&#123;\"id\":\"210000\",\"geometry\":&#123;\"type\":\"MultiPolygon\",\"coordinates\":[[\"@@L@@s]\",\"@@MnNm\",\"@@dc\",\"@@eÀC@b\",\"@@fXwkbrÄ`qg\",\"@@^jtWQ\",\"@@~ Y[c\",\"@@I`ĖN^_¿ZÁM\",\"@@Ïxǌ&#123;q_×^Gigp\",\"@@iX¶BY\",\"@@YZ\",\"@@L_yG`b\",\"@@^WqCTZ\",\"@@\\\\[§t|]\",\"@@m`p[\",\"@@@é^BntaÊU]x ¯ÄPĲ­°hʙK³VÕ@Y~|EvĹsÇ¦­L^pÃ²ŸÒG Ël]xxÄ_fT¤Ď¤cPC¨¸TVjbgH²sdÎdHt`B²¬GJję¶[ÐhjeXdlwhðSČ¦ªVÊÏÆZÆŶ®²^ÎyÅHńĚDMħĜŁH­kçvV[ĳ¼WYÀäĦ`XlR`ôLUVfK¢&#123;NZdĒªYĸÌÚJRr¸SA|ƴgŴĴÆbvªØX~źB|¦ÕE¤Ð`\\\\|KUnnI]¤ÀÂĊnŎR®Ő¿¶\\\\ÀøíDm¦ÎbŨabaĘ\\\\ľãÂ¸atÎSƐ´©v\\\\ÖÚÌǴ¤Â¨JKrZ_ZfjþhPkx`YRIjJcVf~sCN¤ EhæmsHy¨SðÑÌ\\\\\\\\ĐRÊwS¥fqŒßýáĞÙÉÖ[^¯ǤŲê´\\\\¦¬ĆPM¯£»uïpùzExanµyoluqe¦W^£ÊL&#125;ñrkqWňûPUP¡ôJoo·U&#125;£[·¨@XĸDXm­ÛÝºGUCÁª½&#123;íĂ^cjk¶Ã[q¤LÉö³cux«|Zd²BWÇ®Yß½ve±ÃCý£W&#123;Ú^q^sÑ·¨ËMr¹·C¥GDrí@wÕKţÃ«V·i&#125;xËÍ÷i©ĝɝǡ]&#123;c±OW³Ya±_ç©HĕoƫŇqr³Lys[ñ³¯OSďOMisZ±ÅFC¥Pq&#123;Ã[Pg&#125;\\\\¿ghćOk^ĩÃXaĕËĥM­oEqqZûěŉ³F¦oĵhÕP&#123;¯~TÍlªNßYÐ&#123;Ps&#123;ÃVUeĎwk±ŉVÓ½ŽJãÇÇ»Jm°dhcÀffdF~ĀeĖd`sx² ®EĦ¦dQÂd^~ăÔH¦\\\\LKpĄVez¤NP ǹÓRÆąJSh­a[¦´ÂghwmBÐ¨źhI|VV|p] Â¼èNä¶ÜBÖ¼L`¼bØæKVpoúNZÞÒKxpw|ÊEMnzEQIZZNBčÚFÜçmĩWĪñtÞĵÇñZ«uD±|ƏlǗw·±PmÍada CLǑkùó¡³Ï«QaċÏOÃ¥ÕđQȥċƭy³ÁA\"]],\"encodeOffsets\":[[[123686,41445],[126019,40435],[124393,40128],[126117,39963],[125322,40140],[126686,40700],[126041,40374],[125584,40168],[125509,40217],[125453,40165],[125362,40214],[125280,40291],[125774,39997],[125976,40496],[125822,39993],[122731,40949]]]&#125;,\"properties\":&#123;\"cp\":[123.429096,41.796767],\"name\":\"辽宁\",\"childNum\":16&#125;&#125;,&#123;\"id\":\"220000\",\"geometry\":&#123;\"type\":\"Polygon\",\"coordinates\":[\"@@ñr½ÉKāGÁ¤ia ÉÈ¹`\\\\xs¬dĆkNnuNUwNx¶c¸|\\\\¢GªóĄ~RãÖÎĢùđŴÕhQxtcæëSɽŉíëǉ£ƍG£nj°KƘµDsØÑpyĆ¸®¿bXp]vbÍZuĂ&#123;n^IüÀSÖ¦EvRÎûh@â[ƏÈô~FNr¯ôçR±­HÑlĢ^¤¢OðætxsŒ]ÞÁTĠs¶¿âÆGW¾ìA¦·TÑ¬è¥ÏÐJ¨¼ÒÖ¼ƦɄxÊ~StD@Ă¼Ŵ¡jlºWvÐzƦZÐ²CH AxiukdGgetqmcÛ£Ozy¥cE&#125;|¾cZk¿uŐã[oxGikfeäT@SUwpiÚFM©£è^Ú`@v¶eňf heP¶täOlÃUgÞzŸU`l&#125;ÔÆUvØ_Ō¬Öi^ĉi§²ÃB~¡ĈÚEgc|DC_Ȧm²rBx¼MÔ¦ŮdĨÃâYxƘDVÇĺĿg¿cwÅ\\\\¹¥Yĭl¤OvLjM_a W`zļMž·\\\\swqÝSAqŚĳ¯°kRē°wx^ĐkǂÒ\\\\]nrĂ&#125;²ĊŲÒøãh·M&#123;yMzysěnĒġV·°G³¼XÀ¤¹i´o¤ŃÈ`ÌǲÄUĞd\\\\iÖmÈBĤÜɲDEh LG¾ƀÄ¾&#123;WaYÍÈĢĘÔRîĐj&#125;ÇccjoUb½&#123;h§Ǿ&#123;KƖµÎ÷GĄØŜçưÌs«lyiē«`å§H¥Ae^§GK&#125;iã\\\\c]v©ģZmÃ|[M&#125;ģTɟĵÂÂ`ÀçmFK¥ÚíÁbX³ÌQÒHof&#123;]ept·GŋĜYünĎųVY^ydõkÅZW«WUa~U·SbwGçǑiW^qFuNĝ·EwUtW·Ýďæ©PuqEzwAVXRãQ`­©GYYhcUGorBd&#125;ģÉb¡·µMicF«Yƅ»é\\\\ɹ~ǙG³mØ©BšuT§Ĥ½¢Ã_Ã½L¡ûsT\\\\rke\\\\PnwAKy&#125;ywdSefµ]UhĿD@mÿvaÙNSkCuncÿ`lWėVâ¦÷~^fÏ~vwHCį`xqT­­lW«ï¸skmßEGqd¯R©Ý¯¯S\\\\cZ¹iűƏCuƍÓXoR&#125;M^o£R&#125;oªU­FuuXHlEÅÏ©¤ßgXþ¤D²ÄufàÀ­XXÈ±Ac&#123;Yw¬dvõ´KÊ£\\\\rµÄlidā]|î©¾DÂVH¹Þ®ÜWnCķ W§@\\\\¸~¤Vp¸póIO¢VOŇürXql~òÉK]¤¥Xrfkvzpm¶bwyFoúvð¼¤ N°ąO¥«³[éǣű]°Õ\\\\ÚÊĝôîŇÔaâBYlďQ[ Ë[ïÒ¥RI|`j]P\"],\"encodeOffsets\":[[126831,44503]]&#125;,\"properties\":&#123;\"cp\":[125.3245,43.886841],\"name\":\"吉林\",\"childNum\":1&#125;&#125;,&#123;\"id\":\"230000\",\"geometry\":&#123;\"type\":\"MultiPolygon\",\"coordinates\":[[\"@@UµNÿ¥īèçHÍøƕ¶Lǽ|g¨|a¾pVidd~ÈiíďÓQġėÇZÎXb½|ſÃH½KFgɱCģÛÇAnjÕc[VĝǱÃËÇ_ £ń³pj£º¿»WH´¯U¸đĢmtĜyzzNN|g¸÷äűÑ±ĉā~mq^[ǁÑďlw]¯xQĔ¯l°řĴrBÞTxr[tŽ¸ĻN_yX`biNKuP£kZĮ¦[ºxÆÀdhĹŀUÈƗCwáZħÄŭcÓ¥»NAw±qȥnD`&#123;ChdÙFć&#125;¢A±Äj¨]ĊÕjŋ«×`VuÓÅ~_kŷVÝyhVkÄãPsOµfgeŇµf@u_Ù ÙcªNªÙEojVxT@ãSefjlwH\\\\pŏäÀvlY½d&#123;F~¦dyz¤PÜndsrhfHcvlwjF£G±DÏƥYyÏu¹XikĿ¦ÏqƗǀOŜ¨LI|FRĂn sª|C˜zxAè¥bfudTrFWÁ¹Am|ĔĕsķÆF´N&#125;ćUÕ@Áĳſmuçuð^ÊýowFzØÎĕNőǏȎôªÌŒǄàĀÄ˄ĞŀƒʀĀƘŸˮȬƬĊ°Uzouxe]&#125;AyÈW¯ÌmKQ]Īºif¸ÄX|sZt|½ÚUÎ lk^p&#123;f¤lºlÆW A²PVÜPHÊâ]ÎĈÌÜk´\\\\@qàsĔÄQºpRij¼èi`¶bXrBgxfv»uUi^v~J¬mVp´£´VWrnP½ì¢BX¬hðX¹^TjVriªjtŊÄmtPGx¸bgRsT`ZozÆO]ÒFôÒOÆŊvÅpcGêsx´DR&#123;AEOr°x|íb³Wm~DVjºéNNËÜ˛ɶ­GxŷCSt&#125;]ûōSmtuÇÃĕNāg»íT«u&#125;ç½BĵÞʣ¥ëÊ¡MÛ³ãȅ¡ƋaǩÈÉQG¢·lG|tvgrrf«ptęŘnÅĢrI²¯LiØsPf_vĠdxM prʹL¤¤eËÀđKïÙVY§]Ióáĥ]ķK¥j|pŇ\\\\kzţ¦šnņäÔVĂîĪ¬|vW®l¤èØrxm¶ă~lÄƯĄ̈́öȄEÔ¤ØQĄĄ»ƢjȦOǺ¨ìSŖÆƬyQv`cwZSÌ®ü±Ǆ]ŀç¬B¬©ńzƺŷɄeeOĨSfm ĊƀP̎ēz©ĊÄÕÊmgÇsJ¥ƔŊśæÎÑqv¿íUOµªÂnĦÁ_½ä@êí£P&#125;Ġ[@gġ&#125;gɊ×ûÏWXá¢užƻÌsNÍ½ƎÁ§čŐAēeL³àydl¦ĘVçŁpśǆĽĺſÊQíÜçÛġÔsĕ¬Ǹ¯YßċġHµ ¡eå`ļrĉŘóƢFìĎWøxÊkƈdƬv|I|·©NqńRŀ¤éeŊŀàŀU²ŕƀBQ£Ď&#125;L¹Îk@©ĈuǰųǨÚ§ƈnTËÇéƟÊcfčŤ^XmHĊĕË«W·ċëx³ǔķÐċJāwİ_ĸȀ^ôWr­°oú¬ĦŨK~ȰCĐ´Ƕ£fNÎèâw¢XnŮeÂÆĶ¾¾xäLĴĘlļO¤ÒĨA¢Êɚ¨®ØCÔ ŬGƠƦYĜĘÜƬDJg_ͥœ@čŅĻA¶¯@wÎqC½Ĉ»NăëKďÍQÙƫ[«ÃígßÔÇOÝáWñuZ¯ĥŕā¡ÑķJu¤E å¯°WKÉ±_d_&#125;&#125;vyõu¬ï¹ÓU±½@gÏ¿rÃ½DgCdµ°MFYxw¿CG£Rƛ½Õ&#123;]L§&#123;qqą¿BÇƻğëܭǊË|c²&#125;Fµ&#125;ÙRsÓpg±QNqǫŋRwŕnéÑÉK«SeYRŋ@&#123;¤SJ&#125;D Ûǖ֍]gr¡µŷjqWÛham³~S«Ü[\",\"@@ƨĶTLÇyqpÇÛqe&#123;~oyen&#125;s`qiXGù]Ëp½©lÉÁp]Þñ´FĂ^fäîºkàz¼BUv¬D\"]],\"encodeOffsets\":[[[134456,44547],[127123,51780]]]&#125;,\"properties\":&#123;\"cp\":[126.642464,45.756967],\"name\":\"黑龙江\",\"childNum\":2&#125;&#125;,&#123;\"id\":\"320000\",\"geometry\":&#123;\"type\":\"Polygon\",\"coordinates\":[\"@@Õg^vÁbnÀ`Jnĝ¬òM¶ĘTÖŒbe¦¦&#123;¸ZâćNp©Hp|`mjhSEb\\\\afv`sz^lkljÄtg¤D­¾X¿À|ĐiZȀåB·î&#125;GL¢õcßjayBFµÏC^ĭcÙt¿sğH]j&#123;s©HM¢QnDÀ©DaÜÞ·jgàiDbPufjDk`dPOîhw¡ĥ¥GP²ĐobºrYî¶aHŢ´ ]´rılw³r_&#123;£DB_Ûdåuk|Ũ¯F Cºyr&#123;XFye³Þċ¿ÂkĭB¿MvÛpm`rÚã@Ę¹hågËÖƿxnlč¶Åì½Ot¾dJlVJĂǀŞqvnO^JZż·Q&#125;êÍÅmµÒ]ƍ¦Dq&#125;¬R^èĂ´ŀĻĊIÔtĲyQŐĠMNtR®òLhĚs©»&#125;OÓGZz¶A\\\\jĨFäOĤHYJvÞHNiÜaĎÉnFQlNM¤B´ĄNöɂtpŬdZÅglmuÇUšŞÚb¤uŃJŴu»¹ĄlȖħŴw̌ŵ²ǹǠ͛hĭłƕrçü±Yrřl¥i`ã__¢ćSÅr[Çq^ùzWmOĈaŐÝɞï²ʯʊáĘĳĒǭPħ͍ôƋÄÄÍīçÛɈǥ£­ÛmY`ó£Z«§°Ó³QafusNıǅ_k&#125;¢m[ÝóDµ¡RLčiXyÅNïă¡¸iĔÏNÌķoıdōîåŤûHcs&#125;~Ûwbù¹£¦ÓCtOPrE^ÒogĉIµÛÅʹK¤½phMú`mR¸¦PƚgÉLRs`£¯ãhD¨|³¤C\"],\"encodeOffsets\":[[121451,32518]]&#125;,\"properties\":&#123;\"cp\":[118.767413,32.041544],\"name\":\"江苏\",\"childNum\":1&#125;&#125;,&#123;\"id\":\"330000\",\"geometry\":&#123;\"type\":\"MultiPolygon\",\"coordinates\":[[\"@@jX^n\",\"@@sfdM\",\"@@qP\\\\xz[_i\",\"@@o\\\\VzRZ&#125;mECy\",\"@@R¢FX&#125;°[m]\",\"@@Cb\\\\&#125;\",\"@@e|v\\\\laus\",\"@@v~s&#123;\",\"@@QxÂF©&#125;\",\"@@¹nvÞs©m\",\"@@rQgYIh\",\"@@bi«ZX\",\"@@p[&#125;ILd\",\"@@À¿|\",\"@@¹dnb\",\"@@rS&#125;[Kl\",\"@@g~h&#125;\",\"@@FlCk\",\"@@ůTG°ĄLHm°UF\",\"@@OdRe\",\"@@v[u\\\\\",\"@@FjâL~wyoo~sµLZ\",\"@@¬e¹aH\",\"@@\\\\nÔ¡q]L³ë\\\\ÿ®QÌ\",\"@@ÊA­©]ª\",\"@@Kxv&#123;­\",\"@@@hlIk_\",\"@@pWcrxp\",\"@@Md|_iA\",\"@@¢X£½z\\\\ðpN\",\"@@hlÜ[LykAvyfw^E \",\"@@fp¤MusH\",\"@@®_ma~LÁ¬`\",\"@@@°¡mÛGĕ¨§Ianá[ýƤjfæÐNäGp\",\"@@iMt\\\\\",\"@@Zc[b\",\"@@X®±GrÆ°Zæĉm\",\"@@Z~dOSo|A¿qZv\",\"@@@`EN£p\",\"@@|s\",\"@@@nDi\",\"@@na£¾uYL¯QªmĉÅdMgÇjcº«ę¬­K­´B«Âącoċ\\\\xK`cįŧ«®á[~ıxu·ÅKsËÉc¢Ù\\\\ĭƛëbf¹­ģSĜkáƉÔ­ĈZB&#123;aMµfzŉfÓÔŹŁƋǝÊĉ&#123;ğč±g³ne&#123;ç­ií´S¬\\\\ßðK¦w\\\\iqªĭiAuA­µ_W¥ƣO\\\\lċĢttC¨£t`PZäuXßBsĻyekOđġĵHuXBµ]×­­\\\\°®¬F¢¾pµ¼kŘó¬Wät¸|@L¨¸µrºù³Ù~§WIZW®±Ð¨ÒÉx`²pĜrOògtÁZ&#123;üÙ[|ûKwsPlU[&#125;¦Rvn`hsª^nQ´ĘRWb_ rtČFIÖkĦPJ¶ÖÀÖJĈĄTĚòC ²@PúØz©Pî¢£CÈÚĒ±hŖl¬â~nm¨f©iļ«mntqÒTÜÄjL®EÌFª²iÊxØ¨IÈhhst[Ôx&#125;dtüGæţŔïĬaĸpMËÐjē¢·ðĄÆMzjWKĎ¢Q¶À_ê_@ıi«pZgf¤Nrq]§ĂN®«H±yƳí¾×ŊďŀĐÏŴǝĂíÀBŖÕªÁŐTFqĉ¯³ËCĕģi¨hÜ·ñt»¯Ï\",\"@@ºwZRkĕWK \"]],\"encodeOffsets\":[[[125785,31436],[125729,31431],[125513,31380],[125329,30690],[125223,30438],[125115,30114],[124815,29155],[124419,28746],[124095,28635],[124005,28609],[125000,30713],[125111,30698],[125078,30682],[125150,30684],[124014,28103],[125008,31331],[125411,31468],[125329,31479],[125369,31139],[125626,30916],[125417,30956],[125254,30976],[125199,30997],[125095,31058],[125083,30915],[124885,31015],[125218,30798],[124867,30838],[124755,30788],[124802,30809],[125267,30657],[125218,30578],[125200,30562],[125192,30787],[124968,30474],[125167,30396],[125115,30363],[124955,29879],[124714,29781],[124762,29462],[124325,28754],[124863,30077],[125366,31477]]]&#125;,\"properties\":&#123;\"cp\":[120.153576,30.287459],\"name\":\"浙江\",\"childNum\":43&#125;&#125;,&#123;\"id\":\"340000\",\"geometry\":&#123;\"type\":\"MultiPolygon\",\"coordinates\":[[\"@@^iuLV\\\\\",\"@@e©Edh\",\"@@´CE¶zAXêeödK¡~H¸íæAȽd&#123;ďÅÀ½W®£ChÃsikkly]_teu[bFaTign&#123;]GqªoĈMYá|·¥f¥őaSÕėNµñĞ«Im_m¿Âa]uĜp Z_§&#123;Cäg¤°r[_YjÆOdý[I[á·¥Q_nùgL¾mzˆDÜÆ¶ĊJhpc¹O]iŠ]¥ jtsggDÑ¡w×jÉ©±EFË­KiÛÃÕYvsm¬njĻª§emná&#125;k«ŕgđ²ÙDÇ¤í¡ªOy×Où±@DñSęćăÕIÕ¿IµĥOlJÕÍRÍ|JìĻÒåyķrĕq§ÄĩsWÆßF¶X®¿mwRIÞfßoG³¾©uyHį&#123;Ɓħ¯AFnuPÍÔzVdàôº^Ðæd´oG¤&#123;S¬ćxã&#125;ŧ×Kǥĩ«ÕOEÐ·ÖdÖsƘÑ¨[Û^Xr¢¼§xvÄÆµ`K§ tÒ´Cvlo¸fzŨð¾NY´ı~ÉĔēßúLÃÃ_ÈÏ|]ÂÏHlg`ben¾¢pUh~ƴĖ¶_r sĄ~cƈ]|r c~`¼&#123;À&#123;ȒiJjz`îÀT¥Û³]u&#125;fïQl&#123;skloNdjäËzDvčoQďHI¦rbrHĖ~BmlNRaĥTX\\\\&#123;fÁKÁ®TLÂÄMtÊgĀDĄXƔvDcÎJbt[¤D@®hh~kt°ǾzÖ@¾ªdbYhüóV´ŮŒ¨Üc±r@J|àuYÇÔG·ĚąĐlŪÚpSJ¨ĸLvÞcPæķŨ®mÐálsgd×mQ¨ųÆ©Þ¤IÎs°KZpĄ|XwWdĎµmkǀwÌÕæhºgBĝâqÙĊzÖgņtÀÁĂÆáhEz|WzqD¹°Eŧl&#123;ævÜcA`¤C`|´qxĲkq^³³GšµbíZ¹qpa±ď OH¦Ħx¢gPícOl_iCveaOjChß¸iÝbÛªCC¿mRV§¢A|tbkĜEÀtîm^g´fÄ\"]],\"encodeOffsets\":[[[121722,32278],[119475,30423],[121606,33646]]]&#125;,\"properties\":&#123;\"cp\":[117.283042,31.86119],\"name\":\"安徽\",\"childNum\":3&#125;&#125;,&#123;\"id\":\"350000\",\"geometry\":&#123;\"type\":\"MultiPolygon\",\"coordinates\":[[\"@@zht´&#125;[\",\"@@aj^~ĆGå\",\"@@edHse\",\"@@@vPGsyQ\",\"@@sBzddW[O\",\"@@S¨Qy\",\"@@NVucW\",\"@@qptB@q\",\"@@¸[iu\",\"@@Q\\\\pD[_\",\"@@jSwUappI\",\"@@eXª~\",\"@@AjvFoo\",\"@@fT_Çí\\\\v|ba¦jZÆy|®\",\"@@IjLg\",\"@@wJIx«¼AoNe&#123;M¥\",\"@@K±¡ÓČ~N¾\",\"@@k¡¹Eh~c®uDqZì¡I~Māe£bN¨gZý¡a±Öcp©PhI¢QqÇGj|¥U g[Ky¬ŏv@OptÉEF\\\\@ åA¬V&#123;XģĐBycpě¼³Ăp·¤¥ohqqÚ¡ŅLs^Ã¡§qlÀhH¨MCe»åÇGD¥zPO£čÙkJA¼ßėuĕeûÒiÁŧS[¡Uûŗ½ùěcÝ§SùĩąSWó«íęACµeRåǃRCÒÇZÍ¢ź±^dlstjD¸ZpuÔâÃH¾oLUêÃÔjjēò´ĄWƛ^Ñ¥Ħ@ÇòmOw¡õyJyD&#125;¢ďÑÈġfZda©º²z£NjD°Ötj¶¬ZSÎ~¾c°¶ÐmxO¸¢Pl´SL|¥AȪĖMņĲg®áIJČĒü` QF¬h|ĂJ@zµ |ê³È ¸UÖŬŬÀCtrĸr]ðM¤ĶĲHtÏ AĬkvsq^aÎbvdfÊòSD´Z^xPsĂrvƞŀjJd×ŘÉ ®AÎ¦ĤdxĆqAZRÀMźnĊ»İÐZ YXæJyĊ²·¶q§·K@·&#123;sXãô«lŗ¶»o½E¡­«¢±¨Y®Ø¶^AvWĶGĒĢPlzfļtàAvWYãO_¤sD§ssČġ[kƤPX¦`¶®BBvĪjv©jx[L¥àï[F¼ÍË»ğV`«Ip&#125;ccÅĥZEãoP´B@D¸m±z«Ƴ¿å³BRØ¶Wlâþäą`]Z£Tc ĹGµ¶Hm@_©k¾xĨôȉðX«½đCIbćqK³ÁÄš¬OAwã»aLŉËĥW[ÂGIÂNxĳ¤D¢îĎÎB§°_JGs¥E@¤ućPåcuMuw¢BI¿]zG¹guĮI\"]],\"encodeOffsets\":[[[123250,27563],[122541,27268],[123020,27189],[122916,27125],[122887,26845],[122808,26762],[122568,25912],[122778,26197],[122515,26757],[122816,26587],[123388,27005],[122450,26243],[122578,25962],[121255,25103],[120987,24903],[122339,25802],[121042,25093],[122439,26024]]]&#125;,\"properties\":&#123;\"cp\":[119.306239,26.075302],\"name\":\"福建\",\"childNum\":18&#125;&#125;,&#123;\"id\":\"360000\",\"geometry\":&#123;\"type\":\"Polygon\",\"coordinates\":[\"@@ÖP¬ǦĪØLŨä~Ĉw«|TH£pc³Ïå¹]ĉđxe&#123;ÎÓvOEm°BƂĨİ|Gvz½ª´HàpeJÝQxnÀW­EµàXÅĪt¨ÃĖrÄwÀFÎ|Ă¡WÕ¸cf¥XaęST±m[r«_gmQu~¥V\\\\OkxtL E¢Ú^~ýØkbēqoě±_Êw§Ñ²ÏƟė¼mĉŹ¿NQYBąrwģcÍ¥B­ŗÊcØiIƝĿuqtāwO]³YCñTeÉcaubÍ]trluīBÐGsĵıN£ï^ķqsq¿DūūVÕ·´Ç&#123;éĈýÿOER_đûIċâJh­ŅıNȩĕB¦K&#123;Tk³¡OP·wnµÏd¯&#125;½TÍ«YiµÕsC¯iM¤­¦¯P|ÿUHvhe¥oFTuõ\\\\OSsMòđƇiaºćXĊĵà·çhƃ÷Ç&#123;ígu^đgm[ÙxiIN¶Õ»lđÕwZSÆv©_ÈëJbVkĔVÀ¤P¾ºÈMÖxlò~ªÚàGĂ¢B±ÌKyñ`w²¹·`gsÙfIěxŕeykpudjuTfb·hh¿Jd[\\\\LáƔĨƐAĈepÀÂMD~ņªe^\\\\^§ý©j×cZØ¨zdÒa¶lÒJìõ`oz÷@¤uŞ¸´ôęöY¼HČƶajlÞƩ¥éZ[|h&#125;^U  ¥pĄžƦO lt¸Æ Q\\\\aÆ|CnÂOjt­ĚĤdÈF`¶@Ðë ¦ōÒ¨SêvHĢÛ@[ÆQoxHW[ŰîÀt¦Ǆ~NĠ¢lĄtZoCƞÔºCxrpČNpj¢&#123;f_Y`_eq®Aot`@oDXfkp¨|s¬\\\\DÄSfè©Hn¬^DhÆyøJhØxĢĀLÊƠPżċĄwĮ¶\"],\"encodeOffsets\":[[118923,30536]]&#125;,\"properties\":&#123;\"cp\":[115.892151,28.676493],\"name\":\"江西\",\"childNum\":1&#125;&#125;,&#123;\"id\":\"370000\",\"geometry\":&#123;\"type\":\"MultiPolygon\",\"coordinates\":[[\"@@Xjd]mE\",\"@@itnq\",\"@@Dl@k\",\"@@TGw\",\"@@K¬U\",\"@@Wd`c\",\"@@PtMs\",\"@@LnXlc\",\"@@ppVu]Qn\",\"@@cdzAU_\",\"@@udRhnCE\",\"@@oIpP\",\"@@M&#123;ĿčwbxƨîKÎMĮ]ZF½Y]â£ph¶¨râøÀÎǨ¤^ºÄGz~grĚĜlĞÆLĆǆ¢Îo¦cvKbgr°WhmZp L]LºcUÆ­nżĤÌĒbAnrOA´ȊcÀbƦUØrĆUÜøĬƞŶǬĴóò_A̈«ªdÎÉnb²ĦhņBĖįĦåXćì@L¯´ywƕCéÃµė ƿ¸lµZæyj|BíÂKNNnoƈfÈMZwnŐNàúÄsTJULîVjǎ¾ĒØDz²XPn±ŴPè¸ŔLƔÜƺ_TüÃĤBBċÈöA´faM¨&#123;«M`¶d¡ôÖ°mȰBÔjj´PM|c^d¤u¤Û´ä«ƢfPk¶Môl]Lb&#125;su^ke&#123;lCMrDÇ­]NÑFsmoõľHyGă&#123;&#123;çrnÓEƕZGª¹Fj¢ÿ©&#125;ÌCǷë¡ąuhÛ¡^KxC`C\\\\bÅxì²ĝÝ¿_NīCȽĿåB¥¢·IŖÕy\\\\¹kxÃ£ČáKµË¤ÁçFQ¡KtŵƋ]CgÏAùSedcÚźuYfyMmhUWpSyGwMPqŀÁ¼zK¶G­Y§Ë@´śÇµƕBm@IogZ¯uTMx&#125;CVKï&#123;éƵP_K«pÛÙqċtkkù]gTğwoɁsMõ³ăAN£MRkmEÊčÛbMjÝGuIZGPģãħE[iµBEuDPÔ~ª¼ęt]ûG§¡QMsğNPŏįzs£Ug&#123;đJĿļā³]ç«Qr~¥CƎÑ^n¶ÆéÎR~Ż¸YI] PumŝrƿIā[xeÇ³L¯v¯s¬ÁY~&#125;ťuŁgƋpÝĄ_ņī¶ÏSR´ÁP~¿Cyċßdwk´SsX|t`Ä ÈðAªìÎT°¦Dda^lĎDĶÚY°`ĪŴǒàŠv\\\\ebZHŖR¬ŢƱùęOÑM­³FÛaj\"]],\"encodeOffsets\":[[[123806,39303],[123821,39266],[123742,39256],[123702,39203],[123649,39066],[123847,38933],[123580,38839],[123894,37288],[123043,36624],[123344,38676],[123522,38857],[123628,38858],[118267,36772]]]&#125;,\"properties\":&#123;\"cp\":[117.000923,36.675807],\"name\":\"山东\",\"childNum\":13&#125;&#125;,&#123;\"id\":\"410000\",\"geometry\":&#123;\"type\":\"MultiPolygon\",\"coordinates\":[[\"@@dXD&#125;~Hgq~ÔN~zkĘHVsǲßjŬŢ`Pûàl¢\\\\ÀEhİgÞē X¼`khÍLùµP³swIÓzeŠĠð´E®ÚPtºIŊÊºL«šŕQGYfa[şußǑĩų_Z¯ĵÙčC]kbc¥CS¯ëÍB©ïÇÃ_&#123;sWTt³xlàcČzÀD&#125;ÂOQ³ÐTĬµƑÐ¿ŸghłŦv~&#125;ÂZ«¤lPÇ£ªÝŴÅR§ØnhctâknÏ­ľŹUÓÝdKuķI§oTũÙďkęĆH¸Ó\\\\Ä¿PcnS&#123;wBIvÉĽ[GqµuŇôYgûZca©@½Õǽys¯&#125;lgg@­C\\\\£asIdÍuCQñ[L±ęk·ţb¨©kK»KC²òGKmĨS`UQnk&#125;AGēsqaJ¥ĐGRĎpCuÌy ã iMcplk|tRkðev~^´¦ÜSí¿_iyjI|ȑ|¿_»d&#125;q^&#123;Ƈdă&#125;tqµ`ŷé£©V¡om½ZÙÏÁRD|JOÈpÀRsI&#123;ùÓjuµ&#123;t&#125;uËRivGçJFjµåkWê´MÂHewixGw½Yŷpµú³XU½ġyłåkÚwZX·l¢Á¢KzOÎÎjc¼htoDHr|­J½&#125;JZ_¯iPq&#123;tę½ĕ¦Zpĵø«kQĹ¤]MÛfaQpě±ǽ¾]u­Fu÷nčÄ¯ADp&#125;AjmcEÇaª³o³ÆÍSƇĈÙDIzçñİ^KNiÞñ[aA²zzÌ÷D|[íÄ³gfÕÞd®|`Ć~oĠƑô³ŊD×°¯CsøÂ«ìUMhTº¨¸ǝêWÔDruÂÇZ£ĆPZW~ØØv¬gèÂÒw¦X¤Ā´oŬ¬²Ês~]®tªapŎJ¨Öº_ŔfŐ\\\\Đ\\\\Ĝu~m²Ƹ¸fWĦrƔ&#125;Î^gjdfÔ¡J&#125;\\\\n C¦þWxªJRÔŠu¬ĨĨmFdM&#123;\\\\d\\\\YÊ¢ú@@¦ª²SÜsC&#125;fNècbpRmlØ^gd¢aÒ¢CZZxvÆ¶N¿¢T@uC¬^ĊðÄn|lIlXhun[\",\"@@hzUq\"]],\"encodeOffsets\":[[[116744,37216],[116480,33048]]]&#125;,\"properties\":&#123;\"cp\":[113.665412,34.757975],\"name\":\"河南\",\"childNum\":2&#125;&#125;,&#123;\"id\":\"420000\",\"geometry\":&#123;\"type\":\"MultiPolygon\",\"coordinates\":[[\"@@ASd\",\"@@ls&#123;d\",\"@@¾«&#125;&#123;ra®pîÃ\\\\&#123;øCËyyB±b\\\\òÝjKL ]ĎĽÌJyÚCƈćÎT´Å´pb©ÈdFin~BCo°BĎÃømv®E^vǾ½Ĝ²RobÜeN^ĺ£R¬lĶ÷YoĖ¥Ě¾|sOr°jY`~I¾®I&#123;GqpCgyl&#123;£ÍÍyPLÂ¡¡¸kWxYlÙæŁĢz¾V´W¶ùŸo¾ZHxjwfxGNÁ³Xéæl¶EièIH ujÌQ~v|sv¶Ôi|ú¢FhQsğ¦SiŠBgÐE^ÁÐ&#123;čnOÂÈUÎóĔÊēĲ&#125;Z³½Mŧïeyp·uk³DsÑ¨L¶_ÅuÃ¨w»¡WqÜ]\\\\Ò§tƗcÕ¸ÕFÏǝĉăxŻČƟOKÉġÿ×wg÷IÅzCg]m«ªGeçÃTC«[t§&#123;loWeC@ps_Bp­rf_``Z|ei¡oċMqow¹DƝÓDYpûsYkıǃ&#125;s¥ç³[§cY§HK«Qy]¢wwö¸ïx¼ņ¾Xv®ÇÀµRĠÐHM±cÏdƒǍũȅȷ±DSyúĝ£ŤĀàtÖÿï[îb\\\\&#125;pĭÉI±Ñy¿³x¯No|¹HÏÛmjúË~TuęjCöAwě¬Rđl¯ Ñb­ŇTĿ_[IčĄʿnM¦ğ\\\\É[T·k¹©oĕ@A¾wya¥Y\\\\¥Âaz¯ãÁ¡k¥ne£ÛwE©Êō¶˓uoj_U¡cF¹­[WvP©whuÕyBF`RqJUw\\\\i¡&#123;jEPïÿ½fćQÑÀQ&#123;°fLÔ~wXgītêÝ¾ĺHd³fJd]HJ²EoU¥HhwQsƐ»Xmg±çve]DmÍPoCc¾_hhøYrŊU¶eD°Č_N~øĹĚ·`z]Äþp¼äÌQv\\\\rCé¾TnkžŐÚÜa¼ÝƆĢ¶ÛodĔňÐ¢JqPb ¾|J¾fXƐîĨ_Z¯À&#125;úƲN_ĒÄ^ĈaŐyp»CÇÄKñL³ġM²wrIÒŭxjb[n«øæà ^²­h¯ÚŐªÞ¸Y²ĒVø&#125;Ā^İ´LÚm¥ÀJÞ&#123;JVųÞŃx×sxxƈē ģMřÚðòIfĊŒ\\\\Ʈ±ŒdÊ§ĘDvČ_Àæ~Dċ´A®µ¨ØLV¦êHÒ¤\"]],\"encodeOffsets\":[[[113712,34000],[115612,30507],[113649,34054]]]&#125;,\"properties\":&#123;\"cp\":[114.298572,30.584355],\"name\":\"湖北\",\"childNum\":3&#125;&#125;,&#123;\"id\":\"430000\",\"geometry\":&#123;\"type\":\"MultiPolygon\",\"coordinates\":[[\"@@nFZw\",\"@@ãÆá½ÔXrCOËRïÿĩ­TooQyÓ[ŅBE¬ÎÓXaį§Ã¸G °ITxpúxÚĳ¥ÏĢ¾edÄ©ĸGàGhM¤Â_U&#125;Ċ&#125;¢pczfþg¤ÇôAV\",\"@@ȴÚĖÁĐiOĜ«BxDõĚivSÌ&#125;iùÜnÐºG&#123;p°M°yÂÒzJ²Ì ÂcXëöüiáÿñőĞ¤ùTz²CȆȸǎŪƑÐc°dPÎğË¶[È½u¯½WM¡­ÉB·rínZÒ `¨GA¾\\\\pēXhÃRC­üWGġuTé§ŎÑ©êLM³&#125;_EÇģc®ęisÁPDmÅ&#123;b[RÅs·kPŽƥóRoOV~]&#123;g\\\\êYƪ¦kÝbiċƵGZ»Ěõó·³vŝ£ø@pyö_ëIkÑµbcÑ§y×dYØªiþUjŅ³C&#125;ÁN»hĻħƏâƓKA·³CQ±µ§¿AUƑ¹AtćOwD]JUÖgk¯b£ylZFËÑ±H­&#125;EbóľA¡»Ku¦·³åş¥ùBD^&#123;ÌC´­¦ŷJ£^[ª¿ğ|ƅN skóā¹¿ï]ă~÷O§­@Vm¡Qđ¦¢Ĥ&#123;ºjÔª¥nf´~Õo×ÛąGû¥cÑ[Z¶ŨĪ²SÊǔƐƀAÚŌ¦QØ¼rŭ­«&#125;NÏürÊ¬mjr@ĘrTW ­SsdHzƓ^ÇÂyUi¯DÅYlŹu&#123;hT&#125;mĉ¹¥ěDÿë©ıÓ[Oº£¥ótł¹MÕƪ`PDiÛU¾ÅâìUñBÈ£ýhedy¡oċ`pfmjP~kZaZsÐd°wj§@Ĵ®w~^kÀÅKvNmX\\\\¨aŃqvíó¿F¤¡@ũÑVw&#125;S@j&#125;¾«pĂrªg àÀ²NJ¶¶DôK|^ª°LX¾ŴäPĪ±£EXd^¶ĲÞÜ~u¸ǔMRhsRe`ÄofIÔ\\\\Ø ićymnú¨cj ¢»GČìƊÿÐ¨XeĈĀ¾Oð Fi ¢|[jVxrIQ_EzAN¦zLU`cªxOTu RLÄªpUĪȴ^ŎµªÉFxÜf¤ºgĲèy°Áb[¦Zb¦z½xBĖ@ªpºjS´rVźOd©ʪiĎăJP`\"]],\"encodeOffsets\":[[[115640,30489],[112577,27316],[114113,30649]]]&#125;,\"properties\":&#123;\"cp\":[112.982279,28.19409],\"name\":\"湖南\",\"childNum\":3&#125;&#125;,&#123;\"id\":\"440000\",\"geometry\":&#123;\"type\":\"MultiPolygon\",\"coordinates\":[[\"@@QdAsa\",\"@@lxDRm\",\"@@sbhNLo\",\"@@Ă ý\",\"@@WltOY[\",\"@@Kr]S\",\"@@e~AS&#125;\",\"@@I|Mym\",\"@@Û³LS²Q\",\"@@nvºBë¥cÕº\",\"@@zdÛJm\",\"@@°³\",\"@@a yAª¸ËJIxØ@ĀHÉÕZofoo\",\"@@sŗÃÔėAƁZÄ ~°ČPºb\",\"@@¶ÝÌvmĞh¹Ĺ\",\"@@HdSjĒ¢D&#125;waru«ZqadY&#123;K\",\"@@el\\\\LqqO\",\"@@~rMmX\",\"@@f^E\",\"@@øPªoj÷ÍÝħXČx°Q¨ıXJp\",\"@@gÇƳmxatfu\",\"@@EÆC½\",\"@@¸B_¶ekWvSivc&#125;p&#125;Ăº¾NĎyj¦Èm th_®Ä&#125;»âUzLË²Aā¡ßH©Ùñ&#125;wkNÕ¹ÇO½¿£ēUlaUìIÇª`uTÅxYĒÖ¼kÖµMjJÚwn\\\\hĒv]îh|ÈƄøèg¸Ķß ĉĈWb¹ƀdéĘNTtP[öSvrCZaGubo´ŖÒÇĐ~¡zCIözx¢PnÈñ @ĥÒ¦]ƜX³ăĔñiiÄÓVépKG½ÄÓávYoC·sitiaÀyŧÎ¡ÈYDÑům&#125;ý|m[węõĉZÅxUO&#125;÷N¹³ĉo_qtăqwµŁYÙǝŕ¹tïÛUÃ¯mRCºĭ|µÕÊK½Rē ó]GªęAxNqSF|ām¡diď×YïYWªŉOeÚtĐ«zđ¹TāúEáÎÁWwíHcòßÎſ¿Çdğ·ùT×Çūʄ¡XgWÀǇğ·¿ÃOj YÇ÷Sğ³kzőõmĝ[³¡VÙæÅöMÌ³¹pÁaËýý©D©ÜJŹƕģGą¤&#123;ÙūÇO²«BƱéAÒĥ¡«BhlmtÃPµyU¯ucd·w_bŝcīímGOGBȅŹãĻFŷŽŕ@Óoo¿ē±ß&#125;&#125;ÓF÷tĲWÈCőâUâǙIğŉ©IĳE×Á³AĥDĈ±ÌÜÓĨ£L]ĈÙƺZǾĆĖMĸĤfÎĵlŨnÈĐtFFĤêk¶^k°f¶g&#125;®Faf`vXŲxl¦ÔÁ²¬Ð¦pqÊÌ²iXØRDÎ&#125;Ä@ZĠsx®AR~®ETtĄZƈfŠŠHâÒÐAµ\\\\S¸^wĖkRzalŜ|E¨ÈNĀňZTpBh£\\\\ĎƀuXĖtKL¶G|»ĺEļĞ~ÜĢÛĊrOÙîvd]n¬VÊĜ°RÖpMƀ¬HbwEÀ©\\\\¤]ŸI®¥D³|Ë]CúAŠ¦æ´¥¸Lv¼¢ĽBaôF~®²GÌÒEYzk¤°ahlVÕI^CxĈPsBƒºVÀB¶¨R²´D\",\"@@OR\"]],\"encodeOffsets\":[[[117381,22988],[116552,22934],[116790,22617],[116973,22545],[116444,22536],[116931,22515],[116496,22490],[116453,22449],[113301,21439],[118726,21604],[118709,21486],[113210,20816],[115482,22082],[113171,21585],[113199,21590],[115232,22102],[115739,22373],[115134,22184],[113056,21175],[119573,21271],[119957,24020],[115859,22356],[116680,26053],[116561,22649]]]&#125;,\"properties\":&#123;\"cp\":[113.280637,23.125178],\"name\":\"广东\",\"childNum\":24&#125;&#125;,&#123;\"id\":\"450000\",\"geometry\":&#123;\"type\":\"MultiPolygon\",\"coordinates\":[[\"@@H TI¡U\",\"@@Ɣ_LÊFZgčP­kini«qÇczÍY®¬Ů»qR×ō©DÕ§ƙǃŵTÉĩ±ıdÑnYYĲvNĆĆØÜ Öp&#125;e³¦m©iÓ|¹ħņ|ª¦QF¢Â¬ʖovg¿em^ucäāmÇÖåB¡Õçĝ&#125;FĻ¼Ĺ&#123;µHKsLSđƃrč¤[AgoSŇYMÿ§Ç&#123;FśbkylQxĕ]T·¶[BÑÏGáşşƇeăYSs­FQ&#125;­BwtYğÃ@~CÍQ ×WjË±rÉ¥oÏ ±«ÓÂ¥kwWűue_b­E~µh¯ecl¯Ïr¯EģJğ&#125;w³Ƈē`ãògK_ÛsUʝćğ¶höO¤Ǜn³c`¡yię[ďĵűMę§]XÎ_íÛ]éÛUćİÕBƣ±dy¹T^dûÅÑŦ·PĻþÙ`K¦¢ÍeĥR¿³£[~äu¼dltW¸oRM¢ď\\\\z&#125;Æzdvň&#123;ÎXF¶°Â_ÒÂÏL©ÖTmu¼ãlīkiqéfA·Êµ\\\\őDc¥ÝFyÔćcűH_hLÜêĺĐ¨c&#125;rn`½Ì@¸¶ªVLhŒ\\\\Ţĺk~Ġið°|gtTĭĸ^xvKVGréAébUuMJVÃO¡qĂXËSģãlýà_juYÛÒBG^éÖ¶§EGÅzěƯ¤EkN[kdåucé¬dnYpAyČ&#123;`]þ±X\\\\ÞÈk¡ĬjàhÂƄ¢Hè ŔâªLĒ^Öm¶ħĊAǦė¸zÚGn£¾rªŀÜt¬@ÖÚSx~øOŒŶÐÂæȠ\\\\ÈÜObĖw^oÞLf¬°bI lTØBÌF£Ć¹gñĤaYt¿¤VSñK¸¤nM¼JE±½¸ñoÜCƆæĪ^ĚQÖ¦^f´QüÜÊz¯lzUĺš@ìp¶n]sxtx¶@~ÒĂJb©gk&#123;°~c°`Ô¬rV\\\\la¼¤ôá`¯¹LCÆbxEræOv[H­[~|aB£ÖsºdAĐzNÂðsÞÆĤªbab`ho¡³F«èVZs\\\\\\\\ÔRzpp®SĪº¨ÖºNĳd`a¦¤F³¢@`¢ĨĀìhYvlĆº¦Ċ~nS|gźv^kGÆÀè·\"]],\"encodeOffsets\":[[[111707,21520],[113706,26955]]]&#125;,\"properties\":&#123;\"cp\":[108.320004,22.82402],\"name\":\"广西\",\"childNum\":2&#125;&#125;,&#123;\"id\":\"460000\",\"geometry\":&#123;\"type\":\"Polygon\",\"coordinates\":[\"@@¦Ŝil¢XƦƞòïè§ŞCêɕrŧůÇąĻõ·ĉ³œ̅kÇm@ċȧŧĥĽʉ­ƅſȓÒË¦ŝE&#125;ºƑ[ÍĜȋ gÎfǐÏĤ¨êƺ\\\\Ɔ¸ĠĎvʄȀÐ¾jNðĀÒRZǆzÐĊ¢DÀɘZ\"],\"encodeOffsets\":[[112750,20508]]&#125;,\"properties\":&#123;\"cp\":[110.33119,20.031971],\"name\":\"海南\",\"childNum\":1&#125;&#125;,&#123;\"id\":\"510000\",\"geometry\":&#123;\"type\":\"MultiPolygon\",\"coordinates\":[[\"@@LqSn\",\"@@ĆOìÛÐ@ĞǔNY&#123;¤Á§di´ezÝúØãwIþËQÇ¦ÃqÉSJ»ĂéʔõÔƁİlƞ¹§ĬqtÀƄmÀêErĒtD®ċæcQE®³^ĭ¥©l&#125;äQtoŖÜqÆkµªÔĻĴ¡@Ċ°B²Èw^^RsºTĀ£ŚæQPJvÄz^Đ¹Æ¯fLà´GC²dt­ĀRt¼¤ĦOðğfÔðDŨŁĞƘïPÈ®âbMüÀXZ ¸£@Å»»QÉ­]dsÖ×_Í_ÌêŮPrĔĐÕGĂeZÜîĘqBhtO ¤tE[h|YÔZśÎs´xº±Uñt|OĩĠºNbgþJy^dÂY Į]Řz¦gC³R`Āz¢Aj¸CL¤RÆ»@­Ŏk\\\\Ç´£YW&#125;z@Z&#125;Ã¶oû¶]´^NÒ&#125;èNªPÍy¹`S°´ATeVamdUĐwʄvĮÕ\\\\uÆŗ¨Yp¹àZÂmWh&#123;á&#125;WØǍÉüwga§ßAYrÅÂQĀÕ¬LŐý®Xøxª½Ű¦¦[þ`ÜUÖ´òrÙŠ°²ÄkĳnDX&#123;U~ET&#123;ļº¦PZcjF²Ė@pg¨B&#123;u¨ŦyhoÚD®¯¢ WòàFÎ¤¨GDäz¦kŮPġqË¥À]eâÚ´ªKxīPÖ|æ[xÃ¤JÞĥsNÖ½I¬nĨY´®ÐƐmDŝuäđđEbee_v¡&#125;ìęǊē&#125;qÉåT¯µRs¡M@&#125;ůaa­¯wvƉåZw\\\\Z&#123;åû`[±oiJDÅ¦]ĕãïrG réÏ·~ąSfy×Í·ºſƽĵȁŗūmHQ¡Y¡®ÁÃ×t«­T¤JJJyJÈ`Ohß¦¡uËhIyCjmÿwZGTiSsOB²fNmsPa&#123;M&#123;õE^Hj&#125;gYpaeu¯oáwHjÁ½M¡pMuåmni&#123;fk\\\\oÎqCwEZ¼KĝAy&#123;m÷LwO×SimRI¯rKõBS«sFe]fµ¢óY_ÆPRcue°Cbo×bd£ŌIHgtrnyPt¦foaXďxlBowz_&#123;ÊéWiêEGhÜ¸ºuFĈIxf®Y½ĀǙ]¤EyF²ċw¸¿@g¢§RGv»áW`ÃĵJwi]t¥wO­½a[×]`Ãi­üL¦LabbTÀåc&#125;ÍhÆh®BHî|îºÉk­¤Sy£ia©taį·Ɖ`ō¥UhOĝLk&#125;©Fos´JmµlŁuønÑJWÎªYÀïAetTŅÓGË«bo&#123;ıwodƟ½OġÜÂµxàNÖ¾P²§HKv¾]|BÆåoZ`¡Ø`ÀmºĠ~ÌÐ§nÇ¿¤]wğ@srğu~Io[é±¹ ¿ſđÓ@qg¹zƱřaí°KtÇ¤V»Ã[ĩǭƑ^ÇÓ@áťsZÏÅĭƋěpwDóÖáŻneQËq·GCœýS]x·ýq³OÕ¶Qzßti&#123;řáÍÇWŝŭñzÇWpç¿JXĩè½cFÂLiVjx&#125;\\\\NŇĖ¥GeJA¼ÄHfÈu~¸Æ«dE³ÉMA|bÒćhG¬CMõƤąAvüVéŀ_VÌ³ĐwQj´·ZeÈÁ¨X´Æ¡Qu·»ÕZ³ġqDoy`L¬gdp°şp¦ėìÅĮZ°Iähzĵf²å ĚÑKpIN|Ñz]ń·FU×é»R³MÉ»GM«kiér&#125;Ã`¹ăÞmÈnÁîRǀ³ĜoİzŔwǶVÚ£À]ɜ»ĆlƂ²ĠþTº·àUȞÏʦ¶I«dĽĢdĬ¿»Ĕ×h\\\\c¬ä²GêëĤł¥ÀǿżÃÆMº&#125;BÕĢyFVvwxBèĻĒ©Ĉt@Ğû¸£B¯¨ˋäßkķ½ªôNÔ~t¼Ŵu^s¼&#123;TA¼ø°¢İªDè¾Ň¶ÝJ®Z´ğ~Sn|ªWÚ©òzPOȸbð¢|øĞA\"]],\"encodeOffsets\":[[[108815,30935],[100197,35028]]]&#125;,\"properties\":&#123;\"cp\":[104.065735,30.659462],\"name\":\"四川\",\"childNum\":2&#125;&#125;,&#123;\"id\":\"520000\",\"geometry\":&#123;\"type\":\"MultiPolygon\",\"coordinates\":[[\"@@G\\\\lY£cj\",\"@@q|mc¯vÏV\",\"@@hÑ£IsNgßHHªķÃh_¹¡ĝÄ§ń¦uÙùgS¯JH|sÝÅtÁïyMDč»eÕtA¤&#123;b\\\\&#125;G®u\\\\åPFqwÅaDK°ºâ_£ùbµmÁÛĹM[q|hlaªāI&#125;Ñµ@swtwm^oµDéĽŠyVky°ÉûÛR³e¥]RÕěħ[ƅåÛDpJiVÂF²I»mN·£LbÒYbWsÀbpkiTZĄă¶Hq`ĥ_J¯ae«KpÝx]aĕÛPÇȟ[ÁåŵÏő÷Pw&#125;TÙ@Õs«ĿÛq©½m¤ÙH·yǥĘĉBµĨÕnđ]K©œáGçş§ÕßgǗĦTèƤƺ&#123;¶ÉHÎd¾ŚÊ·OÐjXWrãLyzÉAL¾ę¢bĶėy_qMĔąro¼hĊw¶øV¤w²Ĉ]ÊKx|`ź¦ÂÈdrcÈbe¸`I¼čTF´¼Óýȃr¹ÍJ©k_șl³´_pĐ`oÒh¶pa^ÓĔ&#125;D»^Xy`d[KvJPhèhCrĂĚÂ^Êƌ wZL­Ġ£ÁbrzOIlMMĪŐžËr×ÎeŦtw|¢mKjSǘňĂStÎŦEtqFT¾Eì¬¬ôxÌO¢ K³ŀºäYPVgŎ¦ŊmŞ¼VZwVlz¤£Tl®ctĽÚó&#123;G­AÇge~Îd¿æaSba¥KKûj®_Ä^\\\\Ø¾bP®¦x^sxjĶI_Ä Xâ¼Hu¨Qh¡À@Ëô&#125;±GNìĎlT¸`V~R°tbÕĊ`¸úÛtÏFDu[MfqGH·¥yAztMFe|R_GkChZeÚ°tov`xbDnÐ&#123;E&#125;ZèxNEÞREn[Pv@&#123;~rĆAB§EO¿|UZ~ìUf¨J²ĂÝÆsªB`s¶fvö¦Õ~dÔq¨¸º»uù[[§´sb¤¢zþF¢ÆÀhÂW\\\\ıËIÝo±ĭŠ£þÊs&#125;¡R]ěDg´VG¢j±®èºÃmpU[Áëº°rÜbNu¸&#125;º¼`niºÔXĄ¤¼ÔdaµÁ_ÃftQQgR·Ǔv&#125;Ý×ĵ]µWc¤F²OĩųãW½¯K©]&#123;LóµCIµ±Mß¿h©āq¬o½~@i~TUxð´Đhw­ÀEîôuĶb[§nWuMÆJl½]vuıµb\"]],\"encodeOffsets\":[[[112158,27383],[112105,27474],[112095,27476]]]&#125;,\"properties\":&#123;\"cp\":[106.713478,26.578343],\"name\":\"贵州\",\"childNum\":3&#125;&#125;,&#123;\"id\":\"530000\",\"geometry\":&#123;\"type\":\"Polygon\",\"coordinates\":[\"@@[ùx½&#125;ÑRHYīĺûsÍniEoã½Ya²ė&#123;c¬ĝgĂsAØÅwďõzFjw&#125;«Dx¿&#125;Uũlê@HÅ­F¨ÇoJ´Ónũuą¡Ã¢pÒÅØ TF²xa²ËXcÊlHîAßËŁkŻƑŷÉ©hW­æßUËs¡¦&#125;teèÆ¶StÇÇ&#125;Fd£jĈZĆÆ¤Tč\\\\D&#125;O÷£U§~ŃGåŃDĝ¸Tsd¶¶Bª¤u¢ŌĎo~t¾ÍŶÒtD¦ÚiôözØX²ghįh½Û±¯ÿm·zR¦Ɵ`ªŊÃh¢rOÔ´£Ym¼èêf¯ŪĽncÚbw\\\\zlvWªâ ¦gmĿBĹ£¢ƹřbĥkǫßeeZkÙIKueT»sVesbaĕ ¶®dNĄÄpªy¼³BE®lGŭCǶwêżĔÂepÍÀQƞpC¼ŲÈ­AÎô¶RäQ^Øu¬°_Èôc´¹ò¨PÎ¢hlĎ¦´ĦÆ´sâÇŲPnÊD^¯°Upv&#125;®BPÌªjǬxSöwlfòªvqĸ|`H­viļndĜ­Ćhňem·FyÞqóSį¯³X_ĞçêtryvL¤§z¦c¦¥jnŞklD¤øz½ĜàĂŧMÅ|áƆàÊcðÂFÜáŢ¥\\\\\\\\ºİøÒÐJĴîD¦zK²ǏÎEh~CD­hMn^ÌöÄ©ČZÀaüfɭyœpį´ěFűk]Ôě¢qlÅĆÙa¶~ÄqêljN¬¼HÊNQ´ê¼VØ¸E^ŃÒyM&#123;JLoÒęæe±Ķygã¯JYÆĭĘëo¥Šo¯hcK«z_prC´ĢÖY¼ v¸¢RÅW³Â§fÇ¸Yi³xR´ďUË`êĿUûuĆBƣöNDH«ĈgÑaB&#123;ÊNF´¬c·Åv&#125;eÇÃGB»If¦HňĕM~[iwjUÁKE¾dĪçWIèÀoÈXòyŞŮÈXâÎŚj|àsRyµÖPr´þ ¸^wþTDŔHr¸RÌmfżÕâCôoxĜƌÆĮÐYtâŦÔ@]ÈǮƒ\\\\Ī¼Ä£UsÈ¯LbîƲŚºyhr@ĒÔƀÀ²º\\\\êpJ&#125;ĠvqtĠ@^xÀ£È¨mËÏğ&#125;n¹_¿¢×Y_æpÅA^&#123;½Lu¨GO±Õ½ßM¶wÁĢÛPƢ¼pcĲx|apÌ¬HÐŊSfsðBZ¿©XÏÒKk÷Eû¿SrEFsÕūkóVǥŉiTL¡n&#123;uxţÏhôŝ¬ğōNNJkyPaqÂğ¤K®YxÉƋÁ]āęDqçgOgILu\\\\_gz]W¼~CÔē]bµogpÑ_oď`´³Țkl`IªºÎȄqÔþ»E³ĎSJ»_f·adÇqÇc¥Á_Źw&#123;L^É±ćxU£µ÷xgĉp»ĆqNē`rĘzaĵĚ¡K½ÊBzyäKXqiWPÏÉ¸½řÍcÊG|µƕƣGË÷k°_^ý|_zċBZocmø¯hhcæ\\\\lMFlư£ĜÆyHF¨µêÕ]HAàÓ^it `þßäkĤÎT~Wlÿ¨ÔPzUCNVv [jâôDôď[&#125;z¿msSh¯&#123;jïğl&#125;šĹ[őgK©U·µË@¾m_~q¡f¹ÅË^»f³ø&#125;Q¡ÖË³gÍ±^Ç\\\\ëÃA_¿bWÏ[¶ƛé£F&#123;īZgm@|kHǭƁć¦UĔť×ëǟeċ¼ȡȘÏíBÉ£āĘPªĳ¶ŉÿy©nď£G¹¡I±LÉĺÑdĉÜW¥&#125;gÁ&#123;aqÃ¥aıęÏZÁ`\"],\"encodeOffsets\":[[104636,22969]]&#125;,\"properties\":&#123;\"cp\":[102.712251,25.040609],\"name\":\"云南\",\"childNum\":1&#125;&#125;,&#123;\"id\":\"540000\",\"geometry\":&#123;\"type\":\"Polygon\",\"coordinates\":[\"@@ÂhľxŖxÒVºÅâAĪÝȆµę¯Ňa±r_w~uSÕňqOj]ɄQ£ZUDûoY»©M[L¼qãË&#123;VÍçWVi]ë©Ä÷àyƛhÚU°adcQ~Mx¥caÛcSyFÖk­uRýq¿ÔµQĽ³aG&#123;¿FµëªéĜÿª@¬·K·àariĕĀ«V»ŶĴūgèLǴŇƶaftèBŚ£^âǐÝ®M¦ÁǞÿ¬LhJ¾óƾÆºcxwf]Y´¦|QLn°adĊ\\\\¨oǀÍŎ´ĩĀd`tÊQŞŕ|¨C^©Ĉ¦¦ÎJĊ&#123;ëĎjª²rÐl`¼Ą[t|¦Stè¾PÜK¸dƄı]s¤î_v¹ÎVòŦj£Əsc¬_Ğ´|Ł¦Av¦w`ăaÝaa­¢e¤ı²©ªSªÈMĄwÉØŔì@T¤Ę\\\\õª@þo´­xA sÂtŎKzó²ÇČµ¢r^nĊ­Æ¬×üG¢³ &#123;âĊ]G~bÀgVjzlhǶfOfdªB]pjTOtĊn¤&#125;®¦Č¥d¢¼»ddY¼t¢eȤJ¤&#125;Ǿ¡°§¤AÐlc@ĝsªćļđAçwxUuzEÖġ~AN¹ÄÅȀŻ¦¿ģŁéì±Hãd«g[Ø¼ēÀcīľġ¬cJµÐʥVȝ¸ßS¹ý±ğkƁ¼ą^ɛ¤Ûÿb[&#125;¬ōõÃ]ËNm®g@Bg&#125;ÍF±ǐyL¥íCIĳÏ÷Ñį[¹¦[âšEÛïÁÉdƅß&#123;âNÆāŨß¾ě÷yC£k­´ÓH@Â¹TZ¥¢į·ÌAÐ§®Zcv½Z­¹|ÅWZqgW|ieZÅYVÓqdqbc²R@c¥Rã»GeeƃīQ&#125;J[ÒK¬Ə|oėjġĠÑN¡ð¯EBčnwôɍėª²CλŹġǝʅįĭạ̃ūȹ]ΓͧgšsgȽóϧµǛęgſ¶ҍć`ĘąŌJÞä¤rÅň¥ÖÁUětęuůÞiĊÄÀ\\\\Æs¦ÓRb|Â^řÌkÄŷ¶½÷f±iMÝ@ĥ°G¬ÃM¥n£Øąğ¯ß§aëbéüÑOčk£&#123;\\\\eµª×MÉfm«Ƒ&#123;Å×Gŏǩãy³©WÑăû··Qòı&#125;¯ãIéÕÂZ¨īès¶ZÈsæĔTŘvgÌsN@îá¾ó@ÙwU±ÉTå»£TđWxq¹Zobs[×¯cĩvėŧ³BM|¹kªħ¥TzNYnÝßpęrñĠĉRS~½ěVVµõ«M££µBĉ¥áºae~³AuĐh`Ü³ç@BÛïĿa©|z²Ý¼D£àč²ŸIûI āóK¥&#125;rÝ_Á´éMaň¨~ªSĈ½½KÙóĿeƃÆB·¬ën×W|Uº&#125;LJrƳlŒµ`bÔ`QÐÓ@s¬ñIÍ@ûws¡åQÑßÁ`ŋĴ&#123;ĪTÚÅTSÄ³Yo|Ç[Ç¾µMW¢ĭiÕØ¿@MhpÕ]jéò¿OƇĆƇpêĉâlØwěsǩĵ¸cbU¹ř¨WavquSMzeo_^gsÏ·¥Ó@~¯¿RiīB\\\\qTGªÇĜçPoÿfñòą¦óQīÈáPābß&#123;ZŗĸIæÅhnszÁCËìñÏ·ąĚÝUm®ó­L·ăUÈíoù´Êj°ŁŤ_uµ^°ìÇ@tĶĒ¡ÆM³Ģ«İĨÅ®ğRāðggheÆ¢zÊ©Ô\\\\°ÝĎz~ź¤PnMĪÖB£kné§żćĆKĒ°¼L¶èâz¨u¦¥LDĘz¬ýÎmĘd¾ßFzhg²Fy¦ĝ¤ċņbÎ@yĄæm°NĮZRÖíJ²öLĸÒ¨Y®ƌÐVàtt_ÚÂyĠz]ŢhzĎ&#123;ÂĢXc|ÐqfO¢¤ögÌHNPKŖUú´xx[xvĐCûĀìÖT¬¸^&#125;Ìsòd´_KgžLĴÀBon|H@Êx¦BpŰŌ¿fµƌA¾zǈRx¶FkĄźRzŀ~¶[´HnªVƞuĒ­È¨ƎcƽÌm¸ÁÈM¦x͊ëÀxǆBú^´W£dkɾĬpw˂ØɦļĬIŚÊnŔa¸~J°îlɌxĤÊÈðhÌ®gT´øàCÀ^ªerrƘd¢İP|Ė ŸWªĦ^¶´ÂLaT±üWƜǀRÂŶUńĖ[QhlLüAÜ\\\\qRĄ©\"],\"encodeOffsets\":[[90849,37210]]&#125;,\"properties\":&#123;\"cp\":[91.132212,29.660361],\"name\":\"西藏\",\"childNum\":1&#125;&#125;,&#123;\"id\":\"610000\",\"geometry\":&#123;\"type\":\"Polygon\",\"coordinates\":[\"@@¸ÂW¢xR­Fq§uF@N¢XLRMº[ğȣſï|¥Jkc`sŉǷ£Y³WN«ùMëï³ÛIg÷±mTșÚÒķø©þ¥yÓğęmWµÎumZyOŅƟĥÓ~sÑL¤µaÅY¦ocyZ&#123;y c]&#123;Ta©`U_Ěē£ωÊƍKùK¶ȱÝƷ§&#123;û»ÅÁȹÍéuĳ|¹cÑdìUYOuFÕÈYvÁCqÓTǢí§·S¹NgV¬ë÷Át°DØ¯C´ŉƒópģ&#125;ąiEËFéGU¥×K§­¶³BČ&#125;C¿åċ`wġB·¤őcƭ²ő[Å^axwQOñJÙïŚĤNĔwƇÄńwĪ­o[_KÓª³ÙnKÇěÿ]ďă_d©·©Ýŏ°Ù®g]±ß×¥¬÷m\\\\iaǑkěX&#123;¢|ZKlçhLtŇîŵœè[É@ƉĄEtƇÏ³­ħZ«mJ×¾MtÝĦ£IwÄå\\\\Õ&#123;OwĬ©LÙ³ÙTª¿^¦rÌĢŭO¥lãyC§HÍ£ßEñX¡­°ÙCgpťzb`wIvA|¥hoĕ@E±iYd¥OÿµÇvPW|mCĴŜǂÒW¶¸AĜh^Wx&#123;@¬­F¸¡ķn£P|ªĴ@^ĠĈæbÔc¶lYi^MicĎ°Â[ävï¶gv@ÀĬ·lJ¸sn|¼u~a]ÆÈtŌºJpþ£KKf~¦UbyäIĺãnÔ¿^­ŵMThĠÜ¤ko¼Ŏìąǜh`[tRd²Ĳ_XPrɲlXiL§à¹H°Ȧqº®QCbAŌJ¸ĕÚ³ĺ§ `d¨YjiZvRĺ±öVKkjGȊÄePĞZmļKÀ[`ösìhïÎoĬdtKÞ&#123;¬èÒÒBÔpĲÇĬJŊ¦±J«[©ārHµàåVKe§|P²ÇÓ·vUzgnN¾yI@oHĆÛķhxen¡QQ±ƝJǖRbzy¸ËÐl¼EºpĤ¼x¼½~Ğà@ÚüdK^mÌSjp²ȮµûGĦ&#125;Ħðǚ¶òƄjɂz°&#123;ºØkÈęâ¦jªBg\\\\ċ°s¬]jú EȌǆ¬stRÆdĠİwÜ¸ôW¾ƮłÒ_&#123;Ìû¼jº¹¢GǪÒ¯ĘZ`ºŊecņą~BÂgzpâēòYƲȐĎ\"],\"encodeOffsets\":[[113634,40474]]&#125;,\"properties\":&#123;\"cp\":[108.948024,34.263161],\"name\":\"陕西\",\"childNum\":1&#125;&#125;,&#123;\"id\":\"620000\",\"geometry\":&#123;\"type\":\"MultiPolygon\",\"coordinates\":[[\"@@Vu_^\",\"@@ųEĠtt~nkh`Q¦ÅÄÜdwAb×ĠąJ¤DüègĺqBqj°lI¡Ĩ¶ĖIHdjÎB°aZ¢KJO[|A£Dx&#125;NĂ¬HUnrk kp¼Y kMJn[aGáÚÏ[½rc&#125;aQxOgsPMnUsncZsKúvAtÞġ£®ĀYKdnFw¢JE°Latf`¼h¬we|Æbj&#125;GA·~W`¢MC¤tL©Ĳ°qdfObÞĬ¹ttu`^ZúE`[@Æsîz®¡CƳƜG²R¢RmfwĸgÜą G@pzJM½mhVy¸uÈÔO±¨&#123;LfæU¶ßGĂq\\\\ª¬²I¥IŉÈīoıÓÑAçÑ|«LÝcspīðÍgtë_õ\\\\ĉñLYnĝgRǡÁiHLlõUĹ²uQjYi§Z_c¨´ĹĖÙ·ŋIaBD­R¹ȥr¯GºßK¨jWkɱOqWĳ\\\\a­Q\\\\sg_ĆǛōëp»£lğÛgSŶN®À]ÓämĹãJaz¥V&#125;Le¤Lýo¹IsŋÅÇ^bz³tmEÁ´a¹cčecÇNĊãÁ\\\\č¯dNj]jZµkÓdaćå]ğĳ@ ©O&#123;¤ĸm¢E·®«|@Xwg]Aģ±¯XǁÑǳªcwQÚŝñsÕ³ÛV_ý¥\\\\ů¥©¾÷w©WÕÊĩhÿÖÁRo¸V¬âDb¨hûxÊ×ǌ~Zâg|XÁnßYoº§ZÅŘv[ĭÖʃuďxcVbnUSfB¯³_TzºÎO©çMÑ~M³]µ^püµÄY~y@X~¤Z³[Èōl@®Å¼£QK·Di¡ByÿQ_´D¥hŗy^ĭÁZ]cIzýah¹MĪğPs&#123;ò²Vw¹t³ŜË[Ñ&#125;X\\\\gsF£sPAgěp×ëfYHāďÖqēŭOÏëdLü\\\\it^c®RÊº¶¢H°mrY£B¹čIoľu¶uI]vģSQ&#123;UŻÅ&#125;QÂ|Ì°ƅ¤ĩŪU ęĄÌZÒ\\\\v²PĔ»ƢNHĂyAmƂwVm`]ÈbH`Ì¢²ILvĜH®¤Dlt_¢JJÄämèÔDëþgºƫaʎÌrêYi~ Îİ¤NpÀA¾Ĕ¼bð÷®üszMzÖĖQdȨýv§Tè|ªHÃ¾a¸|Ð ƒwKĢx¦ivr^ÿ ¸l öæfƟĴ·PJv&#125;n\\\\h¹¶v·À|\\\\ƁĚN´ĜçèÁz]ġ¤²¨QÒŨTIlªťØ&#125;¼˗ƦvÄùØEÂ«FïËIqōTvāÜŏíÛßÛVj³âwGăÂíNOPìyV³ŉĖýZso§HÑiYw[ß\\\\X¦¥c]ÔƩÜ·«jÐqvÁ¦m^ċ±R¦΋ƈťĚgÀ»IïĨʗƮ°ƝĻþÍAƉſ±tÍEÕÞāNUÍ¡\\\\ſčåÒʻĘm ƭÌŹöʥëQ¤µ­ÇcƕªoIýIÉ_mkl³ăƓ¦j¡YzŇi&#125;Msßõīʋ &#125;ÁVm_[n&#125;eı­Uĥ¼ªI&#123;Î§DÓƻėojqYhĹT©oūĶ£]ďxĩǑMĝq`B´ƃ˺Чç~²ņj@¥@đ´ί&#125;ĥtPńÇ¾V¬ufÓÉCtÓ̻¹£G³]ƖƾŎĪŪĘ̖¨ʈĢƂlɘ۪üºňUðǜȢƢż̌ȦǼĤŊɲĖÂ­KqĘŉ¼ĔǲņɾªǀÞĈĂD½ĄĎÌŗĞrôñnN¼â¾ʄľԆ|Ǆ֦ज़ȗǉ̘̭ɺƅêgV̍ʆĠ·ÌĊv|ýĖÕWĊǎÞ´õ¼cÒÒBĢ͢UĜð͒s¨ňƃLĉÕÝ@ɛƯ÷¿Ľ­ĹeȏĳëCȚDŲyê×Ŗyò¯ļcÂßYtÁƤyAã˾J@ǝrý@¤rz¸oP¹ɐÚyáHĀ[JwcVeȴÏ»ÈĖ&#125;ƒŰŐèȭǢόĀƪÈŶë;Ñ̆ȤМľĮEŔĹŊũ~ËUă&#123;ĻƹɁύȩþĽvĽƓÉ@ēĽɲßǐƫʾǗĒpäWÐxnsÀ^ƆwW©¦cÅ¡Ji§vúF¶¨c~c¼īeXǚ\\\\đ¾JwÀďksãAfÕ¦L&#125;waoZD½Ml«]eÒÅaÉ²áo½FõÛ]ĻÒ¡wYR£¢rvÓ®y®LFLzĈôe]gx&#125;|KK&#125;xklL]c¦£fRtív¦PŨ£\",\"@@M T¥\"]],\"encodeOffsets\":[[[108619,36299],[108594,36341],[108600,36306]]]&#125;,\"properties\":&#123;\"cp\":[103.823557,36.058039],\"name\":\"甘肃\",\"childNum\":3&#125;&#125;,&#123;\"id\":\"630000\",\"geometry\":&#123;\"type\":\"MultiPolygon\",\"coordinates\":[[\"@@InJo\",\"@@CÆ½OŃĦsΰ~Ē³¦@@Ņi±è&#125;ШƄ˹A³r_ĞǒNĪĐw¤^ŬĵªpĺSZgrpiƼĘÔ¨C|ÍJ©Ħ»®VĲ~f\\\\m `UnÂ~ʌĬàöNt~ňjy¢ZiƔ¥Ąk´nl`JÊJþ©pdƖ®È£¶ìRʦźõƮËnʼėæÑƀĎ[¢VÎĂMÖÝÎF²sƊƀÎBļýƞ¯ʘƭðħ¼Jh¿ŦęΌƇ¥²Q]Č¥nuÂÏri¸¬ƪÛ^Ó¦d¥[Wàx\\\\ZjÒ¨GtpþYŊĕ´zUOëPîMĄÁxH´áiÜUàîÜŐĂÛSuŎrJðÌ¬EFÁú×uÃÎkrĒ&#123;V&#125;İ«O_ÌËĬ©ÓŧSRÑ±§Ģ£^ÂyèçěM³Ƃę&#123;[¸¿uºµ[gt£¸OƤĿéYõ·kĀq]juw¥DĩƍõÇPéÄ½G©ã¤GuȧþRcÕĕNyyût­øï»a½ē¿BMoį£Íj&#125;éZËqbʍƬh¹ìÿÓAçãnIÃ¡I`ks£CG­ěUy×Cy@¶ʡÊBnāzGơMē¼±O÷õJËĚăVĪũƆ£¯&#123;ËL½ÌzżVR|ĠTbuvJvµhĻĖHAëáa­OÇðñęNwœľ·LmI±íĠĩPÉ×®ÿscB³±JKßĊ«`ađ»·QAmOVţéÿ¤¹SQt]]Çx±¯A@ĉĳ¢Óļ©l¶ÅÛrŕspãRk~¦ª]Į­´FRåd­ČsCqđéFn¿ÅƃmÉx&#123;W©ºƝºįkÕƂƑ¸wWūÐ©ÈF£\\\\tÈ¥ÄRÈýÌJ lGr^×äùyÞ³fjc¨£ÂZ|ǓMĝÏ@ëÜőRĝ÷¡&#123;aïȷPu°ËXÙ&#123;©TmĠ&#125;Y³­ÞIňµç½©C¡į÷¯B»|St»]vųs»&#125;MÓ ÿʪƟǭA¡fs»PY¼c¡»¦cċ­¥£~msĉPSi^o©AecPeǵkgyUi¿h&#125;aHĉ^|á´¡HØûÅ«ĉ®]m¡qċ¶±ÈyôōLÁstB®wn±ă¥HSòė£Së@×œÊăxÇN©©T±ª£Ĳ¡fb®Þbb_Ą¥xu¥B&#123;łĝ³«`dƐt¤ťiñÍUuºí`£^tƃĲc·ÛLO½sç¥Ts&#123;ă\\\\_»kÏ±q©čiìĉ|ÍI¥ć¥]ª§D&#123;ŝŖÉR_sÿc³ĪōƿÎ§p[ĉc¯bKmR¥&#123;³Ze^wx¹dƽÅ½ôIg §Mĕ ƹĴ¿ǣÜÍ]Ý]snåA&#123;eƭ`ǻŊĿ\\\\ĳŬűYÂÿ¬jĖqßb¸L«¸©@ěĀ©ê¶ìÀEH|´bRľÓ¶rÀQþvl®ÕETzÜdb hw¤&#123;LRdcb¯ÙVgƜßzÃôì®^jUèXÎ|UäÌ»rK\\\\ªN¼pZCüVY¤ɃRi^rPŇTÖ&#125;|br°qňbĚ°ªiƶGQ¾²x¦PmlŜ[Ĥ¡ΞsĦÔÏâ\\\\ªÚŒU\\\\f¢N²§x|¤§xĔsZPòʛ²SÐqF`ªVÞŜĶƨVZÌL`¢dŐIqr\\\\oäõFÎ·¤»Ŷ×h¹]ClÙ\\\\¦ďÌį¬řtTӺƙgQÇÓHţĒ´ÃbEÄlbʔC|CŮkƮ[ʼ¬ň´KŮÈΰÌĪ¶ƶlðļATUvdTGº̼ÔsÊDÔveMg\"]],\"encodeOffsets\":[[[105308,37219],[95370,40081]]]&#125;,\"properties\":&#123;\"cp\":[101.778916,36.623178],\"name\":\"青海\",\"childNum\":2&#125;&#125;,&#123;\"id\":\"640000\",\"geometry\":&#123;\"type\":\"Polygon\",\"coordinates\":[\"@@KëÀęĞ«Oęȿȕı]ŉ¡åįÕÔ«ǴõƪĚQÐZhv K°öqÀÑS[ÃÖHƖčËnL]ûcÙß@ĝ¾&#125;w»»oģF¹»kÌÏ·&#123;zP§B­¢íyÅt@@á]Yv_ssģ¼ißĻL¾ġsKD£¡N_X¸&#125;B~HaiÅf&#123;«x»ge_bsKF¯¡IxmELcÿZ¤­ĢÝsuBLùtYdmVtNmtOPhRw~bd¾qÐ\\\\âÙH\\\\bImlNZ»loqlVmGā§~QCw¤&#123;A\\\\PKNY¯bFkC¥sks_Ã\\\\ă«¢ħkJi¯rrAhĹûç£CUĕĊ_ÔBixÅÙĄnªÑaM~ħpOu¥sîeQ¥¤^dkKwlL~&#123;L~hw^ófćKyE­K­zuÔ¡qQ¤xZÑ¢^ļöÜ¾Ep±âbÊÑÆ^fk¬NC¾YpxbK~¥eÖäBlt¿Đx½I[ĒǙWf»Ĭ&#125;d§dµùEuj¨IÆ¢¥dXªƅx¿]mtÏwßRĶX¢͎vÆzƂZò®ǢÌʆCrâºMÞzÆMÒÊÓŊZÄ¾r°Î®Ȉmª²ĈUªĚîøºĮ¦ÌĘk^FłĬhĚiĀĖ¾iİbjË\"],\"encodeOffsets\":[[109366,40242]]&#125;,\"properties\":&#123;\"cp\":[106.278179,38.46637],\"name\":\"宁夏\",\"childNum\":1&#125;&#125;,&#123;\"id\":\"650000\",\"geometry\":&#123;\"type\":\"Polygon\",\"coordinates\":[\"@@QØĔ²X¨~ǘBºjʐßØvKƔX¨vĊOÃ·¢i@~cĝe_«E&#125;QxgɪëÏÃ@sÅyXoŖ&#123;ô«ŸuXêÎf`C¹ÂÿÐGĮÕĞXŪōŸMźÈƺQèĽôe|¿ƸJR¤ĘEjcUóº¯Ĩ_ŘÁMª÷Ð¥OéÈ¿ÖğǤǷÂFÒzÉx[]­Ĥĝœ¦EP&#125;ûƥé¿İƷTėƫœŕƅƱB»Đ±ēO¦E&#125;`cȺrĦáŖuÒª«ĲπdƺÏØZƴwʄ¤ĖGĐǂZĶèH¶&#125;ÚZצʥĪï|ÇĦMŔ»İĝǈì¥Βba­¯¥ǕǚkĆŵĦɑĺƯxūД̵nơʃĽá½M»òmqóŘĝčË¾ăCćāƿÝɽ©ǱŅ»ēėŊLrÁ®ɱĕģŉǻ̋ȥơŻǛȡVï¹Ň۩ûkɗġƁ§ʇė̕ĩũƽō^ƕUv£ƁQïƵkŏ½ΉÃŭÇ³LŇʻ«ƭ\\\\lŭD&#123;ʓDkaFÃÄa³ŤđÔGRÈƚhSӹŚsİ«ĐË[¥ÚDkº^Øg¼ŵ¸£EÍöůŉT¡c_ËKYƧUśĵÝU_©rETÏʜ±OñtYwē¨&#123;£¨uM³x½şL©Ùá[ÓÐĥ Νtģ¢\\\\śnkOw¥±T»ƷFɯàĩÞáB¹ÆÑUwŕĽw]kE½Èå~Æ÷QyěCFmĭZīŵVÁƿQƛûXS²b½KÏ½ĉS©ŷXĕ&#123;ĕK·¥Ɨcqq©f¿]ßDõU³h­gËÇïģÉɋwk¯í&#125;I·œbmÉřīJɥĻˁ×xoɹīlc¤³Xù]ǅA¿w͉ì¥wÇN·ÂËnƾƍdÇ§đ®ƝvUm©³G\\\\&#125;µĿQyŹlăµEwǇQ½yƋBe¶ŋÀůo¥AÉw@&#123;Gpm¿AĳŽKLh³`ñcËtW±»ÕSëüÿďDu\\\\wwwù³VLŕOMËGh£õP¡erÏd&#123;ġWÁč|yšg^ğyÁzÙs`s|ÉåªÇ&#125;m¢Ń¨`x¥ù^&#125;Ì¥H«YªƅAÐ¹n~ź¯f¤áÀzgÇDIÔ´AňĀÒ¶ûEYospõD[&#123;ù°]uJqU|Soċxţ[õÔĥkŋÞŭZËºóYËüċrw ÞkrťË¿XGÉbřaDü·Ē÷AÃª[ÄäIÂ®BÕĐÞ_¢āĠpÛÄȉĖġDKwbmÄNôfƫVÉviǳHQµâFù­Âœ³¦&#123;YGd¢ĚÜO &#123;Ö¦ÞÍÀP^bƾl[vt×ĈÍEË¨¡Đ~´î¸ùÎhuè`¸HÕŔVºwĠââWò@&#123;ÙNÝ´ə²ȕn&#123;¿¥&#123;l÷eé^eďXj©î\\\\ªÑòÜìc\\\\üqÕ[Č¡xoÂċªbØ­ø|¶ȴZdÆÂońéG\\\\¼C°ÌÆn´nxÊOĨŪƴĸ¢¸òTxÊǪMīĞÖŲÃɎOvʦƢ~FRěò¿ġ~åŊúN¸qĘ[Ĕ¶ÂćnÒPĒÜvúĀÊbÖ&#123;Äî¸~Ŕünp¤ÂH¾ĄYÒ©ÊfºmÔĘcDoĬMŬS¤s²ʘÚžȂVŦ èW°ªB|ĲXŔþÈJĦÆæFĚêYĂªĂ]øªŖNÞüAfɨJ¯ÎrDDĤ`mz\\\\§~D¬&#123;vJÂ«lµĂb¤pŌŰNĄ¨ĊXW|ų ¿¾ɄĦƐMTòP÷fØĶK¢ȝ˔Sô¹òEð­`Ɩ½ǒÂň×äı§ĤƝ§C~¡hlåǺŦŞkâ~&#125;FøàĲaĞfƠ¥Ŕd®U¸źXv¢aƆúŪtŠųƠjdƺƺÅìnrh\\\\ĺ¯äɝĦ]èpĄ¦´LƞĬ´ƤǬ˼Ēɸ¤rºǼ²¨zÌPðŀbþ¹ļD¢¹\\\\ĜÑŚ¶ZƄ³âjĦoâȴLÊȮĐ­ĚăÀêZǚŐ¤qȂ\\\\L¢ŌİfÆs|zºeªÙæ§΢&#123;Ā´ƐÚ¬¨Ĵà²łhʺKÞºÖTiƢ¾ªì°`öøu®Ê¾ãÖ\"],\"encodeOffsets\":[[88824,50096]]&#125;,\"properties\":&#123;\"cp\":[87.617733,43.792818],\"name\":\"新疆\",\"childNum\":1&#125;&#125;,&#123;\"id\":\"110000\",\"geometry\":&#123;\"type\":\"Polygon\",\"coordinates\":[\"@@RºaYÕQaúÍÔiþĩȨWĢü|Ėu[qb[swP@ÅğP¿&#123;\\\\¯Y²·Ñ¨j¯X\\\\¯MSvU¯YIŕY&#123;[fk­VÁûtŷmiÍt_H»Ĩ±d`¹­&#123;bwYr³S]§§o¹qGtm_SŧoaFLgQN_dV@Zom_ć\\\\ßW´ÕiœRcfio§ËgToÛJíĔóu|wP¤XnO¢ÉŦ¯pNÄā¤zâŖÈRpŢZÚ&#123;GrFt¦Òx§ø¹RóäV¤XdżâºWbwŚ¨Ud®bêņ¾jnŎGŃŶnzÚScîĚZen¬\"],\"encodeOffsets\":[[119421,42013]]&#125;,\"properties\":&#123;\"cp\":[116.405285,39.904989],\"name\":\"北京\",\"childNum\":1&#125;&#125;,&#123;\"id\":\"120000\",\"geometry\":&#123;\"type\":\"Polygon\",\"coordinates\":[\"@@ŬgX§Ü«E¶FÌ¬O_ïlÁgz±AXeµÄĵ&#123;¶]gitgIj·¥ì_iU¨ÐƎk&#125;ĕ&#123;gBqGf&#123;¿aU^fIư³õ&#123;YıëNĿk©ïËZukāAīlĕĥs¡bġ«@dekąI[nlPqCnp&#123;ō³°`&#123;PNdƗqSÄĻNNâyj]äÒD ĬH°Æ]~¡HO¾X&#125;ÐxgpgWrDGpù^LrzWxZ^¨´T\\\\|~@IzbĤjeĊªz£®ĔvěLmV¾Ô_ÈNW~zbĬvG²ZmDM~~\"],\"encodeOffsets\":[[120237,41215]]&#125;,\"properties\":&#123;\"cp\":[117.190182,39.125596],\"name\":\"天津\",\"childNum\":1&#125;&#125;,&#123;\"id\":\"310000\",\"geometry\":&#123;\"type\":\"MultiPolygon\",\"coordinates\":[[\"@@ɧư¬EpƸÁx]\",\"@@©²\",\"@@MA\",\"@@QpªKWT§¨\",\"@@bŝÕÕEȣÚƥêImɇǦèÜĠÚÄÓŴ·ʌÇ\",\"@@Sô¤r]ìƬįǜûȬɋŭ×^sYɍDŋŽąñCG²«ªč@h_p¯A&#123;oloY¬j@Ĳ`gQÚpptǀ^MĲvtbe´Rh@oj¨\",\"@@ÆLH&#123;a&#125;Eo¦\"]],\"encodeOffsets\":[[[124702,32062],[124547,32200],[124808,31991],[124726,32110],[124903,32376],[124065,32166],[124870,31965]]]&#125;,\"properties\":&#123;\"cp\":[121.472644,31.231706],\"name\":\"上海\",\"childNum\":7&#125;&#125;,&#123;\"id\":\"500000\",\"geometry\":&#123;\"type\":\"Polygon\",\"coordinates\":[\"@@TÂÛ`Ùƅően½SêqDu[RåÍ¹÷eXÍy¸_ĺę&#125;÷`M¯ċfCVµqŉ÷Zgg^d½pDOÎCn^uf²ènh¼WtƏxRGg¦pVFI±G^Ic´ecGĹÞ½sëÆNäÌ¤KÓe¯|R¸§LÜkPoïƭNï¶&#125;Gywdiù©nkĈzj@Óc£»Wă¹Óf§c[µo·Ó|MvÛaq½«è\\\\ÂoVnÓØÍ²«bq¿ehCĜ^Q~ Évýş¤²ĮpEĶyhsŊwH½¿gÅ¡ýE¡ya£³t\\\\¨\\\\vú¹¼©·Ñr_oÒý¥et³]Et©uÖ¥±ă©KVeë]&#125;wVPÀFA¨ąB&#125;qTjgRemfFmQFÝMyùnÑAmÑCawu_p¯sfÛ_gI_pNysB¦zG¸rHeN\\\\CvEsÐñÚkcDÖĉsaQ¯&#125;_UzÁē&#125;^R Äd^ÍĸZ¾·¶`wećJE¹vÛ·HgéFXjÉê`|ypxkAwWĐpb¥eOsmzwqChóUQl¥F^lafanòsrEvfQdÁUVfÎvÜ^eftET¬ôA\\\\¢sJnQTjPØxøK|nBzĞ»LYFDxÓvr[ehľvN¢o¾NiÂxGpâ¬zbfZo~hGi]öF||NbtOMn eA±tPTLjpYQ|SHYĀxinzDJÌg¢và¥Pg_ÇzIIII£®S¬ØsÎ¼¥¨^LnGĲļĲƤjÎƀƾ¹¸ØÎezĆT¸&#125;êÐqHðqĖä¥^CÆIj²p\\\\_ æüY|[YxƊæu°xb®Űb@~¢NQt°¶Sæ Ê~rǉĔëĚ¢~uf`faĔJåĊnÔ]jƎćÊ@£¾a®£Ű&#123;ŶĕFègLk&#123;Y|¡ĜWƔtƬJÑxq±ĢN´òKLÈÃ¼D|s`ŋć]Ã`đMùƱ¿~Y°ħ`ƏíW½eI½&#123;aOIrÏ¡ĕŇapµÜƃġ²\"],\"encodeOffsets\":[[111728,31311]]&#125;,\"properties\":&#123;\"cp\":[106.504962,29.533155],\"name\":\"重庆\",\"childNum\":1&#125;&#125;,&#123;\"id\":\"810000\",\"geometry\":&#123;\"type\":\"MultiPolygon\",\"coordinates\":[[\"@@AlFi\",\"@@mp\",\"@@EpHo\",\"@@rMUwAS¬]\",\"@@ea¢pl¸Eõ¹hj[]ÔCÎ@lj¡uBX´AI¹[yDU]W`çwZkmcMpÅv&#125;IoJlcafŃK°ä¬XJmÐ đhI®æÔtSHnEÒrÄc\"]],\"encodeOffsets\":[[[117111,23002],[117072,22876],[117045,22887],[116882,22747],[116975,23082]]]&#125;,\"properties\":&#123;\"cp\":[114.173355,22.320048],\"name\":\"香港\",\"childNum\":5&#125;&#125;,&#123;\"id\":\"820000\",\"geometry\":&#123;\"type\":\"Polygon\",\"coordinates\":[\"@@áw&#123;Îr\"],\"encodeOffsets\":[[116285,22746]]&#125;,\"properties\":&#123;\"cp\":[113.54909,22.198951],\"name\":\"澳门\",\"childNum\":1&#125;&#125;],\"UTF8Encoding\":true&#125;);&#125;)); 散点图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;ECharts&lt;/title&gt; &lt;!-- 引入 echarts.js --&gt; &lt;script src=\"echarts.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt; &lt;div id=\"main\" style=\"width: 900px;height:600px;\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); // 指定图表的配置项和数据 var dataBJ = [ [1, 55, 9, 56, 0.46, 18, 6, \"良\"], [2, 25, 11, 21, 0.65, 34, 9, \"优\"], [3, 56, 7, 63, 0.3, 14, 5, \"良\"], [4, 33, 7, 29, 0.33, 16, 6, \"优\"], [5, 42, 24, 44, 0.76, 40, 16, \"优\"], [6, 82, 58, 90, 1.77, 68, 33, \"良\"], [7, 74, 49, 77, 1.46, 48, 27, \"良\"], [8, 78, 55, 80, 1.29, 59, 29, \"良\"], [9, 267, 216, 280, 4.8, 108, 64, \"重度污染\"], [10, 185, 127, 216, 2.52, 61, 27, \"中度污染\"], [11, 39, 19, 38, 0.57, 31, 15, \"优\"], [12, 41, 11, 40, 0.43, 21, 7, \"优\"], [13, 64, 38, 74, 1.04, 46, 22, \"良\"], [14, 108, 79, 120, 1.7, 75, 41, \"轻度污染\"], [15, 108, 63, 116, 1.48, 44, 26, \"轻度污染\"], [16, 33, 6, 29, 0.34, 13, 5, \"优\"], [17, 94, 66, 110, 1.54, 62, 31, \"良\"], [18, 186, 142, 192, 3.88, 93, 79, \"中度污染\"], [19, 57, 31, 54, 0.96, 32, 14, \"良\"], [20, 22, 8, 17, 0.48, 23, 10, \"优\"], [21, 39, 15, 36, 0.61, 29, 13, \"优\"], [22, 94, 69, 114, 2.08, 73, 39, \"良\"], [23, 99, 73, 110, 2.43, 76, 48, \"良\"], [24, 31, 12, 30, 0.5, 32, 16, \"优\"], [25, 42, 27, 43, 1, 53, 22, \"优\"], [26, 154, 117, 157, 3.05, 92, 58, \"中度污染\"], [27, 234, 185, 230, 4.09, 123, 69, \"重度污染\"], [28, 160, 120, 186, 2.77, 91, 50, \"中度污染\"], [29, 134, 96, 165, 2.76, 83, 41, \"轻度污染\"], [30, 52, 24, 60, 1.03, 50, 21, \"良\"], [31, 46, 5, 49, 0.28, 10, 6, \"优\"] ]; var dataGZ = [ [1, 26, 37, 27, 1.163, 27, 13, \"优\"], [2, 85, 62, 71, 1.195, 60, 8, \"良\"], [3, 78, 38, 74, 1.363, 37, 7, \"良\"], [4, 21, 21, 36, 0.634, 40, 9, \"优\"], [5, 41, 42, 46, 0.915, 81, 13, \"优\"], [6, 56, 52, 69, 1.067, 92, 16, \"良\"], [7, 64, 30, 28, 0.924, 51, 2, \"良\"], [8, 55, 48, 74, 1.236, 75, 26, \"良\"], [9, 76, 85, 113, 1.237, 114, 27, \"良\"], [10, 91, 81, 104, 1.041, 56, 40, \"良\"], [11, 84, 39, 60, 0.964, 25, 11, \"良\"], [12, 64, 51, 101, 0.862, 58, 23, \"良\"], [13, 70, 69, 120, 1.198, 65, 36, \"良\"], [14, 77, 105, 178, 2.549, 64, 16, \"良\"], [15, 109, 68, 87, 0.996, 74, 29, \"轻度污染\"], [16, 73, 68, 97, 0.905, 51, 34, \"良\"], [17, 54, 27, 47, 0.592, 53, 12, \"良\"], [18, 51, 61, 97, 0.811, 65, 19, \"良\"], [19, 91, 71, 121, 1.374, 43, 18, \"良\"], [20, 73, 102, 182, 2.787, 44, 19, \"良\"], [21, 73, 50, 76, 0.717, 31, 20, \"良\"], [22, 84, 94, 140, 2.238, 68, 18, \"良\"], [23, 93, 77, 104, 1.165, 53, 7, \"良\"], [24, 99, 130, 227, 3.97, 55, 15, \"良\"], [25, 146, 84, 139, 1.094, 40, 17, \"轻度污染\"], [26, 113, 108, 137, 1.481, 48, 15, \"轻度污染\"], [27, 81, 48, 62, 1.619, 26, 3, \"良\"], [28, 56, 48, 68, 1.336, 37, 9, \"良\"], [29, 82, 92, 174, 3.29, 0, 13, \"良\"], [30, 106, 116, 188, 3.628, 101, 16, \"轻度污染\"], [31, 118, 50, 0, 1.383, 76, 11, \"轻度污染\"] ]; var dataSH = [ [1, 91, 45, 125, 0.82, 34, 23, \"良\"], [2, 65, 27, 78, 0.86, 45, 29, \"良\"], [3, 83, 60, 84, 1.09, 73, 27, \"良\"], [4, 109, 81, 121, 1.28, 68, 51, \"轻度污染\"], [5, 106, 77, 114, 1.07, 55, 51, \"轻度污染\"], [6, 109, 81, 121, 1.28, 68, 51, \"轻度污染\"], [7, 106, 77, 114, 1.07, 55, 51, \"轻度污染\"], [8, 89, 65, 78, 0.86, 51, 26, \"良\"], [9, 53, 33, 47, 0.64, 50, 17, \"良\"], [10, 80, 55, 80, 1.01, 75, 24, \"良\"], [11, 117, 81, 124, 1.03, 45, 24, \"轻度污染\"], [12, 99, 71, 142, 1.1, 62, 42, \"良\"], [13, 95, 69, 130, 1.28, 74, 50, \"良\"], [14, 116, 87, 131, 1.47, 84, 40, \"轻度污染\"], [15, 108, 80, 121, 1.3, 85, 37, \"轻度污染\"], [16, 134, 83, 167, 1.16, 57, 43, \"轻度污染\"], [17, 79, 43, 107, 1.05, 59, 37, \"良\"], [18, 71, 46, 89, 0.86, 64, 25, \"良\"], [19, 97, 71, 113, 1.17, 88, 31, \"良\"], [20, 84, 57, 91, 0.85, 55, 31, \"良\"], [21, 87, 63, 101, 0.9, 56, 41, \"良\"], [22, 104, 77, 119, 1.09, 73, 48, \"轻度污染\"], [23, 87, 62, 100, 1, 72, 28, \"良\"], [24, 168, 128, 172, 1.49, 97, 56, \"中度污染\"], [25, 65, 45, 51, 0.74, 39, 17, \"良\"], [26, 39, 24, 38, 0.61, 47, 17, \"优\"], [27, 39, 24, 39, 0.59, 50, 19, \"优\"], [28, 93, 68, 96, 1.05, 79, 29, \"良\"], [29, 188, 143, 197, 1.66, 99, 51, \"中度污染\"], [30, 174, 131, 174, 1.55, 108, 50, \"中度污染\"], [31, 187, 143, 201, 1.39, 89, 53, \"中度污染\"] ]; var schema = [&#123; name: 'date', index: 0, text: '日' &#125;, &#123; name: 'AQIindex', index: 1, text: 'AQI指数' &#125;, &#123; name: 'PM25', index: 2, text: 'PM2.5' &#125;, &#123; name: 'PM10', index: 3, text: 'PM10' &#125;, &#123; name: 'CO', index: 4, text: '一氧化碳（CO）' &#125;, &#123; name: 'NO2', index: 5, text: '二氧化氮（NO2）' &#125;, &#123; name: 'SO2', index: 6, text: '二氧化硫（SO2）' &#125;]; var itemStyle = &#123; normal: &#123; opacity: 0.8, shadowBlur: 10, shadowOffsetX: 0, shadowOffsetY: 0, shadowColor: 'rgba(0, 0, 0, 0.5)' &#125; &#125;; option = &#123; backgroundColor: '#333', color: [ '#dd4444', '#fec42c', '#80F1BE' ], legend: &#123; y: 'top', data: ['北京', '上海', '广州'], textStyle: &#123; color: '#fff', fontSize: 16 &#125; &#125;, grid: &#123; x: '10%', x2: 150, y: '18%', y2: '10%' &#125;, tooltip: &#123; padding: 10, backgroundColor: '#222', borderColor: '#777', borderWidth: 1, formatter: function(obj) &#123; var value = obj.value; return '&lt;div style=\"border-bottom: 1px solid rgba(255,255,255,.3); font-size: 18px;padding-bottom: 7px;margin-bottom: 7px\"&gt;' + obj.seriesName + ' ' + value[0] + '日：' + value[7] + '&lt;/div&gt;' + schema[1].text + '：' + value[1] + '&lt;br&gt;' + schema[2].text + '：' + value[2] + '&lt;br&gt;' + schema[3].text + '：' + value[3] + '&lt;br&gt;' + schema[4].text + '：' + value[4] + '&lt;br&gt;' + schema[5].text + '：' + value[5] + '&lt;br&gt;' + schema[6].text + '：' + value[6] + '&lt;br&gt;'; &#125; &#125;, xAxis: &#123; type: 'value', name: '日期', nameGap: 16, nameTextStyle: &#123; color: '#fff', fontSize: 14 &#125;, max: 31, splitLine: &#123; show: false &#125;, axisLine: &#123; lineStyle: &#123; color: '#777' &#125; &#125;, axisTick: &#123; lineStyle: &#123; color: '#777' &#125; &#125;, axisLabel: &#123; formatter: '&#123;value&#125;', textStyle: &#123; color: '#fff' &#125; &#125; &#125;, yAxis: &#123; type: 'value', name: 'AQI指数', nameLocation: 'end', nameGap: 20, nameTextStyle: &#123; color: '#fff', fontSize: 16 &#125;, axisLine: &#123; lineStyle: &#123; color: '#777' &#125; &#125;, axisTick: &#123; lineStyle: &#123; color: '#777' &#125; &#125;, splitLine: &#123; show: false &#125;, axisLabel: &#123; textStyle: &#123; color: '#fff' &#125; &#125; &#125;, visualMap: [&#123; left: 'right', top: '10%', dimension: 2, min: 0, max: 250, itemWidth: 30, itemHeight: 120, calculable: true, precision: 0.1, text: ['圆形大小：PM2.5'], textGap: 30, textStyle: &#123; color: '#fff' &#125;, inRange: &#123; symbolSize: [10, 70] &#125;, outOfRange: &#123; symbolSize: [10, 70], color: ['rgba(255,255,255,.2)'] &#125;, controller: &#123; inRange: &#123; color: ['#c23531'] &#125;, outOfRange: &#123; color: ['#444'] &#125; &#125; &#125;, &#123; left: 'right', bottom: '5%', dimension: 6, min: 0, max: 50, itemHeight: 120, calculable: true, precision: 0.1, text: ['明暗：二氧化硫'], textGap: 30, textStyle: &#123; color: '#fff' &#125;, inRange: &#123; colorLightness: [1, 0.5] &#125;, outOfRange: &#123; color: ['rgba(255,255,255,.2)'] &#125;, controller: &#123; inRange: &#123; color: ['#c23531'] &#125;, outOfRange: &#123; color: ['#444'] &#125; &#125; &#125;], series: [&#123; name: '北京', type: 'scatter', itemStyle: itemStyle, data: dataBJ &#125;, &#123; name: '上海', type: 'scatter', itemStyle: itemStyle, data: dataSH &#125;, &#123; name: '广州', type: 'scatter', itemStyle: itemStyle, data: dataGZ &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; K线图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;ECharts&lt;/title&gt; &lt;!-- 引入 echarts.js --&gt; &lt;script src=\"echarts.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt; &lt;div id=\"main\" style=\"width: 900px;height:600px;\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); // 指定图表的配置项和数据 // 数据意义：开盘(open)，收盘(close)，最低(lowest)，最高(highest) var data0 = splitData([ ['2013/1/24', 2320.26, 2320.26, 2287.3, 2362.94], ['2013/1/25', 2300, 2291.3, 2288.26, 2308.38], ['2013/1/28', 2295.35, 2346.5, 2295.35, 2346.92], ['2013/1/29', 2347.22, 2358.98, 2337.35, 2363.8], ['2013/1/30', 2360.75, 2382.48, 2347.89, 2383.76], ['2013/1/31', 2383.43, 2385.42, 2371.23, 2391.82], ['2013/2/1', 2377.41, 2419.02, 2369.57, 2421.15], ['2013/2/4', 2425.92, 2428.15, 2417.58, 2440.38], ['2013/2/5', 2411, 2433.13, 2403.3, 2437.42], ['2013/2/6', 2432.68, 2434.48, 2427.7, 2441.73], ['2013/2/7', 2430.69, 2418.53, 2394.22, 2433.89], ['2013/2/8', 2416.62, 2432.4, 2414.4, 2443.03], ['2013/2/18', 2441.91, 2421.56, 2415.43, 2444.8], ['2013/2/19', 2420.26, 2382.91, 2373.53, 2427.07], ['2013/2/20', 2383.49, 2397.18, 2370.61, 2397.94], ['2013/2/21', 2378.82, 2325.95, 2309.17, 2378.82], ['2013/2/22', 2322.94, 2314.16, 2308.76, 2330.88], ['2013/2/25', 2320.62, 2325.82, 2315.01, 2338.78], ['2013/2/26', 2313.74, 2293.34, 2289.89, 2340.71], ['2013/2/27', 2297.77, 2313.22, 2292.03, 2324.63], ['2013/2/28', 2322.32, 2365.59, 2308.92, 2366.16], ['2013/3/1', 2364.54, 2359.51, 2330.86, 2369.65], ['2013/3/4', 2332.08, 2273.4, 2259.25, 2333.54], ['2013/3/5', 2274.81, 2326.31, 2270.1, 2328.14], ['2013/3/6', 2333.61, 2347.18, 2321.6, 2351.44], ['2013/3/7', 2340.44, 2324.29, 2304.27, 2352.02], ['2013/3/8', 2326.42, 2318.61, 2314.59, 2333.67], ['2013/3/11', 2314.68, 2310.59, 2296.58, 2320.96], ['2013/3/12', 2309.16, 2286.6, 2264.83, 2333.29], ['2013/3/13', 2282.17, 2263.97, 2253.25, 2286.33], ['2013/3/14', 2255.77, 2270.28, 2253.31, 2276.22], ['2013/3/15', 2269.31, 2278.4, 2250, 2312.08], ['2013/3/18', 2267.29, 2240.02, 2239.21, 2276.05], ['2013/3/19', 2244.26, 2257.43, 2232.02, 2261.31], ['2013/3/20', 2257.74, 2317.37, 2257.42, 2317.86], ['2013/3/21', 2318.21, 2324.24, 2311.6, 2330.81], ['2013/3/22', 2321.4, 2328.28, 2314.97, 2332], ['2013/3/25', 2334.74, 2326.72, 2319.91, 2344.89], ['2013/3/26', 2318.58, 2297.67, 2281.12, 2319.99], ['2013/3/27', 2299.38, 2301.26, 2289, 2323.48], ['2013/3/28', 2273.55, 2236.3, 2232.91, 2273.55], ['2013/3/29', 2238.49, 2236.62, 2228.81, 2246.87], ['2013/4/1', 2229.46, 2234.4, 2227.31, 2243.95], ['2013/4/2', 2234.9, 2227.74, 2220.44, 2253.42], ['2013/4/3', 2232.69, 2225.29, 2217.25, 2241.34], ['2013/4/8', 2196.24, 2211.59, 2180.67, 2212.59], ['2013/4/9', 2215.47, 2225.77, 2215.47, 2234.73], ['2013/4/10', 2224.93, 2226.13, 2212.56, 2233.04], ['2013/4/11', 2236.98, 2219.55, 2217.26, 2242.48], ['2013/4/12', 2218.09, 2206.78, 2204.44, 2226.26], ['2013/4/15', 2199.91, 2181.94, 2177.39, 2204.99], ['2013/4/16', 2169.63, 2194.85, 2165.78, 2196.43], ['2013/4/17', 2195.03, 2193.8, 2178.47, 2197.51], ['2013/4/18', 2181.82, 2197.6, 2175.44, 2206.03], ['2013/4/19', 2201.12, 2244.64, 2200.58, 2250.11], ['2013/4/22', 2236.4, 2242.17, 2232.26, 2245.12], ['2013/4/23', 2242.62, 2184.54, 2182.81, 2242.62], ['2013/4/24', 2187.35, 2218.32, 2184.11, 2226.12], ['2013/4/25', 2213.19, 2199.31, 2191.85, 2224.63], ['2013/4/26', 2203.89, 2177.91, 2173.86, 2210.58], ['2013/5/2', 2170.78, 2174.12, 2161.14, 2179.65], ['2013/5/3', 2179.05, 2205.5, 2179.05, 2222.81], ['2013/5/6', 2212.5, 2231.17, 2212.5, 2236.07], ['2013/5/7', 2227.86, 2235.57, 2219.44, 2240.26], ['2013/5/8', 2242.39, 2246.3, 2235.42, 2255.21], ['2013/5/9', 2246.96, 2232.97, 2221.38, 2247.86], ['2013/5/10', 2228.82, 2246.83, 2225.81, 2247.67], ['2013/5/13', 2247.68, 2241.92, 2231.36, 2250.85], ['2013/5/14', 2238.9, 2217.01, 2205.87, 2239.93], ['2013/5/15', 2217.09, 2224.8, 2213.58, 2225.19], ['2013/5/16', 2221.34, 2251.81, 2210.77, 2252.87], ['2013/5/17', 2249.81, 2282.87, 2248.41, 2288.09], ['2013/5/20', 2286.33, 2299.99, 2281.9, 2309.39], ['2013/5/21', 2297.11, 2305.11, 2290.12, 2305.3], ['2013/5/22', 2303.75, 2302.4, 2292.43, 2314.18], ['2013/5/23', 2293.81, 2275.67, 2274.1, 2304.95], ['2013/5/24', 2281.45, 2288.53, 2270.25, 2292.59], ['2013/5/27', 2286.66, 2293.08, 2283.94, 2301.7], ['2013/5/28', 2293.4, 2321.32, 2281.47, 2322.1], ['2013/5/29', 2323.54, 2324.02, 2321.17, 2334.33], ['2013/5/30', 2316.25, 2317.75, 2310.49, 2325.72], ['2013/5/31', 2320.74, 2300.59, 2299.37, 2325.53], ['2013/6/3', 2300.21, 2299.25, 2294.11, 2313.43], ['2013/6/4', 2297.1, 2272.42, 2264.76, 2297.1], ['2013/6/5', 2270.71, 2270.93, 2260.87, 2276.86], ['2013/6/6', 2264.43, 2242.11, 2240.07, 2266.69], ['2013/6/7', 2242.26, 2210.9, 2205.07, 2250.63], ['2013/6/13', 2190.1, 2148.35, 2126.22, 2190.1] ]); function splitData(rawData) &#123; var categoryData = []; var values = [] for (var i = 0; i &lt; rawData.length; i++) &#123; categoryData.push(rawData[i].splice(0, 1)[0]); values.push(rawData[i]) &#125; return &#123; categoryData: categoryData, values: values &#125;; &#125; function calculateMA(dayCount) &#123; var result = []; for (var i = 0, len = data0.values.length; i &lt; len; i++) &#123; if (i &lt; dayCount) &#123; result.push('-'); continue; &#125; var sum = 0; for (var j = 0; j &lt; dayCount; j++) &#123; sum += data0.values[i - j][1]; &#125; result.push(sum / dayCount); &#125; return result; &#125; option = &#123; title: &#123; text: '上证指数', left: 0 &#125;, tooltip: &#123; trigger: 'axis', axisPointer: &#123; type: 'line' &#125; &#125;, legend: &#123; data: ['日K', 'MA5', 'MA10', 'MA20', 'MA30'] &#125;, grid: &#123; left: '10%', right: '10%', bottom: '15%' &#125;, xAxis: &#123; type: 'category', data: data0.categoryData, scale: true, boundaryGap: false, axisLine: &#123; onZero: false &#125;, splitLine: &#123; show: false &#125;, splitNumber: 20, min: 'dataMin', max: 'dataMax' &#125;, yAxis: &#123; scale: true, splitArea: &#123; show: true &#125; &#125;, dataZoom: [&#123; type: 'inside', start: 50, end: 100 &#125;, &#123; show: true, type: 'slider', y: '90%', start: 50, end: 100 &#125;], series: [&#123; name: '日K', type: 'candlestick', data: data0.values, markPoint: &#123; label: &#123; normal: &#123; formatter: function(param) &#123; return param != null ? Math.round(param.value) : ''; &#125; &#125; &#125;, data: [&#123; name: 'XX标点', coord: ['2013/5/31', 2300], value: 2300, itemStyle: &#123; normal: &#123; color: 'rgb(41,60,85)' &#125; &#125; &#125;, &#123; name: 'highest value', type: 'max', valueDim: 'highest' &#125;, &#123; name: 'lowest value', type: 'min', valueDim: 'lowest' &#125;, &#123; name: 'average value on close', type: 'average', valueDim: 'close' &#125;], tooltip: &#123; formatter: function(param) &#123; return param.name + '&lt;br&gt;' + (param.data.coord || ''); &#125; &#125; &#125;, markLine: &#123; symbol: ['none', 'none'], data: [ [&#123; name: 'from lowest to highest', type: 'min', valueDim: 'lowest', symbol: 'circle', symbolSize: 10, label: &#123; normal: &#123; show: false &#125;, emphasis: &#123; show: false &#125; &#125; &#125;, &#123; type: 'max', valueDim: 'highest', symbol: 'circle', symbolSize: 10, label: &#123; normal: &#123; show: false &#125;, emphasis: &#123; show: false &#125; &#125; &#125;], &#123; name: 'min line on close', type: 'min', valueDim: 'close' &#125;, &#123; name: 'max line on close', type: 'max', valueDim: 'close' &#125; ] &#125; &#125;, &#123; name: 'MA5', type: 'line', data: calculateMA(5), smooth: true, lineStyle: &#123; normal: &#123; opacity: 0.5 &#125; &#125; &#125;, &#123; name: 'MA10', type: 'line', data: calculateMA(10), smooth: true, lineStyle: &#123; normal: &#123; opacity: 0.5 &#125; &#125; &#125;, &#123; name: 'MA20', type: 'line', data: calculateMA(20), smooth: true, lineStyle: &#123; normal: &#123; opacity: 0.5 &#125; &#125; &#125;, &#123; name: 'MA30', type: 'line', data: calculateMA(30), smooth: true, lineStyle: &#123; normal: &#123; opacity: 0.5 &#125; &#125; &#125;, ] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 雷达图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;ECharts&lt;/title&gt; &lt;!-- 引入 echarts.js --&gt; &lt;script src=\"echarts.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt;&lt;div id=\"main\" style=\"width: 900px;height:600px;\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; // 基于准备好的dom，初始化echarts实例var myChart = echarts.init(document.getElementById('main'));// 指定图表的配置项和数据option = &#123; title: &#123; text: '基础雷达图' &#125;, tooltip: &#123;&#125;, legend: &#123; data: ['预算分配（Allocated Budget）', '实际开销（Actual Spending）'] &#125;, radar: &#123; // shape: 'circle', indicator: [ &#123; name: '销售（sales）', max: 6500&#125;, &#123; name: '管理（Administration）', max: 16000&#125;, &#123; name: '信息技术（Information Techology）', max: 30000&#125;, &#123; name: '客服（Customer Support）', max: 38000&#125;, &#123; name: '研发（Development）', max: 52000&#125;, &#123; name: '市场（Marketing）', max: 25000&#125; ] &#125;, series: [&#123; name: '预算 vs 开销（Budget vs spending）', type: 'radar', // areaStyle: &#123;normal: &#123;&#125;&#125;, data : [ &#123; value : [4300, 10000, 28000, 35000, 50000, 19000], name : '预算分配（Allocated Budget）' &#125;, &#123; value : [5000, 14000, 28000, 31000, 42000, 21000], name : '实际开销（Actual Spending）' &#125; ] &#125;]&#125;;// 使用刚指定的配置项和数据显示图表。myChart.setOption(option);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 高级使用多个坐标轴两个图标合并展示设置两个y轴配置多个yaxis属性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;ECharts&lt;/title&gt; &lt;!-- 引入 echarts.js --&gt; &lt;script src=\"echarts.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt; &lt;div id=\"main\" style=\"width: 900px;height:600px;\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); // 指定图表的配置项和数据 option = &#123; tooltip: &#123; trigger: 'axis' &#125;, toolbox: &#123; feature: &#123; dataView: &#123; show: true, readOnly: false &#125;, magicType: &#123; show: true, type: ['line', 'bar'] &#125;, restore: &#123; show: true &#125;, saveAsImage: &#123; show: true &#125; &#125; &#125;, legend: &#123; data: ['蒸发量', '降水量', '平均温度'] &#125;, xAxis: [&#123; type: 'category', data: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'] &#125;], yAxis: [&#123; type: 'value', name: '水量', min: 0, max: 250, interval: 50, axisLabel: &#123; formatter: '&#123;value&#125; ml' &#125; &#125;, &#123; type: 'value', name: '温度', min: 0, max: 25, interval: 5, axisLabel: &#123; formatter: '&#123;value&#125; °C' &#125; &#125;], series: [&#123; name: '蒸发量', type: 'bar', data: [2.0, 4.9, 7.0, 23.2, 25.6, 76.7, 135.6, 162.2, 32.6, 20.0, 6.4, 3.3] &#125;, &#123; name: '降水量', type: 'bar', data: [2.6, 5.9, 9.0, 26.4, 28.7, 70.7, 175.6, 182.2, 48.7, 18.8, 6.0, 2.3] &#125;, &#123; name: '平均温度', type: 'line', yAxisIndex: 1, data: [2.0, 2.2, 3.3, 4.5, 6.3, 10.2, 20.3, 23.4, 23.0, 16.5, 12.0, 6.2] &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; dataZoomx轴可以控制区域区间显示缩放显示常用于大数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;ECharts&lt;/title&gt; &lt;!-- 引入 echarts.js --&gt; &lt;script src=\"echarts.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt; &lt;div id=\"main\" style=\"width: 900px;height:600px;\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); var base = +new Date(1968, 9, 3); var oneDay = 24 * 3600 * 1000; var date = []; var data = [Math.random() * 300]; for (var i = 1; i &lt; 20000; i++) &#123; var now = new Date(base += oneDay); date.push([now.getFullYear(), now.getMonth() + 1, now.getDate()].join('-')); data.push(Math.round((Math.random() - 0.5) * 20 + data[i - 1])); &#125; option = &#123; tooltip: &#123; trigger: 'axis', position: function(pt) &#123; return [pt[0], '10%']; &#125; &#125;, title: &#123; left: 'center', text: '大数据量折线图', &#125;, legend: &#123; top: 'bottom', data: ['意向'] &#125;, toolbox: &#123; show: true, feature: &#123; dataView: &#123; show: true, readOnly: false &#125;, magicType: &#123; show: true, type: ['line', 'bar', 'stack', 'tiled'] &#125;, restore: &#123; show: true &#125;, saveAsImage: &#123; show: true &#125; &#125; &#125;, xAxis: &#123; type: 'category', boundaryGap: false, data: date &#125;, yAxis: &#123; type: 'value', boundaryGap: [0, '100%'] &#125;, dataZoom: [&#123; type: 'slider', start: 10, end: 40 &#125;], series: [&#123; name: '模拟数据', type: 'line', smooth: true, symbol: 'none', sampling: 'average', itemStyle: &#123; normal: &#123; color: 'rgb(255, 70, 131)' &#125; &#125;, areaStyle: &#123; normal: &#123; color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [&#123; offset: 0, color: 'rgb(255, 158, 68)' &#125;, &#123; offset: 1, color: 'rgb(255, 70, 131)' &#125;]) &#125; &#125;, data: data &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 值域选择123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;ECharts&lt;/title&gt; &lt;!-- 引入 echarts.js --&gt; &lt;script src=\"echarts.min.js\"&gt;&lt;/script&gt; &lt;script src=\"china.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt; &lt;div id=\"main\" style=\"width: 900px;height:600px;\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); // 指定图表的配置项和数据 var geoCoordMap = &#123; \"海门\": [121.15, 31.89], \"鄂尔多斯\": [109.781327, 39.608266], \"招远\": [120.38, 37.35], \"舟山\": [122.207216, 29.985295], \"齐齐哈尔\": [123.97, 47.33], \"盐城\": [120.13, 33.38], \"赤峰\": [118.87, 42.28], \"青岛\": [120.33, 36.07], \"乳山\": [121.52, 36.89], \"金昌\": [102.188043, 38.520089], \"泉州\": [118.58, 24.93], \"莱西\": [120.53, 36.86], \"日照\": [119.46, 35.42], \"胶南\": [119.97, 35.88], \"南通\": [121.05, 32.08], \"拉萨\": [91.11, 29.97], \"云浮\": [112.02, 22.93], \"梅州\": [116.1, 24.55], \"文登\": [122.05, 37.2], \"上海\": [121.48, 31.22], \"攀枝花\": [101.718637, 26.582347], \"威海\": [122.1, 37.5], \"承德\": [117.93, 40.97], \"厦门\": [118.1, 24.46], \"汕尾\": [115.375279, 22.786211], \"潮州\": [116.63, 23.68], \"丹东\": [124.37, 40.13], \"太仓\": [121.1, 31.45], \"曲靖\": [103.79, 25.51], \"烟台\": [121.39, 37.52], \"福州\": [119.3, 26.08], \"瓦房店\": [121.979603, 39.627114], \"即墨\": [120.45, 36.38], \"抚顺\": [123.97, 41.97], \"玉溪\": [102.52, 24.35], \"张家口\": [114.87, 40.82], \"阳泉\": [113.57, 37.85], \"莱州\": [119.942327, 37.177017], \"湖州\": [120.1, 30.86], \"汕头\": [116.69, 23.39], \"昆山\": [120.95, 31.39], \"宁波\": [121.56, 29.86], \"湛江\": [110.359377, 21.270708], \"揭阳\": [116.35, 23.55], \"荣成\": [122.41, 37.16], \"连云港\": [119.16, 34.59], \"葫芦岛\": [120.836932, 40.711052], \"常熟\": [120.74, 31.64], \"东莞\": [113.75, 23.04], \"河源\": [114.68, 23.73], \"淮安\": [119.15, 33.5], \"泰州\": [119.9, 32.49], \"南宁\": [108.33, 22.84], \"营口\": [122.18, 40.65], \"惠州\": [114.4, 23.09], \"江阴\": [120.26, 31.91], \"蓬莱\": [120.75, 37.8], \"韶关\": [113.62, 24.84], \"嘉峪关\": [98.289152, 39.77313], \"广州\": [113.23, 23.16], \"延安\": [109.47, 36.6], \"太原\": [112.53, 37.87], \"清远\": [113.01, 23.7], \"中山\": [113.38, 22.52], \"昆明\": [102.73, 25.04], \"寿光\": [118.73, 36.86], \"盘锦\": [122.070714, 41.119997], \"长治\": [113.08, 36.18], \"深圳\": [114.07, 22.62], \"珠海\": [113.52, 22.3], \"宿迁\": [118.3, 33.96], \"咸阳\": [108.72, 34.36], \"铜川\": [109.11, 35.09], \"平度\": [119.97, 36.77], \"佛山\": [113.11, 23.05], \"海口\": [110.35, 20.02], \"江门\": [113.06, 22.61], \"章丘\": [117.53, 36.72], \"肇庆\": [112.44, 23.05], \"大连\": [121.62, 38.92], \"临汾\": [111.5, 36.08], \"吴江\": [120.63, 31.16], \"石嘴山\": [106.39, 39.04], \"沈阳\": [123.38, 41.8], \"苏州\": [120.62, 31.32], \"茂名\": [110.88, 21.68], \"嘉兴\": [120.76, 30.77], \"长春\": [125.35, 43.88], \"胶州\": [120.03336, 36.264622], \"银川\": [106.27, 38.47], \"张家港\": [120.555821, 31.875428], \"三门峡\": [111.19, 34.76], \"锦州\": [121.15, 41.13], \"南昌\": [115.89, 28.68], \"柳州\": [109.4, 24.33], \"三亚\": [109.511909, 18.252847], \"自贡\": [104.778442, 29.33903], \"吉林\": [126.57, 43.87], \"阳江\": [111.95, 21.85], \"泸州\": [105.39, 28.91], \"西宁\": [101.74, 36.56], \"宜宾\": [104.56, 29.77], \"呼和浩特\": [111.65, 40.82], \"成都\": [104.06, 30.67], \"大同\": [113.3, 40.12], \"镇江\": [119.44, 32.2], \"桂林\": [110.28, 25.29], \"张家界\": [110.479191, 29.117096], \"宜兴\": [119.82, 31.36], \"北海\": [109.12, 21.49], \"西安\": [108.95, 34.27], \"金坛\": [119.56, 31.74], \"东营\": [118.49, 37.46], \"牡丹江\": [129.58, 44.6], \"遵义\": [106.9, 27.7], \"绍兴\": [120.58, 30.01], \"扬州\": [119.42, 32.39], \"常州\": [119.95, 31.79], \"潍坊\": [119.1, 36.62], \"重庆\": [106.54, 29.59], \"台州\": [121.420757, 28.656386], \"南京\": [118.78, 32.04], \"滨州\": [118.03, 37.36], \"贵阳\": [106.71, 26.57], \"无锡\": [120.29, 31.59], \"本溪\": [123.73, 41.3], \"克拉玛依\": [84.77, 45.59], \"渭南\": [109.5, 34.52], \"马鞍山\": [118.48, 31.56], \"宝鸡\": [107.15, 34.38], \"焦作\": [113.21, 35.24], \"句容\": [119.16, 31.95], \"北京\": [116.46, 39.92], \"徐州\": [117.2, 34.26], \"衡水\": [115.72, 37.72], \"包头\": [110, 40.58], \"绵阳\": [104.73, 31.48], \"乌鲁木齐\": [87.68, 43.77], \"枣庄\": [117.57, 34.86], \"杭州\": [120.19, 30.26], \"淄博\": [118.05, 36.78], \"鞍山\": [122.85, 41.12], \"溧阳\": [119.48, 31.43], \"库尔勒\": [86.06, 41.68], \"安阳\": [114.35, 36.1], \"开封\": [114.35, 34.79], \"济南\": [117, 36.65], \"德阳\": [104.37, 31.13], \"温州\": [120.65, 28.01], \"九江\": [115.97, 29.71], \"邯郸\": [114.47, 36.6], \"临安\": [119.72, 30.23], \"兰州\": [103.73, 36.03], \"沧州\": [116.83, 38.33], \"临沂\": [118.35, 35.05], \"南充\": [106.110698, 30.837793], \"天津\": [117.2, 39.13], \"富阳\": [119.95, 30.07], \"泰安\": [117.13, 36.18], \"诸暨\": [120.23, 29.71], \"郑州\": [113.65, 34.76], \"哈尔滨\": [126.63, 45.75], \"聊城\": [115.97, 36.45], \"芜湖\": [118.38, 31.33], \"唐山\": [118.02, 39.63], \"平顶山\": [113.29, 33.75], \"邢台\": [114.48, 37.05], \"德州\": [116.29, 37.45], \"济宁\": [116.59, 35.38], \"荆州\": [112.239741, 30.335165], \"宜昌\": [111.3, 30.7], \"义乌\": [120.06, 29.32], \"丽水\": [119.92, 28.45], \"洛阳\": [112.44, 34.7], \"秦皇岛\": [119.57, 39.95], \"株洲\": [113.16, 27.83], \"石家庄\": [114.48, 38.03], \"莱芜\": [117.67, 36.19], \"常德\": [111.69, 29.05], \"保定\": [115.48, 38.85], \"湘潭\": [112.91, 27.87], \"金华\": [119.64, 29.12], \"岳阳\": [113.09, 29.37], \"长沙\": [113, 28.21], \"衢州\": [118.88, 28.97], \"廊坊\": [116.7, 39.53], \"菏泽\": [115.480656, 35.23375], \"合肥\": [117.27, 31.86], \"武汉\": [114.31, 30.52], \"大庆\": [125.03, 46.58] &#125;; var convertData = function(data) &#123; var res = []; for (var i = 0; i &lt; data.length; i++) &#123; var geoCoord = geoCoordMap[data[i].name]; if (geoCoord) &#123; res.push(&#123; name: data[i].name, value: geoCoord.concat(data[i].value) &#125;); &#125; &#125; return res; &#125;; option = &#123; backgroundColor: '#404a59', title: &#123; text: '全国主要城市空气质量', subtext: 'data from PM25.in', sublink: 'http://www.pm25.in', x: 'center', textStyle: &#123; color: '#fff' &#125; &#125;, tooltip: &#123; trigger: 'item', formatter: function(params) &#123; return params.name + ' : ' + params.value[2]; &#125; &#125;, legend: &#123; orient: 'vertical', y: 'bottom', x: 'right', data: ['pm2.5'], textStyle: &#123; color: '#fff' &#125; &#125;, dataRange: &#123; min: 0, max: 200, calculable: true, color: ['#d94e5d', '#eac736', '#50a3ba'], textStyle: &#123; color: '#fff' &#125; &#125;, geo: &#123; map: 'china', label: &#123; emphasis: &#123; show: false &#125; &#125;, itemStyle: &#123; normal: &#123; areaColor: '#323c48', borderColor: '#111' &#125;, emphasis: &#123; areaColor: '#2a333d' &#125; &#125; &#125;, series: [&#123; name: 'pm2.5', type: 'scatter', coordinateSystem: 'geo', data: convertData([&#123; name: \"海门\", value: 9 &#125;, &#123; name: \"鄂尔多斯\", value: 12 &#125;, &#123; name: \"招远\", value: 12 &#125;, &#123; name: \"舟山\", value: 12 &#125;, &#123; name: \"齐齐哈尔\", value: 14 &#125;, &#123; name: \"盐城\", value: 15 &#125;, &#123; name: \"赤峰\", value: 16 &#125;, &#123; name: \"青岛\", value: 18 &#125;, &#123; name: \"乳山\", value: 18 &#125;, &#123; name: \"金昌\", value: 19 &#125;, &#123; name: \"泉州\", value: 21 &#125;, &#123; name: \"莱西\", value: 21 &#125;, &#123; name: \"日照\", value: 21 &#125;, &#123; name: \"胶南\", value: 22 &#125;, &#123; name: \"南通\", value: 23 &#125;, &#123; name: \"拉萨\", value: 24 &#125;, &#123; name: \"云浮\", value: 24 &#125;, &#123; name: \"梅州\", value: 25 &#125;, &#123; name: \"文登\", value: 25 &#125;, &#123; name: \"上海\", value: 25 &#125;, &#123; name: \"攀枝花\", value: 25 &#125;, &#123; name: \"威海\", value: 25 &#125;, &#123; name: \"承德\", value: 25 &#125;, &#123; name: \"厦门\", value: 26 &#125;, &#123; name: \"汕尾\", value: 26 &#125;, &#123; name: \"潮州\", value: 26 &#125;, &#123; name: \"丹东\", value: 27 &#125;, &#123; name: \"太仓\", value: 27 &#125;, &#123; name: \"曲靖\", value: 27 &#125;, &#123; name: \"烟台\", value: 28 &#125;, &#123; name: \"福州\", value: 29 &#125;, &#123; name: \"瓦房店\", value: 30 &#125;, &#123; name: \"即墨\", value: 30 &#125;, &#123; name: \"抚顺\", value: 31 &#125;, &#123; name: \"玉溪\", value: 31 &#125;, &#123; name: \"张家口\", value: 31 &#125;, &#123; name: \"阳泉\", value: 31 &#125;, &#123; name: \"莱州\", value: 32 &#125;, &#123; name: \"湖州\", value: 32 &#125;, &#123; name: \"汕头\", value: 32 &#125;, &#123; name: \"昆山\", value: 33 &#125;, &#123; name: \"宁波\", value: 33 &#125;, &#123; name: \"湛江\", value: 33 &#125;, &#123; name: \"揭阳\", value: 34 &#125;, &#123; name: \"荣成\", value: 34 &#125;, &#123; name: \"连云港\", value: 35 &#125;, &#123; name: \"葫芦岛\", value: 35 &#125;, &#123; name: \"常熟\", value: 36 &#125;, &#123; name: \"东莞\", value: 36 &#125;, &#123; name: \"河源\", value: 36 &#125;, &#123; name: \"淮安\", value: 36 &#125;, &#123; name: \"泰州\", value: 36 &#125;, &#123; name: \"南宁\", value: 37 &#125;, &#123; name: \"营口\", value: 37 &#125;, &#123; name: \"惠州\", value: 37 &#125;, &#123; name: \"江阴\", value: 37 &#125;, &#123; name: \"蓬莱\", value: 37 &#125;, &#123; name: \"韶关\", value: 38 &#125;, &#123; name: \"嘉峪关\", value: 38 &#125;, &#123; name: \"广州\", value: 38 &#125;, &#123; name: \"延安\", value: 38 &#125;, &#123; name: \"太原\", value: 39 &#125;, &#123; name: \"清远\", value: 39 &#125;, &#123; name: \"中山\", value: 39 &#125;, &#123; name: \"昆明\", value: 39 &#125;, &#123; name: \"寿光\", value: 40 &#125;, &#123; name: \"盘锦\", value: 40 &#125;, &#123; name: \"长治\", value: 41 &#125;, &#123; name: \"深圳\", value: 41 &#125;, &#123; name: \"珠海\", value: 42 &#125;, &#123; name: \"宿迁\", value: 43 &#125;, &#123; name: \"咸阳\", value: 43 &#125;, &#123; name: \"铜川\", value: 44 &#125;, &#123; name: \"平度\", value: 44 &#125;, &#123; name: \"佛山\", value: 44 &#125;, &#123; name: \"海口\", value: 44 &#125;, &#123; name: \"江门\", value: 45 &#125;, &#123; name: \"章丘\", value: 45 &#125;, &#123; name: \"肇庆\", value: 46 &#125;, &#123; name: \"大连\", value: 47 &#125;, &#123; name: \"临汾\", value: 47 &#125;, &#123; name: \"吴江\", value: 47 &#125;, &#123; name: \"石嘴山\", value: 49 &#125;, &#123; name: \"沈阳\", value: 50 &#125;, &#123; name: \"苏州\", value: 50 &#125;, &#123; name: \"茂名\", value: 50 &#125;, &#123; name: \"嘉兴\", value: 51 &#125;, &#123; name: \"长春\", value: 51 &#125;, &#123; name: \"胶州\", value: 52 &#125;, &#123; name: \"银川\", value: 52 &#125;, &#123; name: \"张家港\", value: 52 &#125;, &#123; name: \"三门峡\", value: 53 &#125;, &#123; name: \"锦州\", value: 54 &#125;, &#123; name: \"南昌\", value: 54 &#125;, &#123; name: \"柳州\", value: 54 &#125;, &#123; name: \"三亚\", value: 54 &#125;, &#123; name: \"自贡\", value: 56 &#125;, &#123; name: \"吉林\", value: 56 &#125;, &#123; name: \"阳江\", value: 57 &#125;, &#123; name: \"泸州\", value: 57 &#125;, &#123; name: \"西宁\", value: 57 &#125;, &#123; name: \"宜宾\", value: 58 &#125;, &#123; name: \"呼和浩特\", value: 58 &#125;, &#123; name: \"成都\", value: 58 &#125;, &#123; name: \"大同\", value: 58 &#125;, &#123; name: \"镇江\", value: 59 &#125;, &#123; name: \"桂林\", value: 59 &#125;, &#123; name: \"张家界\", value: 59 &#125;, &#123; name: \"宜兴\", value: 59 &#125;, &#123; name: \"北海\", value: 60 &#125;, &#123; name: \"西安\", value: 61 &#125;, &#123; name: \"金坛\", value: 62 &#125;, &#123; name: \"东营\", value: 62 &#125;, &#123; name: \"牡丹江\", value: 63 &#125;, &#123; name: \"遵义\", value: 63 &#125;, &#123; name: \"绍兴\", value: 63 &#125;, &#123; name: \"扬州\", value: 64 &#125;, &#123; name: \"常州\", value: 64 &#125;, &#123; name: \"潍坊\", value: 65 &#125;, &#123; name: \"重庆\", value: 66 &#125;, &#123; name: \"台州\", value: 67 &#125;, &#123; name: \"南京\", value: 67 &#125;, &#123; name: \"滨州\", value: 70 &#125;, &#123; name: \"贵阳\", value: 71 &#125;, &#123; name: \"无锡\", value: 71 &#125;, &#123; name: \"本溪\", value: 71 &#125;, &#123; name: \"克拉玛依\", value: 72 &#125;, &#123; name: \"渭南\", value: 72 &#125;, &#123; name: \"马鞍山\", value: 72 &#125;, &#123; name: \"宝鸡\", value: 72 &#125;, &#123; name: \"焦作\", value: 75 &#125;, &#123; name: \"句容\", value: 75 &#125;, &#123; name: \"北京\", value: 79 &#125;, &#123; name: \"徐州\", value: 79 &#125;, &#123; name: \"衡水\", value: 80 &#125;, &#123; name: \"包头\", value: 80 &#125;, &#123; name: \"绵阳\", value: 80 &#125;, &#123; name: \"乌鲁木齐\", value: 84 &#125;, &#123; name: \"枣庄\", value: 84 &#125;, &#123; name: \"杭州\", value: 84 &#125;, &#123; name: \"淄博\", value: 85 &#125;, &#123; name: \"鞍山\", value: 86 &#125;, &#123; name: \"溧阳\", value: 86 &#125;, &#123; name: \"库尔勒\", value: 86 &#125;, &#123; name: \"安阳\", value: 90 &#125;, &#123; name: \"开封\", value: 90 &#125;, &#123; name: \"济南\", value: 92 &#125;, &#123; name: \"德阳\", value: 93 &#125;, &#123; name: \"温州\", value: 95 &#125;, &#123; name: \"九江\", value: 96 &#125;, &#123; name: \"邯郸\", value: 98 &#125;, &#123; name: \"临安\", value: 99 &#125;, &#123; name: \"兰州\", value: 99 &#125;, &#123; name: \"沧州\", value: 100 &#125;, &#123; name: \"临沂\", value: 103 &#125;, &#123; name: \"南充\", value: 104 &#125;, &#123; name: \"天津\", value: 105 &#125;, &#123; name: \"富阳\", value: 106 &#125;, &#123; name: \"泰安\", value: 112 &#125;, &#123; name: \"诸暨\", value: 112 &#125;, &#123; name: \"郑州\", value: 113 &#125;, &#123; name: \"哈尔滨\", value: 114 &#125;, &#123; name: \"聊城\", value: 116 &#125;, &#123; name: \"芜湖\", value: 117 &#125;, &#123; name: \"唐山\", value: 119 &#125;, &#123; name: \"平顶山\", value: 119 &#125;, &#123; name: \"邢台\", value: 119 &#125;, &#123; name: \"德州\", value: 120 &#125;, &#123; name: \"济宁\", value: 120 &#125;, &#123; name: \"荆州\", value: 127 &#125;, &#123; name: \"宜昌\", value: 130 &#125;, &#123; name: \"义乌\", value: 132 &#125;, &#123; name: \"丽水\", value: 133 &#125;, &#123; name: \"洛阳\", value: 134 &#125;, &#123; name: \"秦皇岛\", value: 136 &#125;, &#123; name: \"株洲\", value: 143 &#125;, &#123; name: \"石家庄\", value: 147 &#125;, &#123; name: \"莱芜\", value: 148 &#125;, &#123; name: \"常德\", value: 152 &#125;, &#123; name: \"保定\", value: 153 &#125;, &#123; name: \"湘潭\", value: 154 &#125;, &#123; name: \"金华\", value: 157 &#125;, &#123; name: \"岳阳\", value: 169 &#125;, &#123; name: \"长沙\", value: 175 &#125;, &#123; name: \"衢州\", value: 177 &#125;, &#123; name: \"廊坊\", value: 193 &#125;, &#123; name: \"菏泽\", value: 194 &#125;, &#123; name: \"合肥\", value: 229 &#125;, &#123; name: \"武汉\", value: 273 &#125;, &#123; name: \"大庆\", value: 279 &#125;]), symbolSize: 12, label: &#123; normal: &#123; show: false &#125;, emphasis: &#123; show: false &#125; &#125;, itemStyle: &#123; emphasis: &#123; borderColor: '#fff', borderWidth: 1 &#125; &#125; &#125;] &#125; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 小项目申请百度地图开发api异步加载数据，获取经纬度绘图，在地图上持续做标记可导出图片（可扩展手机号来源地查询，ip地址查询等）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"bootstrap.min.css\"&gt; &lt;style&gt; body &#123; padding-top: 80px &#125; #search-btn &#123; margin-top: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-3 col-md-offset-3\"&gt; &lt;form class=\"form-horizontal\"&gt; &lt;input id=\"place-input\" type=\"text\" class=\"form-control\" value=\"故宫\" placeholder=\"请输入地址\"&gt; &lt;button type=\"button\" id=\"search-btn\" class=\"btn btn-success\"&gt; 查询 &lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=\"col-md-6\"&gt; &lt;div id=\"main\" style=\"height:500px;\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src='jquery.min.js'&gt;&lt;/script&gt; &lt;script src='echarts.min.js'&gt;&lt;/script&gt; &lt;script src='beijing.js'&gt;&lt;/script&gt; &lt;script&gt; // 百度地图的开发者秘钥 var token = 'fHrNQj6DHTjZtfTvfqbsuvTzKc5V9SBl' var url = 'http://api.map.baidu.com/geocoder/v2/?output=json&amp;ak=' + token + '&amp;address=' var ePlaceInput = $('#place-input') var eSearchBtn = $('#search-btn') var myChart = echarts.init(document.getElementById('main')) var chartData = [] eSearchBtn.click(function() &#123; var place = ePlaceInput.val() if (place) &#123; $.getJSON(url + place + '&amp;callback=?', function(res) &#123; var loc if (res.status === 0) &#123; loc = res.result.location chartData.push(&#123; name: name, value: [loc.lng, loc.lat] &#125;) drawMap(place) &#125; else &#123; alert('百度没有找到地址信息') &#125; &#125;) &#125; &#125;) function drawMap(name) &#123; var option = &#123; backgroundColor: '#404a59', title: &#123; text: '2020要去的地方', left: 'center', textStyle: &#123; color: '#fff' &#125; &#125;, tooltip: &#123; trigger: 'item' &#125;, toolbox: &#123; show: true, feature: &#123; saveAsImage: &#123; show: true &#125; &#125; &#125;, geo: &#123; map: '北京', label: &#123; emphasis: &#123; show: false &#125; &#125;, roam: true, itemStyle: &#123; normal: &#123; areaColor: '#323c48', borderColor: '#111' &#125;, emphasis: &#123; areaColor: '#2a333d' &#125; &#125; &#125;, series: [&#123; name: '地址', type: 'scatter', coordinateSystem: 'geo', data: chartData, symbolSize: function(val) &#123; return 10; &#125;, &#125;] &#125; myChart.setOption(option) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 参考https://github.com/shengxinjing/imooc-echarts","raw":null,"content":null,"categories":[{"name":"前端","slug":"前端","permalink":"https://hubojing.github.io/categories/前端/"}],"tags":[{"name":"ECharts","slug":"ECharts","permalink":"https://hubojing.github.io/tags/ECharts/"}]},{"title":"词的向量表示方法","slug":"词的向量表示方法","date":"2020-01-15T12:14:49.000Z","updated":"2020-01-15T12:14:49.000Z","comments":true,"path":"2020/01/15/词的向量表示方法/","link":"","permalink":"https://hubojing.github.io/2020/01/15/词的向量表示方法/","excerpt":"　　思想简记 ","text":"思想简记 NLP中，离散符号化的词语不能包含语义信息，所以把词映射到向量空间。 独热编码（One-Hot Encoding）思想：将一个词表示成很长的向量，该向量的维度是整个词表的大小。对某一具体词，除了该词编号的维度为1，其余都为0。 独热编码 词袋模型（Bag-of-Words, BoW）思想：将文本视为装词的袋子，不考虑词的上下文关系和顺序，只记录每个词在该文本（词袋）中出现的次数。 词袋模型 词向量/词嵌入（Word Embedding）上面对词的表示方法没有考虑语义层面信息。为表示词与词之间的语义相似程度，提出词的分布式表示，即基于上下文的稠密向量表示法，通常称为词向量或词嵌入（Word Embedding）。产生词向量的手段： Count-based。基于计数的方法，即记录词的出现次数。 Predictive。基于预测的方法，即可通过上下文预测中心词，又可通过中心词预测上下文。 Task-based。基于任务的，即通过任务驱动的方法。通过对词向量在具体任务上的表现效果对词向量进行学习。 下面是经典开源工具word2vec中的CBoW模型和Skip-gram模型。 连续词袋模型（Continuous Bag-of-Words, CBoW）和BoW相同点：不考虑词的顺序。思想：将上下文词的独热表示与词向量矩阵相乘，提取相应的词向量并求和得到投影层，然后再经过一个Softmax层最终得到输出，输出的每一维表达的就是词表中每个词作为该上下文中心词的概率。整个模型训练时类似于一个窗口在训练语料上滑动，所以得名连续词袋模型。 Skip-gram模型（Continuous skip-gram Model）思想：与CBoW思想刚好相反，它用中心词来预测上下文词。先通过中心词的独热表示从词向量矩阵中得到中心词的词向量，得到投影层，再经过一层Softmax得到输出，输出的每一维中代表某个词作为输入中心词的上下文出现的概率。 这两种模型都包含三层，输入层、投影层、输出层： Word2Vec 训练好的词向量中，具有一定的空间平移性。 空间平移性 如图，Rome和Italy之间存在is-capital-of关系，而Paris和France也同样存在。可以理解为知识图谱中的relation，即（Rome, is-capital-of, Italy）和（Paris, is-capital-of, France）。通过两对在语义上关系相同的词向量相减可得相似结果，这种连续向量可近似地平移到其它具有类似关系的两个词向量之间。如：vector(‘Paris’) - Vector(‘France’) + Vector(‘Italy’) ≈ Vector(‘Rome’) 论文Efficient Estimation of Word Representations in Vector SpaceDistributed Representations of Sentences and DocumentsEnriching Word Vectors with Subword Information","raw":null,"content":null,"categories":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"https://hubojing.github.io/categories/数据挖掘/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"https://hubojing.github.io/tags/NLP/"},{"name":"Embedding","slug":"Embedding","permalink":"https://hubojing.github.io/tags/Embedding/"}]},{"title":"2020——新的启航","slug":"2020——新的启航","date":"2020-01-02T13:42:00.000Z","updated":"2020-01-18T07:13:39.000Z","comments":true,"path":"2020/01/02/2020——新的启航/","link":"","permalink":"https://hubojing.github.io/2020/01/02/2020——新的启航/","excerpt":"　　20年代第一年的Flag已立　　这篇文章差不多写完了 ","text":"20年代第一年的Flag已立 这篇文章差不多写完了 2020-01-18更新 前段时间去友链博客串门，看了他们的计划，相比之下我的计划可执行性太差了，只是泛泛而谈。应量化之。 于是，有了这一版详细计划：科研方面 多看论文，完成导师任务。 多了解工业届具体应用情况，了解就业市场需求。 对推荐系统，乃至NLP，以及相关传统机器学习、深度学习的代码实操，技术路线搭建。 技术方面 Leetcode一周三题，一年156题。 纸质书五本。 至少细致分析一个开源项目代码。 Java学习。 日常学习方面 微信读书一周2h，一年104h。 （截止今日：73h11min） 纸质书（非技术类）两月一本，一年六本。 今年读书重点依然在推理、历史类，可辅看经济入门书。 英语电台更新大于100期。 健身方面 不熬夜 熬夜则自动领取加读论文一篇的奖励，需在博客上有记录。 Keep 3000min 一周至少三次Keep，运动量大于30min，一年需运动4680min（然而截止2019年底也才2530min），所以折中一下。 对于一些仍然比较泛泛而谈的计划，我还没能找到一个更好的细化方法。 2020-01-02原稿 这篇文章写的很匆忙，我猜自己后期可能会修改。现在是2020年1月2日21点42分，距离零点只有两个多小时了。（毕竟今年的常规Flag就是不能熬夜） 但我一定要写！本来这篇文章应该在2019年12月31日写完的，结果当日上午写另一篇文章才写了几百字，整个心就都飘去跨年活动了，确实很久没有这样期待一些活动了。 再不写的话，Flag的期限感就要没了。嗯，这也算是个仪式感吧！ 首先向各位介绍一下近况，我从职场又回学校啦~开始我的研究生生活。 研究生生活到目前为止，我都感觉挺棒的，做学生真的是一件幸福的事情，坐在教室里听课，坐在实验室里看论文、写代码。生活简简单单，好像所有烦恼都随着重返校园又推迟了几年。而且学习氛围是真的好，不会因为你坐前排就很奇怪，也不会因为学得太晚而被吐槽。因为，前排坐的都是认识的同学，实验室也总有人会比我更晚离开。尤其是我所在的实验室，从来不用担心成为最后一个离开的人，无论多晚都有人还在这里学习。当我的努力学习成为一件稀疏平常的事情时，我感到很踏实。导师真的很负责，每周必会与我们至少见一面讨论目前科研进展，有人带的感觉真的非常好。 技术博客谈技术，我在读研后，最大的收获就是——我在认真科研了。 科研这两个字，曾经我以为此生不会再见了。由于我考的也是专硕，之前构想的是做项目，提高技术，然后进入心仪的大企业做开发。科研，留存于大学以前的梦，听起来就很高级的样子。大二那时曾很想涉足科研，奈何苦寻不到高人指点，为此着实苦恼了很久。读研后，导师似乎并不在乎学硕专硕这个名号，于是我就这样开始了科研的生活。 而我这个人自从大学以后，好像学会了从当下找出价值，干什么事情我都能找出意义来。所以后来工作我觉得很开心，现在回来读书我也觉得很开心。没有做项目，做起了学术，我好像也很开心。我甚至很珍惜这种机会。 我也跑到学术的大门口晃了！哈哈哈——真实想法 我想我应该快速成长起来，毕竟其他同学可能比我接触科研要系统得多。但我要补的知识确实太多了。我就连文献管理软件之前都没用过几次……所以我花了不少时间在我科研的准备上，包括科研的工具，科研怎么读论文等等。（当然都是通过和导师的交流以及万能的知乎） 现在是22：22，我感觉这篇文章算是写不完了。 那先看看去年的Flag完成了多少吧， 不要熬夜，加强锻炼（0/1） 读研前能做到，但天天失眠，读研后。。。和室友一起熬夜 技术方面基础和实战两头抓（0.5/1） 考研算是补了一些基础，不够还要多看书，实战还是弱 提高算法能力，首先从多做题开始（0.5/1） 为考研复试刷了一些题，平日也开始重视刷题，但总的说来还是刷得太少，不成体系 继续提高英语水平，尤其是计算机英语（0/1） 这一点要重点批评自己，后期电台几乎停更了，这是不好的趋势。前年更新了两百多期，去年只更新了八十多期，退步过于明显。这样却妄想六级上六百，我看五百都悬。今年说什么都要重启更新起来！ 研究方向的趋向性研讨（1/1） 大方向是数据挖掘，小方向目前是推荐系统。 综上，2/5的完成度，2019年执行力不强。 2020年，20后都要出生了！想想他们上小学上幼儿园就要学编程……OMG 不能熬夜（是不能，不是不要） 提高算法能力，刷爆Leetcode 科研方向努力钻研，早日定下开发还是算法 我知道目前市场上算法岗难度极大，但我既然目前在做科研，也希望读研期间的工作没有白费，所以希望尝试一番。 目前来说，开发还是算法，我还真拿不定，因为目前我对两者都还挺感兴趣，又或者说我对算法岗还不够了解。 我的愿望依然是想去目前一流的互联网公司，当然这本身就有难度，算法岗就更难了。不过梦想还是要有的，万一~~~ 英语能力不能放松 看英语论文的时候，就发现英语还是有用的…… 专业方面多读英文论文，注意论文的整理。 电台方面，必须重新更新起来。同时，自己稀烂的口语应该改善。 技术方面在一个语言上深耕 目前暂定Java 目前只想到这些，感觉都能做到的话也很不错了。 22:50了！！！下线下线，在实验室赶作业般的写这篇博文，我真是（手动滑稽） 2020，新的生活冲冲冲！ ——写于2020年1月2日的夜晚","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"年终总结","slug":"年终总结","permalink":"https://hubojing.github.io/tags/年终总结/"}]},{"title":"《推荐系统实践》笔记","slug":"《推荐系统实践》笔记","date":"2019-11-30T10:45:33.000Z","updated":"2020-09-04T03:51:41.770Z","comments":true,"path":"2019/11/30/《推荐系统实践》笔记/","link":"","permalink":"https://hubojing.github.io/2019/11/30/《推荐系统实践》笔记/","excerpt":"　　to be continued ","text":"to be continued 第1章 好的推荐系统什么是推荐系统 推荐系统的基本任务是联系用户和物品，解决信息过载的问题。 社会化推荐(social recommendation)：向朋友咨询 基于内容的推荐(content-based filtering)：寻找和自己之前喜欢的物品相似的物品 基于协同过滤(collaborative filtering)：找到和自己历史兴趣相似的用户所喜欢的物品 推荐系统评测实验方法 离线实验（offline experiment）、用户调查（user study）、在线实验（online experiment） 离线实验步骤： 通过日志系统获得用户行为数据，并按照一定格式生成一个标准的数据集; 将数据集按照一定的规则分成训练集和测试集; 在训练集上训练用户兴趣模型，在测试集上进行预测; 通过事先定义的离线指标评测算法在测试集上的预测结果。 在线实验：AB测试 AB测试是一种很常用的在线评测算法的实验方法。它通过一定的规则将用户随机分成几组，并对不同组的用户采用不同的算法，然后通过统计不同组用户的各种不同的评测指标比较不同算法，比如可以统计不同组用户的点击率，通过点击率比较不同算法的性能。 评测指标 用户满意度 预测准确度 评分预测：均方根误差RMSE和平均绝对误差（MAE） TopN推荐：准确率（precision）和召回率（recall） 覆盖率（coverage） 信息熵和基尼系数（Gini Index） 多样性 新颖性 惊喜度 信任度 实时性 健壮性 商业目标评测维度 用户维度 物品维度 时间维度 第2章 利用用户行为数据 基于用户行为分析的推荐算法是个性化推荐系统的重要算法，学术界一般将这种类型的算法称为协同过滤算法。 按反馈的明确性分，显式反馈（explicit feedback）和隐式反馈（implicit feedback） 按反馈的方向分，正反馈（用户的行为倾向于指用户喜欢该物品）和负反馈（用户的行为倾向于指用户不喜欢该物品） 有代表性的数据集： 无上下文信息的隐性反馈数据集：每一条行为记录仅仅包含用户ID和物品ID。 无上下文信息的显性反馈数据集：每一条记录包含用户ID、物品ID和用户对物品的评分。 有上下文信息的隐性反馈数据集：每一条记录包含用户ID、物品ID和用户对物品产生行为的时间戳。 有上下文信息的显性反馈数据集：每一条记录包含用户ID、物品ID、用户对物品的评分和评分行为发生的时间戳。 用户活跃度和物品流行度的分布 PowerLaw分布（长尾分布）$$f(x)=αx^k$$ 令$f_u(k)$为对k个物品产生过行为的用户数，令$f_i(k)$为被k个用户产生过行为的物品数。它们都满足长尾分布。$$f_i(k)=a_ik^{β_i}$$$$f_u(k)=a_uk^{β_u}$$ 物品的流行度指对物品产生过行为的用户总数。 用户的活跃度为用户产生过行为的物品总数。 用户活跃度和物品流行度的关系 仅仅基于用户行为数据设计的推荐算法一般称为协同过滤算法。 基于邻域的方法（neighborhood-based）：基于用户的协同过滤算法（推荐和用户兴趣相似的其他用户喜欢的物品）、基于物品的协同过滤算法（推荐和他之前喜欢的物品相似的物品） 隐语义模型（latent factor model） 基于图的随机游走算法（random walk on graph） 基于邻域的算法基于用户的协同过滤算法基础算法 步骤： 找到和目标用户兴趣相似的用户集合。 找到这个集合中的用户喜欢的，且目标用户没有听说过的物品推荐给目标用户。 步骤1关键是计算两个用户的兴趣相似度。 利用行为的相似度计算兴趣相似度。Jaccard公式计算用户u和用户v的兴趣相似度。$$w_{uv}=\\frac{|{N(u)∩N(v)}|}{|{N(u)∪N(v)}|}$$ 或者通过余弦相似度$$w_{uv}=\\frac{|{N(u)∩N(v)}}{|\\sqrt{|{N(u)||N(v)}|}}$$ N(u)表示用户u曾经有过正反馈的物品集合，N(v)为用户曾经有过正反馈的物品集合。 时间复杂度：O(|U|*|U|) 用户数很大时耗时，并且很多时候|N(u)∩N(v)|=0。改进算法 用户相似度计算的改进：User-IIF算法 两个用户对冷门物品采取同样的行为更能说明他们兴趣的相似度。$$w_uv = \\frac{\\sum i\\epsilon N(u)∩N(v)\\frac{1}{log1+|N(i)|}}{\\sqrt{|N(u)||N(v)|}}$$ 该公式通过$\\frac{1}{log1+|N(i)|}$惩罚了用户u和用户v共同兴趣列表中热门物品对他们相似度的影响。 基于物品的协同过滤算法 ItemCF算法并不利用物品的内容属性计算物品之间的相似度，它主要通过分析用户的行为记录计算物品之间的相似度。该算法认为，物品A和物品B具有很大的相似度是因为喜欢物品A的用户大都也喜欢物品B。 步骤： 计算物品之间的相似度 根据物品的相似度和用户的历史行为给用户生成推荐列表$$w_{ij}=\\frac{|N(i)∩N(j)|}{|N(i)|}$$ |N(i)|是喜欢物品i的用户数，分子|N(i)∩N(j)|是同时喜欢物品i和物品j的用户数。 公式可理解为喜欢物品i的用户中有多少比例的用户也喜欢物品j。 公式问题：若物品j很热门，很多人都喜欢，则$w_{ij}$很大，接近1。造成任何物品都会和热门物品有很大的相似度，这对致力于挖掘长尾信息的推荐系统来说不好。为避免出热门的物品，改进：$$w_{ij}=\\frac{|N(i)∩N(j)|}{\\sqrt{|N(i)||N(j)|}}$$ 该公式惩罚了物品j的权重，因此减轻了热门物品和很多物品相似的可能性。 从定义可看出，在协同过滤中两个物品产生相似度是因为它们共同被很多用户喜欢，即每个用户都可以通过他们的历史兴趣列表给物品贡献相似度。 用户活跃度对物品相似度的影响 每个用户对相似度的贡献应该不同。 ItemCF-IUF(Inverse User Frequence)，即用户活跃度对数的倒数的参数。活跃用户对物品相似度的贡献小于不活跃的用户。$$w_uv = \\frac{\\sum u\\epsilon N(i)∩N(j)\\frac{1}{log1+|N(u)|}}{\\sqrt{|N(i)||N(j)|}}$$ 物品相似度的归一化$$w_{ij} = \\frac{w_{ij}}{max w_{ij}}$$ UserCF和ItemCF对比 UserCF的推荐结果着重于反映和用户兴趣相似的小群体的热点，而ItemCF的推荐结果着重于维系用户的历史兴趣。换句话说，UserCF的推荐更社会化，反映了用户所在的小型兴趣群体中物品的热门程度，而ItemCF的推荐更加个性化，反映了用户自己的兴趣传承。 UserCF使用场景：新闻推荐 ItemCF使用场景：图书、电子商务、电影网站 在实际的互联网中，用户数目往往非常庞大，而在图书、电子商务网站中，物品的数目则是比较少的。此外，物品的相似度相对于用户的兴趣一般比较稳定，因此使用ItemCF是比较好的选择。当然，新闻网站是个例外，在那儿，物品的相似度变化很快，物品数目庞大，相反用户兴趣则相对固定（都是喜欢看热门的），所以新闻网站的个性化推荐使用UserCF算法的更多。 隐语义模型基础算法 思想：通过隐含特征（latent factor）联系用户兴趣和物品。 基于兴趣分类的方法大概需解决三个问题： 如何给物品进行分类？ 如何确定用户对哪些类的物品感兴趣，以及感兴趣的程度？ 对于一个给定的类，选择哪些属于这个类的物品推荐给用户，以及如何确定这些物品在一个类中的权重？ 隐含语义分析技术采取基于用户行为统计的自动聚类。 隐含语义分析技术从诞生到今天产生了很多著名模型和方法：pLSA、LDA、隐含类别模型（latent class model）、隐含主题模型（latent topic model）、矩阵分解（matrix factorization）。 LFM 用户u对物品i的兴趣：$$Preference(u,i) = r_{ui} = p_u^Tq_i = \\sum_{f=1}^Fp_{u,k}q_{i,k}$$ $p_{u,k}$和$q_{i,k}$是模型参数，$p_{u,k}$度量了用户u的兴趣和第k个隐类的关系，而$q_{i,k}$度量了第k个隐类和物品i之间的关系。 这两个参数是从数据集中计算出来的。要计算这两个参数，需要一个训练集，对于每个用户u，训练集里都包含了用户u喜欢的物品和不感兴趣的物品，通过学习这个数据集，就可以获得上面的模型参数。 推荐系统的用户行为分为显性反馈和隐性反馈。 LFM在显性反馈数据(也就是评分数据)上解决评分预测问题并达到了很好的精度。隐性反馈数据集：只有正样本（用户喜欢什么物品），没有负样本（用户对什么物品不感兴趣）。在隐性反馈数据集上应用LFM解决TopN推荐的第一个关键问题就是如何给每个用户生成负样本。 生成负样本方法： 对于一个用户，用他所有没有过行为的物品作为负样本。//负样本太多，正负样本数目相差悬殊，计算复杂度很高，结果精度差。 对于一个用户，从他没有过行为的物品中均匀采样出一些物品作为负样本。 对于一个用户，从他没有过行为的物品中采样出一些物品作为负样本，但采样时，保证每个用户的正负样本数目相当。 对于一个用户，从他没有过行为的物品中采样出一些物品作为负样本，但采样时，偏重采样不热门的物品。第三种好于第二种，第二种好于第四种。 对负样本采样时应遵循以下原则： 对每个用户，要保证正负样本的平衡（数目相似）。 对每个用户采样负样本时，要选取那些很热门，而用户却没有行为的物品。一般认为，很热门而用户却没有行为更加代表用户对这个物品不感兴趣。因为对于冷门的物品，用户可能是没发现这个物品，所以谈不上是否感兴趣。LFM模型在实际使用中有一个困难：它很难实现实时的推荐。 LFM和基于领域的方法比较 理论基础LFM具有比较好的理论基础，它是一种学习方法，通过优化一个设定的指标建立最优的模型。基于邻域的方法更多的是一种基于统计的方法，并没有学习过程。 离线计算的空间复杂度用户相关表，则需要O(M*M)的空间，而对于物品相关表，则需要O(N*N)的空间。LFM在建模过程中，如果是F个隐类，那么它需要的存储空间是O(F*(M+N))，这在M和N很大时可以很好地节省离线计算的内存。 离线计算的时间复杂度假设有M个用户、 N个物品、 K条用户对物品的行为记录。UserCF计算用户相关表的时间复杂度是O(N (K/N)^2)，而ItemCF计算物品相关表的时间复杂度是O(M(K/M)^2)。而对于LFM，如果用F个隐类，迭代S次，那么它的计算复杂度是O(K F S)。总体上没有质的差别。 在线实时推荐UserCF、ItemCF可，LFM不可。 推荐解释ItemCF解释很好，LFM无法解释。 基于图的模型（graph-based model）用户行为数据的二分图表示很多研究者把基于邻域的模型也称为基于图的模型，因为基于邻域的模型可看做基于图的模型的简单形式。二元组（u, i）表示用户u对物品i产生过行为。令G（V, E）表示用户物品二分图，其中$V = V_U∪V_1$由用户顶点集合$V_U$和物品顶点集合$V_1$组成。对于数据集中每一个二元组（u, i），图中都有一套对应的边e（$v_u$, $v_i$），其中$v_u\\epsilon V_U$是用户u对应的顶点，$v_i\\epsilon V_1$是物品i对应的顶点。 用户物品二分图模型 图中是一个简单的用户物品二分图模型，其中圆形节点代表用户，方形节点代表物品，圆形节点和方形节点之间的边代表用户对物品的行为。比如图中用户节点A和物品节点a、 b、 d相连，说明用户A对物品a、 b、 d产生过行为。 基于图的推荐算法（graph-based model）可把基于领域的模型看做基于图的模型的简单形式。相关性高的一对顶点一般具有如下特征： 两个顶点之间有很多路径相连 连接两个顶点之间的路径长度都比较短 连接两个顶点之间的路径不会经过出度比较大的顶点 基于随机游走的PersonalRank算法假设要给用户u进行个性化推荐，可以从用户u对应的节点vu开始在用户物品二分图上进行随机游走。游走到任何一个节点时，首先按照概率α决定是继续游走，还是停止这次游走并从vu节点开始重新游走。如果决定继续游走，那么就从当前节点指向的节点中按照均匀分布随机选择一个节点作为游走下次经过的节点。这样，经过很多次随机游走后，每个物品节点被访问到的概率会收敛到一个数。最终的推荐列表中物品的权重就是物品节点的访问概率。 缺点：复杂度高，耗时 第三章 冷启动问题冷启动问题（cold start）分三类：用户冷启动（新用户到来）、物品冷启动（新物品到来）、系统冷启动（新开发网站，没有用户和用户行为，只有物品信息）解决方法： 提供非个性化推荐：比如热门排行榜 利用用户注册时提供的年龄、性别等数据做粗粒度的个性化 利用用户社交网络账号（需用户授权），导入用户好友信息，给用户推荐好友喜欢的物品 要求用户登录时对物品进行反馈，收集兴趣信息从而推荐和物品相似的物品 新加入的物品利用内容信息，将它们推荐给喜欢过相似物品的用户 系统冷启动引入专家知识 用户注册信息分3种： 人口统计学信息：年龄、性别、职业、民族、学历和居住地 用户兴趣描述 其它网站导入用户站外行为数据 基于人口统计学特征的推荐系统其典型代表是Bruce Krulwich开发的Lifestyle Finder。 基于注册信息的个性化推荐流程： 获取用户的注册信息； 根据用户的注册信息对用户分类； 给用户推荐他所属分类中用户喜欢的物品。 有两个推荐系统数据集包含了人口统计学信息，BookCrossing数据集和Last.fm数据集。BookCrossing数据集包含用户对图书的行为信息，包含3个文件。BX-Users.csv，包含用户的ID、位置和年龄。BX-Books.csv，包含图书的ISBN、标题、作者、发表年代、出版社和缩略。BX-Book-Ratings.csv，包含用户对图书的评分信息。 ItemCF算法存在严重的冷启动问题。 一般来说，物品的内容可以通过向量空间模型（Vector Space Model）表示，该模型会将物品表示成一个关键词向量。从文本生成关键词向量的主要步骤：文本–&gt;分词–&gt;实体检测–&gt;关键词排名–&gt;关键词向量对物品d，它的内容表示成一个关键词向量：$$d_i = {(e_1, w_1),(e_2,w_2),…}$$其中$e_i$是关键词，$w_i$是关键词权重。若物品是文本，可用信息检索领域著名的TF-IDF公式计算词的权重： …先让我更新一下友链","raw":null,"content":null,"categories":[{"name":"推荐系统","slug":"推荐系统","permalink":"https://hubojing.github.io/categories/推荐系统/"}],"tags":[{"name":"推荐系统","slug":"推荐系统","permalink":"https://hubojing.github.io/tags/推荐系统/"}]},{"title":"注意力机制","slug":"注意力机制","date":"2019-11-26T06:08:38.000Z","updated":"2020-01-18T04:53:42.000Z","comments":true,"path":"2019/11/26/注意力机制/","link":"","permalink":"https://hubojing.github.io/2019/11/26/注意力机制/","excerpt":"　　没写完 ","text":"没写完 概念从众多信息中选择出对当前任务目标更关键的信息。 起源图像领域到自然语言处理领域 Encoder-Decoder框架目前大多数注意力模型附着于Encoder-Decoder框架。一般而言，文本处理和语音识别的Encoder部分通常采用RNN模型，图像处理的Encoder一般采用CNN模型。对比：分心模型Attention函数的本质可以被描述为一个查询（query）到一系列（键key-值value）对的映射。在计算attention时主要分为三步，第一步是将query和每个key进行相似度计算得到权重，常用的相似度函数有点积，拼接，感知机等；然后第二步一般是使用一个softmax函数对这些权重进行归一化；最后将权重和相应的键值value进行加权求和得到最后的attention。目前在NLP研究中，key和value常常都是同一个，即key=value。 参考资料https://blog.csdn.net/hpulfc/article/details/80448570https://www.cnblogs.com/robert-dlut/p/8638283.html","raw":null,"content":null,"categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://hubojing.github.io/categories/人工智能/"}],"tags":[{"name":"注意力机制","slug":"注意力机制","permalink":"https://hubojing.github.io/tags/注意力机制/"},{"name":"论文笔记","slug":"论文笔记","permalink":"https://hubojing.github.io/tags/论文笔记/"}]},{"title":"一元线性回归","slug":"一元线性回归","date":"2019-11-25T07:31:46.000Z","updated":"2019-12-27T13:55:21.098Z","comments":true,"path":"2019/11/25/一元线性回归/","link":"","permalink":"https://hubojing.github.io/2019/11/25/一元线性回归/","excerpt":"　　深度学习实践系列笔记 ","text":"深度学习实践系列笔记 损失函数L1损失：基于模型预测的值与标签的实际值之差的绝对值平方误差（L2误差）：均方误差（MSE）指每个样本的平均平方损失 MSE 梯度下降法梯度：矢量沿着负梯度方向探索 超参数超参数：开始学习过程之前设置的参数，而不是训练得到的参数典型超参数：学习率、神经网络的隐含层数量 步骤 准备数据 构建模型 训练模型 进行预测 生成人工数据集123456789101112131415#在jupyter中使用matplotlib显示图像需设为inline模式，否则不会显示图像%matplotlib inlineimport matplotlib.pyplot as pltimport numpy as npimport tensorflow as tf#设置随机数种子np.random.seed(5)#直接采用np生成等差数列的方法，生成100个点，每个点的取值在-1~1之间x_data = np.linspace(-1, 1, 100)# y=2x+1+噪声，噪声的维度与x_data一致y_data = 2*x_data + 1.0 + np.random.randn(*x_data.shape) * 0.4 numpy.random.randn(d0, d1, …, dn)是从标准正态分布中返回一个或多个样本值实参前加上*和**时代表拆包，单个*表示将元祖拆成一个个单独的实参 画图12345#画出随机生成数据的散点图plt.scatter(x_data, y_data)#画出线性函数y=2x+1plt.plot(x_data, 2*x_data + 1.0, color='red', linewidth=3) 散点图 构建模型1234567891011121314x = tf.placeholder(\"float\", name = \"x\")y = tf.placeholder(\"float\", name = \"y\")def model(x, w, b): return tf.multiply(x, w) + b#构建线性函数的斜率w = tf.Variable(1.0, name=\"w0\")#构建线性函数的截距b = tf.Variable(0.0, name=\"b0\")#pred是预测值，前向计算pred = model(x, w, b) 训练模型123456789101112131415161718192021222324252627282930#迭代次数（训练轮数）train_epochs = 10#学习率learning_rate = 0.05#采用均方差作为损失函数loss_function = tf.reduce_mean(tf.square(y - pred))#梯度下降优化器optimizer = tf.train.GradientDescentOptimizer(learning_rate).minimize(loss_function)sess = tf.Session()init = tf.global_variables_initializer()sess.run(init)#开始训练，采用SGD随机梯度下降优化方法for epoch in range(train_epochs): for xs,ys in zip(x_data, y_data): _, loss = sess.run([optimizer,loss_function], feed_dict=&#123;x: xs, y: ys&#125;) b0temp = b.eval(session=sess) w0temp = w.eval(session=sess) #plt.plot(x_data, w0temp * x_data + b0temp) print(\"w:\", sess.run(w))print(\"b:\", sess.run(b))plt.scatter(x_data, y_data, label='Original data')plt.plot(x_data, x_data * sess.run(w) + sess.run(b), label='Fitted line', color='r', linewidth=3)plt.legend(loc=2)#通过参数loc指定图例位置 常见损失函数：均方差（Mean Square Error, MSE）和交叉熵（cross-entropy）定义优化器Optimizer，初始化一个GradientDescentOptimizer设置学习率和优化目标：最小化损失 训练结果 w: 1.9822965b: 1.0420128 对比 预测1234567x_test = 3.21predict = sess.run(pred, feed_dict=&#123;x: x_test&#125;)print(\"预测值：%f\" % predict)target = 2 * x_test + 1.0print(\"目标值：%f\" % target) 或者123x_test = 3.21predict = sess.run(w) * x_test + sess.run(b)print(\"预测值：%f\" % predict) 预测值：7.405184目标值：7.420000 显示损失值12345678910111213141516step = 0#训练步数loss_list = []display_step = 2for epoch in range(train_epochs): for xs,ys in zip(x_data, y_data): _, loss = sess.run([optimizer,loss_function], feed_dict=&#123;x: xs, y: ys&#125;) #显示损失值loss,display_step控制报告的粒度 #若display_step为2，则将每训练2个样本输出一次损失值 loss_list.append(loss) step = step + 1 if step % display_step == 0: print(\"Train Epoch:\",\"%02d\" % (epoch+1), \"Step: %03d\" % (step), \"loss=\", \"&#123;:.9f&#125;\".format(loss))#plt.plot(loss_list)plt.plot(loss_list,'r+') 123456789101112Train Epoch: 05 Step: 408 loss= 0.125508696Train Epoch: 05 Step: 410 loss= 0.036273275Train Epoch: 05 Step: 412 loss= 0.000716237Train Epoch: 05 Step: 414 loss= 0.097748078Train Epoch: 05 Step: 416 loss= 0.026035903Train Epoch: 05 Step: 418 loss= 0.633028984Train Epoch: 05 Step: 420 loss= 0.084138028Train Epoch: 05 Step: 422 loss= 0.088319123Train Epoch: 05 Step: 424 loss= 0.002654018Train Epoch: 05 Step: 426 loss= 0.116265893Train Epoch: 05 Step: 428 loss= 0.018808722Train Epoch: 05 Step: 430 loss= 0.000472802 显示损失值 loss1 loss2 1[x for x in loss_list if x&gt;1] 打印突出的点1234567891011121314151617[1.0133754, 1.2284044, 1.0088208, 1.2116321, 2.3539772, 2.3148305, 1.3175836, 1.0387748, 1.5018207, 1.547514, 1.5514, 1.5517284, 1.5517554, 1.551758, 1.551758, 1.551758, 1.551758] 随机梯度下降梯度下降法中，批量指用于在单次迭代中计算梯度的样本总数。批量可能相当巨大。随机梯度下降法（SGD）每次迭代只是用一个样本（批量大小为1）。随机表示构成各批量的一个样本是随机选择的。小批量随机梯度下降法（小批量SGD）是介于全批量迭代与SGD之间的折中方案。通常包含10-1000个随机选择的样本。 完整代码https://github.com/hubojing/DeepLearningCode-TensorFlow/blob/master/Simple%20linear%20regression.py","raw":null,"content":null,"categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://hubojing.github.io/categories/人工智能/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://hubojing.github.io/tags/深度学习/"}]},{"title":"再学Java-基础","slug":"再学Java","date":"2019-10-27T13:21:25.000Z","updated":"2020-11-27T14:12:31.000Z","comments":true,"path":"2019/10/27/再学Java/","link":"","permalink":"https://hubojing.github.io/2019/10/27/再学Java/","excerpt":"　　详尽笔记，用于复习和速查　　将包含基础、进阶、高阶　　目前更新到数据结构-JCF-Set ","text":"详尽笔记，用于复习和速查 将包含基础、进阶、高阶 目前更新到数据结构-JCF-Set 概述 Java SE(Standard Edition) 面向PC级应用开发 Java EE(Enterprise Edition) 面向企业级应用开发 Java ME(Micro Edition) 面向嵌入式应用开发 环境搭建JDK下载搜索java archive，选择版本下载。（本文选择JDK1.8)安装JDK时，会同时安装JRE。 配置环境变量新增JAVA_HOMEC:\\Java\\jdk1.8.0_73（jdk地址）修改Path新增%JAVA_HOME%\\bin 上移到最高 打开cmdjava -version有版本号输出javac有用法输出即可。 配置Eclipse修改字号Window-Preferences-General-Appaerance-Colors and Fonts-右侧Java-Java Editor Text Font 显示行号General-Editors-Text Editors-右侧show line numbers勾上 自动保存时间间隔General-Workspace-右侧Workspace save interval(in minutes)（默认5分钟）下方可以修改文本编码格式 复原视窗Window-Perspective-Reset Perspective… Eclipse使用教程 Java从编写到运行编写：利用记事本/vi/IDE等完成代码文件(.java)编写编译：利用JDK中javac.exe将代码(.java)编译成字节码文件(.class)运行：java.exe读入并解释字节码文件(.class)，最终在JVM上运行 编程标准 类名首字母大写，后面单词驼峰命名 方法名和变量名首字母小写，后面单词驼峰命名 阿里巴巴编程标准 基础知识class类 java文件必须以.java作为扩展名 一个java文件只能有一个public class public class的名字必须和文件名字一样，大小写都要完全一致 一个文件可有多个class，但是只能有一个是public。不提倡一个文件里面放多个类（内部类除外） System.out.print 输出 System.out.println 换行输出 类是Java中最基础逻辑单位Java所有内容都需放在类的范围中 类的构成成员变量/属性成员方法/函数 main函数 一个class最多只能有一个main函数（经指正，一个类可以有多个main函数-通过重载，但只能有一个入口函数）类可以没有main函数，没有main函数的类不能主动执行，但可以被动执行（被调用执行） 程序入口都是main函数 main函数的形参和前缀修饰符public、static、void等都不能省略，是固定写法注意区别 12345678public static void main(String[] args)&#123; //PSVM，main函数&#125;public void main()&#123; //普通main函数，不是入口函数&#125; 严格意义上说，main函数不属于这个类的所拥有函数。只是因为Java要求所有内容都必须放置在class范围内，所有main函数“寄居”在某一个class中。 main函数无法被其它方法/类所调用。 一个Java程序可调用多个其它Java class。 String[] args是main函数的形参，即在main函数中可使用args的值（这些值在main函数启动时输入）。 右键test.java，Run As-&gt;Run Configuration-右侧Arguments-输入Program arguments程序参数-Run多个变量需用空格隔开 八种基本类型 boolean 布尔true false(默认) byte 字节1 byte = 8 bits存储有符号的，以二进制补码表示的整数最小值-128，最大值127，默认值0该类型用在大型数组中可显著节约空间（占用空间只用int类型的四分之一），主要代替小整数在二进制文件读写中使用较多1234byte a = (byte) -129;System.out.println(a);//127byte b = (byte) 128;System.out.println(b);//-128 怎么理解：标准值：-128~127两边可以延伸左延伸-384(-128)~-129(127)右延伸128(-128)~383(127) short/int/long 短整数/整数/长整数short 16位 2个字节 -32768~32767,-2^15~2^15-1，默认值0int 32位，4个字节 -2147483648~2147483647，-2^31~2^31-1，默认值0long 64位 8个字节 -9223372036854775808~9223372036854775807,-2^63~2^63-1,默认值0L float/double 浮点数float 单精度 32位 4个字节 1.410^-45~3.410^38 默认值0.0fdouble 双精度 64位 8个字节 4.910^-324~1.710^308 默认值0.0dfloat和double都不能用来表示很精确的数字 char 字符16位 Unicode字符最小值是 \\u0000(即为0)最大值是\\uffff(即为65535)（\\u4e00~\\u9fa5两万多汉字） 运算符&gt;&gt; 右移 除以2&lt;&lt; 左移 乘以2 自定义函数重载(overload)：同一个类中，函数名称可以相同，但函数参数的个数或者类型必须有所不同不能以返回值来区分同名的函数 面向对象对象=属性+方法对象的规范=属性定义+方法定义1A obj = new A(); obj可看作是内存中一个对象（包含若干个数据）的句柄 在C/C++中，obj称为指针，在Java中称为Reference 对象赋值是Reference赋值，基本类型是直接值拷贝理解：基本类型的变量值小，可直接拷贝；对象包含多个值，不容易复制，赋值采用共享同一块内存区域。 函数内的局部变量，编译器不会给默认值，需初始化；类的成员变量，编译器会给默认值，可直接使用。 构造函数 构造函数名称必须和类名一样，且没有返回值public void A(int x)不是构造函数，而是普通函数。 Java有构造函数，但没有析构函数 每个变量都有生命周期，它只能存储在离它最近的一对{}中（经指正，此条不够严谨） Java具有内存自动回收机制，当变量退出其生命周期后，JVM会自动回收所分配的对象的内存。 对象回收效率依赖于垃圾回收器GC(Garbage Collector)，其回收算法关系到性能好坏，是JVM研究热点。 每个Java类都必须有构造函数 若没有显式定义构造函数，Java编译器自动为该类产生一个空的无形参构造函数。若有显式构造函数，编译器就不会再产生构造函数 每个子类的构造函数的第一句话，都默认调用父类的无参数构造函数super()，除非子类的构造函数第一句话是super，而且super语句必须放在第一条 一个类可有多个构造函数，只要形参列表不同 多个class可写在一个.java文件中，但最多只有一个类是public class，并且public class类的名字必须和.java文件名相同。 信息隐藏原则 类的成员属性，是私有的private 类的方法，是共有的public，通过方法修改成员属性的值 get和set方法是公有public的，统称为getter和setter 外界对类成员的操作只能通过get和set方法 可用Java IDE快速生成Source-Generate Getters and Setters… this this负责指向本类中的成员变量 123456789101112public class Test&#123; private int id; public Test(int id)&#123; //在这个构造函数里，形参优先级更高 this.id = id; &#125; public int getId()&#123; return id; &#125;&#125; this负责指向本类中的成员方法 1this.add(1,2);//调用本类的add方法，this可忽略 this可代替本类的构造函数 1this(5);//调用本类的一个形参的构造函数 继承、接口和抽象类继承父类/基类/超类Parent class/Base class/Super class子类/派生类Child class/Derived class 子类继承父类所有的属性和方法（但不能直接访问private成员） 根据信息隐藏原则：子类会继承父类所有的方法，可直接使用 子类也会继承父类的父类所有的属性和方法（但不能直接访问private成员）子类可以通过调用父类的方法来访问父类的私有的成员属性在同样方法名和参数情况下，本类的方法会比父类的方法优先级高 区别于C++，单根继承 单根继承原则：每个类都只能继承一个类 若不写extends，Java类默认继承java.lang.Object类 Java所有类从java.lang.Object开始，构造出一个类型继承树 Object类里面默认就有clone, equals, finalize, getClass, hashCode, toString等方法 每个子类的构造函数的第一句话，都默认调用父类的无参数构造函数super()，除非子类的构造函数第一句话是super，而且super语句必须放在第一条如果构造函数的第一句话不是super，编译器会自动增加一句super();。如果构造函数第一句是自己写的super语句，编译器就不会自动添加。 抽象类若方法只有方法名字，形参列表，没有方法体，那所在的类就被定义为抽象类。若一个类暂时有方法未实现，需被定义为抽象类。 一个类继承于抽象类，就不能继承于其他的（抽象）类 子类可继承于抽象类，但一定要实现父类们所有abstract的方法，若不能完全实现，子类也必须被定义为抽象类 接口 如果类的所有方法都没有实现，这个类就算是接口interface 1234public interface Animal&#123; public void eat(); public void move();&#125; 类只可以继承(extends)一个类，但可实现(implements)多个接口，继承和实现可以同时 接口不算类，或者说是特殊的类 接口可以继承（多个）接口，没有实现的方法将会叠加 类实现接口，就必须实现所有未实现的方法。若没有全部实现，只能成为一个抽象类 接口里可定义变量，但一般是常量 （经指正，成员变量只能是常量） 总结抽象类和接口相同点：两者都不能被实例化，不能new操作不同点： 抽象类abstract，接口interface 抽象类可有部分方法实现，接口所有方法不能有实现 （经指正，Java8后，接口可有默认实现） 一个类只能继承(extends)一个（抽象）类，实现(implenments)多个接口 接口可继承(extends)多个接口 抽象类有构造函数，接口没有构造函数 抽象类可有main，也能运行，接口没有main函数 抽象类方法可有private/protected，接口方法都是public 类转型类型可相互转型，但只限制于有继承关系的类 子类可转换成父类（从大到小，向上转型），而父类不可转为子类（从小变大，向下转型） 父类转为子类有一种情况例外：这个父类本身就是从子类转化而来12Human obj1 = new Man();//OK, Man extends HumanMan obj2 = (Man) obj1;//OK, because obj1 is born from Man class 多态 类型转换带来的作用就是多态 子类继承父类的所有方法，但子类可重新定义一个名字，参数和父类样的方法，这种行为是重写（覆写，覆盖，overwrite/override,not overload(重载)) 子类方法优先级高于父类123456789101112131415public class Man extends Human&#123; public void eat()&#123; System.out.println(\"I can eat more\"); &#125; public void plough() &#123; &#125; public static void main(String[] a)&#123; Man obj1 = new Man(); obj1.eat();//call Man.eat() Human obj2 = (Human) obj1; obj2.eat();//call Man.eat() Man obj3 = (Man) obj2; obj3.eat();//call Man.eat() &#125;&#125; 契约设计：类不会直接使用另外一个类，而是采用接口的形式，外部可以“空投”这个接口下的任意子类对象 static、final和常量设计staticstatic关键字可作用在： 变量static变量只依赖于类存在（通过类即可访问），不依赖于对象实例存在。所有对象实例，关于同一个变量的值都共享存储在一个共同的空间（栈）。 方法静态方法无需通过对象来引用，而通过类名可直接引用。静态方法中只能使用静态变量，不能使用非静态变量。静态方法禁止引用非静态方法。 类 匿名方法块static块只在类第一次被加载时调用，在程序运行期间，代码只运行一次执行顺序：static块 &gt; 匿名块 &gt; 构造函数1234567891011121314151617class StaticBlock&#123; static &#123; System.out.println(\"static 块\"); &#125; &#123; System.out.println(\"匿名块\"); &#125; public StaticBlock() &#123; System.out.println(\"构造函数\"); &#125; &#123; System.out.println(\"匿名块\"); &#125;&#125; 单例模式 又名单态模式，Singleton 限定某一个类在整个程序运行过程中，只能保留一个实例对象在内存空间 GoF的23中设计模式(Design Pattern)（创建型、结构型、行为型）中经典的一种，属于创建型模式类型 采用static来共享对象实例 采用private构建函数，防止外界new操作 finalfinal关键字用来修饰 类 方法 字段 final的类，不能被继承（不能有子类） 父类中若有final方法，子类不能改写此方法子类方法和父类方法在方法名和参数列表一样，就属于方法改写/重写/覆写，若参数列表不一样，就属于方法重载 final的变量不能再次赋值若是基本类型的变量，不能修改其值若是对象实例，不能修改其指针（但可修改对象内部的值）1234567891011121314class FinalObject&#123; int a = 10;&#125;public class FinalObjectTest&#123; public static void main(String[] args)&#123; final FinalObject obj1 = new FinalObject(); System.out.println(obj1.a); obj1.a = 20; System.out.println(obj1.a);//正确，可以修改内部值 obj1 = new FinalObject();//报错，不能修改指针 &#125;&#125; 常量设计 Java没有constant关键字 不能修改， final 不会修改/只读/只要一份， static 方便访问public Java中的常量 public static final 建议变量名字全大写，以连字符相连，如UPPER_BOUND 一种特殊的常量：接口内定义的变量默认是常量 常量池 Java为很多基本类型的包装类/字符串都建立常量池 常量池：相同的值只存储一份，节省内存，共享访问 基本类型的包装类Boolean: true, falseByte:-128~127Short, Integer, Long:-128~127Character:0~127不包括Float, Double:没有缓存(常量池) 1234567891011Long l1 = -128L;Long l2 = -128L;System.out.println(String.valueOf(l1==l2));//trueFloat f1 = 0.5f;Float f2 = 0.5f;System.out.println(String.valueOf(f1 == f2));//falseDouble d1 = 0.5;Double d2 = 0.5;System.out.println(String.valueOf(d1 == d2));//false Java为常量字符串都建立常量池缓存机制 基本类型的包装类和字符串有两种创建方式 常量式（字面量）复制创建，放在栈内存（将被常量化） 12Integer a = 10;String b = \"abc\"; new对象进行创建，放在堆内存（不会常量化） 12Integer c = new Integer(10);String d = new String(\"abc\"); 这两种创建方式导致创建的对象存放的位置不同栈内存读取速度快但容量小堆内存读取速度慢但容量大 基本类型和包装类比较，将对包装类自动拆箱 对象比较，比较地址 加法+会自动拆箱 12345678910111213141516171819202122232425int i1 = 10;Integer i2 = 10;//自动装箱System.out.println(i1 == i2);//true//自动拆箱 基本类型和包装类进行比较，包装类自动拆箱Integer i3 = new Integer(10);System.out.println(i1 == i3);//true//自动拆箱 基本类型和包装类进行比较，包装类自动拆箱System.out.println(i2 == i3);//false//两个对象比较，比较其地址//i2是常量，放在栈内存常量池中，i3是new出对象，放在堆内存中Integer i4 = new Integer(5);Integer i5 = new Integer(5);System.out.println(i1 == (i4+i5));//trueSystem.out.println(i2 == (i4+i5));//trueSystem.out.println(i3 == (i4+i5));//true//i4+i5操作将会使得i4,i5自动拆箱为基本类型并运算得到10//基础类型10和对象相比，将会使对象自动拆箱，做基本类型比较Integer i6 = i4 + i5;//+操作使得i4,i5自动拆箱，得到10，因此i6 == i2System.out.println(i1 == i6);//trueSystem.out.println(i2 == i6);//trueSystem.out.println(i3 == i6);//false 常量赋值（堆内存）和new创建（栈内存）不是同一个对象 编译器只会优化确定的字符串，并缓存12345678910111213141516171819202122String s0 = \"abcdef\";String s1 = \"abc\";String s2 = \"abc\";String s3 = new String(\"abc\");String s4 = new String(\"abc\");System.out.println(s1 == s2);//true常量池System.out.println(s1 == s3);//false一个栈内存，一个堆内存System.out.println(s3 == s4);//false两个都是堆内存String s5 = s1 + \"def\";//设计到变量，编译器不优化String s6 = \"abc\" + \"def\";//都是常量，编译器会自动优化成abcdefString s7 = \"abc\" + new String(\"def\");//设计到new对象，编译器不优化System.out.println(s5 == s6);//falseSystem.out.println(s6 == s7);//falseSystem.out.println(s0 == s6);//trueString s8 = s3 + \"def\";//涉及到new对象，编译器不优化String s9 = s4 + \"def\";//设计到new对象，编译器不优化String s10 = s3 + new String(\"def\");//涉及到new对象，编译器不优化System.out.println(s8 == s9);//falseSystem.out.println(s8 == s10);//falseSystem.out.println(s9 == s10);//false 不可变对象和字符串不可变对象 不可变对象(Immutable Object)一旦创建，该对象（状态/值）不能被更改其内在的成员变量的值不能修改如八个基本型别的包装类String, BigInteger和BigDecimal等 可变对象(Mutable Object)普通对象12345String a = new String(\"abc\");String b = a;System.out.println(b);//abca = \"def\";System.out.println(b);//abc 不可变对象是指值对象不再修改，即abc不会被修改，而指针（句柄/变量名）a的指向可以修改。不可变对象，也是传指针（引用）由于不可变，临时变量指向新内存，外部实参的指针不改动1234567public static void change(String b)&#123; b = \"def\";&#125;a = new String(\"abc\");change(a);System.out.println(a);//abc a-&gt;abcb–^change(a)后a-&gt;abcb-&gt;def 如何创建不可变对象immutable对象是不可改变，改变要clone/new一个对象进行修改所有属性是final和private不提供setter方法类是final的，或所有方法都是final勒种包含mutable对象，那么返回拷贝需要深度clone 不可变对象(Immutable Object)优点只读，线程安全并发读，提高性能可重复使用 缺点制造垃圾，浪费空间 字符串不可变对象字符串内容比较：equals方法是否指向同一个对象：指针比较== 字符串加法12String a = \"abc\";a = a + \"def\";//String不可修改，需新申请空间，效率差 使用SrringBuffer/StringBuilder类的append方法进行修改StringBuffer/StringBuilder的对象都是可变对象StringBuffer(同步，线程安全，修改快速)，StringBuilder（不同步，线程不安全，修改更快）12345678910111213141516171819202122232425public static void changeValue(int a)&#123; a = 10;&#125;public static void changeValue(String s1)&#123; s1 = \"def\";&#125;public static void changeValue(StringBuffer s1)&#123; s1.append(\"def\");&#125;public static void main(String[] args)&#123; int a = 5; String b = \"abc\"; StringBuffer c = new StringBuffer(\"abc\"); changeValue(a); changeValue(b); changeValue(c); System.out.println(a);//5 System.out.println(b);//abc System.out.println(c);//abcdef&#125; package, import和classpathpackage和import 若所有Java类都是放置在同一个目录下的，类之间相互调用无需显式声明调用同一个目录下，两个类的名字不能相同文件过多不方便查找 Java支持多个目录放置Java，并通过package/import/classpath/jar等机制配合使用，可支持跨目录放置和调用Java类1234package cn.edu.pku;public class PackageExample&#123;&#125; 类全称cn.edu.pku.PackageExample，短名称PackageExample引用类时，必须采用全称引用；程序正文可用短名称PackageExample.java必须严格放置在cn/edu/pku目录下 包名尽量唯一 域名是唯一的，因此常用域名做包名 域名逆序：cn.edu.pku，范围通常从大到小类的完整名字：包名+类名，cn.edu.pku.PackageExample包名：和目录层次一样，cn\\edu\\pku\\PackageExample.java包具体放在上面位置不重要，编译和运行时再制定 举个栗子123456789101112package cn.edu.pku;import cn.edu.pku.PackageExample;//或import cn.edu.pku.*//但不能是import cn.*//若PackageExample和当前类在同一个目录，可省略importpublic class PackageExampleTest&#123; public static void main(String[] args)&#123; PackageExample obj = new PackageExample(); //此处可用类的短名称来引用 &#125;&#125; “*”代表这个目录下所有文件，但不包括子文件夹和子文件夹内的文件。 import规则 import必须全部放在package之后，类定义之前package必须是第一句话 多个import的顺序无关 可用来引入一个目录下的所有类，比如import java.lang.;注意：不能递归包含其下各个目录下的文件 import尽量精确，不推荐*，以免新增同名程序会使老程序报错 jar用于可执行程序文件的传播，实际上是一组class文件的压缩包项目引入一个jar文件，就可以使用jar文件中所有类（.class文件），无需类的源码（.java文件）。jar只包含.class文件，没有.java文件，不会泄露源码。不过Java里的一些反编译工具，可从class反编译到Java。 利用Eclipse的Export功能导出jar文件 选中项目，点击顶部菜单File-Export-Java-Jar File classpath手动创建c:\\temp\\cn\\com\\test\\Man.java编译：1javac c:\\temp\\cn\\com\\test\\Man.java 运行：1java -classpath .;c:\\temp cn.com.test.Man -classpath固定格式参数，简写为-cp.;c:\\tempwindows是分号，Linux/Mac是冒号当在某一个子路径找到所需类后，后续子路径不再寻找在classpath中，子路径排在前面优先级高当所有子路径都寻找不到所需类，系统会报告NoClassDefFoundException错误 编译和运行规则 编译一个类，需java文件全路径，包括拓展名 运行一个类，需写类名全称（非文件路径），无需写扩展名 编译类时，需给出这个类所依赖的类（包括依赖的类再次依赖的所有其他类）的所在路径 运行类时，需给出这个类，以及被依赖类的路径总和 classpath参数也可以包含jar包。若路径内有空格，请将classpath参数整体加双引号。1java -classpath &quot;.;c:\\test.jar;c:\\temp;c:\\a bc&quot; cn.com.test.Man Java访问权限 private：私有，只能本类访问 default（通常忽略不写）：同一个包内访问 protected: 同一个包，子类均可以访问 public：公开，所有类都可访问四种都可用来修饰成员变量、成员方法、构造函数default和public可修饰类12class A &#123; &#125;//default classpublic class B&#123; &#125;//public class 权限表 同一个类 同一个包 不同包的子类 不同包的非子类private √default √ √protected √ √ √public √ √ √ √ Java常用类Java类库文档https://docs.oracle.com/en/https://docs.oracle.com/en/java/javase/13/docs/api/index.html这些文档原先是程序中的注释。利用JavaDoc技术，将这些注释抽取出来，组织形成的以HTML为表现形式的API文档。 数字类 Java数字类整数Short, Int, Long浮点数Float, Double大数类BigInteger(大整数), BigDecimal(大浮点数)大数类没有限制，可表示无穷大的数字123456789101112131415161718BigInteger b1 = new BigInteger(\"123456789\");BigInteger b2 = new BigInteger(\"987654321\");System.out.println(b2.add(b1));//加法操作System.out.println(b2.subtract(b1));//减法操作System.out.println(b2.multiply(b1));//乘法操作System.out.println(b2.divide(b1));//除法操作System.out.println(b2.max(b1));//求出最大数System.out.println(b2.min(b1));//求出最小数BigInteger result[] = b2.divideAndRemainder(b1);//求出余数的除法操作System.out.println(\"商是：\" + result[0] + \"；余数是：\" + result[1]);//求出余数的除法操作System.out.println(b1.equals(b2));//是否等价int flag = b1.compareTo(b2);if(flag == -1) System.out.println(\"比较操作：b1&lt;b2\");else if(flag == 0) System.out.println(\"比较操作：b1==b2\");else System.out.println(\"比较操作：b1&gt;b2\"); 尽量采用字符串对BigDecimal赋值，这样精度更准确。12345678System.out.println(new BigDecimal(\"2.3\"));System.out.println(new BigDecimal(2.3));//2.29999999999999BigDecimal num1 = new BigDecimal(\"10\");BigDecimal num2 = new BigDecimal(\"3\");//需要指定位数，防止无限循环，或者包含在try-catch中BigDecimal num3 = num1.divide(num2, 3, BigDecimal.ROUND_HALF_UP);System.out.println(num3); BigDecimal做除法操作，需要注意截断，防止出现无限循环小数。 随机数类RandomnextInt() 返回一个随机IntnextInt(int a) 返回一个[0,a)之间的随机intnextDouble() 返回一个[0.0,1.0]之间doubleints方法批量返回随机数数组Math.random() 返回一个[0.0,1.0]之间double1234567891011121314151617181920212223242526//第一种，采用Random类随机生成Random rd = new Random();System.out.println(rd.nextInt());System.out.println(rd.nextInt(100));//0-100的随机数System.out.println(rd.nextLong());System.out.println(rd.nextDouble());//第二种，生成一个范围内的随机数 例如0-10之间的随机数System.out.println(Math.round(Math.random()*10));//JDK 8 新增方法rd.ints();//返回无限个int类型范围内的数据int[] arr = rd.ints(10).toArray();//生成10个int范围类的个数for(int i = 0;i &lt; arr.length; i++)&#123; System.out.println(arr[i]);&#125;arr = rd.ints(5, 10, 100).toArray();//5个10-100的随机数for(int i = 0; i &lt; arr.length; i++)&#123; System.out.println(arr[i]);&#125;arr = rd.ints(10).limit(5).toArray();for(int i = 0;i &lt; arr.length; i++)&#123; System.out.println(arr[i]);&#125; 工具类Mathjava.math包java.lang.Math绝对值函数abs对数函数log比较函数max、min幂函数pow四舍五入函数round向下取整floor向上取整ceil 字符串相关类StringJava使用频率最高的类一个不可变对象，加减操作性能较差常用：charAt, concat, contains, endsWith, equals, equalsIgnoreCase, hashCode, indexOf, length, matches, replace, replaceAll, split, startsWith, subString, trim, valueOf1234567891011121314151617181920212223String a = \"123;456,789,123 \";System.out.println(a.charAt(0));//返回第0个元素System.out.println(a.indexOf(\";\"));//返回第一个;的位置System.out.println(a.concat(\";000\"));//连接一个新字符串并返回，a不变System.out.println(a.contains(\"000\"));//判断a是否包含000System.out.println(a.endWith(\"000\"));//判断a是否以000结尾System.out.println(a.equals(\"000\"));//判断是否等于000System.out.println(a.equalsIgnoreCase(\"000\"));//判断在忽略大小写情况下是否等于000System.out.println(a.length());//返回a长度System.out.println(a.trim());//返回a去除前后空格后的字符串，a不变String[] b = a.split(\";\");//将a字符串按照;分割成数组for(int i = 0; i &lt; b.length; i++)&#123; System.out.println(b[i]);&#125;System.out.println(a.substring(2, 5));//截取a的第2个到第5个字符 a不变System.out.println(a.replace(\"1\", \"a\"));System.out.println(a.replaceAll(\"1\", \"a\");//replaceAll第一个参数是正则表达式String s1 = \"123456789\";String s2 = s1.replace(\"?\", \"a\");String s3 = s1.replaceAll(\"[?]\", \"a\");//这里的[?]才表示字符问号，这样才能正常替换。不然在正则中会有特殊的意义就会报异常 trim方法去掉的是字符串的前后空格，无法去除字符串中间的空格。 可变字符串StringBuffer(字符串加减，同步，性能好)StringBuilder(字符串加减，不同步，性能更好) StringBuffer/StringBuilder：方法一样，区别在同步append/insert/delete/replace/substringlength字符串实际大小，capacity字符串占用空间大小trimToSize()：去除空隙，将字符串存储压缩到实际大小如有大量append，事先预估大小，再调用相应构造函数 时间类 java.util.Date（基本废弃，Deprecated）getTime()，返回自1970.1.1以来的毫秒数 java.spl.Date（和数据库对应的时间类） Calendar是目前程序中最常用的，但是是抽象类Calendar gc = Calendar.getInstance();Calendar gc = new GregorianCalendar();简单工厂模式查看CalendarClassTest.java Calendarget(Field) 来获取时间中每个属性的值，注意，月份0-11getTime() 返回相应的Date对象getTimeInMillis() 返回自1970.1.1以来的毫秒数set(Field) 设置时间字段add(field, amount) 根据指定字段增加/减少时间roll(field, amount) 根据指定字段增加/减少时间，但不影响上一级的时间段12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182Calendar calendar = Calendar.getInstance();public void test1()&#123; //获取年 int year = calendar.get(Calendar.YEAR); //获取月 int month = calendar.get(Calendar.MONTH) + 1; //获取日 int day = calendar.get(Calendar.DAY_OF_MONTH); //获取时 int hour = calendar.get(Calendar.HOUR); //获取分 int minute = calendar.get(Calendar.MINUTE); //获取秒 int second = calendar.get(Calendar.SECOND); //星期，从星期日算起 int weekday = calendar.get(Calendar.DAY_OF_WEEK);&#125;//一年后的今天public void test2()&#123; calendar.add(Calendar.YEAR, 1); //获取年 int year = calendar.get(Calendar.YEAR); //获取月 int month = calendar.get(Calendar.MONTH) + 1; //获取日 int day = calendar.get(Calendar.DAY_OF_MONTH);&#125;//获取任意一个月的最后一天public void test3()&#123; //假设求6月的最后一天 int currentMonth = 6; //先求出7月份的第一天 calendar.set(calendar.get(Calendar.YEAR), currentMonth, 1); calendar.add(Calenadr.DATA, -1); //获取日 int day = calendar.get(Calendar.DAY_OF_MONTH);&#125;//设置日期public void test4()&#123; calendar.set(Calendar.YEAR, 2000); System.out.println(\"现在是\" + calendar.get(Calendar.YEAR) + \"年\"); calendar.set(2018, 1, 2); //获取年 int year = calendar.get(Calendar.YEAR); //获取月 int month = calendar.get(Calendar.MONTH) + 1; //获取日 int day = calendar.get(Calendar.DAY_OF_MONTH);&#125;public void test5()&#123; calendar.set(2018, 7, 8); calendar.add(Calendar.DAY_OF_MONTH, -8); //获取年 int year = calendar.get(Calendar.YEAR); //获取月 int month = calendar.get(Calendar.MONTH) + 1; //获取日 int day = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(\"2018.7.8，用add减少8天，现在是\" + year + \".\" + month + \".\" + day); //2018.7.31 calendar.set(2018, 7, 8); calendar.roll(Calendar.DAY_OF_MONTH, -8); //获取年 int year = calendar.get(Calendar.YEAR); //获取月 int month = calendar.get(Calendar.MONTH) + 1; //获取日 int day = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(\"2018.7.8，用roll减少8天，现在是\" + year + \".\" + month + \".\" + day); //2018.8.31只改变天数，不改变月份&#125; roll函数做加减法，只影响当前字段，不影响进位。add函数则会影响进位。 Java 8 退出新的时间APIjava.time包旧的设计不好（重名的类、线程不安全等）新版本优点：不变性，在多线程环境下；遵循设计模式，设计得更好，可扩展性强 Java 8 时间包概述java.time包：新的Java日期/时间API的基础包主要类：LocalDate日期类LocalTime时间类（时分秒-纳秒）LocalDateTime：LocalDate + LocalTimeInstant时间戳java.time.chrono包：为非ISO的日历系统定义了一些泛化的APIjava.time.format包：格式化和解析日期时间对象的类java.time.temporal包：包含一些时态对象，可以用其找出关于日期/时间对象的某个特定日期或时间java.time.zone包：包含支持不同时区以及相关规则的类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//当前时间LocalDate today = LocalDate.now();//根据指定时间创建LocalDateLocalDate firstDay_2014 = LocalDate.of(2014, Month.JANUARY, 1);//给定错误时间参数，将报异常java.time.DateTimeException//LocalDate firstDay_2014 = LocalDate.of(2014, Month.FEBRUARY, 29);//可更改时区LocalDate todayBeijing = LocalDate.now(ZoneId.of(\"Asia/Shanghai\"));//从纪元日01/01/1970开始365天LocalDate dateFromBase = LocalDate.ofEpochDay(365);//2014年的第100天LocalDate hundredDay2014 = LocalDate.ofYearDay(2014, 100);//当前时间 时分秒 纳秒LocalTime time = LocalTime.now();//根据时分秒LocalTime specificTime = LocalTime.of(12, 20, 25, 40);//错误的时间参数 将报DateTimeException//LocalTime invalidTime = LocalTime.of(25,20);//上海时间LocalTime timeSH = LocalTime.mow(ZoneId.of(\"Asia/Shanghai\"));//一天当中第几秒LocalTime specificSecondTime = LocalTime.ofSecondOfDay(10000);//当前时间戳Instant timestamp = Instant.now();//从毫秒数来创建时间戳Instant specificTime = Instant.ofEpochMilli(timestamp.toEpochMilli());Date date = Date.from(timestamp);LocalDate today = LocalDate.now();//判断是否是闰年System.out.println(\"Year \" + today.getYear() + \"is Leap Year\" + today.isLeapYear());//今天和01/01/2015比较System.out.println(\"Today is before 01/01/2015\" + today.isBefore(LocalDate.of(2015,1,1)));//当前时分秒System.out.println(\"Current Time =\" + today.atTime(LocalTime.now()));//加减时间System.out.println(\"10 days after today will be \" + today.plusDays(10));System.out.println(\"3 weeks after today will be \" + today.plusWeeks(3));System.out.println(\"20 months after today will be \" + today.plusMonths(20));System.out.println(\"10 days after today will be \" + today.minusDays(10));System.out.println(\"3 weeks after today will be \" + today.minusWeeks(3));System.out.println(\"3 weeks after today will be \" + today.minusMonths(20));//调整时间System.out.println(\"First date of this month = \" + today.with(TemporalAdjusters.firstDayOfMonth()));LocalDate lastDayOfYear = today.with(TemporalAdjusters.lastDayOfYear());System.out.println(\"Last date of this year = \" + lastDayOfYear);//时间段计算Period period = today.until(lastDayOfYear);System.out.println(\"Period Format = \" + period);System.out.println(\"Months remaining in the year = \" + period.getMonths()); 格式化（Format）相关类 java.text包java.text.Format的子类NumberFormat：数字格式化，抽象类– DecimalFormat 工厂模式例如：将1234567格式化输出为1,234,567 12345678910111213141516171819202122232425DecimalFormat df1,df2;//整数部分为0，#认为整数不存在，可不写；0认为没有，但至少写一位，写0df1 = new DecimalFormat(\"#.00\");df2 = new DecimalFormat(\"0.00\");System.out.println(df1.format(0.1));//.10System.out.println(df2.format(0.1));//0.10df1 = new DecimalFormat(\"0.00\");df2 = new DecimalFormat(\"0.##\");System.out.println(df1.format(0.1));//0.10System.out.println(df2.format(0.1));//0.1df1 = new DecimalFormat(\"0.00\");df2 = new DecimalFormat(\"#.00\");System.out.println(df1.format(2));//2.00System.out.println(df2.format(2));//2.00System.out.println(df1.format(20));//20.00System.out.println(df2.format(20));//20.00System.out.println(df1.format(200));//200.00System.out.println(df2.format(200));//200.00 MessageFormat：字符串格式化支持多个参数-值对位复制文本S支持变量的自定义格式例如将“Hello {1}”根据变量值格式化为Hello World 1234567String message = \"&#123;0&#125;&#123;1&#125;&#123;2&#125;&#123;3&#125;&#123;4&#125;&#123;5&#125;&#123;6&#125;&#123;7&#125;&#123;8&#125;&#123;9&#125;&#123;10&#125;&#123;11&#125;&#123;12&#125;&#123;13&#125;&#123;14&#125;&#123;15&#125;&#123;16&#125;\";object[] array = new Object[]&#123;\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\"&#125;;String value = MessageFormat.format(message, array);System.out.println(value);message = \"oh, &#123;0,number,#.##&#125; is a good number\";array = new Object[]&#123;new Double(3.1415)&#125;;value = MessageFormat.format(message, array); 输出12ABCDEFGHIJKLMNOPQoh, 3.14 is a good number DateFormat：日期/时间格式化，抽象类 – SimpleDateFormat 工厂模式 parse：将字符串格式化为时间对象 format：将时间对象格式化为字符串 如将当前时间转为YYYY-MM-DD HH24:MI:SS输出1234567891011121314String strDate = \"2008-10-19 10:11:30.345\";//准备第一个模板，从字符串中提取出日期数字String pat1 = \"yyyy-MM-dd HH:mm:ss.SSS\";//准备第二个模板，将提取后的日期数字变为指定的格式String pat2 = \"yyyy年MM月dd日 HH时mm分ss秒SSS毫秒\";SimpleDateFormat sdf1 = new SimpleDateFormat(pat1); SimpleDateFormat sdf2 = new SimpleDateFormat(pat2);Date d = null;try&#123; d = sdf1.parse(strDate);//将给定的字符串中的日期提取出来&#125;catch(Exception e)&#123;//如果提供的字符串格式有错误，则进行异常处理 e.printStackTrace();//打印异常信息&#125;System.out.println(sdf2.format(d));//将日期变为新的格式 java.time.format包下java.time.format.DateFormatter：时间格式化JDK 8 发布，线程安全（vs SimpleDateFormat 线程不安全）ofPattern：设定时间格式parse：将字符串格式化为时间对象format：将时间对象格式化为字符串如将当前时间转为YYYY-MM-DD HH24:MI:SS输出1234567891011//将字符串转化为时间String dateStr = \"2020年1月1日\";DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy年MM月dd日\");LocalDate date = LocalDate.parse(dateStr, formatter);System.out.println(date.getYear() + \"-\" + date.getMonthValue() + \"-\" + date.getDayOfMonth());//将日期转换为字符串输出LocalDateTime now = LocalDateTime.now();DateTimeFormatter format = DateTimeFormatter.ofPattern(\"yyyy年MM月dd日 hh:mm:ss\");String nowStr = now.format(format);System.out.println(nowStr); LocalDate类的月份是1-12，不用加1；Calendar类的月份是0-11，需要加1。 异常和异常处理异常Java异常分成Exception（程序相关）和Error（系统相关）。 异常分类 Exception分为RuntimeException程序自身的错误（如5/0，空指针，数组越界）和非RuntimeException外界相关的错误（如打开一个不存在的文件，加载一个不存在的类）。IOException是非RuntimeException的典型示例。另一种分类方法：Unchecked Exception：（编译器不会辅助检查的，需要管理员自己管的）异常，包括Error子类和RuntimeException子类。非RuntimeException的Exception的子类：（编译器会辅助检查的）异常，checked exception。注意：编译器会检查程序是否为checked exception配置了处理。若没有处理，会报错。 异常处理 try-catch-finally：一种保护代码正常运行的机制。 异常结构try…catch（catch可以有多个，下同）try…catch…finallytry…finally try必须有，catch和finally至少要有一个try：正常业务逻辑代码catch：当try发生异常，将执行catch代码。若无异常，绕之。finally：当try或catch执行结束后，必须要执行finally。12345678910111213141516171819202122232425262728293031323334353637383940414243try&#123; int a = 5/2; System.out.println(a);&#125;catch(Exception ex)&#123; ex.printStackTrace();&#125;finally&#123; System.out.println(\"1 over\");&#125;try&#123; int a = 5/0; System.out.println(a);&#125;catch(Exception ex)&#123; ex.printStackTrace();&#125;finally&#123; System.out.println(\"2 over\");&#125;try&#123; int a = 5/0; System.out.println(a);&#125;catch(Exception ex)&#123; ex.printStackTrace(); int a = 5/0;&#125;finally&#123; System.out.println(\"3 over\");&#125; 3中，第一个异常执行完finally后再执行第二个异常。（catch内部再次发生异常也不影响finally的正常运行。）进入catch块后，并不会返回到try发生异常的位置，也不会执行后续的catch块，一个异常只能进入一个catch块。一般将小异常（具体的异常子类，如ArithmeticException）写在前面，大（宽泛）的异常（如Exception）写在末尾。允许包含：123456789try&#123; try-catch-finally结构&#125;catch()&#123; try-catch-finally结构&#125;finally&#123; try-catch-finally结构&#125; 方法存在可能异常的语句，但不处理，可使用throws来声明异常。 调用带有throws异常（checked exception）的方法，要么处理这些异常，或者再次向外throws，直到main函数为止。 1234567891011121314151617181920212223242526public class ThrowsDemo&#123; public static void main(String [] args) &#123; try &#123; int result = new Test().divide(3,1); System.out.println(\"1 result:\" + result); &#125; catch(ArithmeticException ex) &#123; ex.printStackTrace(); &#125; int result = new Test().divide(3,0); System.out.println(\"2 result:\" + result); &#125;&#125;class Test&#123; //ArithmeticException is a RuntimeException, not checked exception public int divide(int x, int y) throws ArithmeticException &#123; int result = x/y; return x/y; &#125;&#125; 一个方法被覆盖，覆盖它的方法不限抛出相同的异常，或者异常的子类。 如果父类的方法抛出多个异常，那么重写的子类方法必须抛出那些异常的子集，也就是不能抛出新的异常。Father.java123456public class Father&#123; public void f1() throws ArithmeticException &#123; &#125;&#125; Son.java123public class Son extends Father&#123; public void f1() throws Exception//错误&#125; 自定义异常 自定义异常需要继承Exception类或其子类。继承自Exception，就变成Checked Exception。继承自RuntimeException，就变成Unchecked Exception。（非RuntimeException，是Checked Exception，IDE辅助检查；RuntimeException，是Unchecked Exception，IDE不会辅助检查，是程序员自行处理。） 自定义重点在构造函数调用父类Exception的message构造函数可自定义自己的成员变量 在程序中采用throw主动抛出异常MyException.java123456789101112131415161718192021222324252627public class MyException extends Exception&#123; private String returnCode;//异常对应的返回码 private String returnMsg;//异常对应的描述信息 public MyException()&#123; super(); &#125; public MyException(String returnMsg)&#123; super(returnMsg); this.returnMsg = returnMsg; &#125; public MyException(String returnCode, String returnMsg)&#123; super(returnMsg); this.returnCode = returnCode; this.returnMsg = returnMsg; &#125; public String getReturnCode()&#123; return returnCode; &#125; public String getReturnMsg()&#123; return returnMsg; &#125;&#125; 在方法内部程序中，抛出异常采用throw关键字；在方法头部声明中，声明异常采用throws关键字。MyExceptionTest.java12345678910111213141516public class MyExceptionTest &#123; public static void testException() throws MyException &#123; throw new MyException(\"10001\", \"The reason of myException\"); &#125; public static void main(String[] args) &#123; //MyExceptionTest.testException();注释1 要报错需注释掉下方代码 try &#123; MyExceptionTest.testException(); &#125; catch (MyException e) &#123; e.printStackTrace(); System.out.println(\"returnCode:\" + e.getReturnCode()); System.out.println(\"returnCode:\" + e.getReturnMsg()); &#125; &#125;&#125; 注释1：main函数里调用了一个声明MyException异常的方法，但没处理。因为MyException继承Exception，是属于非RuntimeException，也就是Checked Exception，因此编译器会检查到程序没处理而报错。解法：1）采用try-catch-finally结构 2）main函数也throws MyException。DivideByMinusException.java123456789101112public class DivideByMinusException extends Exception &#123; int divisor; public DivideByMinusException(String msg, int divisor) &#123; super(msg); this.divisor = divisor; &#125; public int getDevisor() &#123; return this.getDevisor(); &#125;&#125; Student.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class Student &#123; public int divide(int x, int y) &#123; return x/y; &#125; public static void main(String[] args) throws DivideByMinusException &#123; Student newton = new Student(); //newton.divide2(5,0); newton.divide5(5,-2); &#125; public int divide2(int x,int y) &#123; int result; try &#123; result = x/y; System.out.println(\"result is \" + result); &#125; catch(ArithmeticException ex) &#123; System.out.println(ex.getMessage()); return 0; &#125; catch(Exception ex) &#123; ex.printStackTrace(); return 0; &#125; &#125; public int divide3(int x,int y) throws ArithmeticException//unchecked exception &#123; return x/y; &#125; public int divide4(int x, int y) &#123;// try// &#123;// return divide3(x,y);// &#125;// catch(ArithmeticException ex)// &#123;// ex.printStackTrace();// return 0;// &#125; return divide3(x,y);//尽管divide3报告异常，但divide4无需处理。 //若调用divide5(x,y);就需要做try-catch处理。 &#125; public int divide5(int x,int y) throws DivideByMinusException &#123; try &#123; if(y &lt; 0) &#123; throw new DivideByMinusException(\"The divisor is negative\", y); &#125; return divide3(x,y); &#125; catch(ArithmeticException ex) &#123; ex.printStackTrace(); return 0; &#125; &#125;&#125; 对于CheckedException，编译器要求调用者处理，要么采用try-catch-finally处理，要么采用throws声明异常。 数据结构数组 数组是一个存放多个数据的容器数据是同一种类型所有数据是线性规则排列可通过位置索引来快速定位访问数据需明确容器的长度 Java数组定义和初始化 12345678910111213int a[];//还没有new操作，实际上是null，也不知道内存位置int[] b;int[] c = new int[2];//c有2个元素，都是0c[0] = 1, c[1] = 2;//初始化int d[] = new int[]&#123;1,2,3&#125;;//同时定义和初始化int d1[] = &#123;1,2,3&#125;;//同时定义和初始化//声明变量时没有分配内存，不需要指定大小，以下是错误的//int a[2];//int[2] b;//int[2] c = new int[2];//int d[2] = new int[2]; 数组索引数组的length属性标识数组的长度从0开始，到length-1 1int[] a = new int[5];//a[0]~a[4],a.length是5 数组不能越界访问，否则会报ArrayIndexOutOfBoundsException异常 数组遍历：两种方法 1234567891011//需控制索引位置for(int i = 0; i &lt; d.length; i++)&#123; System.out.println(d[i]);&#125;//无需控制索引位置for(int e : d)&#123; System.out.println(e);&#125; 多维数组数组的数组存储按照行存储原则 12345678//规则数组int a[][] = new int[2][3];//不规则数组int b[][];b = new int[3][];b[0] = new int[3];b[1] = new int[4];b[2] = new int[5]; 1234567891011121314151617int k = 0;for(int i = 0; i &lt; a.length; i++)&#123; for(int j = 0; j &lt; a[i].length; j++) &#123; a[i][j] = ++k; &#125;&#125;for(int[] items : a)&#123; for(int item : items) &#123; System.out.println(item + \", \"); &#125; System.out.println();&#125; JCFJava Collection Framework 容器：能够存放数据的空间结构数组/多维数组，只能线性存放列表/散列集/树/… 容器框架：为表示和操作容器而规定的一种标准体系结构对外的接口：容器中所能存放的抽象数据类型接口的实现：可复用的数据结构算法：对数据的查找和排序 容器框架优点：提高数据存取效率，避免程序员重复劳动 C++的STL, Java的JCF Java 1.1和以前的数据结构Vector, Stack, Hashtable, Enumeration等 Java 1.2和以后，JCF集合框架功能更强大，易于学习接口和实现分离，多种设计模式更灵活泛型设计 主要由列表（List）、散列集合（Set）、映射（Map）组成。（还有Arrays和Collection工具类）Dictionary和Hashtable属于JDK1.1的类，已经较少使用了。 早期接口Enumeration JCF的集合接口是Collectionadd, contains, remove, sizeiterator JCF的迭代器接口IteratorhasNext, next, remove JCF主要的数据结构实现类列表（List, ArrayList, LinkedList）集合（Set, HashSet, TreeSet, LinkedHashSet）映射（Map, HashMap, TreeMap, LinkedHashMap） JCF主要的算法类Arrays: 对数组进行查找和排序等操作Collections: 对Collection及其子类进行排序和查找操作 List List 列表有序的Collection允许重复元素{1, 2, 3, {1, 2}, 1, 3} List主要实现ArrayList（非同步）LinkedList（非同步）Vector（同步） ArrayList以数组实现的列表，不支持同步利用索引位置可以快速定位访问不适合指定位置的插入、删除操作适合变动不大，主要用于查询的数据和Java数组相比，其容量是可动态调整的//Java数组是静态的，长度确定不可修改ArrayList在元素填满容器时会自动扩充容器大小的50% 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.ArrayList;//Vector几乎和ArrayList一样，除了Vector本身是同步的public class ArrayListTest&#123; public static void main(String[] a)&#123; ArrayList&lt;Integer&gt; al = new ArrayList&lt;Integer&gt;();//ArrayList&lt;Integer&gt; al 是泛型表示，意思是al这个数据结构里只能容纳Integer的对象，其它对象无法放入 al.add(1);//ArrayList只能装对象，当add(1)时，会自动将普通int变量1自动装箱为Integer(1)的对象，然后放入ArrayList容器中 al.add(2); al.add(3); al.add(4); al.add(new Integer(6)); System.out.println(al.get(3)); al.remove(3);//删除第4个元素，后面元素往前挪 al.add(3, 0);//将0插入到第3个元素，后面元素往后挪 //遍历方法 ArrayList&lt;Integer&gt; as = new ArrayList&lt;Integer&gt;(100000); for(int i = 0; i &lt; 100000; i++) &#123; as.add(i); &#125; traverseByIterator(as); traverseByIndex(as); traverseByFor(as); &#125; //迭代器遍历 public static void traverseByIterator(ArrayList&lt;Integer&gt; al) &#123; long startTime = System.namoTime(); Iterator&lt;Integer&gt; iter1 = al.iterator(); while(iter1.hasNext())&#123; iter1.next(); &#125; long endTime = System.nanoTime(); long duration = endTime - startTime; System.out.println(duration + \"纳秒\"); &#125; //随机索引值遍历 public static void traverseByIndex(ArrayList&lt;Integer&gt; al) &#123; long startTime = System.namoTime(); for(int i = 0; i&lt; al.size(); i++) &#123; al.get(i); &#125; long endTime = System.nanoTime(); long duration = endTime - startTime; System.out.println(duration + \"纳秒\"); &#125; //for循环遍历 public static void traverseByFor(ArrayList&lt;Integer&gt; al) &#123; long startTime = System.namoTime(); for(Integer item : al) &#123; ; &#125; long endTime = System.namoTime(); long duration = endTime - startTime; System.out.println(duration + \"纳秒\"); &#125;&#125; 结果表明：for循环遍历最快，随机索引值遍历和for差距不大，迭代器最慢。 LinkedList以双向链表实现的列表，不支持同步可被当作堆栈、队列和双端队列进行操作顺序访问高效、随机访问较差，中间插入和删除高效适用于经常变化的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.ArrayList;public class LinkedListTest&#123; public static void main(String[] a)&#123; LinkedList&lt;Integer&gt; ll = new LinkedList&lt;Integer&gt;(); ll.add(1); ll.add(2); ll.add(3); ll.add(4); System.out.println(ll.size()); ll.addFirst(0);//在头部增加0 ll.add(3,5);//将5插入到第四个元素，四及后续元素往后挪 ll.remove(3);//将第四个元素删除 LinkedList&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;(); for(int i = 0; i &lt; 100000; i++) &#123; list.add(i); &#125; traverseByIterator(list); traverseByIndex(list); traverseByFor(list); &#125; //迭代器遍历 public static void traverseByIterator(LinkedList&lt;Integer&gt; list) &#123; long startTime = System.namoTime(); Iterator&lt;Integer&gt; iter1 = list.iterator(); while(iter1.hasNext())&#123; iter1.next(); &#125; long endTime = System.nanoTime(); long duration = endTime - startTime; System.out.println(duration + \"纳秒\"); &#125; //随机索引值遍历 public static void traverseByIndex(LinkedList&lt;Integer&gt; list) &#123; long startTime = System.namoTime(); for(int i = 0; i&lt; list.size(); i++) &#123; list.get(i); &#125; long endTime = System.nanoTime(); long duration = endTime - startTime; System.out.println(duration + \"纳秒\"); &#125; //for循环遍历 public static void traverseByFor(LinkedList&lt;Integer&gt; list) &#123; long startTime = System.namoTime(); for(Integer item : list) &#123; ; &#125; long endTime = System.namoTime(); long duration = endTime - startTime; System.out.println(duration + \"纳秒\"); &#125;&#125; 结果：for循环最快，迭代器稍微慢一些，随机索引特别慢。 性能比较12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.util.ArrayList;public class ListCompareTest &#123; public static void main(String[] args) &#123; int times = 10 * 1000; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;Integer&gt;(); //ArrayList add long startTime = System.nanoTime(); for(int i = 0; i &lt; times; i++) &#123; arrayList.add(0, i);//add到头部 &#125; long endTime = System.namoTime(); long duration = endTime - startTime; System.out.println(duration + \"纳秒\"); //LinkedList add startTime = System.nanoTime(); for(int i = 0; i &lt; times; i++) &#123; linkedList.add(0, i); &#125; endTime = System.namoTime(); duration = endTime - startTime; System.out.println(duration + \"纳秒\"); //ArrayList get startTime = System.nanoTime(); for(int i = 0; i &lt; times; i++) &#123; arrayList.get(i); &#125; endTime = System.namoTime(); duration = endTime - startTime; System.out.println(duration + \"纳秒\"); //LinkedList get startTime = System.nanoTime(); for(int i = 0; i &lt; times; i++) &#123; linkedList.get(i); &#125; endTime = System.namoTime(); duration = endTime - startTime; System.out.println(duration + \"纳秒\"); //ArrayList remove startTime = System.nanoTime(); for(int i = 0; i &lt; times; i++) &#123; arrayList.remove(0); &#125; endTime = System.namoTime(); duration = endTime - startTime; System.out.println(duration + \"纳秒\"); //LinkedList remove startTime = System.nanoTime(); for(int i = 0; i &lt; times; i++) &#123; linkedList.remove(0); &#125; endTime = System.namoTime(); duration = endTime - startTime; System.out.println(duration + \"纳秒\"); &#125;&#125; 结果：add ArrayList时间远大于LinkedListget ArrayList时间远小于LinkedListremove ArrayList时间远大于LinkedList 结论：ArrayList适用于较多查询的（静态）数据，LinkedList适用于频繁增删的数据。 Vector(同步)和ArrayList类似，可变数组实现的列表Vector同步，适合在多线程下使用原先不属于JCF框架，属于Java最早的数据结构，性能较差从JDK 1.2开始，Vector被重写，并纳入到JCF官方文档建议在非同步情况下，优先采用ArrayList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.util.ArrayList;public class VectorTest &#123; public static void main(String[] args) &#123; Vector&lt;Integer&gt; v = new Vector&lt;Integer&gt;(); v.add(1); v.add(2); v.add(3); v.remove(2); v.add(1, 5); System.out.println(v.size()); //遍历方法 Vector&lt;Integer&gt; v2 = new Vector&lt;Integer&gt;(100000); for(int i = 0; i &lt; 100000; i++) &#123; v2.add(i); &#125; traverseByIterator(v2); traverseByIndex(v2); traverseByFor(v2); traverseByEnumeration(v2); &#125; //迭代器遍历 public static void traverseByIterator(Vector&lt;Integer&gt; v) &#123; long startTime = System.namoTime(); Iterator&lt;Integer&gt; iter1 = v.iterator(); while(iter1.hasNext())&#123; iter1.next(); &#125; long endTime = System.nanoTime(); long duration = endTime - startTime; System.out.println(duration + \"纳秒\"); &#125; //随机索引值遍历 public static void traverseByIndex(Vector&lt;Integer&gt; v) &#123; long startTime = System.namoTime(); for(int i = 0; i&lt; v.size(); i++) &#123; v.get(i); &#125; long endTime = System.nanoTime(); long duration = endTime - startTime; System.out.println(duration + \"纳秒\"); &#125; //for循环遍历 public static void traverseByFor(Vector&lt;Integer&gt; v) &#123; long startTime = System.namoTime(); for(Integer item : v) &#123; ; &#125; long endTime = System.namoTime(); long duration = endTime - startTime; System.out.println(duration + \"纳秒\"); &#125; //Enumeration遍历 public static void traverseByEnumeration(Vector&lt;Integer&gt; v) &#123; long startTime = System.namoTime(); for(Enumeration&lt;Integer&gt; enu = v.elements(); enu.hasMoreElements();) &#123; enu.nextElement(); &#125; long endTime = System.namoTime(); long duration = endTime - startTime; System.out.println(duration + \"纳秒\"); &#125;&#125; 结果：for循环是最快的，位置索引第二名，Enumeration第三，迭代器最慢。 Set确定性：对任意对象都能判定其是否属于某一个集合互异性：集合内每个元素都是不相同的，内容互异无序性：集合内的顺序无关集合接口Set HashSet 基于散列函数的集合，无序，不支持同步基于HashMap实现的，可以容纳null元素，不支持同步但以下方法可以实现同步1Set s = Collections.synchronizedSet(new HashSet(...)); add 添加一个元素clear 清除整个HashSetcontains 判定是否包含一个元素remove 删除一个元素 size 大小retainAll 计算两个集合交集 TreeSet 基于树结构的集合，可排序的，不支持同步 LinkedHashSet 基于散列函数和双向链表的集合，可排序的，不支持同步 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.util.ArrayList;import java.util.HashSet;import java.util.Iterator;public class HashSetTest &#123; public static void main(String[] args) &#123; HashSet&lt;Integer&gt; hs = new HashSet&lt;Integer&gt;(); hs.add(null); hs.add(1); hs.add(2); hs.add(3); hs.add(40000); hs.add(5000000); hs.add(3); //3 重复 hs.add(null); //null重复 System.out.println(hs.size()); //6 if(!hs.contains(6)) &#123; hs.add(6); &#125; System.out.println(hs.size()); //7 hs.remove(4); System.out.println(hs.size()); //6 //hs.clear(); //System.out.println(hs.size()); //0 //or循环遍历 for(Integer item : hs) &#123; System.out.println(item); &#125; //测试集合交集 HashSet&lt;String&gt; set1 = new HashSet&lt;String&gt;(); HashSet&lt;String&gt; set2 = new HashSet&lt;String&gt;(); set1.add(\"a\"); set1.add(\"b\"); set1.add(\"c\"); set2.add(\"c\"); set2.add(\"d\"); set2.add(\"e\"); //交集 set1.retainAll(set2); System.out.println(\"交集是 \"+set1); //测试遍历方法速度 HashSet&lt;Integer&gt; hs2 = new HashSet&lt;Integer&gt;(); for(int i=0;i&lt;100000;i++) &#123; hs2.add(i); &#125; traverseByIterator(hs2); traverseByFor(hs2); &#125; public static void traverseByIterator(HashSet&lt;Integer&gt; hs) &#123; long startTime = System.nanoTime(); //迭代器遍历 Iterator&lt;Integer&gt; iter1 = hs.iterator(); while(iter1.hasNext())&#123; iter1.next(); &#125; long endTime = System.nanoTime(); long duration = endTime - startTime; System.out.println(duration + \"纳秒\"); &#125; public static void traverseByFor(HashSet&lt;Integer&gt; hs) &#123; long startTime = System.nanoTime(); //for循环遍历 for(Integer item : hs) &#123; ; &#125; long endTime = System.nanoTime(); long duration = endTime - startTime; System.out.println(duration + \"纳秒\"); &#125;&#125; 迭代器慢于for循环。 LinkedHashSet继承HashSet，也是基于HashMap实现的，可容纳null元素不支持同步 1Set s = Collections.synchronizedSet(new LinkedHashSet(...)); 方法和HashSet基本一致add,clear,contains,remove,size通过一个双向链表维护插入顺序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.util.ArrayList;import java.util.HashSet;import java.util.Iterator;import java.util.LinkedHashSet;public class LinkedHashSetTest &#123; public static void main(String[] args) &#123; LinkedHashSet&lt;Integer&gt; lhs = new LinkedHashSet&lt;Integer&gt;(); lhs.add(null); lhs.add(1000); lhs.add(20); lhs.add(3); lhs.add(40000); lhs.add(5000000); lhs.add(3); //3 重复 lhs.add(null); //null 重复 System.out.println(lhs.size()); //6 if(!lhs.contains(6)) &#123; lhs.add(6); &#125; System.out.println(lhs.size()); //7 lhs.remove(4); System.out.println(lhs.size()); //6 //lhs.clear(); //System.out.println(lhs.size()); //0 //for循环遍历 for(Integer item : lhs) &#123; System.out.println(item); &#125; LinkedHashSet&lt;Integer&gt; lhs2 = new LinkedHashSet&lt;Integer&gt;(); for(int i=0;i&lt;100000;i++) &#123; lhs2.add(i); &#125; traverseByIterator(lhs2); traverseByFor(lhs2); &#125; public static void traverseByIterator(LinkedHashSet&lt;Integer&gt; hs) &#123; long startTime = System.nanoTime(); //迭代器遍历 Iterator&lt;Integer&gt; iter1 = hs.iterator(); while(iter1.hasNext())&#123; iter1.next(); &#125; long endTime = System.nanoTime(); long duration = endTime - startTime; System.out.println(duration + \"纳秒\"); &#125; public static void traverseByFor(LinkedHashSet&lt;Integer&gt; hs) &#123; long startTime = System.nanoTime(); //for循环遍历 for(Integer item : hs) &#123; ; &#125; long endTime = System.nanoTime(); long duration = endTime - startTime; System.out.println(duration + \"纳秒\"); &#125;&#125; LinkedHashSet是保留顺序的，其遍历顺序和插入顺序一致；而HashSet没有保留顺序，其遍历顺序无序。 TreeSet基于TreeMap实现的，不可以容纳null元素，不支持同步1SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...)); add 添加一个元素clear 清除整个TreeSetcontains 判定是否包含一个元素remove 删除一个元素size 大小根据compareTo方法或指定Comparator排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.util.ArrayList;import java.util.HashSet;import java.util.Iterator;import java.util.LinkedHashSet;import java.util.TreeSet;public class TreeSetTest &#123; public static void main(String[] args) &#123; TreeSet&lt;Integer&gt; ts = new TreeSet&lt;Integer&gt;(); // ts.add(null); 错误，不支持null ts.add(1000); ts.add(20); ts.add(3); ts.add(40000); ts.add(5000000); ts.add(3); //3 重复 System.out.println(ts.size()); //5 if(!ts.contains(6)) &#123; ts.add(6); &#125; System.out.println(ts.size()); //6 ts.remove(4); System.out.println(ts.size()); //5 //lhs.clear(); //System.out.println(lhs.size()); //0 //for循环遍历 for(Integer item : ts) &#123; System.out.println(item); &#125; TreeSet&lt;Integer&gt; ts2 = new TreeSet&lt;Integer&gt;(); for(int i=0;i&lt;100000;i++) &#123; ts2.add(i); &#125; traverseByIterator(ts2); traverseByFor(ts2); &#125; public static void traverseByIterator(TreeSet&lt;Integer&gt; hs) &#123; long startTime = System.nanoTime(); //迭代器遍历 Iterator&lt;Integer&gt; iter1 = hs.iterator(); while(iter1.hasNext())&#123; iter1.next(); &#125; long endTime = System.nanoTime(); long duration = endTime - startTime; System.out.println(duration + \"纳秒\"); &#125; public static void traverseByFor(TreeSet&lt;Integer&gt; hs) &#123; long startTime = System.nanoTime(); //for循环遍历 for(Integer item : hs) &#123; ; &#125; long endTime = System.nanoTime(); long duration = endTime - startTime; System.out.println(duration + \"纳秒\"); &#125;&#125; HashSet是无序输出的LinkedHashSet是按照插入的顺序进行遍历输出的TreeSet是按照所存储对象大小升序输出的 HashSet, LinkedHashSet, TreeSet的元素都只能是对象 HashSet和LinkedHashSet判定元素重复的原则判定两个元素的hashCode返回值是否相同，不同则返回false若两者hashCode相同，判定equals方法，不同则返回falsehashCode和equals方法是所有类都有的，因为Object类有 TreeSet判定元素重复的原则需要元素继承自Comparable接口比较两个元素的compareTo方法HashSetJudgeRuleTest.java1234567891011121314import java.util.HashSet;public class HashSetJudgeRuleTest &#123; public static void main(String[] args) &#123; HashSet&lt;Cat&gt; hs = new HashSet&lt;Cat&gt;(); hs.add(new Cat(1)); hs.add(new Cat(2)); hs.add(new Cat(3)); hs.add(new Cat(3)); System.out.println(hs.size()); //4 &#125;&#125; Cat.java12345678910class Cat&#123; private int size; public Cat(int size) &#123; this.size = size; &#125;&#125; Dog.java123456789101112131415161718192021222324252627282930class Dog &#123; private int size; public Dog(int s) &#123; size = s; &#125; public int getSize() &#123; return size; &#125; public boolean equals(Object obj2) &#123; System.out.println(\"Dog equals()~~~~~~~~~~~\"); if(0==size - ((Dog) obj2).getSize()) &#123; return true; &#125; else &#123; return false; &#125; &#125; public int hashCode() &#123; System.out.println(\"Dog hashCode()~~~~~~~~~~~\"); return size; &#125; public String toString() &#123; System.out.print(\"Dog toString()~~~~~~~~~~~\"); return size + \"\"; &#125;&#125; Tiger.java1234567891011121314151617public class Tiger implements Comparable&#123; private int size; public Tiger(int s) &#123; size = s; &#125; public int getSize() &#123; return size; &#125; public int compareTo(Object o) &#123; System.out.println(\"Tiger compareTo()~~~~~~~~~~~\"); return size - ((Tiger) o).getSize(); &#125;&#125; Tiger实现Comparable接口，所以必须实现compareTo方法来比较大小。compareTo方法具体规则如下：1int a = obj1.compareTo(obj2); 若a&gt;0，则obj1&gt;obj2；若a==0，则obj1==obj2；若a&lt;0，则obj1&lt;obj2。 HashSet的元素判定规则只和hashCode、equals这2个方法有关，和compareTo方法无关。 Java的四个重要接口：Comparable可比较的Clonable可克隆的Runnable可线程化的Serializable可序列化的ObjectHashSetTest.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.util.HashSet;import java.util.Iterator;import java.util.LinkedHashSet;import java.util.TreeSet;public class ObjectHashSetTest &#123; public static void main(String[] args) &#123; System.out.println(\"==========Cat HashSet ==============\"); HashSet&lt;Cat&gt; hs = new HashSet&lt;Cat&gt;(); hs.add(new Cat(2)); hs.add(new Cat(1)); hs.add(new Cat(3)); hs.add(new Cat(5)); hs.add(new Cat(4)); hs.add(new Cat(4)); System.out.println(hs.size()); //6 System.out.println(\"========================\"); LinkedHashSet&lt;Cat&gt; lhs= new LinkedHashSet&lt;Cat&gt;(); lhs.add(new Cat(2)); lhs.add(new Cat(1)); lhs.add(new Cat(3)); lhs.add(new Cat(5)); lhs.add(new Cat(4)); lhs.add(new Cat(4)); System.out.println(lhs.size()); //6 System.out.println(\"==========Dog HashSet ==============\"); HashSet&lt;Dog&gt; hs2 = new HashSet&lt;Dog&gt;(); hs2.add(new Dog(2)); hs2.add(new Dog(1)); hs2.add(new Dog(3)); hs2.add(new Dog(5)); hs2.add(new Dog(4)); hs2.add(new Dog(4)); System.out.println(hs2.size()); //5 System.out.println(\"========================\"); LinkedHashSet&lt;Dog&gt; lhs2= new LinkedHashSet&lt;Dog&gt;(); lhs2.add(new Dog(2)); lhs2.add(new Dog(1)); lhs2.add(new Dog(3)); lhs2.add(new Dog(5)); lhs2.add(new Dog(4)); lhs2.add(new Dog(4)); System.out.println(lhs2.size()); //5 System.out.println(\"==========Tiger HashSet ==============\"); HashSet&lt;Tiger&gt; hs3 = new HashSet&lt;Tiger&gt;(); hs3.add(new Tiger(2)); hs3.add(new Tiger(1)); hs3.add(new Tiger(3)); hs3.add(new Tiger(5)); hs3.add(new Tiger(4)); hs3.add(new Tiger(4)); System.out.println(hs3.size()); //6 System.out.println(\"========================\"); LinkedHashSet&lt;Tiger&gt; lhs3= new LinkedHashSet&lt;Tiger&gt;(); lhs3.add(new Tiger(2)); lhs3.add(new Tiger(1)); lhs3.add(new Tiger(3)); lhs3.add(new Tiger(5)); lhs3.add(new Tiger(4)); lhs3.add(new Tiger(4)); System.out.println(lhs3.size()); //6 &#125;&#125; Cat类本身没有hashCode()，而是继承Object类，而Object的hashCode()会返回对象信息和内存地址经过运算后的一个int值。两个不同的Cat(4)对象，它们的hashCode()返回值是不同的。Dog类本身改写了hashCode()方法，其返回值是具体的size。所以两个不同Dog(4)，它们的hashCode()返回值是相同的。 这三个方法三位一体：equals()是相同的；hashCode()是相同的；toString()也应该是相同的。 ObjectTreeSetTest.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.TreeSet;public class ObjectTreeSetTest &#123; public static void main(String[] args) &#123; /* System.out.println(\"==========Cat TreeSet ==============\"); TreeSet&lt;Cat&gt; ts = new TreeSet&lt;Cat&gt;(); ts.add(new Cat(2)); ts.add(new Cat(1)); ts.add(new Cat(3)); ts.add(new Cat(5)); ts.add(new Cat(4)); ts.add(new Cat(4)); System.out.println(ts.size()); //5 System.out.println(\"==========Dog TreeSet ==============\"); TreeSet&lt;Dog&gt; ts2 = new TreeSet&lt;Dog&gt;(); ts2.add(new Dog(2)); ts2.add(new Dog(1)); ts2.add(new Dog(3)); ts2.add(new Dog(5)); ts2.add(new Dog(4)); ts2.add(new Dog(4)); System.out.println(ts2.size()); //5 */ //添加到TreeSet的，需要实现Comparable接口，即实现compareTo方法 System.out.println(\"==========Tiger TreeSet ==============\"); TreeSet&lt;Tiger&gt; ts3 = new TreeSet&lt;Tiger&gt;(); ts3.add(new Tiger(2)); ts3.add(new Tiger(1)); ts3.add(new Tiger(3)); ts3.add(new Tiger(5)); ts3.add(new Tiger(4)); ts3.add(new Tiger(4)); System.out.println(ts3.size()); //5 &#125;&#125; Map定义：两个集合之间的元素对应关系。一个输入对应到一个输出。{Key, Value} 键值对，K-V对 Hashtable 同步，慢，数据量小HashMap 不支持同步，快，数据量大Properties 同步，文件形式，数据量小 HashtableK-V对，K和V都不允许为null同步，多线程安全无序的适合小数据量主要方法：clear, contains/containsValue, containsKey, get, put, remove, size1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import java.util.Enumeration;import java.util.Hashtable;import java.util.Iterator;import java.util.Map;import java.util.Map.Entry;public class HashtableTest &#123; public static void main(String[] args) &#123; Hashtable&lt;Integer,String&gt; ht =new Hashtable&lt;Integer,String&gt;(); //ht.put(1, null); 编译不报错 运行报错 //ht.put(null,1); 编译报错 ht.put(1000, \"aaa\"); ht.put(2, \"bbb\"); ht.put(30000, \"ccc\"); System.out.println(ht.contains(\"aaa\")); System.out.println(ht.containsValue(\"aaa\")); System.out.println(ht.containsKey(30000)); System.out.println(ht.get(30000)); ht.put(30000, \"ddd\"); //更新覆盖ccc System.out.println(ht.get(30000)); ht.remove(2); System.out.println(\"size: \" + ht.size()); ht.clear(); System.out.println(\"size: \" + ht.size()); Hashtable&lt;Integer,String&gt; ht2 =new Hashtable&lt;Integer,String&gt;(); for(int i=0;i&lt;100000;i++) &#123; ht2.put(i, \"aaa\"); &#125; traverseByEntry(ht2); traverseByKeySet(ht2); traverseByKeyEnumeration(ht2); &#125; public static void traverseByEntry(Hashtable&lt;Integer,String&gt; ht) &#123; long startTime = System.nanoTime(); System.out.println(\"============Entry迭代器遍历==============\"); Integer key; String value; Iterator&lt;Entry&lt;Integer, String&gt;&gt; iter = ht.entrySet().iterator(); while(iter.hasNext()) &#123; Map.Entry&lt;Integer, String&gt; entry = iter.next(); // 获取key key = entry.getKey(); // 获取value value = entry.getValue(); //System.out.println(\"Key:\" + key + \", Value:\" + value); &#125; long endTime = System.nanoTime(); long duration = endTime - startTime; System.out.println(duration + \"纳秒\"); &#125; public static void traverseByKeySet(Hashtable&lt;Integer,String&gt; ht) &#123; long startTime = System.nanoTime(); System.out.println(\"============KeySet迭代器遍历==============\"); Integer key; String value; Iterator&lt;Integer&gt; iter = ht.keySet().iterator(); while(iter.hasNext()) &#123; key = iter.next(); // 获取value value = ht.get(key); //System.out.println(\"Key:\" + key + \", Value:\" + value); &#125; long endTime = System.nanoTime(); long duration = endTime - startTime; System.out.println(duration + \"纳秒\"); &#125; public static void traverseByKeyEnumeration(Hashtable&lt;Integer,String&gt; ht) &#123; long startTime = System.nanoTime(); System.out.println(\"============KeyEnumeration迭代器遍历==============\"); Integer key; String value; Enumeration&lt;Integer&gt; keys = ht.keys(); while(keys.hasMoreElements()) &#123; key = keys.nextElement(); // 获取value value = ht.get(key); //System.out.println(\"Key:\" + key + \", Value:\" + value); &#125; long endTime = System.nanoTime(); long duration = endTime - startTime; System.out.println(duration + \"纳秒\"); &#125;&#125; 运行结果：12345678910111213truetruetruecccdddsize: 2size: 0============Entry迭代器遍历==============11238700纳秒============KeySet迭代器遍历==============10546900纳秒============KeyEnumeration迭代器遍历==============11115100纳秒 HashMap K-V对，K和V都运行为null 不同步，多线程不安全Map m = Collections.synchronizedMap(new HashMap(…));无序的主要方法：clear, containsValue, containsKey, get, put, remove, size 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.util.Enumeration;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Map.Entry;public class HashMapTest &#123; public static void main(String[] args) &#123; HashMap&lt;Integer,String&gt; hm =new HashMap&lt;Integer,String&gt;(); hm.put(1, null); hm.put(null, \"abc\"); hm.put(1000, \"aaa\"); hm.put(2, \"bbb\"); hm.put(30000, \"ccc\"); System.out.println(hm.containsValue(\"aaa\")); System.out.println(hm.containsKey(30000)); System.out.println(hm.get(30000)); hm.put(30000, \"ddd\"); //更新覆盖ccc System.out.println(hm.get(30000)); hm.remove(2); System.out.println(\"size: \" + hm.size()); hm.clear(); System.out.println(\"size: \" + hm.size()); HashMap&lt;Integer,String&gt; hm2 =new HashMap&lt;Integer,String&gt;(); for(int i=0;i&lt;100000;i++) &#123; hm2.put(i, \"aaa\"); &#125; traverseByEntry(hm2); traverseByKeySet(hm2); &#125; public static void traverseByEntry(HashMap&lt;Integer,String&gt; ht) &#123; long startTime = System.nanoTime(); System.out.println(\"============Entry迭代器遍历==============\"); Integer key; String value; Iterator&lt;Entry&lt;Integer, String&gt;&gt; iter = ht.entrySet().iterator(); while(iter.hasNext()) &#123; Map.Entry&lt;Integer, String&gt; entry = iter.next(); // 获取key key = entry.getKey(); // 获取value value = entry.getValue(); //System.out.println(\"Key:\" + key + \", Value:\" + value); &#125; long endTime = System.nanoTime(); long duration = endTime - startTime; System.out.println(duration + \"纳秒\"); &#125; public static void traverseByKeySet(HashMap&lt;Integer,String&gt; ht) &#123; long startTime = System.nanoTime(); System.out.println(\"============KeySet迭代器遍历==============\"); Integer key; String value; Iterator&lt;Integer&gt; iter = ht.keySet().iterator(); while(iter.hasNext()) &#123; key = iter.next(); // 获取value value = ht.get(key); //System.out.println(\"Key:\" + key + \", Value:\" + value); &#125; long endTime = System.nanoTime(); long duration = endTime - startTime; System.out.println(duration + \"纳秒\"); &#125;&#125; 运行结果12345678910truetruecccdddsize: 4size: 0============Entry迭代器遍历==============13389400纳秒============KeySet迭代器遍历==============12616200纳秒 LinkedHashMap基于双向链表的维持插入顺序的HashMap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.util.LinkedHashMap;import java.util.Iterator;import java.util.Map;import java.util.Map.Entry;public class LinkedHashMapTest &#123; public static void main(String[] args) &#123; LinkedHashMap&lt;Integer,String&gt; hm =new LinkedHashMap&lt;Integer,String&gt;(); hm.put(1, null); hm.put(null, \"abc\"); hm.put(1000, \"aaa\"); hm.put(2, \"bbb\"); hm.put(30000, \"ccc\"); System.out.println(hm.containsValue(\"aaa\")); System.out.println(hm.containsKey(30000)); System.out.println(hm.get(30000)); hm.put(30000, \"ddd\"); //更新覆盖ccc System.out.println(hm.get(30000)); hm.remove(2); System.out.println(\"size: \" + hm.size()); //hm.clear(); //System.out.println(\"size: \" + hm.size()); System.out.println(\"遍历开始==================\"); Integer key; String value; Iterator&lt;Entry&lt;Integer, String&gt;&gt; iter = hm.entrySet().iterator(); while(iter.hasNext()) &#123; Map.Entry&lt;Integer, String&gt; entry = iter.next(); // 获取key key = entry.getKey(); // 获取value value = entry.getValue(); System.out.println(\"Key:\" + key + \", Value:\" + value); &#125; System.out.println(\"遍历结束==================\"); LinkedHashMap&lt;Integer,String&gt; hm2 =new LinkedHashMap&lt;Integer,String&gt;(); for(int i=0;i&lt;100000;i++) &#123; hm2.put(i, \"aaa\"); &#125; traverseByEntry(hm2); traverseByKeySet(hm2); &#125; public static void traverseByEntry(LinkedHashMap&lt;Integer,String&gt; ht) &#123; long startTime = System.nanoTime(); System.out.println(\"============Entry迭代器遍历==============\"); Integer key; String value; Iterator&lt;Entry&lt;Integer, String&gt;&gt; iter = ht.entrySet().iterator(); while(iter.hasNext()) &#123; Map.Entry&lt;Integer, String&gt; entry = iter.next(); // 获取key key = entry.getKey(); // 获取value value = entry.getValue(); //System.out.println(\"Key:\" + key + \", Value:\" + value); &#125; long endTime = System.nanoTime(); long duration = endTime - startTime; System.out.println(duration + \"纳秒\"); &#125; public static void traverseByKeySet(LinkedHashMap&lt;Integer,String&gt; ht) &#123; long startTime = System.nanoTime(); System.out.println(\"============KeySet迭代器遍历==============\"); Integer key; String value; Iterator&lt;Integer&gt; iter = ht.keySet().iterator(); while(iter.hasNext()) &#123; key = iter.next(); // 获取value value = ht.get(key); //System.out.println(\"Key:\" + key + \", Value:\" + value); &#125; long endTime = System.nanoTime(); long duration = endTime - startTime; System.out.println(duration + \"纳秒\"); &#125;&#125; 123456789101112131415truetruecccdddsize: 4遍历开始==================Key:1, Value:nullKey:null, Value:abcKey:1000, Value:aaaKey:30000, Value:ddd遍历结束==============================Entry迭代器遍历==============9191900纳秒============KeySet迭代器遍历==============9211800纳秒 HashMap遍历是无序的LinkedHashMap遍历的顺序和它的插入的顺序保持一致TreeMap遍历的顺序是按照大小或者compareTo方法规定的 TreeMap基于红黑树的Map，可以根据key的自然排序或者compareTo方法进行排序输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.util.TreeMap;import java.util.Iterator;import java.util.Map;import java.util.Map.Entry;public class TreeMapTest &#123; public static void main(String[] args) &#123; TreeMap&lt;Integer,String&gt; hm =new TreeMap&lt;Integer,String&gt;(); hm.put(1, null); //hm.put(null, \"abc\"); 编译没错，运行报空指针异常 hm.put(1000, \"aaa\"); hm.put(2, \"bbb\"); hm.put(30000, \"ccc\"); System.out.println(hm.containsValue(\"aaa\")); System.out.println(hm.containsKey(30000)); System.out.println(hm.get(30000)); hm.put(30000, \"ddd\"); //更新覆盖ccc System.out.println(hm.get(30000)); //hm.remove(2); System.out.println(\"size: \" + hm.size()); //hm.clear(); //System.out.println(\"size: \" + hm.size()); System.out.println(\"遍历开始==================\"); Integer key; String value; Iterator&lt;Entry&lt;Integer, String&gt;&gt; iter = hm.entrySet().iterator(); while(iter.hasNext()) &#123; Map.Entry&lt;Integer, String&gt; entry = iter.next(); // 获取key key = entry.getKey(); // 获取value value = entry.getValue(); System.out.println(\"Key:\" + key + \", Value:\" + value); &#125; System.out.println(\"遍历结束==================\"); TreeMap&lt;Integer,String&gt; hm2 =new TreeMap&lt;Integer,String&gt;(); for(int i=0;i&lt;100000;i++) &#123; hm2.put(i, \"aaa\"); &#125; traverseByEntry(hm2); traverseByKeySet(hm2); &#125; public static void traverseByEntry(TreeMap&lt;Integer,String&gt; ht) &#123; long startTime = System.nanoTime(); System.out.println(\"============Entry迭代器遍历==============\"); Integer key; String value; Iterator&lt;Entry&lt;Integer, String&gt;&gt; iter = ht.entrySet().iterator(); while(iter.hasNext()) &#123; Map.Entry&lt;Integer, String&gt; entry = iter.next(); // 获取key key = entry.getKey(); // 获取value value = entry.getValue(); //System.out.println(\"Key:\" + key + \", Value:\" + value); &#125; long endTime = System.nanoTime(); long duration = endTime - startTime; System.out.println(duration + \"纳秒\"); &#125; public static void traverseByKeySet(TreeMap&lt;Integer,String&gt; ht) &#123; long startTime = System.nanoTime(); System.out.println(\"============KeySet迭代器遍历==============\"); Integer key; String value; Iterator&lt;Integer&gt; iter = ht.keySet().iterator(); while(iter.hasNext()) &#123; key = iter.next(); // 获取value value = ht.get(key); //System.out.println(\"Key:\" + key + \", Value:\" + value); &#125; long endTime = System.nanoTime(); long duration = endTime - startTime; System.out.println(duration + \"纳秒\"); &#125;&#125; 123456789101112131415truetruecccdddsize: 4遍历开始==================Key:1, Value:nullKey:2, Value:bbbKey:1000, Value:aaaKey:30000, Value:ddd遍历结束==============================Entry迭代器遍历==============12081400纳秒============KeySet迭代器遍历==============19865000纳秒 Properties继承于Hashtable可以将K-V对保存在文件中适用于数据量少的配置文件继承自Hashtable的方法： clear, contains/containsValue, containsKey, get, put, remove, size从文件加载的load方法，写入到文件中的store方法获取属性getProperty，设置属性setProperty1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.io.BufferedInputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.util.Enumeration;import java.util.Properties;//关于Properties类常用的操作public class PropertiesTest &#123; //根据Key读取Value public static String GetValueByKey(String filePath, String key) &#123; Properties pps = new Properties(); try &#123; InputStream in = new BufferedInputStream (new FileInputStream(filePath)); pps.load(in); //所有的K-V对都加载了 String value = pps.getProperty(key); //System.out.println(key + \" = \" + value); return value; &#125;catch (IOException e) &#123; e.printStackTrace(); return null; &#125; &#125; //读取Properties的全部信息 public static void GetAllProperties(String filePath) throws IOException &#123; Properties pps = new Properties(); InputStream in = new BufferedInputStream(new FileInputStream(filePath)); pps.load(in); //所有的K-V对都加载了 Enumeration en = pps.propertyNames(); //得到配置文件的名字 while(en.hasMoreElements()) &#123; String strKey = (String) en.nextElement(); String strValue = pps.getProperty(strKey); //System.out.println(strKey + \"=\" + strValue); &#125; &#125; //写入Properties信息 public static void WriteProperties (String filePath, String pKey, String pValue) throws IOException &#123; File file = new File(filePath); if(!file.exists()) &#123; file.createNewFile(); &#125; Properties pps = new Properties(); InputStream in = new FileInputStream(filePath); //从输入流中读取属性列表（键和元素对） pps.load(in); //调用 Hashtable 的方法 put。使用 getProperty 方法提供并行性。 //强制要求为属性的键和值使用字符串。返回值是 Hashtable 调用 put 的结果。 OutputStream out = new FileOutputStream(filePath); pps.setProperty(pKey, pValue); //以适合使用 load 方法加载到 Properties 表中的格式， //将此 Properties 表中的属性列表（键和元素对）写入输出流 pps.store(out, \"Update \" + pKey + \" name\"); out.close(); &#125; public static void main(String [] args) throws IOException&#123; System.out.println(\"写入Test.properties================\"); WriteProperties(\"Test.properties\",\"name\", \"12345\"); System.out.println(\"加载Test.properties================\"); GetAllProperties(\"Test.properties\"); System.out.println(\"从Test.properties加载================\"); String value = GetValueByKey(\"Test.properties\", \"name\"); System.out.println(\"name is \" + value); &#125;&#125; 运行结果123456789101112131415truetruecccdddsize: 4遍历开始==================Key:1, Value:nullKey:2, Value:bbbKey:1000, Value:aaaKey:30000, Value:ddd遍历结束==============================Entry迭代器遍历==============13335400纳秒============KeySet迭代器遍历==============20651700纳秒 工具类JCF中工具类不存储数据，而是在数据容器上，实现高效操作排序搜索 Arrays类排序：对数组排序，sort/parallelSort查找：从数组中查找一个元素，binarySearch批量拷贝：从源数组批量复制元素到目标数组，copyOf。批量赋值：对数组进行批量赋值，fill。等价性比较：判定两个数组内容是否相同，equals。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import java.util.Arrays;import java.util.Random;public class ArraysTest &#123; public static void main(String[] args) &#123; testSort(); testSearch(); testCopy(); testFill(); testEquality(); &#125; public static void testSort() &#123; Random r = new Random(); int[] a = new int[10]; for(int i=0;i&lt;a.length;i++) &#123; a[i] = r.nextInt(); &#125; System.out.println(\"===============测试排序================\"); System.out.println(\"排序前\"); for(int i=0;i&lt;a.length;i++) &#123; System.out.print(a[i] + \",\"); &#125; System.out.println(); System.out.println(\"排序后\"); Arrays.sort(a); for(int i=0;i&lt;a.length;i++) &#123; System.out.print(a[i] + \",\"); &#125; System.out.println(); &#125; public static void testSearch() &#123; Random r = new Random(); int[] a = new int[10]; for(int i=0;i&lt;a.length;i++) &#123; a[i] = r.nextInt(); &#125; a[a.length-1] = 10000; System.out.println(\"===========测试查找============\"); System.out.println(\"10000 的位置是\" + Arrays.binarySearch(a, 10000)); &#125; public static void testCopy() &#123; Random r = new Random(); int[] a = new int[10]; for(int i=0;i&lt;a.length;i++) &#123; a[i] = r.nextInt(); &#125; int[] b = Arrays.copyOf(a, 5); System.out.println(\"===========测试拷贝前五个元素============\"); System.out.print(\"源数组：\"); for(int i=0;i&lt;a.length;i++) &#123; System.out.print(a[i] + \",\"); &#125; System.out.println(); System.out.print(\"目标数组：\"); for(int i=0;i&lt;b.length;i++) &#123; System.out.print(b[i] + \",\"); &#125; System.out.println(); &#125; public static void testFill() &#123; int[] a = new int[10]; Arrays.fill(a, 100); Arrays.fill(a, 2, 8, 200); System.out.println(\"===========测试批量赋值============\"); System.out.print(\"数组赋值后：\"); for(int i=0;i&lt;a.length;i++) &#123; System.out.print(a[i] + \",\"); &#125; System.out.println(); &#125; public static void testEquality() &#123; int[] a = new int[10]; Arrays.fill(a, 100); int[] b = new int[10]; Arrays.fill(b, 100); System.out.println(Arrays.equals(a, b)); b[9] = 200; System.out.println(Arrays.equals(a, b)); &#125;&#125; Collections类处理对象是Collection及其子类排序：对List进行排序，sort搜索：从List中搜索元素，binarySearch批量赋值：对List批量赋值，fill最大、最小：查找集合中最大/小值，max，min反序：将List反序排列，reverse 对象比较 对象实现Comparable接口（需要修改对象类）compareTo方法“&gt;” 返回1，”==”返回0，”&lt;” 返回-1Arrays和Collections在进行对象sort时，自动调用该方法 新建Comparator（适用于对象类不可更改的情况）compare方法“&gt;” 返回1，”==”返回0，”&lt;” 返回-1Comparator比较强将作为参数提交给工具类的sort方法123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Arrays;public class Person implements Comparable&lt;Person&gt; &#123; String name; int age; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public int compareTo(Person another) &#123; int i = 0; i = name.compareTo(another.name); // 使用字符串的比较 if (i == 0) &#123; // 如果名字一样,比较年龄, 返回比较年龄结果 return age - another.age; &#125; else &#123; return i; // 名字不一样, 返回比较名字的结果. &#125; &#125; public static void main(String... a) &#123; Person[] ps = new Person[3]; ps[0] = new Person(\"Tom\", 20); ps[1] = new Person(\"Mike\", 18); ps[2] = new Person(\"Mike\", 20); Arrays.sort(ps); for (Person p : ps) &#123; System.out.println(p.getName() + \",\" + p.getAge()); &#125; &#125;&#125; 1234567891011121314151617public class Person2 &#123; private String name; private int age; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public Person2(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125; 12345678910111213141516171819202122232425262728import java.util.Arrays;import java.util.Comparator;public class Person2Comparator implements Comparator&lt;Person2&gt; &#123; public int compare(Person2 one, Person2 another) &#123; int i = 0; i = one.getName().compareTo(another.getName()); if (i == 0) &#123; // 如果名字一样,比较年龄,返回比较年龄结果 return one.getAge() - another.getAge(); &#125; else &#123; return i; // 名字不一样, 返回比较名字的结果. &#125; &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub Person2[] ps = new Person2[3]; ps[0] = new Person2(\"Tom\", 20); ps[1] = new Person2(\"Mike\", 18); ps[2] = new Person2(\"Mike\", 20); Arrays.sort(ps, new Person2Comparator()); for (Person2 p : ps) &#123; System.out.println(p.getName() + \",\" + p.getAge()); &#125; &#125;&#125; 运行结果123Mike,18Mike,20Tom,20 文件读写文件系统及Java文件基本操作文件系统是由OS（操作系统）管理的文件系统和Java进程是平行的，是两套系统文件系统是由文件夹和文件递归组合而成文件目录分隔符Linux/Unix 用/隔开Windows用\\隔开，涉及到转义，在程序中需用/或\\代替文件包括文件里面的内容和文件基本属性文件基本属性：名称、大小、扩展名、修改时间等 文件类Filejava.io.File是文件和目录的重要类(JDK6及以前是唯一) 目录也使用File类进行表示File类与OS无关，但会受到OS的权限限制常用方法createNewFile,delete,exists, getAbsolutePath, getName, getParent,getPath, isDirectory, isFile, length, listFiles, mkdir, mkdirs注意：File不涉及到具体的文件内容，只涉及属性","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hubojing.github.io/categories/编程语言/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hubojing.github.io/tags/Java/"}]},{"title":"在Eclipse中使用Weka","slug":"在Eclipse中使用Weka","date":"2019-10-17T02:28:49.000Z","updated":"2019-10-17T11:11:29.223Z","comments":true,"path":"2019/10/17/在Eclipse中使用Weka/","link":"","permalink":"https://hubojing.github.io/2019/10/17/在Eclipse中使用Weka/","excerpt":"　　笔记备忘。 ","text":"笔记备忘。 版本Weka 3.8Eclipse 2019-9 过程 解压weka-src.jar，获得weka-src文件夹。 将weka-src文件夹放在桌面（或任何喜欢的位置）。 打开Eclipse，新建Java Project项目，取消Use default location的勾，选择weka-src所在位置。Finish。 在项目src中新建package, weka.classifiers.xxx(自己命名)，添加算法文件。比如NB.java。 修改配置（每次添加算法都需要）weka.gui下GenericPropertiesCreator.props中添加创建的包1234weka.classifiers.Classifier=\\ ... weka.classifiers.xxx,\\ ... GenericObjectEditor.props中添加创建的算法1234weka.classifiers.functions.supportVector.Kernel=\\... weka.classifiers.xxx.NB,\\... 点击GUIChooser.java运行。弹出Weka。 选择Explorer-Preprocess-Open file...添加数据。（Weka的data里有实例数据） 选择Classify-Choose，找到添加的算法-Start。完成！","raw":null,"content":null,"categories":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"https://hubojing.github.io/categories/数据挖掘/"}],"tags":[{"name":"Weka","slug":"Weka","permalink":"https://hubojing.github.io/tags/Weka/"}]},{"title":"ArcGIS操作备忘","slug":"ArcGIS操作备忘","date":"2019-10-09T08:27:29.000Z","updated":"2019-11-17T08:38:56.699Z","comments":true,"path":"2019/10/09/ArcGIS操作备忘/","link":"","permalink":"https://hubojing.github.io/2019/10/09/ArcGIS操作备忘/","excerpt":"　　好记性不如烂笔头。 ","text":"好记性不如烂笔头。 xls转shp文件添加数据xls-Sheet1$-右键 显示XY数据-Y字段改为纬度-确定对Sheet1$个事件右键 数据-导出数据-确定 转换坐标系十进制度–&gt;米打开shp文件，打开ArcToolbox-数据管理工具-投影和变换-定义投影坐标系选择地理坐标系-World-WGS 1984 再选择投影-输出坐标系-投影坐标系-World-WGS 1984 Web Mercator(Auxiliary Sphere) 完成。 属性表相关添加字段表选项-添加字段 修改属性按属性选择1&quot;class&quot;=&apos;park&apos; 修改选中行特定属性选中该列右键 字段计算器1&quot;green place&quot; 写上需填写的值即可。注意单双引号。 裁剪ArcToolbox-分析工具-提取分析-裁剪输入要素-大范围的（比如国家地图）裁剪要素-要留下来的（比如区域地图） 建立服务区建立服务区之前需要先构建网络数据集打开ArcCatalog-连接到文件夹-选中.shp文件右键-新建网络数据集-一路“下一步”（不用高程字段、修改连通性策略为任意节点）-生成nd文件即可。 勾上 自定义-拓展模块-Network Analyst和Spatial Analyst自定义-工具条-勾上Network Analyst-新建服务区在Network Analyst窗口选中设施点-右键加载位置-选择需要加进去的点文件服务区-右键图层属性-分析设置-默认中断：1000米","raw":null,"content":null,"categories":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"https://hubojing.github.io/categories/数据挖掘/"}],"tags":[{"name":"GIS","slug":"GIS","permalink":"https://hubojing.github.io/tags/GIS/"}]},{"title":"学习R语言","slug":"学习R语言","date":"2019-09-27T13:21:27.000Z","updated":"2019-12-04T02:33:10.000Z","comments":true,"path":"2019/09/27/学习R语言/","link":"","permalink":"https://hubojing.github.io/2019/09/27/学习R语言/","excerpt":"　　嘤嘤嘤还要学统计 ","text":"嘤嘤嘤还要学统计 基本操作最基本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110x1=c(171,175,159,155,152,158,154,164,168,166,159,164)&gt; x1 [1] 171 175 159 155 152 158 154 164 168 166 159 164&gt; x2=c(57,64,41,38,35,44,41,51,57,49,47,46);x2 [1] 57 64 41 38 35 44 41 51 57 49 47 46&gt; rbind(x1,x2)#按行合并 [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]x1 171 175 159 155 152 158 154 164 168 166 159 164x2 57 64 41 38 35 44 41 51 57 49 47 46&gt; cbind(x1,x2)#按列合并 x1 x2 [1,] 171 57 [2,] 175 64 [3,] 159 41 [4,] 155 38 [5,] 152 35 [6,] 158 44 [7,] 154 41 [8,] 164 51 [9,] 168 57[10,] 166 49[11,] 159 47[12,] 164 46#利用x1数据创建矩阵&gt; matrix(x1,nrow=3,ncol=4) [,1] [,2] [,3] [,4][1,] 171 155 154 166[2,] 175 152 164 159[3,] 159 158 168 164#创建行数列数发生变化的矩阵&gt; matrix(x1,nrow=4,ncol=3) [,1] [,2] [,3][1,] 171 152 168[2,] 175 158 166[3,] 159 154 159[4,] 155 164 164#创建两个相同的矩阵&gt; A=B=matrix(1:12,nrow=3,ncol=4)&gt; A+B#矩阵加法 [,1] [,2] [,3] [,4][1,] 2 8 14 20[2,] 4 10 16 22[3,] 6 12 18 24&gt; A-B#矩阵减法 [,1] [,2] [,3] [,4][1,] 0 0 0 0[2,] 0 0 0 0[3,] 0 0 0 0&gt; A=matrix(1:9,nrow=3,ncol=3)&gt; B=matrix(1:9,nrow=3,ncol=3)&gt; A*B#矩阵对应元素的乘积 [,1] [,2] [,3][1,] 1 16 49[2,] 4 25 64[3,] 9 36 81&gt; A%*%B#矩阵的乘积 [,1] [,2] [,3][1,] 30 66 102[2,] 36 81 126[3,] 42 96 150&gt; A=matrix(1:16,nrow=4,ncol=4)&gt; diag(A)#获得矩阵对角线元素[1] 1 6 11 16&gt; diag(diag(A))#利用对角线元素创建对角矩阵 [,1] [,2] [,3] [,4][1,] 1 0 0 0[2,] 0 6 0 0[3,] 0 0 11 0[4,] 0 0 0 16&gt; A=matrix(rnorm(16),4,4)&gt; solve(A)#求矩阵的逆 [,1] [,2] [,3] [,4][1,] -0.2144625 0.9291739 0.41134588 -0.4129970[2,] -0.2990380 0.5107384 -0.03081756 0.6477244[3,] -0.1700996 1.4089089 -0.49639658 0.4082339[4,] -0.4334604 -0.3543499 -0.30915934 -0.5515849&gt; A=diag(4)+1&gt; A.e=eigen(A,symmetric=T)&gt; A.e#求特征根和特征向量eigen() decomposition$values[1] 5 1 1 1$vectors [,1] [,2] [,3] [,4][1,] -0.5 0.8660254 0.0000000 0.0000000[2,] -0.5 -0.2886751 -0.5773503 -0.5773503[3,] -0.5 -0.2886751 -0.2113249 0.7886751[4,] -0.5 -0.2886751 0.7886751 -0.2113249&gt; A=matrix(1:12,3,4)&gt; dim(A)#矩阵的维数[1] 3 4&gt; nrow(A)#矩阵的行数[1] 3&gt; ncol(A)#矩阵的列数[1] 4&gt; rowSums(A)#矩阵按行求和[1] 22 26 30&gt; rowMeans(A)#矩阵按行求均值[1] 5.5 6.5 7.5&gt; colSums(A)#矩阵按列求和[1] 6 15 24 33&gt; colMeans(A)#矩阵按列求均值[1] 2 5 8 11 函数apply()函数1234567891011121314&gt; apply(A,1,sum)#矩阵按行求和[1] 22 26 30&gt; apply(A,1,mean)#矩阵按行求均值[1] 5.5 6.5 7.5&gt; A=matrix(rnorm(100),20,5)&gt; apply(A,2,var)#矩阵按列求方差[1] 0.864552 1.153079 1.143116 1.264152 1.061721&gt; B=matrix(1:12,3,4)#矩阵按列求函数结果&gt; apply(B,2,function(x,a)x*a,a=2) [,1] [,2] [,3] [,4][1,] 2 8 14 20[2,] 4 10 16 22[3,] 6 12 18 24 数据框#产生由X1和X2构建的数据框123456789101112131415161718192021222324252627282930&gt; X=data.frame(x1,x2);X x1 x21 171 572 175 643 159 414 155 385 152 356 158 447 154 418 164 519 168 5710 166 4911 159 4712 164 46#赋予数据框新的列标签&gt; X=data.frame('身高'=x1,'体重'=x2);X 身高 体重1 171 572 175 643 159 414 155 385 152 356 158 447 154 418 164 519 168 5710 166 4911 159 4712 164 46 读取从剪切板读取12dat = read.table(\"clipboard\",header=TRUE)dat = read.table(\"clipboard\") 从文本文件读取12dat = read.table(\"textdata.txt\",header=TRUE)dat = read.table(\"textdata.txt\") 读取csv格式1X=read.csv(\"textdata.csv\") 读取excel格式 下载包”readxl” 调用包library(readxl)3.读取文件1X=read_excel(\"data.xlsx\") 定性变量分析12345#将剪切板数据读入数据框中&gt; d=read.table(\"clipboard\",header=T)&gt; head(d)#显示前6组数据&gt; attach(d)#绑定数据&gt; table(年龄)#以为列联表 单因素分析1234#条形图&gt; barplot(table(年龄)，col=1:7)#饼图&gt; pie(table(结果)) 两因素分析1234#以性别分组的年龄条图&gt; barplot(table(年龄,性别),beside=T,col=1:7)#以年龄分组的性别条图&gt; barplot(table(性别,年龄),beside=T,col=1:2) 三因素分析1234#以年龄、性别排列的结果频数三维列联表&gt; ftable(年龄,性别,结果)#以性别、年龄排列的结果频数三维列联表&gt; ftable(性别,年龄,结果) 当数据不使用时，记得解除绑定1&gt; detach(d) 可视化123456789101112131415161718192021222324252627282930313233343536373839404142&gt; X=read.table('clipboard',header=T);X#按行做均值条形图&gt; barplot(apply(X,1,mean))#修改横坐标位置&gt; barplot(apply(X,1,mean),las=3)#按列做均值图条形&gt; barplot(apply(X,2,mean))#按列做彩色均值图条形图&gt; barplot(apply(X,2,mean),col=1:8)#按列做中位数条形图&gt; barplot(apply(X,2,median),col=1:8)#按列做均值饼图&gt; pie(apply(X,2,mean))# 垂直箱线图&gt; boxplot(X)#水平箱线图&gt; boxplot(X,horizontal=T)#简单星相图&gt; stars(X)#带图例的星相图&gt; stars(X,key.loc=c(17,7))#带图例度彩色星相图&gt; stars(X,key.loc=c(17,7),draw.segments=T)#脸谱图#加载aplpack包&gt; library(aplpack)&gt; faces(X)#去掉变量1做脸谱图&gt; faaces(X[,-1])#face(X,[,2:8])#选择第1,5,6,9,18个观测的多元数据做脸谱图&gt; faces(X[C(1,5,6,9,18),])#调和曲线图&gt; library(mvstats)#mvstats不是官方包&gt; plot.andrews(X)&gt; plot.andrews(X[C(1,5,6,9,18),]) 多元相关及回归分析123x=c(171,175,159,155,152,158,154,164,168,166,159,164)#身高y=c(57,64,41,38,35,44,41,51,57,49,47,46)#体重plot(x,y) 画散点图计算lxx=556.9 lyy=813 lxy=645.5r=lxy/根号下(lxxlyy)=0.9593 高的正相关 相关系数计算函数cor()cor(x,y=NULL,method=c(“pearson”,”kendall”,”spearman”))x 数值向量、矩阵或数据框，y 空或数值向量、矩阵或数据框method 计算方法，包括”pearson”,”kendall”或”spearman”三种，默认pearson 123456789计算pearson相关系数：&gt; cor(x,y)建立假设检验 H0：ρ=0，H1：ρ≠0，α=0.05计算相关系数r的t值：tr=r-0/根号下(1-r^2/n-2)=10.74&gt; n=length(x)&gt; tr=r/sqrt((1-r^2)/(n-2));tr计算t值和P值，作结论：&gt; cor.test(x,y)#相关系数假设检验 12345678910 Pearson&apos;s product-moment correlationdata: x and yt = 10.743, df = 10, p-value = 8.21e-07alternative hypothesis: true correlation is not equal to 095 percent confidence interval: 0.8574875 0.9888163sample estimates: cor 0.9593031 由于p-value &lt; 0.05，于是在α=0.05水准上拒绝H0，接受H1，可认为该人群身高与体重呈现正的线性关系。 建立直线回归方程1234567b=lxy(x,y)/lxy(x,x)#不过我这里报错没有lxy函数...lxy好像是离差平方和a=mean(y)-b*mean(x)c(a=a,b=b)#散点图plot(x,y)lines(x,a+b*x) 1234#数据输入d=read.table(\"clipboard\",header=T);d#拟合模型m=lm(y~x,data=d);m 输出123456Call:lm(formula = y ~ x, data = d)Coefficients:(Intercept) x -140.364 1.159 y估计=-140.364+1.159x作回归直线12plot(y~x,data=d)#作散点图abline(m)#添加回归线 模型的方差分析（ANOVA)1anova(fm) 1summary(fm)#回归系数t检验 广义线性模型Poisson分布族模型和拟Poisson分布族模型的使用方法为12glm(formula,family=poisson,data,...)glm(formula,family=poisson(link=log),data,...) (1)建立Poisson对数线性模型：123d=read.table(\"clipboard\",header=T)log=glm(y~x1+x2,family=poisson,data=d)#对数线性模型summary(log)#检验结果 广义线性模型glm()的用法1glm(formula, family=gaussian, data, ...) formula为公式，即为要拟合的模型，famliy为分布族，包括正态分布（gaussian）、二项分布（binomial）、泊松分布（poission）和伽玛分布（gamma），分布族还可以通过选项link=来指定使用的连接函数，data为可选择的数据框。123456789#(1)建立全变量logistic回归模型d=read.table(\"clipboard\",header=T)logit&lt;-glm(y~x1+x2+x3,family=binomial,data=d)#Logistic模型summary(logit)#Logistic模型结果#(2)逐步筛选变量logistic回归模型#逐步筛选法变量选择logit.step=step(logit)#逐步筛选法变量选择结果summar(logit.step) 12d=read.table(&quot;clipboard&quot;,header=T)anova(lm(Y~factor(A),data=d))#完全随机设计方差分析 判别分析1234567#线性判别分析d=read_excel('data.xlsx','d')boxplot(x1~G,d)boxplot(x2~G,d)t.test(x1~G,d)t.test(x2~G,d)summary(glm(G-1~x1+x2,family=binomial,d))#Logistic模型分析 线性判别分析函数lda的用法lda(formula, data, …)formula形如y~x1+x2+…的公式框架，data数据框123456789attach(d)plot(x1,x2);text(x1,x2,G,adj=-0.5)#表示点所属类别Glibrary(MASS)ld=lda(G~x1+x2);ldlp=predict(ld)G1=lp$classdata.frame(G,G1)tab1=table(G,G1);tab1sum(diag(prop.table(tab1))) ……没有实践写不下去","raw":null,"content":null,"categories":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"https://hubojing.github.io/categories/数据挖掘/"}],"tags":[{"name":"R语言","slug":"R语言","permalink":"https://hubojing.github.io/tags/R语言/"}]},{"title":"初涉Hadoop","slug":"初涉Hadoop","date":"2019-09-24T10:45:27.000Z","updated":"2019-10-12T08:40:33.032Z","comments":true,"path":"2019/09/24/初涉Hadoop/","link":"","permalink":"https://hubojing.github.io/2019/09/24/初涉Hadoop/","excerpt":"　　最基本的概念+简单实战。 ","text":"最基本的概念+简单实战。 最近看到一篇用Hadoop解决交通问题的论文，然而我还没有接触过…… Hadoop是什么Hadoop是一个开源的大数据框架Hadoop是一个分布式计算的解决方案Hadoop=HDFS(分布式文件系统)+MapReduce(分布式计算)HDFS：存储是大数据技术的基础MapReduce编程模型：分布式计算是大数据应用的解决方案 HDFS概念数据块默认大小为64MB，一般设置为128M，备份x3 NameNode管理文件系统的命名空间，存放文件元数据维护着文件系统的所有文件和目录，文件与数据块的映射记录每个文件中各个块所在数据节点的信息 DataNode存储并检索数据块向NameNode更新所存储块的列表 HDFS优缺点优点适合大文件存储，支持TB、PB级的数据存储，并有副本策略可以构建在廉价的机器上，并有一定的容错和恢复机制支持流式数据访问，一次写入，多次读取最高效 缺点不适合大量小文件存储不适合并发写入，不支持文件随机修改不支持随机读等低延时的访问方式 Hadoop基础架构YARN概念ResourceManager分配和调度资源启动并监控ApplicationMaster监控NodeManager ApplicationMaster为MR类型的程序申请资源，并分配给内部任务负责数据的切分监控任务的执行及容错NodeManager管理单个节点的资源处理来自ResourceManager的命令处理来自ApplicationMaster的命令 MapReduce编程模型输入一个大文件，通过Split之后，将其分为多个分片每个文件分片由单独的机器去处理，这就是Map方法将各个机器计算的结果进行汇总并得到最终的结果，这就是Reduce方法 1.0和2.0区别 区别 Hadoop生态圈很多… HBase高可靠，高性能，面向列，可伸缩，实时读写的分布式数据库利用HDFS作为其文件存储系统，支持MR程序读取数据存储非结构化和半结构化数据RowKey:数据唯一标识，按字典排序Column Family:列族，多个列的集合。最多不要超过3个TimeStamp时间戳：支持多版本数据同时存在 Spark基于内存计算的大数据并行计算框架Spark是MapReduce的替代方案，兼容HDFS, HIVE等数据源优点：基于内存计算的分布式计算框架抽象出分布式内存存储数据结构 弹性分布式数据集RDD基于事件驱动，通过线程池复用线程提高性能 简单实战常用HDFS Shell命令类Linux系统：ls, cat, mkdir, rm, chmod, chown等HDFS文件交互：copyFromLocal, copyToLocal, get, put","raw":null,"content":null,"categories":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"https://hubojing.github.io/categories/数据挖掘/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"https://hubojing.github.io/tags/Hadoop/"}]},{"title":"Hexo博客进阶优化","slug":"hexo博客进阶优化","date":"2019-09-14T15:03:40.000Z","updated":"2019-09-14T07:28:39.000Z","comments":true,"path":"2019/09/14/hexo博客进阶优化/","link":"","permalink":"https://hubojing.github.io/2019/09/14/hexo博客进阶优化/","excerpt":"　　　　　　　Hexo优化的一些汇总整理。　　　　 ","text":"Hexo优化的一些汇总整理。 老记录https://hubojing.github.io/2015/11/10/hexo%E4%BC%98%E5%8C%96/原来写的，排版什么的不是很好看… 一些重要参考 HEXO https://hexo.io/ Hexo在github上构建免费的web应用 http://blog.fens.me/hexo-blog-github/ Hexo你的博客 http://www.tuicool.com/articles/AfQnQjy/ 不蒜子 http://ibruce.info/2015/04/04/busuanzi/ Markdown 编辑器语法指南 https://segmentfault.com/markdown/ Markdown入门 http://www.360doc.com/content/13/1119/13/3300331_330476656.shtml/ GitHub for Windows 2.0使用教程 http://www.cnblogs.com/jiqing9006/p/3987702.html/ Github使用技巧 higrid.net/hi/docs/github-cheat-sheet/ 解决Hexo置顶问题 http://www.netcan666.com/2015/11/22/%E8%A7%A3%E5%86%B3Hexo%E7%BD%AE%E9%A1%B6%E9%97%AE%E9%A2%98/ 如何向google提交sitemap（详细） http://fionat.github.io/blog/2013/10/23/sitemap/ 用微信与Github搭建“微博” https://joway.github.io/posts/Toy/2016-05-14-%E7%94%A8%E5%BE%AE%E4%BF%A1%E4%B8%8EGithub%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BE%AE%E5%8D%9A.html/ 多说样式（UA浏览器标识、旋转头像） http://moxfive.xyz/2015/09/29/duoshuo-style/# 添加相册功能 http://www.tuicool.com/articles/fYZ7Zrj 页面自动刷新与移动端调试 http://moxfive.xyz/2016/03/27/hexo-browsersync/ chrome 谷歌浏览器报错DNS查找失败的解决办法 http://www.t522.com/suibi/238.html/ 用自己的页面做主页 https://jacklightchen.github.io/blog/2016/10/27/HexoOverview/ 统计文章字数 https://github.com/willin/hexo-wordcount 高级进阶 Daocloud持续集成————Hexo博客自动发布系统 https://nullun.tk/ci/daocloud/Daocloud%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E2%80%94%E2%80%94%E2%80%94%E2%80%94Hexo%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83%E7%B3%BB%E7%BB%9F/#more/ 使用 Termux 在手机上运行 linux 黑科技 http://www.oyohyee.com/post/Note/Termux.html/ Hexo+Github实现相册功能 http://blog.csdn.net/u013082989/article/details/70162293/ Hexo+yilia主题实现文章目录和添加视频 http://blog.csdn.net/u013082989/article/details/70212008/ 用 Hexo 做个人 Wiki 知识管理系统 https://www.v2ex.com/t/347176?p=1/ Hexo自定义页面的方法 http://www.cnblogs.com/refined-x/p/7160174.html/ 在 Hexo 博客中跳过渲染，创建自定义网页 http://www.jianshu.com/p/f89428fce8d5/ 增加打赏功能 http://cighao.com/2016/02/23/add-donate-to-hexo/ hexo移植 http://nodlee.com/2015/06/07/how-to-porting-hexo/#more 网页特效 鼠标点击特效 https://laod.cn/design/page/javascript-texiao.html sortnode_modules/hexo-generator-index/lib/generator.js12345678910111213141516171819202122232425262728293031323334&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 按更新时间排序：改一下上面文章里的代码 a.date, b.date 分别改为 a.updated, b.updated参考资料：http://www.netcan666.com/2015/11/22/解决Hexo置顶问题/ 原始代码：123456789101112131415161718&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts.sort(&apos;-date&apos;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;;","raw":null,"content":null,"categories":[{"name":"博客","slug":"博客","permalink":"https://hubojing.github.io/categories/博客/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hubojing.github.io/tags/Hexo/"}]},{"title":"SSD重装系统最简教程","slug":"SSD重装系统最简教程","date":"2019-09-12T05:59:01.000Z","updated":"2019-09-12T05:59:01.000Z","comments":true,"path":"2019/09/12/SSD重装系统最简教程/","link":"","permalink":"https://hubojing.github.io/2019/09/12/SSD重装系统最简教程/","excerpt":"　　懒人装机必备。（预计可以节约100元装机费） ","text":"懒人装机必备。（预计可以节约100元装机费） 起因一直没看好心仪的笔记本，但为了接下来的学习任务，决定先把我古老的联想Y400改造了凑合用一段时间，刚好内存和SSD的价格都降下来了。换了8G内存，加了SSD。 硬件 内存条 目的是能用就OK，所以越便宜越好…… SSD SSD也有更便宜的，不过数据还是重要，买个适配好点的吧…（数据最终还是要存到硬盘的嘛…内存坏了的损失比SSD小，希望我没想错）具体物理安装过程没什么好说的，就是拆机就完事了。 重装系统真不建议迁移系统，感觉现在所谓的迁移系统都有很多的缺漏，不是真正意义上的迁移。我试了试傲梅分区助手的迁移功能，其实还是假迁移。还是重装最合适。 第一步MSDN，我告诉你下载原版win10的iso文件。 第二步一个很偷懒且硬核的方法：先暂时卸下机械硬盘，只安装SSD。然后直接点开下载的文件里的setup安装就好了。不过我没尝试，因为好不容易把后盖给盖上了，实在是不想拧螺丝了。网上有很多U盘制作工具，但是不够简洁。而且还容易制作失败。（我用老毛桃制作就失败了…)我觉得最简单的是用软碟通UltraISO制作U盘启动盘。所以先下载UltraISO，安装。 第三步插入一个空8G以上U盘。打开UltraISO，将下载好的iso文件导入，点击启动-写入硬盘映像。写入，完成。 第四步重启，屏幕亮起时按F1进入BIOS，将USB启动设置优先级到第一。保存。系统进入安装引导页。 第五步正常安装，记得将系统选择安装在SSD里。等待。 重装成功！ 我看到有同学花100块去找人装系统，唉，这个钱花的好亏。（我只收50！手动滑稽）","raw":null,"content":null,"categories":[{"name":"数码","slug":"数码","permalink":"https://hubojing.github.io/categories/数码/"}],"tags":[{"name":"硬件","slug":"硬件","permalink":"https://hubojing.github.io/tags/硬件/"},{"name":"装机","slug":"装机","permalink":"https://hubojing.github.io/tags/装机/"}]},{"title":"Github+SSH就这么连","slug":"Github+SSH就这么连","date":"2019-09-11T13:06:02.000Z","updated":"2019-09-11T13:06:02.000Z","comments":true,"path":"2019/09/11/Github+SSH就这么连/","link":"","permalink":"https://hubojing.github.io/2019/09/11/Github+SSH就这么连/","excerpt":"　　这篇文章很短。 ","text":"这篇文章很短。 官方说明https://help.github.com/en/articles/connecting-to-github-with-ssh不知道是我英语进步了还是咋的，感觉官网的文档写的特别清晰，阅读起来也特别清爽。 电脑重装了，反正又要添加SSH。我寻思着以前有记录就翻了翻，唉，刚写技术博那会儿的文章真是乱的不能看。干脆重新整理一下吧。 整个过程非常简单！1$ ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\" 不停回车。（没设密码） 在/c/Users/you/.ssh文件夹中复制id_rsa.pub中的全部。 在Github的Setting中的SSH and GPG keys中新建SSH，并粘贴刚才的内容。 完成！ 1ssh -T git@github.com 检测一下，1Hi hubojing! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 成功！","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"https://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://hubojing.github.io/tags/Github/"},{"name":"SSH","slug":"SSH","permalink":"https://hubojing.github.io/tags/SSH/"}]},{"title":"ChromeDevTools调试备忘","slug":"ChromeDevTools开发者工具调试指南","date":"2019-08-14T07:22:21.000Z","updated":"2019-08-14T07:22:21.000Z","comments":true,"path":"2019/08/14/ChromeDevTools开发者工具调试指南/","link":"","permalink":"https://hubojing.github.io/2019/08/14/ChromeDevTools开发者工具调试指南/","excerpt":"　　笔记备忘。 ","text":"笔记备忘。 打开Chrome开发者工具 打开最近关闭的状态：Ctrl+Shift+I(Windows) 或 Cmd+Opt+I(Mac) 快速查看DOM或样式：Ctrl+Shift+C(Windows) 或 Command+Option+C(Mac) 快速进入Console查看log运行JavaScript:Ctrl+Shift+J(Windows) 或 Command+Option+J(Mac) F12打开 在Console中访问节点 使用document.querySelectAll访问 使用$0快速访问选中的元素 拷贝 -&gt; JS Path 在Elements页面按ESC键可以同时打开Console面板。 DOM中断点调试 属性修改时打断点：break on -&gt; attribute modifications 节点删除时打断点：break on -&gt; node removal 子树修改时打断点：break on -&gt; subtree modifications 断点调试JS console.log() alert() debugger 事件断点 鼠标选中","raw":null,"content":null,"categories":[{"name":"软件开发","slug":"软件开发","permalink":"https://hubojing.github.io/categories/软件开发/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hubojing.github.io/tags/Web/"}]},{"title":"初涉Maven","slug":"初涉Maven","date":"2019-08-10T08:26:08.000Z","updated":"2019-08-10T08:26:08.000Z","comments":true,"path":"2019/08/10/初涉Maven/","link":"","permalink":"https://hubojing.github.io/2019/08/10/初涉Maven/","excerpt":"　　笔记。 ","text":"笔记。 安装官网下载安装包，解压。 bin目录包含mvn的运行脚本boot目录包含一个类加载器的框架conf是配置文件目录 配置环境变量M2_HOME变量值：E:\\maven\\apache-maven-3.6.1 Path中添加%M2_HOME%\\bin cmd输入mvn -v 输出1234Maven home: E:\\maven\\apache-maven-3.6.1\\bin\\..Java version: 1.8.0_201, vendor: Oracle Corporation, runtime: E:\\JDK\\jreDefault locale: zh_CN, platform encoding: GBKOS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;windows&quot; 即安装成功。 结构12345678src -main -java -package -test -java -package resources 新建结构E:\\maven\\code\\maven01\\src\\main\\java\\com\\jinger\\maven01\\model在这里新建HelloWorld.java1234567package com.jinger.maven01.model;public class HelloWorld&#123; public String sayHello()&#123; return \"Hello World!\"; &#125;&#125; 新建结构E:\\maven\\code\\maven01\\src\\test\\java\\com\\jinger\\maven01\\model在这里新建HelloWorldTest.java1234567891011package com.jinger.maven01.model;import org.junit.*;import org.junit.Assert.*;public class HelloWorldTest&#123; @Test public void testHello()&#123; Assert.assertEquals(\"Hello World!\",new HelloWorld().sayHello()); &#125;&#125; 在E:\\maven\\code\\maven01新建pom.xml12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.jinger.maven01&lt;/groupId&gt; &lt;artifactId&gt;maven01-model&lt;/artifactId&gt; &lt;version&gt;0.0.1SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; groupId的值是项目包名artifactId的值是模块名 cmd里mvn compile编译，第一次安装会自动下载相关依赖。 mvn test测试，显示12345678910111213141516------------------------------------------------------- T E S T S-------------------------------------------------------Running com.jinger.maven01.model.HelloWorldTestTests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.039 secResults :Tests run: 1, Failures: 0, Errors: 0, Skipped: 0[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 2.068 s[INFO] Finished at: 2019-07-28T17:26:39+08:00[INFO] ------------------------------------------------------------------------ 跟目录下生成了target文件夹 mvn package打包 1234567[INFO] Building jar: E:\\maven\\code\\maven01\\target\\maven01-model-0.0.1SNAPSHOT.jar[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 01:46 min[INFO] Finished at: 2019-07-28T17:29:43+08:00[INFO] ------------------------------------------------------------------------ 生成了jar包。 基础mvn -v 查看maven版本 compile 编译 test 测试 package 打包 clean 删除target install 安装jar包到本地仓库中 新建结构E:\\maven\\code\\maven02\\src\\main\\java\\com\\jinger\\maven02\\util在这里新建Speak.java123456789package com.jinger.maven02.util;import com.jinger.maven01.model.HelloWorld;public class Speak&#123; public String sayHi()&#123; return new HelloWorld().sayHello(); &#125;&#125; 新建结构E:\\maven\\code\\maven02\\src\\test\\java\\com\\jinger\\maven02\\util在这里新建SpeakTest.java1234567891011package com.jinger.maven02.util;import org.junit.*;import org.junit.Assert.*;public class SpeakTest&#123; @Test public void testHello()&#123; Assert.assertEquals(\"Hello World!\",new Speak().sayHi()); &#125;&#125; mvn compile编译 1错误：[ERROR] /E:/maven/code/maven02/src/main/java/com/jinger/maven02/util/Speak.java:[3,32] 程序包com.jinger.maven01.model不存在 进入maven01文件夹执行mvn install发送到本地仓库中在pow.xml加入依赖项12345&lt;dependency&gt; &lt;groupId&gt;com.jinger.maven01&lt;/groupId&gt; &lt;artifactId&gt;maven01-model&lt;/artifactId&gt; &lt;version&gt;0.0.1SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 完整pom.xml123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.jinger.maven02&lt;/groupId&gt; &lt;artifactId&gt;maven02-model02&lt;/artifactId&gt; &lt;version&gt;0.0.1SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.jinger.maven01&lt;/groupId&gt; &lt;artifactId&gt;maven01-model&lt;/artifactId&gt; &lt;version&gt;0.0.1SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 自动创建目录骨架archetype插件创建目录的两种方式： mvn archetype:generate选1389 Choose org.apache.maven.archetypes:maven-archetype-quickstart version 再选最新版 Confirm properties configuration:groupId: com.jinger.maven03artifactId: maven03-serviceversion: 1.0.0SNAPSHOTpackage: com.jinger.maven03.service 1234mvn archetype:generate -DgroupId=组织名, 公司网址的反写+项目名 -DartifactId=项目名-模块名 -Dversion=版本号 -Dpackage=代码所存在的包名 坐标和仓库构件通过坐标作为其唯一标识 修改镜像仓库位置：E:\\maven\\apache-maven-3.6.1\\conf打开settings.xml146行增加123456&lt;mirror&gt; &lt;id&gt;maven.net.cn&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;central mirror in China&lt;/name&gt; &lt;url&gt;http://maven.net.cn/content/groups/public&lt;/url&gt; &lt;/mirror&gt; 这个源好像不太行，换成阿里云的可以123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; * &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; 修改默认本地仓库位置49行增加1&lt;localRepository&gt;E:/maven/repo&lt;/localRepository&gt; 将该settings.xml复制到repo文件夹下。 在Eclipse中的使用新版Eclipse自带Maven插件。新建New-Other-Maven Project，选择quickstart模板。Group Id:com.jinger.hiArtifact Id:hi 建成后，对pom.xml右键，Run As-2 Maven build …在Goals中填入compile 再在Goals中填入packagejar包构建成功 Maven生命周期和插件完整的项目构建过程包括：清理、编译、测试、打包、集成测试、验证、部署 maven生命周期：clean 清理项目default 构建项目site 生成项目站点 clean清理项目pre-clean 执行清理前的工作clean 清理上一次构建生成的所有文件post-clean 执行清理后的文件 default 构建项目（最核心）compile test package install site 生成项目站点pre-site 在生成项目站点前要完成的工作site 生成项目的站点文档post-site 在生成项目站点后要完成的工作site-deploy 发布生成的站点到服务器上 举例在pom.xml新增1234567891011121314151617&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar-no-fork&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; run as - maven build …clean package pom.xml常用元素1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859pom.xml：maven项目的核心管理文件，用于项目描述、组织管理、依赖管理、构建信息的管理，Pom中包含了许多的标签。Pom.xml的常用元素：&lt;project&gt;是pom.xml的根元素，包含了pom的一些约束信息。&lt;modelVersion&gt;是一个固定的版本，也是必须的元素，指定了当前pom的版本。坐标的信息由以下标签组成：&lt;groupId&gt;主项目标识，公司网址+项目名组成&lt;/groupId&gt;注意：maven的项目和实际的项目不是一一对应关系，maven项目体现的是模块化的概念，因此一个实际项目往往会划分成很多的模块。&lt;artifactId&gt;一个模块的标识，项目名+模块名进行标识&lt;/artifactId&gt;&lt;version&gt;第一个0标识大版本号，第二个0表示分支版本号，第三个0表示小版本号，一般形式可以写为0.0.1snapshot，snapshot快照、alpha内部测试、beta公测、Release稳定、GA版本正式发布&lt;version&gt;。&lt;packaging&gt;maven项目打包的方式，默认打包是jar，、其他类型war、zip、pom等&lt;packaging&gt;其他标签：&lt;name&gt;项目的描述名，一般是在产生对象文档时候才会使用&lt;/name&gt;&lt;url&gt;项目的地址&lt;/url&gt;&lt;description&gt;项目的描述&lt;/description&gt;&lt;developers&gt;开发人员的列表&lt;/developers&gt;&lt;licenses&gt;许可证的信息，比如经常用到的开源框架，它都会有一些许可证的信息&lt;/licenses&gt;&lt;organization&gt;组织信息&lt;/organization&gt;&lt;dependencies&gt;依赖列表&lt;dependencies&gt; 依赖项(可以包含多个) 依赖项用坐标确定依赖的位置 &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;type&gt;类型&lt;/type&gt; &lt;scope&gt;依赖的范围（比如上面写的junit的测试范围是test，只在测试的依赖范围内有用，在主代码中引用junit这个类，它就会报错）&lt;/scope&gt; &lt;optional&gt;设置依赖是否可选(默认是false，子项目默认是false时，子项目默认是继承的，如果为true，子项目必须显示的引入该依赖)&lt;/optional&gt; &lt;executions&gt; 排除依赖的传递列表(可以排除多个依赖，比如Ajar包依赖Bjar包，Bjar包又依赖Cjar包，C对于A来说就是传递依赖，如果A不想依赖C，就使用该标签) &lt;execution&gt;&lt;/execution&gt; &lt;/executions&gt;&lt;/dependencies&gt;&lt;dependencyManagementy&gt;依赖的管理&lt;/dependencyManagementy&gt;&lt;dependencies&gt;&lt;dependency&gt;&lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt;依赖的管理,也可以通过&lt;dependencies&gt;声明依赖列表,通过&lt;dependency&gt;包含多个依赖，但是它并不会被运行，也就是说它不会被引入到实际的依赖当中，该标签一般主要用于定义在父模块中，供子模块继承用的。比如之前多个maven项目中，都使用到junit，我们就可以抽象出一个父类的模块，然后在父类模块中对junit进行一个定义，其他子模块直接继承该父模块即可。&lt;build&gt; 插件列表 &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;&lt;parent&gt;用于子模块对父模块的pom的继承&lt;/parent&gt;&lt;modules&gt;指定多个模块一起编译&lt;/modules&gt; scope三种classpath： 编译 测试 运行 compile:默认的范围，编译测试运行都有效provided:在编译和测试时有效runtime:在测试和运行时有效test:只在测试时有效system:与本机系统相关联，可移植性差import:导入的范围，它只使用在dependencyManagement中，表示从其它的pom中导入dependency的配置 依赖依赖的传递：多个项目依次依赖，A&lt;-B&lt;-C，后面的引入前面的项目坐标要把前面的项目编译、打包、安装后，后面的项目才能运行build 短路冲突：1、短路优先A-&gt;B-&gt;C-&gt;X(jar)A-&gt;D-&gt;X(jar) 先解析下面的 2、先声明优先如果路径长度相同，则谁先声明，先解析谁 聚合和继承 项目的继承在父类项目中使用dependencyManagement对依赖进行管理，但是并不会使用依赖，子类需要使用parent标签，来引用父类中的依赖，一般可以将版本号在父类中进行声明，子类无需声明版本号，这样可以保证子类和父类版本号一致。 项目的聚合 将packaging打包方式改为pom，使用modules标签，引入其他项目 12345&lt;modules&gt; &lt;module&gt;../A&lt;/module&gt; &lt;module&gt;../B&lt;/module&gt; &lt;module&gt;../C&lt;/module&gt;&lt;/modules&gt; 构建web项目新建项目，模板选择webapp。GroupId: com.jinger.webdemoArtifact Id:webdemo 建成后，在Navigator中新建src/main/java和src/test/java`src/test/resources`文件夹 在Project Explorer中对项目右键Build Path-Configure Build Path-Source，确保Output folder是webdemo/target/classes 项目属性-Project Facets（没有这一项请下载输入http://download.eclipse.org/releases/oxygen ，选择Web, XML, Java EE and OSGi Enterprise Development 安装即可。）勾选Dynamic Web Module最终发布产品时不需要测试代码，项目属性-Deployment Assemnly，remove相关测试文件。 在pom.xml的下添加1234567&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;8.1.16.v20140903&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; run as build jetty:run浏览器输入http://localhost:8080/显示Hello World! 在打包成功后使用jetty:run来运行jetty服务 标签下12345678&lt;executions&gt;&lt;execution&gt;&lt;phase&gt;package&lt;/phase&gt;&lt;goals&gt;&lt;goal&gt;run&lt;/goal&gt;&lt;/goals&gt;&lt;/execution&gt;&lt;/executions&gt; run as build clean package浏览器输入http://localhost:8080/显示Hello World! 使用tomcat同理。","raw":null,"content":null,"categories":[{"name":"软件开发","slug":"软件开发","permalink":"https://hubojing.github.io/categories/软件开发/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hubojing.github.io/tags/Java/"},{"name":"Maven","slug":"Maven","permalink":"https://hubojing.github.io/tags/Maven/"}]},{"title":"测手速软件APMShow开发——佟年送给韩商言的礼物","slug":"测手速软件APMShow开发——佟年送给韩商言的礼物","date":"2019-07-22T06:26:45.000Z","updated":"2019-07-22T13:17:26.000Z","comments":true,"path":"2019/07/22/测手速软件APMShow开发——佟年送给韩商言的礼物/","link":"","permalink":"https://hubojing.github.io/2019/07/22/测手速软件APMShow开发——佟年送给韩商言的礼物/","excerpt":"　　Electron开发　　追剧写代码啧啧啧　　 ","text":"Electron开发 追剧写代码啧啧啧 前言 最近看了一部剧，可以说是很甜了…… 傻白甜女主角佟年99年计算机专业研二（ε=(´ο｀*)))唉，其实人家肤白貌美智商高碾压众人让人悲伤 （ACM亚军呜呜呜呜呜…） 还可爱！ 男主韩商言本来设定是顶级电竞选手，后来改成了CTF比赛顶级选手。虽然改的很生硬，但也算是成功科普了CTF。（还是得吐槽，打CTF的人怎么可能不知道计算机专业的东西……） 二次元韩商言 CTF(Capture The Flag)，夺旗赛。CTF是一种流行的信息安全竞赛形式，其英文名可直译为“夺得Flag”，也可意译为“夺旗赛”。其大致流程是，参赛团队之间通过进行攻防对抗、程序分析等形式，率先从主办方给出的比赛环境中得到一串具有一定格式的字符串或其他内容，并将其提交给主办方，从而夺得分数。为了方便称呼，我们把这样的内容称之为“Flag”。 这是多么酷炫的比赛啊。剧里所有的家长们却都嫌弃男主不务正业天天玩电脑？？？ 写的一手好代码的佟年，送给Gun神的第一件礼物竟然是—— 熬夜写了一个晚上的测手速的软件…… ？ 散发着工科硬核味道的礼物还真是可爱一言难尽哦 不禁使我想起了本科毕业时，本来我也为朋友们准备了毕业礼物的。当时兴致勃勃打算给朋友们每人写一个app…… 然而由于时间都在工作上，加上当时开发速度太慢了，后来拖久了感觉失去了毕业礼物的时效性，就不了了之了…… 那么，我要说的是什么 …… 我要说，这个测手速的软件呢，佟年提到的时候我觉得应该挺简单的，所以我也做了一个，顺便把kk俱乐部里原来那种听音测试也加了进去，娱乐一下哈哈哈哈 总览 框架：Electron 语言：Html、CSS、JS Electron开发安装与配置 新建app文件夹。 初始化npm init 安装Electronnpm install electron --save-dev 开发 Electron安好了 再就HTML CSS JS慢慢写呗 打包npm install electron-packager -g package.json添加：1&quot;package&quot;: &quot;electron-packager . APMShow --platform=win32 --arch=x64 --out=./out --asar --app-version=0.0.1 --electron-version=5.0.7 --overwrite --ignore=node_modules&quot; 执行npm run package打包。 Electron小笔记开启调试工具1win.webContents.openDevTools() 锁定窗口大小12345678win = new BrowserWindow(&#123; width: 650, height: 990, resizable: false, webPreferences: &#123; nodeIntegration: true &#125; &#125;) resizable: false是重点。 效果 首页 限时测速 倒计时 听音测速 色变测速 成绩 再加个排行榜？ 软件下载 点开文件夹里的exe程序直接运行即可。（也许哪天想给它加个安装程序也未可知…） 链接：https://pan.baidu.com/s/1MfuyH7QAHjZT311888t4Og 提取码：vbz9 代码 https://github.com/hubojing/APMShow 后语 纯属娱乐~~ 听说最近韩商言要分手，要不佟年看看可怜的吴白吧…… 表情包","raw":null,"content":null,"categories":[{"name":"软件开发","slug":"软件开发","permalink":"https://hubojing.github.io/categories/软件开发/"}],"tags":[{"name":"Electron","slug":"Electron","permalink":"https://hubojing.github.io/tags/Electron/"}]},{"title":"推荐那些事儿","slug":"LBSN","date":"2019-07-17T06:35:46.000Z","updated":"2019-12-27T13:34:20.023Z","comments":true,"path":"2019/07/17/LBSN/","link":"","permalink":"https://hubojing.github.io/2019/07/17/LBSN/","excerpt":"　　记得比较乱，自用。 ","text":"记得比较乱，自用。 POI推荐——2019.11.10兴趣点预测是预测用户将要访问的兴趣点(其中包含已经访问过的兴趣点) ，兴趣点推荐是将用户没有访问过的兴趣点推荐给用户。including next POI recommendation, timeaware POI recommendation and out-of-town POI recommendation. Matrix Factorization (MF), Context Embedding (CE) and Pairwise Ranking (PR)MF based methods such as GeoMF and RankGeoFM exhibit superior performance on POI recommendation. 根据check-in行为加入了社交因素（又可分为朋友、评论、图片）、地理因素（空间聚类现象而导致的地理影响、幂律分布、核密度估计）朋友：社交关系中的朋友，位置上的朋友和邻居层面的朋友、用户信任关系时序 位置变化的序列性 马尔科夫链(Markov chain)个性化马尔科夫链(Factorizing Personalized Markov Chain, FPMC)张量分解(Tensor Factorization, TF)RNN(Recurrent Neural Networks长短时记忆循环神经网络(Long-Short Memory recurrent neural networks, LSTM)经典推荐算法：概率矩阵分解模型（Probabilistic Matrix Factorization, PMF）SoRec(Social Recommendation using probabilistic matrix factorization)TrustMF(Social Collaborative Filtering by Trust)TrustSVD(Social Collaborative Filtering by Trust with SVD) PMF 利用用户对 POI 的历史评分数据；SoＲec 利用用户社交关系和兴趣点的历史评分数据；Trust MF、Trust SVD 利用用户信任关系和 POI 的历史评分数据。POI-LSTM模型（[1] 王立, 张谧. 基于LSTM的POI个性化推荐框架[J]. 计算机系统应用, 2018,27(12):56-61.）单纯的 LSTM 模型只能对用户的行为序列进行建模, 将用户访问过的地点信息输入到网络中, 只能捕捉到用户的访问地点兴趣信息, 不加入用户的历史评论信息就不能精细描述用户的兴趣变化, 同时也不能接受用户好友关系对于用户选择的影响. 狄利克雷分配(LatentDirichlet Allocation，LDA)主题模型 LBSN基于位置的社交网络——2019.07.21签到(check-in)：用户上传自身位置到社交网站的行为。每一个签到的位置称为一个兴趣点POI(Point of Interest)。 对签到信息聚类，对用户历史轨迹进行机器学习，可预测用户未来的轨迹路线。传统研究模型采用k-means或k-medoids聚类方法将数据划分为k个簇集，通过计算对象之间的相似度进行聚类。 传统在线社交网络(OSN, Online Social Network)。LBS(Location Based Service),基于位置的服务。LBSN(Location-based Social Network)，基于位置的社会网络。对于不同的LBSN网络，不同的推荐系统使用了不同的推荐算法，常见的推荐算法包括：协同过滤算法、基于内容的推荐算法、基于位置的推荐算法等。 协同过滤算法(collaborative filtering, CF)基于Memory-based(基于记忆)/基于Content-based基于内容/基于邻域又可分为Item-based推荐算法和User-based推荐算法，计算用户和用户之间的相似度(User-based)，商品和商品之间的相似度(Item-based)Item-based推荐算法 输入item-user矩阵 求item-item相似度 （不同相似度度量：person系数、曼哈顿距离、余弦值、欧几里得距离） 根据相似度求评分 User-based推荐算法 输入item-user矩阵 求user-user相似度（不同相似度度量：person系数、曼哈顿距离、余弦值、欧几里得距离） 根据相似度求评分 基于Model-based(基于模型)分解模型算法：如奇异值分解(Singular Value Decomposition)模型算法基于矩阵分解的协同过滤算法（简称矩阵分解推荐方法）矩阵分解(Matrix Factorization, MF)算法：它将用户–兴趣点矩阵分解成两个或者多个低维矩阵的乘积实现维数的规约, 用低维空间数据研究高维数据的性质,主要包括正则矩阵分解、非负矩阵分解和概率矩阵分解等方法。该方法仅仅利用评分信息，将用户对物品的评分信息用矩阵的形式进行表示; 然后将评分矩阵分解为低维的用户特征矩阵和物品特征矩阵，利用用户与物品的向量内积来表示用户对物品的喜好程度，进而构建出基于矩阵分解的推荐方法。然而，由于评分矩阵的高稀疏和不均匀分布等特点，导致仅仅利用评分信息进行推荐带来的推荐性能低、冷启动等问题。 基于图模型的推荐算法：如贝叶斯网络(Bayesian Network)模型推荐算法决策树(Decision Tree)模型推荐算法图聚类(Graph Clustering)模型推荐算法 CF面临的问题：数据稀疏 基于关联规则的推荐算法 Apriori算法 FPGrowth算法 聚类K-Means等 分类 贝叶斯分类器 逻辑回归 KNN 回归隐语义SVDSVD++TrustSVD(加入社会化信任机制) 神经网络基于混合的推荐算法常用混合思路：加权、特征组合、层叠、变换等 基于位置的推荐算法LBSN用户行为预测基于用户个人的数据只关注用户的历史移动轨迹来预测用户下一个位置。 基于所有用户产生的数据采用概率分布模型的方法预测下一个位置。 基于前两种数据的结合参考资料罗维佳.基于LBSN的个性化推荐技术研究 2016","raw":null,"content":null,"categories":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"https://hubojing.github.io/categories/数据挖掘/"}],"tags":[{"name":"LBSN","slug":"LBSN","permalink":"https://hubojing.github.io/tags/LBSN/"},{"name":"POI","slug":"POI","permalink":"https://hubojing.github.io/tags/POI/"},{"name":"推荐系统","slug":"推荐系统","permalink":"https://hubojing.github.io/tags/推荐系统/"}]},{"title":"微言笔记","slug":"微言笔记","date":"2019-07-14T04:11:34.000Z","updated":"2019-07-14T04:19:04.000Z","comments":true,"path":"2019/07/14/微言笔记/","link":"","permalink":"https://hubojing.github.io/2019/07/14/微言笔记/","excerpt":"　　来自微言板块（自言自语）的临时笔记汇总。 ","text":"来自微言板块（自言自语）的临时笔记汇总。 程序员是软件食物链的最后一环。架构师吃掉需求，设计师吃掉架构，而程序员则消化设计。 问题定义-&gt;需求-&gt;架构-&gt;构建-&gt;系统测试-&gt;将来的改进 一个程序中的设计层次：软件系统-&gt;分解为子系统和包-&gt;分解为包中的类-&gt;分解为类中的数据和子程序-&gt;子程序内部 问题“这个类需要隐藏些什么？”正切中了接口设计的核心。要养成“我该隐藏些什么？”的习惯。 好的抽象：类的接口应该展现一致的抽象层次；要理解类所实现的抽象是什么；提供成对的服务；把不相关的信息转移到其他类中；尽可能让接口可编程，而不是表达语义；谨防在修改时破坏接口的抽象；不要添加与接口抽象不一致的公用成员；同时考虑抽象性和内聚性。 好的封装：尽可能地限制类和成员的可访问性；不要公开暴露成员数据；避免把私用的实现细节放入类的接口中；不要对类的使用者做出任何假设；避免使用友元类；不要因为一个子程序里仅使用公用子程序，就把它归入公开接口；让阅读代码比编写代码更方便；要警惕从语义上破坏封装性；留意过于紧密的耦合关系。 封装：把数据声明为private，不允许外界随意存取，只能通过特定的接口来操作。继承：成员函数有一个隐藏参数，名为this指针。虚函数与多态：如果预期派生类有可能重新定义某一个成员函数，就在基类中把比函数设为virtual。纯虚函数不需定义其实际操作，它的存在只是为了在派生类中被重新定义（在函数声明之后加上“＝0”即可）。虚函数派生下去仍为虚函数，而且可以省略virtual关键词。 static成员变量不属于对象的一部分，而是类的的一部分，所以程序可以在还没有诞生任何对象时处理这种成员变量，但首先必须初始化它。不要把static成员变量的初始化操作安排在类的构造函数中，因为构造函数可能一再被调用，而变量的初值却只应设定一次。也不要把初始化操作安排在头文件中，因为它可能会被载入许多地方，因此也就可能被执行许多次。应该在应用程序文件中，类以外的任何位置设定其初值。例如在main之中，或全局函数中，或任何函数之外。 所谓”Unwinding”：C++按顺序析构，但若发生异常情况(exception)，且程序设计了异常情况处理程序(exception handling)，控制权就会“直接跳”到你所设定的处理程序去。此时堆栈中的C++对象有没有机会被析构，要视编译器而定。若编译器支持unwinding功能，则会在异常情况发生时，将堆栈中的所有对象都析构掉。 C指针：在C语言里，只有当你在赋值语句的参数前面加了星号（*），才能把该参数从子程序中传回去。在内存分配中使用sizeof()确定变量的大小。由于sizeof()是在编译期间计算的，因此不会带来性能上的损失。 p p是指针，p是对象 在Java中，a==b判断的是a和b是否引用了同一个对象，而a.equals(b)判断的是这两个对象是否具有相同的值。一般来说，Java应用程序里应该使用像a.equals(b)这样的表达式，而不要用a==b。 如果一个错误无法重现，这通常会是一个初始化错误，或者是一个同时间有关的问题，或者是悬空指针(dangling-pointer)问题。如果某个求和结果时对时错，很有可能是参与计算的某个变量未能正确地初始化——可能正好在大多数情况它是从0开始。如果这个问题诡异且变幻莫测，并且又在使用指针，那么几乎可以肯定是代码中有未初始化的指针，或者用了所指向的内存区域已经被释放的指针。 windows文件结束符Ctrl+Z，UNIX（包括Mac OS X）是Ctrl+D。 “编辑-编译-调试”（edit-compile-debug）周期 计算机以比特序列存储数据，每个比特非0即1。大多数计算机以2的整数次幂个比特作为块来处理内存，可寻址的最小内存块称为“字节（byte）”，存储的基本单元称为“字（word）”，它通常由几个字节组成。在C++中，一个字节要至少能容纳机器基本字符集中的字符。大多数机器的字节由8比特构成，字则由32或64比特构成，也就是4或8字节。大多数计算机将内存中的每个字节与一个数字（被称为“地址（address）”）关联起来。 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如，8比特大小的unsigned char可以表示0至255区间内的值，如果赋了一个区间以外的值，则实际的结果是该值对256取模后所得的余数。因此，把-1赋给8比特大小的unsigned char所得的结果是255。当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。 如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量。C++是一种静态类型（statically typed）语言，其含义是在编译阶段检查类型。 int i=42;int ＆r＝i;//＆紧随类型名出现，因此是声明的一部分，r是一个引用int p;//紧随类型名出现，因此是声明的一部分，p是一个指针p＝＆i;//＆出现在表达式中，是一个取地址符p＝i;//出现在表达式中，是一个解引用符int ＆r2＝p;//＆是声明的一部分，是一个解引用符在声明语句中，＆和*用于组成复合类型；在表达式中，它们的角色又转变成运算符。 int p1＝nullptr;//等价于int p1＝0;在新标准下，现在的C++程序最好使用nullptr，同时尽量避免使用NULL。 指向指针的引用引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用:int i＝42;int p;//p是一个int型指针int ＆r=p;//r是一个对指针p的引用r=＆i;//r引用了一个指针，因此给r赋值＆i就是令p指向i*r=0;//解引用r得到i，也就是p指向的对象，将i的值改为0 如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。 select SalesPersonID,OrderDate,Max(TotalDue) as MaximumTotalSalesfrom [Sales].[SalesOrderHeader]where SalesPersonID is not null and OrderDate &gt;=’2007/1/1’group by SalesPersonID,OrderDatehaving Max(TotalDue)&gt;150000order by OrderDate desc “A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E.” 建议把较大的数组放在main函数外（局部变量放在堆栈段）。栈溢出不一定是递归调用太多，也可能是局部变量太大。只要总大小超过了允许的范围，就会产生栈溢出。 计算机图形学：结构特征数据–&gt;图像信号计算机视觉：图像信号—&gt;结构特征数据数字图像处理：图像信号—&gt;图像信号 JS中如何输出空格:1.document.write(“ “+”1”+” “+”23”);2.document.write(“”+” 1 2 3 “+””);“white-space:pre;”样式表示”空白会被浏览器保留” JavaScript为HTML赋予行为，通过ECMAScript标准，利用BOM对象来操作浏览器窗口，浏览器导航对象，屏幕分辨率，浏览器历史，cookie等，利用DOM操作HTML（核心）。","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"https://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://hubojing.github.io/tags/笔记/"}]},{"title":"图","slug":"图","date":"2019-06-22T07:12:35.000Z","updated":"2019-06-23T10:44:46.000Z","comments":true,"path":"2019/06/22/图/","link":"","permalink":"https://hubojing.github.io/2019/06/22/图/","excerpt":"　　图、 prim 和 kruskal ","text":"图、 prim 和 kruskal 数据结构笔记目录栈 https://hubojing.github.io/2017/11/14/%E6%A0%88/队列 https://hubojing.github.io/2017/11/12/%E9%98%9F%E5%88%97/线性表 https://hubojing.github.io/2019/06/12/%E7%BA%BF%E6%80%A7%E8%A1%A8/树 https://hubojing.github.io/2017/07/23/%E6%A0%91/ 图的基本操作和遍历Node.h123456789101112#ifndef NODE_H#define NODE_Hclass Node&#123;public: Node(char data = 0); char m_cData; bool m_bIsVisited;&#125;;#endif Node.cpp1234567#include \"Node.h\"Node::Node(char data)&#123; m_cData = data; m_bIsVisited = false;&#125; CMap.h12345678910111213141516171819202122232425262728#include\"Node.h\"#include &lt;vector&gt;using namespace std;class CMap&#123;public: CMap(int capacity); ~CMap(); bool addNode(Node *pNode); void resetNode(); bool setValueToMatrixForDirectedGraph(int row, int col, int val = 1);//为有向图设置邻接矩阵 bool setValueToMatrixForUndirectedGraph(int row, int col, int val = 1);//为无向图设置邻接矩阵 void printMatrix(); void depthFirstTraverse(int nodeIndex);//深度优先遍历 void breadthFirstTraverse(int nodeIndex);//广义优先遍历private: bool getValueFromMatrix(int row, int col, int &amp;val);//从矩阵中获取权值 void breadthFirstTraverseImpl(vector&lt;int&gt; preVec);//广度优先遍历实现函数private: int m_iCapacity;//最多可容纳的顶点数 int m_iNodeCount;//已添加的顶点个数 Node *m_pNodeArray;//存放顶点数组 int *m_pMatrix;//存放邻接矩阵&#125;; CMap.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include \"CMap.h\"#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;CMap::CMap(int capacity)&#123; m_iCapacity = capacity; m_iNodeCount = 0; m_pNodeArray = new Node[m_iCapacity]; m_pMatrix = new int[m_iCapacity * m_iCapacity]; memset(m_pMatrix, 0, m_iCapacity*m_iCapacity * sizeof(int)); // for (int i = 0; i &lt; m_iCapacity*m_iCapacity; ++i) // &#123; // m_pMatrix[i] = 0; // &#125;&#125;CMap::~CMap()&#123; delete[]m_pNodeArray; delete[]m_pMatrix;&#125;bool CMap::addNode(Node *pNode)&#123; if (pNode == NULL) &#123; return false; &#125; m_pNodeArray[m_iNodeCount].m_cData = pNode-&gt;m_cData; m_iNodeCount++; return true;&#125;void CMap::resetNode()&#123; for (int i = 0; i &lt; m_iNodeCount; ++i) &#123; m_pNodeArray[i].m_bIsVisited = false; &#125;&#125;bool CMap::setValueToMatrixForDirectedGraph(int row, int col, int val)&#123; if (row &lt; 0 || row &gt;= m_iCapacity) &#123; return false; &#125; if (col &lt; 0 || col &gt;= m_iCapacity) &#123; return false; &#125; m_pMatrix[row * m_iCapacity + col] = val; return true;&#125;bool CMap::setValueToMatrixForUndirectedGraph(int row, int col, int val)&#123; if (row &lt; 0 || row &gt;= m_iCapacity) &#123; return false; &#125; if (col &lt; 0 || col &gt;= m_iCapacity) &#123; return false; &#125; m_pMatrix[row * m_iCapacity + col] = val; m_pMatrix[col * m_iCapacity + row] = val; return true;&#125;void CMap::printMatrix()&#123; for (int i = 0; i &lt; m_iCapacity; ++i) &#123; for (int j = 0; j &lt; m_iCapacity; ++j) &#123; cout &lt;&lt; m_pMatrix[i * m_iCapacity + j] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125;&#125;bool CMap::getValueFromMatrix(int row, int col, int &amp;val)&#123; if (row &lt; 0 || row &gt;= m_iCapacity) &#123; return false; &#125; if (col &lt; 0 || col &gt;= m_iCapacity) &#123; return false; &#125; val = m_pMatrix[row * m_iCapacity + col]; return true;&#125;void CMap::depthFirstTraverse(int nodeIndex)&#123; int value = 0; cout &lt;&lt; m_pNodeArray[nodeIndex].m_cData &lt;&lt; \" \"; m_pNodeArray[nodeIndex].m_bIsVisited = true; //通过邻接矩阵判断是否与其他顶点相连 for (int i = 0; i &lt; m_iCapacity; ++i) &#123; getValueFromMatrix(nodeIndex, i, value); if (value == 1)//判断有弧连接其他顶点 &#123; //再判断该点是否被访问过 if (m_pNodeArray[i].m_bIsVisited) &#123; continue; &#125; else &#123; depthFirstTraverse(i); &#125; &#125; else &#123; continue; &#125; &#125;&#125;void CMap::breadthFirstTraverse(int nodeIndex)&#123; cout &lt;&lt; m_pNodeArray[nodeIndex].m_cData &lt;&lt; \" \"; m_pNodeArray[nodeIndex].m_bIsVisited = true; vector&lt;int&gt; curVec; curVec.push_back(nodeIndex); breadthFirstTraverseImpl(curVec);&#125;void CMap::breadthFirstTraverseImpl(vector&lt;int&gt; preVec)&#123; int value = 0; vector&lt;int&gt; curVec; for (int i = 0; (int)i &lt; preVec.size(); ++i) &#123; for (int j = 0; j &lt; m_iCapacity; ++j) &#123; getValueFromMatrix(preVec[i], j, value); if (value != 0) &#123; if (m_pNodeArray[j].m_bIsVisited) &#123; continue; &#125; else &#123; cout &lt;&lt; m_pNodeArray[j].m_cData &lt;&lt; \" \"; m_pNodeArray[j].m_bIsVisited = true; curVec.push_back(j); &#125; &#125; &#125; &#125; if (curVec.size() == 0) &#123; return; &#125; else &#123; breadthFirstTraverseImpl(curVec); &#125;&#125; demo.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include \"CMap.h\"using namespace std;/* A / \\ B D / \\ / \\ C - F G - H \\ / E*/int main()&#123; CMap *pMap = new CMap(8); Node *pNodeA = new Node('A'); Node *pNodeB = new Node('B'); Node *pNodeC = new Node('C'); Node *pNodeD = new Node('D'); Node *pNodeE = new Node('E'); Node *pNodeF = new Node('F'); Node *pNodeG = new Node('G'); Node *pNodeH = new Node('H'); pMap-&gt;addNode(pNodeA); pMap-&gt;addNode(pNodeB); pMap-&gt;addNode(pNodeC); pMap-&gt;addNode(pNodeD); pMap-&gt;addNode(pNodeE); pMap-&gt;addNode(pNodeF); pMap-&gt;addNode(pNodeG); pMap-&gt;addNode(pNodeH); pMap-&gt;setValueToMatrixForUndirectedGraph(0, 1); pMap-&gt;setValueToMatrixForUndirectedGraph(0, 3); pMap-&gt;setValueToMatrixForUndirectedGraph(1, 2); pMap-&gt;setValueToMatrixForUndirectedGraph(1, 5); pMap-&gt;setValueToMatrixForUndirectedGraph(3, 6); pMap-&gt;setValueToMatrixForUndirectedGraph(3, 7); pMap-&gt;setValueToMatrixForUndirectedGraph(6, 7); pMap-&gt;setValueToMatrixForUndirectedGraph(2, 4); pMap-&gt;setValueToMatrixForUndirectedGraph(4, 5); pMap-&gt;printMatrix(); cout &lt;&lt; endl; pMap-&gt;depthFirstTraverse(0); cout &lt;&lt; endl; pMap-&gt;resetNode(); pMap-&gt;breadthFirstTraverse(0); cout &lt;&lt; endl; return 0;&#125; 输出：12345678910110 1 0 1 0 0 0 01 0 1 0 0 1 0 00 1 0 0 1 0 0 01 0 0 0 0 0 1 10 0 1 0 0 1 0 00 1 0 0 1 0 0 00 0 0 1 0 0 0 10 0 0 1 0 0 1 0A B C E F D G HA B D C F G H E 最小生成树算法普利姆算法Edge.h123456789101112131415#ifndef EDGE_H#define EDGE_Hclass Edge&#123;public: Edge(int nodeIndexA = 0, int nodeIndexB = 0, int weightValue = 0); int m_iNodeIndexA; int m_iNodeIndexB; int m_iWeightValue; bool m_bSelected;&#125;;#endif Edge.cpp123456789#include \"Edge.h\"Edge::Edge(int nodeIndexA, int nodeIndexB, int weightValue)&#123; m_iNodeIndexA = nodeIndexA; m_iNodeIndexB = nodeIndexB; m_iWeightValue = weightValue; m_bSelected = false;&#125; Node.h123456789101112#ifndef NODE_H#define NODE_Hclass Node&#123;public: Node(char data = 0); char m_cData; bool m_bIsVisited;&#125;;#endif Node.cpp1234567#include \"Node.h\"Node::Node(char data)&#123; m_cData = data; m_bIsVisited = false;&#125; CMap.h123456789101112131415161718192021222324252627282930313233343536#include\"Node.h\"#include \"Edge.h\"#include &lt;vector&gt;using namespace std;class CMap&#123;public: CMap(int capacity); ~CMap(); bool addNode(Node *pNode); void resetNode(); bool setValueToMatrixForDirectedGraph(int row, int col, int val = 1);//为有向图设置邻接矩阵 bool setValueToMatrixForUndirectedGraph(int row, int col, int val = 1);//为无向图设置邻接矩阵 void printMatrix(); void depthFirstTraverse(int nodeIndex);//深度优先遍历 void breadthFirstTraverse(int nodeIndex);//广义优先遍历 void primTree(int nodeIndex);//普里姆生成树private: bool getValueFromMatrix(int row, int col, int &amp;val);//从矩阵中获取权值 void breadthFirstTraverseImpl(vector&lt;int&gt; preVec);//广度优先遍历实现函数 int getMinEdge(vector&lt;Edge&gt; edgeVec);private: int m_iCapacity;//最多可容纳的顶点数 int m_iNodeCount;//已添加的顶点个数 Node *m_pNodeArray;//存放顶点数组 int *m_pMatrix;//存放邻接矩阵 Edge *m_pEdge;&#125;; CMap.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include \"CMap.h\"#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;CMap::CMap(int capacity)&#123; m_iCapacity = capacity; m_iNodeCount = 0; m_pNodeArray = new Node[m_iCapacity]; m_pMatrix = new int[m_iCapacity * m_iCapacity]; memset(m_pMatrix, 0, m_iCapacity*m_iCapacity * sizeof(int)); // for (int i = 0; i &lt; m_iCapacity*m_iCapacity; ++i) // &#123; // m_pMatrix[i] = 0; // &#125; m_pEdge = new Edge[m_iCapacity - 1];&#125;CMap::~CMap()&#123; delete[]m_pNodeArray; delete[]m_pMatrix;&#125;bool CMap::addNode(Node *pNode)&#123; if (pNode == NULL) &#123; return false; &#125; m_pNodeArray[m_iNodeCount].m_cData = pNode-&gt;m_cData; m_iNodeCount++; return true;&#125;void CMap::resetNode()&#123; for (int i = 0; i &lt; m_iNodeCount; ++i) &#123; m_pNodeArray[i].m_bIsVisited = false; &#125;&#125;bool CMap::setValueToMatrixForDirectedGraph(int row, int col, int val)&#123; if (row &lt; 0 || row &gt;= m_iCapacity) &#123; return false; &#125; if (col &lt; 0 || col &gt;= m_iCapacity) &#123; return false; &#125; m_pMatrix[row * m_iCapacity + col] = val; return true;&#125;bool CMap::setValueToMatrixForUndirectedGraph(int row, int col, int val)&#123; if (row &lt; 0 || row &gt;= m_iCapacity) &#123; return false; &#125; if (col &lt; 0 || col &gt;= m_iCapacity) &#123; return false; &#125; m_pMatrix[row * m_iCapacity + col] = val; m_pMatrix[col * m_iCapacity + row] = val; return true;&#125;void CMap::printMatrix()&#123; for (int i = 0; i &lt; m_iCapacity; ++i) &#123; for (int j = 0; j &lt; m_iCapacity; ++j) &#123; cout &lt;&lt; m_pMatrix[i * m_iCapacity + j] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125;&#125;bool CMap::getValueFromMatrix(int row, int col, int &amp;val)&#123; if (row &lt; 0 || row &gt;= m_iCapacity) &#123; return false; &#125; if (col &lt; 0 || col &gt;= m_iCapacity) &#123; return false; &#125; val = m_pMatrix[row * m_iCapacity + col]; return true;&#125;void CMap::depthFirstTraverse(int nodeIndex)&#123; int value = 0; cout &lt;&lt; m_pNodeArray[nodeIndex].m_cData &lt;&lt; \" \"; m_pNodeArray[nodeIndex].m_bIsVisited = true; //通过邻接矩阵判断是否与其他顶点相连 for (int i = 0; i &lt; m_iCapacity; ++i) &#123; getValueFromMatrix(nodeIndex, i, value); if (value == 1)//判断有弧连接其他顶点 &#123; //再判断该点是否被访问过 if (m_pNodeArray[i].m_bIsVisited) &#123; continue; &#125; else &#123; depthFirstTraverse(i); &#125; &#125; else &#123; continue; &#125; &#125;&#125;void CMap::breadthFirstTraverse(int nodeIndex)&#123; cout &lt;&lt; m_pNodeArray[nodeIndex].m_cData &lt;&lt; \" \"; m_pNodeArray[nodeIndex].m_bIsVisited = true; vector&lt;int&gt; curVec; curVec.push_back(nodeIndex); breadthFirstTraverseImpl(curVec);&#125;void CMap::breadthFirstTraverseImpl(vector&lt;int&gt; preVec)&#123; int value = 0; vector&lt;int&gt; curVec; for (int i = 0; (int)i &lt; preVec.size(); ++i) &#123; for (int j = 0; j &lt; m_iCapacity; ++j) &#123; getValueFromMatrix(preVec[i], j, value); if (value != 0) &#123; if (m_pNodeArray[j].m_bIsVisited) &#123; continue; &#125; else &#123; cout &lt;&lt; m_pNodeArray[j].m_cData &lt;&lt; \" \"; m_pNodeArray[j].m_bIsVisited = true; curVec.push_back(j); &#125; &#125; &#125; &#125; if (curVec.size() == 0) &#123; return; &#125; else &#123; breadthFirstTraverseImpl(curVec); &#125;&#125;void CMap::primTree(int nodeIndex)&#123; int value = 0; int edgeCount = 0; vector&lt;int&gt; nodeVec; vector&lt;Edge&gt; edgeVec; cout &lt;&lt; m_pNodeArray[nodeIndex].m_cData &lt;&lt; endl; nodeVec.push_back(nodeIndex); m_pNodeArray[nodeIndex].m_bIsVisited = true; while (edgeCount &lt; m_iCapacity - 1) &#123; int temp = nodeVec.back(); for (int i = 0; i &lt; m_iCapacity; ++i) &#123; getValueFromMatrix(temp, i, value); if (value != 0) &#123; if (m_pNodeArray[i].m_bIsVisited) &#123; continue; &#125; else &#123; Edge edge(temp, i, value); edgeVec.push_back(edge); &#125; &#125; &#125; //从可选边集合中找出最小的边 int edgeIndex = getMinEdge(edgeVec); edgeVec[edgeIndex].m_bSelected = true; cout &lt;&lt; edgeVec[edgeIndex].m_iNodeIndexA &lt;&lt; \"---\" &lt;&lt; edgeVec[edgeIndex].m_iNodeIndexB &lt;&lt; \" \"; cout &lt;&lt; edgeVec[edgeIndex].m_iWeightValue &lt;&lt; endl; m_pEdge[edgeCount] = edgeVec[edgeIndex]; edgeCount++; int nextNodeIndex = edgeVec[edgeIndex].m_iNodeIndexB; nodeVec.push_back(nextNodeIndex); m_pNodeArray[nextNodeIndex].m_bIsVisited = true; cout &lt;&lt; m_pNodeArray[nextNodeIndex].m_cData &lt;&lt; endl; &#125;&#125;int CMap::getMinEdge(vector&lt;Edge&gt; edgeVec)&#123; int minWeight = 0; int edgeIndex = 0; int i = 0; for (; i &lt; edgeVec.size(); ++i) &#123; if (!edgeVec[i].m_bSelected) &#123; minWeight = edgeVec[i].m_iWeightValue; edgeIndex = i; break; &#125; &#125; if (minWeight == 0) &#123; return -1; &#125; for (; i &lt; edgeVec.size(); ++i) &#123; if (edgeVec[i].m_bSelected) &#123; continue; &#125; else &#123; if (minWeight &gt; edgeVec[i].m_iWeightValue) &#123; minWeight = edgeVec[i].m_iWeightValue; edgeIndex = i; &#125; &#125; &#125; return edgeIndex;&#125; demo.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include \"CMap.h\"using namespace std;/* A / \\ B D / \\ / \\ C - F G - H \\ / E*//*算法例子： A / | \\ B - F - E \\ / \\ / C - D 权值： A-B 6 A-E 5 A-F 1 B-C 3 B-F 2 C-F 8 C-D 7 D-F 4 D-E 2 E-F 9*/int main()&#123; CMap *pMap = new CMap(6); Node *pNodeA = new Node('A'); Node *pNodeB = new Node('B'); Node *pNodeC = new Node('C'); Node *pNodeD = new Node('D'); Node *pNodeE = new Node('E'); Node *pNodeF = new Node('F'); pMap-&gt;addNode(pNodeA); pMap-&gt;addNode(pNodeB); pMap-&gt;addNode(pNodeC); pMap-&gt;addNode(pNodeD); pMap-&gt;addNode(pNodeE); pMap-&gt;addNode(pNodeF); pMap-&gt;setValueToMatrixForUndirectedGraph(0, 1, 6); pMap-&gt;setValueToMatrixForUndirectedGraph(0, 4, 5); pMap-&gt;setValueToMatrixForUndirectedGraph(0, 5, 1); pMap-&gt;setValueToMatrixForUndirectedGraph(1, 2, 3); pMap-&gt;setValueToMatrixForUndirectedGraph(1, 5, 2); pMap-&gt;setValueToMatrixForUndirectedGraph(2, 5, 8); pMap-&gt;setValueToMatrixForUndirectedGraph(2, 3, 7); pMap-&gt;setValueToMatrixForUndirectedGraph(3, 5, 4); pMap-&gt;setValueToMatrixForUndirectedGraph(3, 4, 2); pMap-&gt;setValueToMatrixForUndirectedGraph(4, 5, 9); pMap-&gt;primTree(0); return 0;&#125; 输出：1234567891011A0---5 1F5---1 2B1---2 3C5---3 4D3---4 2E 克鲁斯卡尔算法Node.h123456789101112#ifndef NODE_H#define NODE_Hclass Node&#123;public: Node(char data = 0); char m_cData; bool m_bIsVisited;&#125;;#endif Node.cpp1234567#include \"Node.h\"Node::Node(char data)&#123; m_cData = data; m_bIsVisited = false;&#125; Edge.h123456789101112131415#ifndef EDGE_H#define EDGE_Hclass Edge&#123;public: Edge(int nodeIndexA = 0, int nodeIndexB = 0, int weightValue = 0); int m_iNodeIndexA; int m_iNodeIndexB; int m_iWeightValue; bool m_bSelected;&#125;;#endif Edge.cpp123456789#include \"Edge.h\"Edge::Edge(int nodeIndexA, int nodeIndexB, int weightValue)&#123; m_iNodeIndexA = nodeIndexA; m_iNodeIndexB = nodeIndexB; m_iWeightValue = weightValue; m_bSelected = false;&#125; CMap.h12345678910111213141516171819202122232425262728293031323334353637383940#include\"Node.h\"#include \"Edge.h\"#include &lt;vector&gt;using namespace std;class CMap&#123;public: CMap(int capacity); ~CMap(); bool addNode(Node *pNode); void resetNode(); bool setValueToMatrixForDirectedGraph(int row, int col, int val = 1);//为有向图设置邻接矩阵 bool setValueToMatrixForUndirectedGraph(int row, int col, int val = 1);//为无向图设置邻接矩阵 void printMatrix(); void depthFirstTraverse(int nodeIndex);//深度优先遍历 void breadthFirstTraverse(int nodeIndex);//广义优先遍历 void primTree(int nodeIndex); void kruskalTree();private: bool getValueFromMatrix(int row, int col, int &amp;val);//从矩阵中获取权值 void breadthFirstTraverseImpl(vector&lt;int&gt; preVec);//广度优先遍历实现函数 int getMinEdge(vector&lt;Edge&gt; edgeVec);//获取最小边 bool isInSet(vector&lt;int&gt; nodeSet, int target);//判断顶点是否在点集合中 void mergeNodeSet(vector&lt;int&gt; &amp;nodeSetA, vector&lt;int&gt; nodeSetB);//合并两个顶点集合private: int m_iCapacity;//最多可容纳的顶点数 int m_iNodeCount;//已添加的顶点个数 Node *m_pNodeArray;//存放顶点数组 int *m_pMatrix;//存放邻接矩阵 Edge *m_pEdge;&#125;; CMap.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384#include \"CMap.h\"#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;CMap::CMap(int capacity)&#123; m_iCapacity = capacity; m_iNodeCount = 0; m_pNodeArray = new Node[m_iCapacity]; m_pMatrix = new int[m_iCapacity * m_iCapacity]; memset(m_pMatrix, 0, m_iCapacity*m_iCapacity * sizeof(int)); // for (int i = 0; i &lt; m_iCapacity*m_iCapacity; ++i) // &#123; // m_pMatrix[i] = 0; // &#125; m_pEdge = new Edge[m_iCapacity - 1];&#125;CMap::~CMap()&#123; delete[]m_pNodeArray; delete[]m_pMatrix; delete[]m_pEdge;&#125;bool CMap::addNode(Node *pNode)&#123; if (pNode == NULL) &#123; return false; &#125; m_pNodeArray[m_iNodeCount].m_cData = pNode-&gt;m_cData; m_iNodeCount++; return true;&#125;void CMap::resetNode()&#123; for (int i = 0; i &lt; m_iNodeCount; ++i) &#123; m_pNodeArray[i].m_bIsVisited = false; &#125;&#125;bool CMap::setValueToMatrixForDirectedGraph(int row, int col, int val)&#123; if (row &lt; 0 || row &gt;= m_iCapacity) &#123; return false; &#125; if (col &lt; 0 || col &gt;= m_iCapacity) &#123; return false; &#125; m_pMatrix[row * m_iCapacity + col] = val; return true;&#125;bool CMap::setValueToMatrixForUndirectedGraph(int row, int col, int val)&#123; if (row &lt; 0 || row &gt;= m_iCapacity) &#123; return false; &#125; if (col &lt; 0 || col &gt;= m_iCapacity) &#123; return false; &#125; m_pMatrix[row * m_iCapacity + col] = val; m_pMatrix[col * m_iCapacity + row] = val; return true;&#125;void CMap::printMatrix()&#123; for (int i = 0; i &lt; m_iCapacity; ++i) &#123; for (int j = 0; j &lt; m_iCapacity; ++j) &#123; cout &lt;&lt; m_pMatrix[i * m_iCapacity + j] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125;&#125;bool CMap::getValueFromMatrix(int row, int col, int &amp;val)&#123; if (row &lt; 0 || row &gt;= m_iCapacity) &#123; return false; &#125; if (col &lt; 0 || col &gt;= m_iCapacity) &#123; return false; &#125; val = m_pMatrix[row * m_iCapacity + col]; return true;&#125;void CMap::depthFirstTraverse(int nodeIndex)&#123; int value = 0; cout &lt;&lt; m_pNodeArray[nodeIndex].m_cData &lt;&lt; \" \"; m_pNodeArray[nodeIndex].m_bIsVisited = true; //通过邻接矩阵判断是否与其他顶点相连 for (int i = 0; i &lt; m_iCapacity; ++i) &#123; getValueFromMatrix(nodeIndex, i, value); if (value == 1)//判断有弧连接其他顶点 &#123; //再判断该点是否被访问过 if (m_pNodeArray[i].m_bIsVisited) &#123; continue; &#125; else &#123; depthFirstTraverse(i); &#125; &#125; else &#123; continue; &#125; &#125;&#125;void CMap::breadthFirstTraverse(int nodeIndex)&#123; cout &lt;&lt; m_pNodeArray[nodeIndex].m_cData &lt;&lt; \" \"; m_pNodeArray[nodeIndex].m_bIsVisited = true; vector&lt;int&gt; curVec; curVec.push_back(nodeIndex); breadthFirstTraverseImpl(curVec);&#125;void CMap::breadthFirstTraverseImpl(vector&lt;int&gt; preVec)&#123; int value = 0; vector&lt;int&gt; curVec; for (int i = 0; (int)i &lt; preVec.size(); ++i) &#123; for (int j = 0; j &lt; m_iCapacity; ++j) &#123; getValueFromMatrix(preVec[i], j, value); if (value != 0) &#123; if (m_pNodeArray[j].m_bIsVisited) &#123; continue; &#125; else &#123; cout &lt;&lt; m_pNodeArray[j].m_cData &lt;&lt; \" \"; m_pNodeArray[j].m_bIsVisited = true; curVec.push_back(j); &#125; &#125; &#125; &#125; if (curVec.size() == 0) &#123; return; &#125; else &#123; breadthFirstTraverseImpl(curVec); &#125;&#125;void CMap::primTree(int nodeIndex)&#123; int value = 0; int edgeCount = 0; vector&lt;int&gt; nodeVec; vector&lt;Edge&gt; edgeVec; cout &lt;&lt; m_pNodeArray[nodeIndex].m_cData &lt;&lt; endl; nodeVec.push_back(nodeIndex); m_pNodeArray[nodeIndex].m_bIsVisited = true; while (edgeCount &lt; m_iCapacity - 1) &#123; int temp = nodeVec.back(); for (int i = 0; i &lt; m_iCapacity; ++i) &#123; getValueFromMatrix(temp, i, value); if (value != 0) &#123; if (m_pNodeArray[i].m_bIsVisited) &#123; continue; &#125; else &#123; Edge edge(temp, i, value); edgeVec.push_back(edge); &#125; &#125; &#125; //从可选边集合中找出最小的边 int edgeIndex = getMinEdge(edgeVec); edgeVec[edgeIndex].m_bSelected = true; cout &lt;&lt; edgeVec[edgeIndex].m_iNodeIndexA &lt;&lt; \"---\" &lt;&lt; edgeVec[edgeIndex].m_iNodeIndexB &lt;&lt; \" \"; cout &lt;&lt; edgeVec[edgeIndex].m_iWeightValue &lt;&lt; endl; m_pEdge[edgeCount] = edgeVec[edgeIndex]; edgeCount++; int nextNodeIndex = edgeVec[edgeIndex].m_iNodeIndexB; nodeVec.push_back(nextNodeIndex); m_pNodeArray[nextNodeIndex].m_bIsVisited = true; cout &lt;&lt; m_pNodeArray[nextNodeIndex].m_cData &lt;&lt; endl; &#125;&#125;int CMap::getMinEdge(vector&lt;Edge&gt; edgeVec)&#123; int minWeight = 0; int edgeIndex = 0; int i = 0; for (; i &lt; edgeVec.size(); ++i) &#123; if (!edgeVec[i].m_bSelected) &#123; minWeight = edgeVec[i].m_iWeightValue; edgeIndex = i; break; &#125; &#125; if (minWeight == 0) &#123; return -1; &#125; for (; i &lt; edgeVec.size(); ++i) &#123; if (edgeVec[i].m_bSelected) &#123; continue; &#125; else &#123; if (minWeight &gt; edgeVec[i].m_iWeightValue) &#123; minWeight = edgeVec[i].m_iWeightValue; edgeIndex = i; &#125; &#125; &#125; return edgeIndex;&#125;void CMap::kruskalTree()&#123; int value = 0; int edgeCount = 0; //定义存放结点集合的数组 vector&lt;vector&lt;int&gt;&gt; nodeSets; //第一步：取出所有边 vector&lt;Edge&gt; edgeVec; for (int i = 0; i &lt; m_iCapacity; ++i) &#123; for (int j = i + 1; j &lt; m_iCapacity; ++j) &#123; getValueFromMatrix(i, j, value); if (value != 0) &#123; Edge edge(i, j, value); edgeVec.push_back(edge); &#125; &#125; &#125; //1.找到算法结束条件 while (edgeCount &lt; m_iCapacity - 1) &#123; //2.从边集合中找到最小边 int minEdgeIndex = getMinEdge(edgeVec); edgeVec[minEdgeIndex].m_bSelected = true; //3.找出最小边连接的点 int nodeAIndex = edgeVec[minEdgeIndex].m_iNodeIndexA; int nodeBIndex = edgeVec[minEdgeIndex].m_iNodeIndexB; bool nodeAIsInSet = false; bool nodeBIsInSet = false; int nodeAInSetLabel = -1; int nodeBInSetLabel = -1; //4.找出点所在的点集合 for (int i = 0; i &lt; nodeSets.size(); ++i) &#123; nodeAIsInSet = isInSet(nodeSets[i], nodeAIndex); if (nodeAIsInSet) &#123; nodeAIsInSet = i; &#125; &#125; for (int i = 0; i &lt; nodeSets.size(); ++i) &#123; nodeBIsInSet = isInSet(nodeSets[i], nodeBIndex); if (nodeBIsInSet) &#123; nodeBIsInSet = i; &#125; &#125; //5.根据点所在集合的不同做出不同处理 if (nodeAInSetLabel == -1 &amp;&amp; nodeBInSetLabel == -1) &#123; vector&lt;int&gt; vec; vec.push_back(nodeAIndex); vec.push_back(nodeBIndex); nodeSets.push_back(vec); &#125; else if (nodeAInSetLabel == -1 &amp;&amp; nodeBInSetLabel != -1) &#123; nodeSets[nodeBInSetLabel].push_back(nodeAIndex); &#125; else if (nodeAInSetLabel != -1 &amp;&amp; nodeBInSetLabel == -1) &#123; nodeSets[nodeBInSetLabel].push_back(nodeBIndex); &#125; else if (nodeAInSetLabel != -1 &amp;&amp; nodeBInSetLabel != -1 &amp;&amp; nodeAInSetLabel != nodeBInSetLabel) &#123; mergeNodeSet(nodeSets[nodeAInSetLabel], nodeSets[nodeBInSetLabel]); for (int i = 0; i &lt; (int)nodeSets.size() - 1; ++i) &#123; nodeSets[i] = nodeSets[i + 1]; &#125; &#125; else if (nodeAInSetLabel != -1 &amp;&amp; nodeBInSetLabel != -1 &amp;&amp; nodeAInSetLabel == nodeBInSetLabel) &#123; continue; &#125; m_pEdge[edgeCount] = edgeVec[minEdgeIndex]; edgeCount++; cout &lt;&lt; edgeVec[minEdgeIndex].m_iNodeIndexA &lt;&lt; \"---\" &lt;&lt; edgeVec[minEdgeIndex].m_iNodeIndexB &lt;&lt; \" \"; cout &lt;&lt; edgeVec[minEdgeIndex].m_iWeightValue &lt;&lt; endl; &#125;&#125;bool CMap::isInSet(vector&lt;int&gt; nodeSet, int target)&#123; for (int i = 0; i &lt; nodeSet.size(); ++i) &#123; if (nodeSet[i] == target) &#123; return true; &#125; &#125; return false;&#125;void CMap::mergeNodeSet(vector&lt;int&gt; &amp;nodeSetA, vector&lt;int&gt; nodeSetB)&#123; for (int i = 0; i &lt; nodeSetB.size(); ++i) &#123; nodeSetA.push_back(nodeSetB[i]); &#125;&#125; demo.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include \"CMap.h\"using namespace std;/* A / \\ B D / \\ / \\ C - F G - H \\ / E*//*算法例子： A / | \\ B - F - E \\ / \\ / C - D 权值： A-B 6 A-E 5 A-F 1 B-C 3 B-F 2 C-F 8 C-D 7 D-F 4 D-E 2 E-F 9*/int main()&#123; CMap *pMap = new CMap(6); Node *pNodeA = new Node('A'); Node *pNodeB = new Node('B'); Node *pNodeC = new Node('C'); Node *pNodeD = new Node('D'); Node *pNodeE = new Node('E'); Node *pNodeF = new Node('F'); pMap-&gt;addNode(pNodeA); pMap-&gt;addNode(pNodeB); pMap-&gt;addNode(pNodeC); pMap-&gt;addNode(pNodeD); pMap-&gt;addNode(pNodeE); pMap-&gt;addNode(pNodeF); pMap-&gt;setValueToMatrixForUndirectedGraph(0, 1, 6); pMap-&gt;setValueToMatrixForUndirectedGraph(0, 4, 5); pMap-&gt;setValueToMatrixForUndirectedGraph(0, 5, 1); pMap-&gt;setValueToMatrixForUndirectedGraph(1, 2, 3); pMap-&gt;setValueToMatrixForUndirectedGraph(1, 5, 2); pMap-&gt;setValueToMatrixForUndirectedGraph(2, 5, 8); pMap-&gt;setValueToMatrixForUndirectedGraph(2, 3, 7); pMap-&gt;setValueToMatrixForUndirectedGraph(3, 5, 4); pMap-&gt;setValueToMatrixForUndirectedGraph(3, 4, 2); pMap-&gt;setValueToMatrixForUndirectedGraph(4, 5, 9); // pMap-&gt;primTree(0); pMap-&gt;kruskalTree(); return 0;&#125; 输出：123450---5 11---5 23---4 21---2 33---5 4","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hubojing.github.io/categories/编程语言/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"},{"name":"数据结构","slug":"数据结构","permalink":"https://hubojing.github.io/tags/数据结构/"}]},{"title":"线性表","slug":"线性表","date":"2019-06-12T04:17:40.000Z","updated":"2019-06-19T09:20:59.000Z","comments":true,"path":"2019/06/12/线性表/","link":"","permalink":"https://hubojing.github.io/2019/06/12/线性表/","excerpt":"　　线性表（顺序表和链式表）。　　补之前的系列 ","text":"线性表（顺序表和链式表）。 补之前的系列 数据结构系列栈 https://hubojing.github.io/2017/11/14/%E6%A0%88/队列 https://hubojing.github.io/2017/11/12/%E9%98%9F%E5%88%97/树 https://hubojing.github.io/2017/07/23/%E6%A0%91/ 顺序表List.h12345678910111213141516171819202122232425262728#ifndef LIST_H#define LIST_H#include \"Coordinate.h\"class List&#123;public: List(int size); ~List(); void ClearList(); bool ListEmpty(); int ListLength(); bool GetElem(int i, Coordinate *e); int LocateElem(Coordinate *e); bool PriorElem(Coordinate *currentElem, Coordinate *preElem); bool NextElem(Coordinate *currentElem, Coordinate *nextElem); void ListTraverse(); bool ListInsert(int i, Coordinate *e); bool ListDelete(int i, Coordinate *e);private: Coordinate *m_pList; int m_iSize; int m_iLength;&#125;;#endif List.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135//线性表--顺序表#include \"List.h\"#include &lt;iostream&gt;using namespace std;List::List(int size)&#123; m_iSize = size; m_pList = new Coordinate[m_iSize]; m_iLength = 0;&#125;List::~List()&#123; delete[]m_pList; m_pList = NULL;&#125;void List::ClearList()&#123; m_iLength = 0;&#125;bool List::ListEmpty()&#123; if (m_iLength == 0) &#123; return true; &#125; else &#123; return false; &#125;&#125;int List::ListLength()&#123; return m_iLength;&#125;bool List::GetElem(int i, Coordinate *e)&#123; if (i &lt; 0 || i &gt;= m_iSize) &#123; return false; &#125; *e = m_pList[i]; return true;&#125;int List::LocateElem(Coordinate *e)&#123; for (int i = 0; i &lt; m_iLength; ++i) &#123; if (m_pList[i] == *e) &#123; return i; &#125; &#125; return -1;&#125;bool List::PriorElem(Coordinate *currentElem, Coordinate *preElem)&#123; int temp = LocateElem(currentElem); if (temp == -1 || temp == 0) &#123; return false; &#125; else &#123; *preElem = m_pList[temp - 1]; &#125;&#125;bool List::NextElem(Coordinate *currentElem, Coordinate *nextElem)&#123; int temp = LocateElem(currentElem); if (temp == -1 || temp == m_iLength - 1) &#123; return false; &#125; else &#123; *nextElem = m_pList[temp + 1]; return true; &#125;&#125;void List::ListTraverse()&#123; for (int i = 0; i &lt; m_iLength; ++i) &#123; cout &lt;&lt; m_pList[i] &lt;&lt; endl; // m_pList[i].printCoordinate(); &#125;&#125;bool List::ListInsert(int i, Coordinate *e)&#123; if (i&lt;0 || i&gt;m_iLength) &#123; return false; &#125; for (int k = m_iLength - 1; k &gt;= i; --k) &#123; m_pList[k + 1] = m_pList[k]; &#125; m_pList[i] = *e; m_iLength++; return true;&#125;bool List::ListDelete(int i, Coordinate *e)&#123; if (i &lt; 0 || i &gt;= m_iLength) &#123; return false; &#125; *e = m_pList[i]; for (int k = i + 1; k &lt; m_iLength; ++k) &#123; m_pList[k - 1] = m_pList[k]; &#125; m_iLength--; return true;&#125; Coordinate.h123456789101112131415161718192021#ifndef COORDINATE_H#define COORDINATE_H#include &lt;ostream&gt;using namespace std;class Coordinate&#123; friend ostream &amp;operator&lt;&lt;(ostream &amp;out, Coordinate &amp;coor);public: Coordinate(int x = 0, int y = 0); void printCoordinate(); bool operator==(Coordinate &amp;coor);private: int m_iX; int m_iY;&#125;;#endif Coordinate.cpp1234567891011121314151617181920212223242526272829#include \"Coordinate.h\"#include &lt;iostream&gt;using namespace std;Coordinate::Coordinate(int x, int y)&#123; m_iX = x; m_iY = y;&#125;void Coordinate::printCoordinate()&#123; cout &lt;&lt; \"(\" &lt;&lt; m_iX &lt;&lt; \",\" &lt;&lt; m_iY &lt;&lt; \")\" &lt;&lt; endl;&#125;ostream &amp;operator&lt;&lt;(ostream &amp;out, Coordinate &amp;coor)&#123; out &lt;&lt; \"(\" &lt;&lt; coor.m_iX &lt;&lt; \",\" &lt;&lt; coor.m_iY &lt;&lt; \")\" &lt;&lt; endl; return out;&#125;bool Coordinate::operator==(Coordinate &amp;coor)&#123; if (this-&gt;m_iX == coor.m_iX &amp;&amp; this-&gt;m_iY == coor.m_iY) &#123; return true; &#125; return false;&#125; demo.cpp1234567891011121314151617181920#include &lt;stdio.h&gt;#include \"List.h\"int main()&#123; Coordinate e1(1, 2); Coordinate e2(3, 4); Coordinate e3(5, 6); List *list = new List(10); list-&gt;ListInsert(0, &amp;e1); list-&gt;ListInsert(1, &amp;e2); list-&gt;ListInsert(2, &amp;e3); list-&gt;ListTraverse(); printf(\"长度：%d\\n\", list-&gt;ListLength()); return 0;&#125; 运行结果：1234567(1,2)(3,4)(5,6)长度：3 链式表Node.h123456789101112#ifndef NODE_H#define NODE_Hclass Node&#123;public: int data; Node *next; void printNode();&#125;;#endif Node.cpp12345678#include \"Node.h\"#include &lt;iostream&gt;using namespace std;void Node::printNode()&#123; cout &lt;&lt; data &lt;&lt; endl;&#125; List.h1234567891011121314151617181920212223242526272829#ifndef LIST_H#define LIST_H#include\"Node.h\"class List&#123;public: List(); ~List(); void ClearList(); bool ListEmpty(); int ListLength(); bool GetElem(int i, Node *pNode); int LocateElem(Node *pNode); bool PriorElem(Node *pCurrentNode, Node *pPreNode); bool NextElem(Node *pCurrentNode, Node *pNextNode); void ListTraverse(); bool ListInsert(int i, Node *pNode); bool ListDelete(int i, Node *pNode); bool ListInsertHead(Node *pNode); bool ListInsertTail(Node *pNode);private: Node *m_pList; int m_iLength;&#125;;#endif List.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212//线性表--顺序表#include \"List.h\"#include &lt;iostream&gt;using namespace std;List::List()&#123; m_pList = new Node; m_pList-&gt;data = 0; m_pList-&gt;next = NULL; m_iLength = 0;&#125;List::~List()&#123; ClearList(); delete m_pList; m_pList = NULL;&#125;bool List::ListInsertHead(Node *pNode)&#123; Node *newNode = new Node; if (newNode == NULL) &#123; return false; &#125; newNode-&gt;data = pNode-&gt;data; newNode-&gt;next = m_pList-&gt;next; m_pList-&gt;next = newNode; m_iLength++; return true;&#125;bool List::ListInsertTail(Node *pNode)&#123; Node *currentNode = m_pList; while (currentNode-&gt;next != NULL) &#123; currentNode = currentNode-&gt;next; &#125; Node *newNode = new Node; if (newNode == NULL) &#123; return false; &#125; newNode-&gt;data = pNode-&gt;data; newNode-&gt;next = NULL; currentNode-&gt;next = newNode; m_iLength++; return true;&#125;bool List::ListInsert(int i, Node* pNode)&#123; if (i&lt;0 || i&gt;m_iLength) &#123; return false; &#125; Node *currentNode = m_pList; for (int k = 0; k &lt; i; ++k) &#123; currentNode = currentNode-&gt;next; &#125; Node *newNode = new Node; if (newNode == NULL) &#123; return false; &#125; newNode-&gt;data = pNode-&gt;data; newNode-&gt;next = currentNode-&gt;next; currentNode-&gt;next = newNode; return true;&#125;bool List::ListDelete(int i, Node *pNode)&#123; if (i &lt; 0 || i &gt;= m_iLength) &#123; return false; &#125; Node *currentNode = m_pList; Node *currentNodeBefore = NULL; for (int k = 0; k &lt;= i; ++k) &#123; currentNodeBefore = currentNode; currentNode = currentNode-&gt;next; &#125; currentNodeBefore-&gt;next = currentNode-&gt;next; pNode-&gt;data = currentNode-&gt;data; delete currentNode; currentNode = NULL; m_iLength--; return true;&#125;void List::ClearList()&#123; Node *currentNode = m_pList-&gt;next; while (currentNode != NULL) &#123; Node *temp = currentNode-&gt;next; delete currentNode; currentNode = temp; &#125; m_pList-&gt;next = NULL; m_iLength = 0;&#125;bool List::ListEmpty()&#123; if (m_iLength == 0) &#123; return true; &#125; else &#123; return false; &#125;&#125;int List::ListLength()&#123; return m_iLength;&#125;bool List::GetElem(int i, Node *pNode)&#123; if (i &lt; 0 || i &gt;= m_iLength) &#123; return false; &#125; Node *currentNode = m_pList; Node *currentNodeBefore = NULL; for (int k = 0; k &lt;= i; ++k) &#123; currentNodeBefore = currentNode; currentNode = currentNode-&gt;next; &#125; pNode-&gt;data = currentNode-&gt;data; return true;&#125;int List::LocateElem(Node *pNode)&#123; Node *currentNode = m_pList; int count = 0; while (currentNode-&gt;next != NULL) &#123; currentNode = currentNode-&gt;next; if (currentNode-&gt;data == pNode-&gt;data) &#123; return count; &#125; count++; &#125; return -1;&#125;bool List::PriorElem(Node *pCurrentNode, Node *pPreNode)&#123; Node *currentNode = m_pList; Node *tempNode = NULL; while (currentNode-&gt;next != NULL) &#123; tempNode = currentNode; currentNode = currentNode-&gt;next; if (currentNode-&gt;data == pCurrentNode-&gt;data) &#123; if (tempNode == m_pList) &#123; return false; &#125; pPreNode-&gt;data = tempNode-&gt;data; return true; &#125; &#125; return false;&#125;bool List::NextElem(Node *pCurrentNode, Node *pNextNode)&#123; Node *currentNode = m_pList; while (currentNode-&gt;next != NULL) &#123; currentNode = currentNode-&gt;next; if (currentNode-&gt;data == pCurrentNode-&gt;data) &#123; if (currentNode-&gt;next == NULL) &#123; return false; &#125; pNextNode-&gt;data = currentNode-&gt;next-&gt;data; return true; &#125; &#125; return false;&#125;void List::ListTraverse()&#123; Node *currentNode = m_pList; while (currentNode-&gt;next != NULL) &#123; currentNode = currentNode-&gt;next; currentNode-&gt;printNode(); &#125;&#125; demo.cpp123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include \"List.h\"#include &lt;iostream&gt;using namespace std;int main()&#123; List *pList = new List(); Node node1; node1.data = 1; Node node2; node2.data = 2; Node node3; node3.data = 3; Node node4; node4.data = 4; Node node5; node5.data = 5; // pList-&gt;ListInsertHead(&amp;node1); // pList-&gt;ListInsertHead(&amp;node2); // pList-&gt;ListInsertHead(&amp;node3); // pList-&gt;ListInsertHead(&amp;node4); pList-&gt;ListInsertTail(&amp;node1); pList-&gt;ListInsertTail(&amp;node2); pList-&gt;ListInsertTail(&amp;node3); pList-&gt;ListInsertTail(&amp;node4); pList-&gt;ListInsert(1, &amp;node5); // Node temp; // pList-&gt;ListDelete(1, &amp;temp); // cout &lt;&lt; \"temp = \" &lt;&lt; temp.data &lt;&lt; endl; pList-&gt;ListTraverse(); delete pList; pList = NULL; return 0;&#125; 链表应用之通讯录Person.h123456789101112131415161718#ifndef PERSON_H#define PERSON_H#include &lt;string&gt;#include &lt;ostream&gt;using namespace std;class Person&#123; friend ostream &amp;operator&lt;&lt;(ostream &amp;out, Person &amp;person);public: string name; string phone; Person &amp;operator=(Person &amp;person); bool operator==(Person &amp;person);&#125;;#endif Person.cpp1234567891011121314151617181920212223#include \"Person.h\"ostream &amp;operator&lt;&lt;(ostream &amp;out, Person &amp;person)&#123; out &lt;&lt; person.name &lt;&lt; \"----\" &lt;&lt; person.phone &lt;&lt; endl; return out;&#125;Person &amp;Person::operator=(Person &amp;person)&#123; this-&gt;name = person.name; this-&gt;phone = person.phone; return *this;&#125;bool Person::operator==(Person &amp;person)&#123; if (this-&gt;name == person.name &amp;&amp; this-&gt;phone==person.phone) &#123; return true; &#125; return false;&#125; Node.h1234567891011121314#ifndef NODE_H#define NODE_H#include \"Person.h\"class Node&#123;public: Person data; Node *next; void printNode();&#125;;#endif Node.cpp12345678#include \"Node.h\"#include &lt;iostream&gt;using namespace std;void Node::printNode()&#123; cout &lt;&lt; data &lt;&lt; endl;&#125; List.h1234567891011121314151617181920212223242526272829#ifndef LIST_H#define LIST_H#include\"Node.h\"class List&#123;public: List(); ~List(); void ClearList(); bool ListEmpty(); int ListLength(); bool GetElem(int i, Node *pNode); int LocateElem(Node *pNode); bool PriorElem(Node *pCurrentNode, Node *pPreNode); bool NextElem(Node *pCurrentNode, Node *pNextNode); void ListTraverse(); bool ListInsert(int i, Node *pNode); bool ListDelete(int i, Node *pNode); bool ListInsertHead(Node *pNode); bool ListInsertTail(Node *pNode);private: Node *m_pList; int m_iLength;&#125;;#endif List.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212//线性表--顺序表#include \"List.h\"#include &lt;iostream&gt;using namespace std;List::List()&#123; m_pList = new Node;// m_pList-&gt;data = 0; m_pList-&gt;next = NULL; m_iLength = 0;&#125;List::~List()&#123; ClearList(); delete m_pList; m_pList = NULL;&#125;bool List::ListInsertHead(Node *pNode)&#123; Node *newNode = new Node; if (newNode == NULL) &#123; return false; &#125; newNode-&gt;data = pNode-&gt;data; newNode-&gt;next = m_pList-&gt;next; m_pList-&gt;next = newNode; m_iLength++; return true;&#125;bool List::ListInsertTail(Node *pNode)&#123; Node *currentNode = m_pList; while (currentNode-&gt;next != NULL) &#123; currentNode = currentNode-&gt;next; &#125; Node *newNode = new Node; if (newNode == NULL) &#123; return false; &#125; newNode-&gt;data = pNode-&gt;data; newNode-&gt;next = NULL; currentNode-&gt;next = newNode; m_iLength++; return true;&#125;bool List::ListInsert(int i, Node* pNode)&#123; if (i&lt;0 || i&gt;m_iLength) &#123; return false; &#125; Node *currentNode = m_pList; for (int k = 0; k &lt; i; ++k) &#123; currentNode = currentNode-&gt;next; &#125; Node *newNode = new Node; if (newNode == NULL) &#123; return false; &#125; newNode-&gt;data = pNode-&gt;data; newNode-&gt;next = currentNode-&gt;next; currentNode-&gt;next = newNode; return true;&#125;bool List::ListDelete(int i, Node *pNode)&#123; if (i &lt; 0 || i &gt;= m_iLength) &#123; return false; &#125; Node *currentNode = m_pList; Node *currentNodeBefore = NULL; for (int k = 0; k &lt;= i; ++k) &#123; currentNodeBefore = currentNode; currentNode = currentNode-&gt;next; &#125; currentNodeBefore-&gt;next = currentNode-&gt;next; pNode-&gt;data = currentNode-&gt;data; delete currentNode; currentNode = NULL; m_iLength--; return true;&#125;void List::ClearList()&#123; Node *currentNode = m_pList-&gt;next; while (currentNode != NULL) &#123; Node *temp = currentNode-&gt;next; delete currentNode; currentNode = temp; &#125; m_pList-&gt;next = NULL; m_iLength = 0;&#125;bool List::ListEmpty()&#123; if (m_iLength == 0) &#123; return true; &#125; else &#123; return false; &#125;&#125;int List::ListLength()&#123; return m_iLength;&#125;bool List::GetElem(int i, Node *pNode)&#123; if (i &lt; 0 || i &gt;= m_iLength) &#123; return false; &#125; Node *currentNode = m_pList; Node *currentNodeBefore = NULL; for (int k = 0; k &lt;= i; ++k) &#123; currentNodeBefore = currentNode; currentNode = currentNode-&gt;next; &#125; pNode-&gt;data = currentNode-&gt;data; return true;&#125;int List::LocateElem(Node *pNode)&#123; Node *currentNode = m_pList; int count = 0; while (currentNode-&gt;next != NULL) &#123; currentNode = currentNode-&gt;next; if (currentNode-&gt;data == pNode-&gt;data) &#123; return count; &#125; count++; &#125; return -1;&#125;bool List::PriorElem(Node *pCurrentNode, Node *pPreNode)&#123; Node *currentNode = m_pList; Node *tempNode = NULL; while (currentNode-&gt;next != NULL) &#123; tempNode = currentNode; currentNode = currentNode-&gt;next; if (currentNode-&gt;data == pCurrentNode-&gt;data) &#123; if (tempNode == m_pList) &#123; return false; &#125; pPreNode-&gt;data = tempNode-&gt;data; return true; &#125; &#125; return false;&#125;bool List::NextElem(Node *pCurrentNode, Node *pNextNode)&#123; Node *currentNode = m_pList; while (currentNode-&gt;next != NULL) &#123; currentNode = currentNode-&gt;next; if (currentNode-&gt;data == pCurrentNode-&gt;data) &#123; if (currentNode-&gt;next == NULL) &#123; return false; &#125; pNextNode-&gt;data = currentNode-&gt;next-&gt;data; return true; &#125; &#125; return false;&#125;void List::ListTraverse()&#123; Node *currentNode = m_pList; while (currentNode-&gt;next != NULL) &#123; currentNode = currentNode-&gt;next; currentNode-&gt;printNode(); &#125;&#125; demo.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include \"List.h\"#include &lt;iostream&gt;using namespace std;int menu()&#123; cout &lt;&lt; \"功能菜单\" &lt;&lt; endl; cout &lt;&lt; \"1.新建联系人\" &lt;&lt; endl; cout &lt;&lt; \"2.删除联系人\" &lt;&lt; endl; cout &lt;&lt; \"3.浏览通讯录\" &lt;&lt; endl; cout &lt;&lt; \"4.退出通讯录\" &lt;&lt; endl; cout &lt;&lt; \"请输入：\" &lt;&lt; endl; int order = 0; cin &gt;&gt; order; return order;&#125;void createPerson(List *pList)&#123; Node node; cout &lt;&lt; \"请输入姓名：\" &lt;&lt; endl; cin &gt;&gt; node.data.name; cout &lt;&lt; \"请输入电话：\" &lt;&lt; endl; cin &gt;&gt; node.data.phone; pList-&gt;ListInsertTail(&amp;node);&#125;void deletePerson(List *pList)&#123; Node node; cout &lt;&lt; \"请输入姓名：\" &lt;&lt; endl; cin &gt;&gt; node.data.name; cout &lt;&lt; \"请输入电话：\" &lt;&lt; endl; cin &gt;&gt; node.data.phone; int num = 0; num = pList-&gt;LocateElem(&amp;node); pList-&gt;ListDelete(num, &amp;node);&#125;int main()&#123; List *pList = new List(); int userOrder = 0; while (userOrder != 4) &#123; userOrder = menu(); switch (userOrder) &#123; case 1: cout &lt;&lt; \"用户指令---&gt;新建联系人：\" &lt;&lt; endl; createPerson(pList); break; case 2: cout &lt;&lt; \"用户指令---&gt;删除联系人：\" &lt;&lt; endl; cout &lt;&lt; \"请输入被删除者姓名：\" &lt;&lt; endl; deletePerson(pList); break; case 3: cout &lt;&lt; \"用户指令---&gt;浏览通讯录：\" &lt;&lt; endl; pList-&gt;ListTraverse(); break; case 4: cout &lt;&lt; \"用户指令---&gt;退出通讯录：\" &lt;&lt; endl; break; default: break; &#125; &#125; delete pList; pList = NULL; return 0;&#125;","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hubojing.github.io/categories/编程语言/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"},{"name":"数据结构","slug":"数据结构","permalink":"https://hubojing.github.io/tags/数据结构/"}]},{"title":"浅谈面向接口编程","slug":"浅谈面向接口编程","date":"2019-06-11T08:52:13.000Z","updated":"2019-06-11T14:10:34.000Z","comments":true,"path":"2019/06/11/浅谈面向接口编程/","link":"","permalink":"https://hubojing.github.io/2019/06/11/浅谈面向接口编程/","excerpt":"　　聊一聊面向接口编程。 ","text":"聊一聊面向接口编程。 最近看Go语言的资料，看到interface类型，突然想起来以前面试的时候面试官问过我是否了解C++接口编程。当时对于这个问题，我脑袋里只有类？抽象类？这样模糊的答案。Bug产出者的我好像经常把接口当类和函数在写。现在再看这个问题，包括对面向对象，似乎明白了些。 从王者荣耀说开去 比如玩王者荣耀，里面有各种英雄。比如智商250的鲁班七号，他会跑，攻击。 面向过程的思维就是先定义一个结构体，里面有英雄的静态信息，比如名字、性别等等。“跑”、“攻击”这些动作让它发生，很简单啊，写一个run()和attack()的函数就好了。这时优秀的思维活跃的大佬们想，这个动作是鲁班本身就能发出的啊，不是我外界赋予的，这不够科学。 于是面向对象诞生了。 干脆写一个名为“LubanSeven”的类，把run()和attack()放入类里。 此时对面迎来的敌人是扁鹊。 他也会跑，攻击。于是还有一个名为“BianQue”的类，同样地，有run()和attack()两个方法。 但是，这似乎很浪费代码。除了名字不同，他们的方法一样啊。 优秀的思维活跃的大佬们说，要改。这样吧，鲁班七号是英雄，扁鹊也是英雄。干脆写个英雄的基类吧。鲁班七号类和扁鹊类继承它不就好了嘛! 于是有了英雄类，类里有两个方法run()和attack()。 英雄总归是要推塔的。于是还有一个防御塔类，防御塔也不是省油的灯，你靠近它它也会攻击的。所以里面也有个attack()方法。 同是攻击，但英雄不会承认自己的攻击和防御塔的攻击是一回事。 可是无聊的看客说，管它是什么，反正就是攻击就完事了，对方会掉血。 那……这个攻击能不能放一块说？英雄表示拒绝（我又不是个塔），防御塔也闪光表示不服（我…又不是个人？）。 这时优秀的思维活跃的大佬们又说话了。 得了得了，我给你们写个接口吧。这个接口就叫做攻击，你们都可以用。 甚至，水晶都可以用。 这样一来，好像是更抽象了有没有？ 把不同类别的事物的相同特性摘出来，就是接口。使用者可以忽略细节。就像人会吃，猪也会吃。干脆接口就叫吃，下次有个猫来了，也可以调用。 例子讲完。 总结 C++貌似是没有接口这个狭义的语法概念的，但是我们依然可以写出类似于java里的interface这样的设计概念（使用纯虚函数）。 面向过程编程(Procedure Oriented Programming, POP)对应的是面向对象编程(Object Oriented Programming, OOP)，面向接口编程(Interface Oriented Programming, IOP)对应的是面向实现编程(Realize Oriented Programming, ROP)。 面向过程编程把世界分为数据结构和函数，追求过程一步步实现，面向对象编程把世界分为对象和方法。 面向实现编程和面向接口编程都是基于面向对象编程来谈的。 面向实现编程就是在自身类中实例化该类，直接调用相应方法。耦合度高。 面向接口编程主要是为了将定义和实现分开，提高了代码的解耦度，复用性强，便于扩展，能够更好的维护。 所有的思想本质都是模拟现实。 之前分不清抽象类和接口的区别，但现在觉得抽象类是广义的用法，而其中针对某些特定功能实现的抽象类就可以称之为接口，或者说接口更侧重于定义规则。比如高考学生类、考研学生类它们的抽象类是学生类，而其中一个接口是“考试”。 参考文章https://www.cnblogs.com/moveofgod/archive/2013/05/08/3066325.htmlhttps://blog.csdn.net/u013400743/article/details/51252003https://blog.csdn.net/qq_35923749/article/details/78422977","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"https://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hubojing.github.io/tags/Java/"},{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"}]},{"title":"计算机图形学实验","slug":"计算机图形学实验","date":"2019-05-12T09:25:58.000Z","updated":"2019-05-16T09:33:36.000Z","comments":true,"path":"2019/05/12/计算机图形学实验/","link":"","permalink":"https://hubojing.github.io/2019/05/12/计算机图形学实验/","excerpt":"　　计算机图形学实验笔记　　计算机视觉学累了就看看计算机图形学…反向消化…　　理论看累了就敲敲代码　　说不弃坑，就不弃坑|( ´・∧・｀) ","text":"计算机图形学实验笔记 计算机视觉学累了就看看计算机图形学…反向消化… 理论看累了就敲敲代码 说不弃坑，就不弃坑|( ´・∧・｀) 实验：搭建OpenGL环境 OpenGL版本：3.3 GLFW GLFW是一个OpenGL的C语言库，是对之前固定管线常用的GLUT的一种改进。 官网下载源代码包（推荐），或者下载32位的预编译的二进制版本。 编译glfw3.lib 我下载的最新3.3版，下载后解压。并新建一个build文件夹。 下载CMake，安装Win32版本。 找到bin文件夹下cmake-gui.exe， 填入源代码路径和build文件夹路径： Where is the source code: E:/glfw-3.3 Where to build the binaries: E:/glfw-3.3/build 点击Configure按钮，选择合适的生成器（我选择的是VS2015)。点Finish。 再次点击Configure按钮保存设置。 点击Generate按钮，生成工程文件。 在build文件夹打开GLFW.sln文件，并且生成解决方案。 在E:\\glfw-3.3\\build\\src\\Debug中所需要的glfw3.lib就有了。 配置 方便起见，我专门建立了一个文件夹OpenGLFiles用来存放相关的头文件和库文件。 在文件夹下新建include文件夹和lib文件夹。 将glfw-3.3\\include下的文件复制到新建的include文件夹中，将glfw3.lib复制到新建的lib文件夹中。 新建项目所需工程文件，创建空项目。 打开工程属性页，选择VC++目录-包含目录中加上： E:\\OpenGLFiles\\include 库目录加上： E:\\OpenGLFiles\\lib 链接器-输入，附加依赖项加上： glfw3.lib GLAD 开发者需要在OpenGL运行时获取函数地址并保存在一个函数指针中，取地址方法因平台而异，而GLAD库能简化该过程。 通过GLAD在线服务，language选择C/C++,gl选择3.3，Profile选择Core，Options选中Generate a loader。 点击Generate，下载压缩包。解压后，将include文件夹下的文件复制到我新建的include文件夹里，并且将src下的glad.c添加到工程中。 环境搭好了！ 实验：绘制一个窗口包含头文件12#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt; 初始化GLFW123456glfwInit(); // 初始化GLFWglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); // OpenGL版本为3.3，主次版本号均设为3glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // 使用核心模式(无需向后兼容性)glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // 如果使用的是Mac OS X系统，需加上这行glfwWindowHint(GLFW_RESIZABLE, false); // 不可改变窗口大小 查看GLFW版本123int Major, Minor, Rev;glfwGetVersion(&amp;Major, &amp;Minor, &amp;Rev);printf(\"GLFW %d.%d.%d initialized\\n\", Major, Minor, Rev); 创建窗口12345678GLFWwindow* window = glfwCreateWindow(screen_width, screen_height, \"HelloWorld\", nullptr, nullptr); if (window == nullptr) &#123; // 如果窗口创建失败 std::cout &lt;&lt; \"Failed to Create OpenGL Context\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); // 将窗口的上下文设置为当前线程的主上下文 初始化GLAD加载OpenGL函数指针地址的函数12345if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))&#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1;&#125; 指定视口1glViewport(0, 0, screen_width, screen_height); glViewport函数前两个参数控制窗口左下角的位置，第三、第四个参数控制渲染窗口的宽度和高度（像素）。实际上也可以将视口的维度设置为比GLFW的维度小，这样所有的OpenGL渲染将会在一个更小的窗口中显示，这样我们可以将一些其它元素显示在OpenGL视口之外。 渲染12345while (!glfwWindowShouldClose(window)) &#123; glfwSwapBuffers(window);// 交换缓冲 glfwPollEvents();//检查是否有触发事件(比如键盘输入、鼠标移动等）&#125; 双缓冲：单缓冲使图像闪烁（图像是从左到右，从上到下逐像素绘制），不够真实。使用双缓冲规避该问题，前缓冲保存着最终输出的图像，显示在屏幕上。所有渲染指令在后缓冲上绘制，指令执行完毕后交换(swap)前缓冲和后缓冲，图像会立即呈现。 渲染结束，释放资源：1glfwTerminate(); 运行，此时会看到一个黑色的窗口。 修改窗口颜色在渲染循环中加入：12glClearColor(0.0f, 0.34f, 0.57f, 1.0f);glClear(GL_COLOR_BUFFER_BIT); 当调用 glClear函数，清除颜色缓冲之后，整个颜色缓冲都会被填充为glClearColor里所设置的颜色。 运行效果1GLFW 3.3.0 initialized 绘制窗口 完整代码https://github.com/hubojing/ComputerGraphics/blob/master/CreateWindow.cpp 总结： 初始化：GLFW窗口，GLAD。 渲染：清空缓冲，交换缓冲区检查触发事件后释放资源。 实验：绘制三角形初始化123456789101112131415161718192021222324252627//初始化GLFWglfwInit();glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);glfwWindowHint(GLFW_RESIZABLE, FALSE);//创建窗口auto window = glfwCreateWindow(screen_width, screen_height, \"Triangle\", nullptr, nullptr);if (window == nullptr)&#123; std::cout &lt;&lt; \"Failed to Create OpenGL Context\" &lt;&lt; std::endl; glfwTerminate(); return -1;&#125;glfwMakeContextCurrent(window);//初始化GLADif (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))&#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1;&#125;//指定当前视口尺寸 glViewport(0, 0, screen_width, screen_height); 顶点输入 三角形顶点数据是标准化的设备坐标，即x,y,z轴坐标映射到[-1,1]之间。123456const float triangle[]=&#123; -0.5f,-0.5f,0.0f;//左下 0.5f, -0.5f, 0.0f;//右下 0.0f, 0.5f, 0.0f;//正上&#125;; 数据处理VBO 将顶点数据发送到GPU处理。生成一个顶点缓冲对象VBO，将其绑定到顶点缓冲对象上。 作用：不用将顶点数据逐个发送至显卡，可借助VBO一次性发送过去。 再使用glBufferData将顶点数据绑定到当前默认的缓冲上。123456//生成并绑定VBOGLuint vertex_buffer_object;glGenBuffers(1, &amp;vertex_buffer_object);glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer_object);//将顶点数据绑定到当前默认的缓冲中glBufferData(GL_ARRAY_BUFFER, sizeof(triangle), triangle, GL_STATIC_DRAW); VAO 作用：核心模式需要使用VAO，渲染时只需调用一次VAO即可，之前的数据对应存储在VAO中，不用再调用VBO。123GLuint vertex_array_object;glGenVertexArrays(1, &amp;vertex_array_object);glBindVertexArray(vertex_array_object); 顶点属性 告诉OpenGL如何解释顶点数据。123//设置顶点属性指针glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0); glVertexAttribPointer函数参数含义： 1-顶点着色器位置值 2-顶点属性是一个三分量的向量 3-顶点类型 4-数据是否被标准化（映射到0-1之间） 5-步长（这里表示下组数据在3个float之后） 6-数据偏移量（此处位置属性在数组开头，因此为0） glEnableVertexAttribArray表示开启0这个通道，默认状态是关闭的。 此时需要解绑VAO和VBO。 原因： 1. 防止继续绑定VAO时影响当前VAO。 2. 使代码更具灵活性，在渲染需要时会再次绑定VAO。12glBindVertexArray(0);glBindBuffer(GL_ARRAY_BUFFER, 0); 顶点着色器和片段着色器顶点着色器 GLSL语言，类似C语言。 源码：1234567const char *vertex_shader_source = \"#version 330 core\\n\" \"layout (location = 0) in vec3 aPos;\\n\" \"void main()\\n\" \"&#123;\\n\" \" gl_Position = vec4(aPos, 1.0);\\n\" \"&#125;\\n\\0\"; 第一行：使用OpenGL3.3核心模式 第二行：上面提到的位置值 in表示输入变量 main函数中将顶点数据直接输出到GLSL定义好的内建变量gl_Position中，这是顶点着色器的输出。 （即在顶点着色器这儿上面都没做，只是将顶点位置作为顶点着色器的输出。） 片段着色器 源码：1234567const char *fragment_shader_source = \"#version 330 core\\n\" \"out vec4 FragColor;\\n\" \"void main()\\n\" \"&#123;\\n\" \" FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\\n\" \"&#125;\\n\\0\"; 前两行类似上面，out表示输出变量。四分量是RGBA。 生成和编译 目的是为了得到着色器程序，所以首先生成和编译着色器，再链接到着色器程序中。 生成并编译顶点着色器123456789101112int vertex_shader = glCreateShader(GL_VERTEX_SHADER);glShaderSource(vertex_shader, 1, &amp;vertex_shader_source, NULL);glCompileShader(vertex_shader);int success;char info_log[512];//是否成功编译glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &amp;success);if (!success)&#123; glGetShaderInfoLog(vertex_shader, 512, NULL, info_log); std::cout &lt;&lt; \"ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\" &lt;&lt; info_log &lt;&lt; std::endl;&#125; 生成并编译片段着色器12345678910int fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);glShaderSource(fragment_shader, 1, &amp;fragment_shader_source, NULL);glCompileShader(fragment_shader);//是否成功编译glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &amp;success);if (!success)&#123; glGetShaderInfoLog(fragment_shader, 512, NULL, info_log); std::cout &lt;&lt; \"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n\" &lt;&lt; info_log &lt;&lt; std::endl;&#125; 链接顶点和片段着色器至一个着色器程序，并删除着色器123456789101112131415int shader_program = glCreateProgram();glAttachShader(shader_program, vertex_shader);glAttachShader(shader_program, fragment_shader);glLinkProgram(shader_program);//是否成功链接glGetProgramiv(shader_program, GL_LINK_STATUS, &amp;success);if (!success)&#123; glGetProgramInfoLog(shader_program, 512, NULL, info_log); std::cout &lt;&lt; \"ERROR::SHADER::PROGRAM::LINKING_FAILED\\n\" &lt;&lt; info_log &lt;&lt; std::endl;&#125;//删除着色器glDeleteShader(vertex_shader);glDeleteShader(fragment_shader); 渲染 渲染时只需使用链接好的着色器程序就行，不再需要使用顶点和片段着色器。 窗口未关闭就一直进行渲染。1234while (!glfwWindowShouldClose(window))&#123; //渲染操作&#125; 这里使用蓝色背景色清空屏幕颜色缓冲。12glClearColor(0.0f, 0.34f, 0.57f, 1.0f);glClear(GL_COLOR_BUFFER_BIT); 接下来使用链接好的着色器和VAO来绘制三角形。123456//使用着色器程序glUseProgram(shader_program);//绘制三角形glBindVertexArray(vertex_array_object);glDrawArrays(GL_TRIANGLES, 0, 3);glBindVertexArray(0); 其实绘制本身只是一个glDrawArrays函数，参数1表示三角形，参数2表示顶点数组起始索引值，参数3表示要绘制的顶点数量。 绘制结束后解除绑定。 双缓冲技术：1234//交换缓冲glfwSwapBuffers(window);//检查是否有触发事件（键盘输入、鼠标移动等）glfwPollEvents(); 善后工作123456//删除VAO和VBOglDeleteVertexArrays(1, &amp;vertex_array_object);glDeleteBuffers(1, &amp;vertex_buffer_object);//退出glfwTerminate(); 实验效果 三角形 完整代码https://github.com/hubojing/ComputerGraphics/blob/master/Triangle 总结： 初始化。 数据处理：给定顶点数据，生成并绑定VAO和VBO，准备在GPU处理，设置顶点属性指针（告诉OpenGL怎么处理数据）。 着色器：生成并编译顶点和片段着色器，链接为着色器程序。 渲染绘制三角形。 下一个实验准备中…","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"https://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://hubojing.github.io/tags/计算机图形学/"}]},{"title":"记一回失败的渲染操作","slug":"记一次失败的渲染操作","date":"2019-04-20T14:43:56.000Z","updated":"2019-04-20T14:43:56.000Z","comments":true,"path":"2019/04/20/记一次失败的渲染操作/","link":"","permalink":"https://hubojing.github.io/2019/04/20/记一次失败的渲染操作/","excerpt":"　　离烧CPU就差这一篇文章 ","text":"离烧CPU就差这一篇文章 时间：今晚 地点：诡异的电脑 起因：剪辑视频 结果：写这篇文章 T_T 配置：CPU 锐龙5 1600X 作为一枚初级音视频剪辑玩家，音频处理得多，而上次认真剪视频是一两年前（或者三年？时间过得有点快啊……）的事情了吧…….我几乎忘记了渲染操作，把渲染想得和导出一样简单ε=(´ο｀*)))唉 视频时长只有1分钟！为了严谨行文，我又打开了Vegas确认一下（是00:01:06)。 第一次渲染操作：输出格式：Internet HD 1080P,渲染到一半，电脑关机了？？？ 我的内心： ??? 目光下移，我腿踢机箱了？ 开机，再整一次。又黑了。 我：？？？？？？锐龙1600x怎么这么经不起折腾，之前用y400（i5 3230M）渲染十分钟的视频都毫无问题呢~ 再开机。看一眼CPU温度，55°。隐隐感觉热啊… 再来一次，这次降低要求，720P，720P也可以。把温度监控就放在一边，然后就静静地看着温度往上爬…… 后来换输出格式又测试了几次，几乎都是八十多度，最高直逼90度。那还是关机吧，烧了我的CPU我心疼。就算CPU没烧，烧了主板我也心疼。 看着我只有一分钟的视频，我默默关掉了Vegas，转身打开了年迈的笔记本。 P.S. Vegas12用GPU加速感觉效果..没有效果（不过只尝试了一次） 虽说渲染是会升温吧，可是CPU占有率只有37%，这显然已经没有很好地发挥CPU性能了，温度还如此高，散热出了问题吧。 但我已经不记得装的什么散热器了。只有打开京东查记录—&gt; 安钛克(Antec)战虎A40战斗版 CPU散热器 送导热硅脂硅胶(纯铜4热管/9cm风扇/LED蓝光风扇/电脑主机箱显卡风冷 https://item.jd.com/695774.html 当时看来是没单独买散热器，直接用的买CPU送的散热器，作为一名初级装机玩家留下了悔不当初的眼泪。 这么凉爽的天气还算不够热的天气，我才发现什么都不干的情况下CPU就有47°，早知道就不卸载鲁大师了。 一个一分钟的视频让我又要开箱了…… 还水了一篇文章。 那..看官推荐一个渲染时CPU不会超过80°（70°以下就更好了）的散热器？另外CPU占比提不起来要改善啊…","raw":null,"content":null,"categories":[{"name":"数码","slug":"数码","permalink":"https://hubojing.github.io/categories/数码/"}],"tags":[{"name":"硬件","slug":"硬件","permalink":"https://hubojing.github.io/tags/硬件/"}]},{"title":"小概念杂记","slug":"论文杂记","date":"2019-02-25T12:42:15.000Z","updated":"2019-02-25T12:42:15.000Z","comments":true,"path":"2019/02/25/论文杂记/","link":"","permalink":"https://hubojing.github.io/2019/02/25/论文杂记/","excerpt":"　　零碎记录（自用）。 ","text":"零碎记录（自用）。 分集增益（Diversity Gain）：分集技术是研究如何充分利用传输中的多径信号能量，以改善传输的可靠性，它也是一项研究利用信号的基本参量在时域、频域与空域中，如何分散开又如何收集起来的技术。 Zipf定律：Zipf定律可以表述为在自然语言的语料库里，一个单词出现的次数与它在频率表里的排名成反比。Zipf定律是美国学者G.K.齐普夫1935年提出的。 Zipf分布：用X~Zipf(alpha,n)表示随机变量X具有带参数alpha和n的Zipf分布。带有参数alpha和n的Zipf随机变量X是有概率质量函数在里面。 概率质量函数：在概率论中，概率质量函数 (Probability Mass Function，PMF)是离散随机变量在各特定取值上的概率。概率质量函数和概率密度函数不同之处在于：概率密度函数是对连续随机变量定义的，本身不是概率，只有对连续随机变量的取值进行积分后才是概率。 上面公式的含义为在随机变量X的映射函数下，所有样本空间中的结果在此映射下输出结果为x的概率。 讲人话：所谓的二八原则（20%的用户，会占有80%的访问量）即是Zipf应用。比如，按照单词在语料库中出现的次数排序，该单词的排序数与其在语料库中出现频数成反比，或者说，二者乘积为一个常数。 其公式为：P(r) = C / r^α 这里 r 表示一个单词的出现频率的排名，P(r)表示排名为r的单词的出现频率。单词频率分布中 C约等于0.1, α约等于1。这说明在英语单词中，只有极少部分的词被经常使用，而绝大部分词很少被使用。 SNR （信噪比SIGNAL-NOISE RATIO） 通信中断概率（Outage Probability）","raw":null,"content":null,"categories":[{"name":"通信工程","slug":"通信工程","permalink":"https://hubojing.github.io/categories/通信工程/"}],"tags":[]},{"title":"JingPic——github图床外链小工具","slug":"JingPic——github图床快速复制外链工具","date":"2019-01-27T11:28:55.000Z","updated":"2019-01-27T13:50:16.000Z","comments":true,"path":"2019/01/27/JingPic——github图床快速复制外链工具/","link":"","permalink":"https://hubojing.github.io/2019/01/27/JingPic——github图床快速复制外链工具/","excerpt":"　　针对写markdown文章贴图过程繁琐的问题，写了一个小工具自用。（C++版） ","text":"针对写markdown文章贴图过程繁琐的问题，写了一个小工具自用。（C++版） 源起Markdown写作者都会对贴图的问题进行一番探索。好在现在有很多优秀的图床上传工具（比如PicGo）。那为什么还会自己写一个工具呢？主要是目前的工具不能完全满足我的需求，比如图片上传后，备注需注明是哪篇文章，方便整理。 这个工具是这两天利用闲散时间做成的，未来还会根据自我需要进行更新完善。 一开始是打算用python写的 需求平台：VS2015图床：github开发前理清思路，罗列出需求是必要的。于是我大概列了几点： 有UI界面，不要在控制台操作 采用直接拖入图片到窗口的形式，不要采用选择文件的形式（懒） 自动推送到github对应项目，形成外链 拖入图片时要求输入文章标题即符合备注格式 该文章标题以备注形式出现在github对应项 url链接地址可以一键复制 给小工具起一个名字 原有上传图片的备注格式 备注格式 事实证明最后一条最难 准备工作把github图床项目下载到本地。 设计最开始设计的是网页。后来考虑是网页的话，就要考虑用户独立性，比如设置账户登录，或者能证明是我本人的id什么的。（麻烦，不够快准狠） 整个问题大致分为三个。 拖动图片拖动到窗口，并复制到本地图床文件夹。 git推送一开始打算直接调cmd完成，后来用bat脚本文件包装看起来清爽一点。 如何获取外链最初是准备解析网页的。后来发现url有规律可循：如 https://github.com/hubojing/test/blob/master/%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%B9%8B%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0.png?raw=true每一张图都是https://github.com/hubojing/项目名/blob/master/ 开头 ?raw=true结尾。这就省了解析网页这一步，直接拼url就好了。 界面 整体界面 代码拖动JingPicDlg.h加上1afx_msg void OnDropFiles(HDROP hDropInfo); JingPicDlg.cpp BEGIN_MESSAGE_MAP加上ON_WM_DROPFILES() 1234567891011121314void CJingPicDlg::OnDropFiles(HDROP hDropInfo)&#123; UINT Num; TCHAR filePath[MAX_PATH]; Num = DragQueryFile(hDropInfo, 0xFFFFFFFF, NULL, 0); if (Num &gt; 0) &#123; for (UINT i = 0; i &lt; Num; i++) &#123; DragQueryFile(hDropInfo, i, filePath, sizeof(filePath)); &#125; &#125; DragFinish(hDropInfo); CDialog::OnDropFiles(hDropInfo); 复制到剪贴板1234567891011121314151617BOOL CJingPicDlg::CopyToClipboard(const char* pszData, const int nDataLen)&#123; if (::OpenClipboard(NULL)) &#123; ::EmptyClipboard(); HGLOBAL clipbuffer; char *buffer; clipbuffer = ::GlobalAlloc(GMEM_DDESHARE, nDataLen + 1); buffer = (char *)::GlobalLock(clipbuffer); strcpy(buffer, pszData); ::GlobalUnlock(clipbuffer); ::SetClipboardData(CF_TEXT, clipbuffer); ::CloseClipboard(); return TRUE; &#125; return FALSE;&#125; 调用脚本123char s[MAX_PATH];sprintf_s(s, \"%s %s\", \"E:\\\\AutoUpload.bat\", strNotes);system(s); 脚本123456E:cd E:\\test @rem 此处是本地图床地址git add .git commit -m %1%git pushexit url拼接本来这里应该有UrlEncode一步的，毕竟我所得到的url里有中文字，需要编码后才是真正所需的url。比如我们现在拼接的地址是：https://github.com/hubojing/test/blob/master/动态分配所得的array.png?raw=true应得到：https://github.com/hubojing/test/blob/master/%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E6%89%80%E5%BE%97%E7%9A%84array.png?raw=true 然而我发现在浏览器里输入上面的网址，也能得到正确的图片，大概是github已经处理了该问题。所以我就偷懒了 注意事项 克隆项目到本地最好选择ssh方式下载，可以避免输入用户名密码。第一次推送要用git push -u origin master，加了参数-u后，下次即可直接用git push代替git push origin master。 代码地址JingPic——github图床外链小工具 再没有理由写文章不带图了o(一︿一+)o","raw":null,"content":null,"categories":[{"name":"软件开发","slug":"软件开发","permalink":"https://hubojing.github.io/categories/软件开发/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"},{"name":"MFC","slug":"MFC","permalink":"https://hubojing.github.io/tags/MFC/"}]},{"title":"C++程序设计之兼谈对象模型","slug":"C-程序设计之兼谈对象模型","date":"2019-01-22T03:51:11.000Z","updated":"2019-02-23T13:35:04.000Z","comments":true,"path":"2019/01/22/C-程序设计之兼谈对象模型/","link":"","permalink":"https://hubojing.github.io/2019/01/22/C-程序设计之兼谈对象模型/","excerpt":"　　C++ Programming(part II), and Object Model.　　侯捷　　笔记 ","text":"C++ Programming(part II), and Object Model. 侯捷 笔记 前言应具备的基础 是上一篇博文“面向对象程序设计”的续集 本文将探讨上文未讨论的主题 目标 在先前培养正规、大器的编程素养上，继续探讨更多技术。 泛型编程(Generic Programming)和面向对象编程(Object-Oriented Programming)虽然分属不同思维，但它们正是C++的技术主线。本文也讨论template(模板)。 深入探索面向对象之继承关系(inheritance)所形成的对象模型(Object Model)，包括隐藏于底层的this指针，vptr指针（虚指针），vtbl(虚表)，virtual mechanism（虚机制），以及虚函数(virtual functions)造成的polymorphism（多态）效果。 将获得的代码Test-Cpp.cpp C++编译器 编译(compile) 连接(link) conversion function, 转换函数123456789101112class Fraction&#123;public: Fraction(int num, int den=1):m_numerator(num), m_denominator(den) &#123; &#125; operator double() const &#123; return (double)(m_numerator / m_denominator) &#125;private: int m_numerator;//分子 int m_denominator;//分母&#125;; 使用：12Fraction f(3, 5);double d = 4 + f;//调用operator double()将f转为0.6 non-explicit-one-argument ctor12345678910111213class Fraction&#123;public: Fraction(int num, int den=1):m_numerator(num), m_denominator(den) &#123; &#125; Fraction operator+(const Fraction&amp; f) &#123; return Fraction(......); &#125;private: int m_numerator; int m_denominator;&#125;; 使用：12Fraction f(3, 5);Fraction d2 = f + 4;//调用non-explicit ctor将4转为Fraction(4, 1)，然后调用operator+ conversion function vs. non-explicit-one-argument ctor12345678910111213141516class Fraction&#123;public: Fraction(int num, int den=1):m_numerator(num), m_denominator(den) &#123; &#125; operator double() const &#123; return (double) (m_numerator / m_denominator); &#125; Fraction operator+(const Fraction&amp; f) &#123; return Fraction(......); &#125;private: int m_numerator; int m_denominator;&#125;; 使用：12Fraction f(3, 5);Fraction d2 = f + 4;//[ERROR]ambiguous 二义 explicit-one-argument ctor12345678910111213141516class Fraction&#123;public: explicit Fraction(int num, int den=1):m_numerator(num), m_denominator(den) &#123; &#125; operator double() const &#123; return (double) (m_numerator / m_denominator); &#125; Fraction operator+(const Fraction&amp; f) &#123; return Fraction(......); &#125;private: int m_numerator; int m_denominator;&#125;; 使用：12Fraction f(3, 5);Fraction d2 = f + 4;//[ERROR]conersion from 'double' to 'Fraction' requested conversion function, 转换函数proxy1234567891011template&lt;class Alloc&gt;class vector&lt;bool, Alloc&gt;&#123;public: typedef __bit_reference reference;protected: reference operator[] (size_type n) &#123; return *(begin() + difference_type(n)); &#125;... 12345678struct __bit_reference&#123; unsigned int* p; unsigned int mask; ...public:operator bool() const &#123;return !(!(*p &amp; mask)); &#125;... pointer-like classes, 关于智能指针1234567891011121314151617template&lt;class T&gt;class shared_ptr&#123;public: T&amp; operator*() const &#123;return *px;&#125; T* operator-&gt;() const &#123;return px;&#125; shared_ptr(T* p):px(p) &#123; &#125;private: T* px; long* pn;...&#125;; 使用：12345struct Foo&#123; ... void method(void) &#123;......&#125;&#125;; 12345shared_ptr&lt;Foo&gt; sp(new Foo);Foo f(*sp);sp-&gt;method(); 相当于1px-&gt;method(); pointer-like classes, 关于迭代器1234567891011121314151617template&lt;class T, class Ref, class Ptr&gt;struct __list_iterator&#123; typedef __list_iterator&lt;T, Ref, Ptr&gt; self; typedef Ptr pointer; typedef Ref reference; typedef __list_node&lt;T&gt;* link_type; link_type node; bool operator==(const self&amp; x) const &#123;return node == x.node; &#125; bool operator!=(const self&amp; x) const &#123; return node != x.node; &#125; reference operator*() const &#123; return &#123;*node&#125;.data; &#125; pointer operator-&gt;() const &#123; return &amp;(operator*());&#125; self&amp; operator++() &#123; node = (link_type)((*node).next); return *this;&#125; self operator++(int) &#123; self tmp = *this; ++*this; return tmp;&#125; self&amp; operator--() &#123; node = (link_type)((*node).prev); return *this;&#125; self operator--(int) &#123; self tmp = *this; --*this; return tmp; &#125;&#125;; 使用：1234567list&lt;Foo&gt;::iterator ite;...*ite;//获得一个Foo objectite-&gt;method();//意思是调用Foo::method()//相当于(*ite).method();//相当于(&amp;(*ite))-&gt;method(); funciton-like classes, 所谓仿函数12345678910111213141516171819202122template &lt;class T&gt;struct identity&#123; const T&amp; operator() (const T&amp; x) const &#123; return x; &#125;&#125;;template &lt;class Pair&gt;struct select1st&#123; const typename Pair::first_type&amp; operator() (const Pair&amp; x) const &#123; return x.first; &#125;&#125;;template &lt;class Pair&gt;struct select2nd&#123; const typename Pair::second_type&amp; operator() (const Pair&amp; x) const &#123; return x.second; &#125;&#125;; 123456789template &lt;class T1, class T2&gt;struct pair&#123; T1 first; T2 second; pair() : first(T1()), second(T2()) &#123;&#125; pair(const T1&amp; a, const T2&amp; b): first(a), second(b) &#123;&#125;......&#125;; 标准库中仿仿函数的奇特模样12345678910111213141516171819202122template &lt;class T&gt;struct identity : public unary_function&lt;T, T&gt;&#123; const T&amp; operator() (const T&amp; x) const &#123; return x; &#125;&#125;;template &lt;class Pair&gt;struct select1st : public unary_function&lt;Pair, typename Pair::first_type&gt;&#123; const typename Pair::first_type&amp; operator() (const Pair&amp; x) const &#123; return x.first; &#125;&#125;;template &lt;class Pair&gt;struct select2nd : public unary_function&lt;Pair, typename Pair::second_type&gt;&#123; const typename Pair::second_type&amp; operator() (const Pair&amp; x) const &#123; return x.second; &#125;&#125;; 1234567891011121314151617181920template &lt;class T&gt;struct plus : public binary_function&lt;T, T, T&gt;&#123; T operator()(const T&amp; x, const T&amp; y) const &#123; return x + y; &#125;&#125;;template &lt;class T&gt;struct minus : public binary_function&lt;T, T, T&gt;&#123; T operator()(const T&amp; x, const T&amp; y) const &#123; return x - y; &#125;&#125;;template &lt;class T&gt;struct equal_to : public binary_function&lt;T, T, bool&gt;&#123; T operator()(const T&amp; x, const T&amp; y) const &#123; return x == y; &#125;&#125;;template &lt;class T&gt;struct plus : public binary_function&lt;T, T, bool&gt;&#123; T operator()(const T&amp; x, const T&amp; y) const &#123; return x &lt; y; &#125;&#125;; 标准库中，仿函数所使用的奇特的base classes1234567891011121314template &lt;class Arg, class Result&gt;struct unary_function&#123; typedef Arg argument_type; typedef Result result_type;&#125;;template &lt;class Arg1, class Arg2, class Result&gt;struct binary_function&#123; typedef Arg1 first_argument_type; typedef Arg2 second_argument_type; typedef Result result_type;&#125;; less::result_type-&gt;bool namespace经验谈1234567891011121314151617181920using namespace std;//-----------------------------------#include&lt;iostream&gt;#include&lt;memory&gt;//share_ptrnamespace jj01&#123;void test_member_template()&#123; ...... &#125;&#125;//namespace//-----------------------------------#include&lt;iostream&gt;#include&lt;list&gt;namespace jj02&#123;template&lt;typename T&gt;using Lst = list&lt;T, allocator&lt;T&gt;&gt;;void test_template_template_param()&#123; ...... &#125;&#125;//namespace//----------------------------------- 使用：123int main(int argc, char** argv)jj01::test_member_template();jj02::test_template_template(); class template, 类模板123456789101112131415template&lt;typename T&gt;class complex&#123;public: complex(T r = 0, T i = 0) : re(r), im(i) &#123;&#125; complex&amp; operator += (const complex&amp;); T real () const &#123; return re; &#125; T imag () const &#123; return im; &#125;private: T re, im; friend complex&amp; __doapl (complex*, const complex&amp;);&#125;; 使用：12345&#123; complex&lt;double&gt; c1(2.5, 1.5); complex&lt;int&gt; c2(2, 6); ...&#125; function template, 函数模板12stone r1(2, 3), r2(3, 3), r3;r3 = min(r1, r2); 编译器会对function template进行实参推导(argument deduction)12345template &lt;class T&gt;inline const T&amp; min(const T&amp; a, const T&amp; b)&#123; return b &lt; a ? b : a;&#125; 实参推导的结果，T为stone，于是调用stone::operator&lt;1234567891011class stone&#123;public: stone(int w, int h, int we) : _w(w), _h(h), _weight(we) &#123; &#125; bool operator&lt; (const stone&amp; rhs) const &#123; return _weight &lt; rhs._weight; &#125;private: int _w, _h, _weight;&#125;; member template, 成员函数1234567891011121314151617template &lt;class T1, class T2&gt;struct pair&#123; typedef T1 first_type; typedef T2 second_type; T1 first; T2 second; pair() : first(T1()), second(T2()) &#123;&#125; pair(const T1&amp; a, const T2&amp; b) : first(a), second(b) &#123;&#125; template &lt;class U1, class U2&gt; pair(const pair&lt;U1, U2&gt;&amp; p) : first(p.first), second(p.second) &#123;&#125;&#125;; 12345class Base1&#123;&#125;;class Derived1:public Base1&#123;&#125;;class Base2&#123;&#125;;class Derived2:public Base2&#123;&#125;; 12pair&lt;Derived1, Derived2&gt;p;pair&lt;Base1, Base2&gt;p2(p); 1pair&lt;Base1, Base2&gt;p2(pair&lt;Derived1, Derived2&gt;()); 123456789template&lt;typename _Tp&gt;class shared_ptr:public __shared_ptr&lt;_Tp&gt;&#123;... template&lt;typename _Tp1&gt; explicit shared_ptr(_Tpl* __p) :__shared_ptr&lt;_Tp&gt;(__p)&#123;&#125;... &#125;; 12Base1* ptr = new Derived1;//up-castshared_ptr&lt;Base1&gt;sptr(new Derived1);//模拟up-cast specialization, 模板特化【注】特化反义词：泛化 泛化12template &lt;class Key&gt;struct hash&#123; &#125;; 特化1234567891011121314151617template&lt;&gt;struct hash&lt;char&gt;&#123; size_t operator() (char x) const &#123; return x; &#125;&#125;;template&lt;&gt;struct hash&lt;int&gt;&#123; size_t operator() (int x) const &#123; return x; &#125;&#125;;template&lt;&gt;struct hash&lt;long&gt;&#123; size_t operator() (long x) const &#123; return x; &#125;&#125;; 使用：1cout &lt;&lt; hash&lt;long&gt;() (1000); 泛化又叫full specialization，全泛化，对应偏特化。 patial specialization, 模板偏特化——个数的偏12345template&lt;typename T, typename Alloc=...&gt;class vector&#123; ...&#125;; 绑定1234template&lt;typename Alloc=...&gt;class vector&lt;bool, Alloc&gt;&#123; ... patial specialization, 模板偏特化——范围的偏12345template &lt;typename T&gt;class C&#123; ...&#125;; 【注】上下的T不是一个T12345template &lt;typename T&gt;class C&lt;T*&gt;&#123; ...&#125;; 这样写也可以12345template &lt;typename U&gt;class C&lt;U*&gt;&#123; ...&#125;; 使用：12C&lt;string&gt; obj1;C&lt;string*&gt; obj2; template template parameter, 模板模板参数1234567891011template&lt;typename T, template &lt;typename T&gt; class Container &gt;class XCls&#123;private: Container&lt;T&gt; c;public: ......&#125;; 12template&lt;typename T&gt;using Lst = list&lt;T, allocator&lt;T&gt;&gt;; 12XCls&lt;string, list&gt; mylst1;//错误XCls&lt;string, Lst&gt; mylst2; 1234567891011template&lt;typename T, template &lt;typename T&gt; class SmartPtr &gt;class XCls&#123;private: SmartPtr&lt;T&gt; sp;public: XCls():sp(new T) &#123; &#125;&#125;; 1234XCls&lt;string, shared_ptr&gt; p1;XCls&lt;string, unique_ptr&gt; p2;//错误XCls&lt;int, weak_ptr&gt; p3;//错误XCls&lt;long, auto_ptr&gt; p4; 这不是template template parameter12345678910template &lt;class T, class Sequence = deque&lt;T&gt;&gt;class stack&#123; friend bool operator== &lt;&gt; (const stack&amp;, const stack&amp;); friend bool operator&lt; &lt;&gt; (const stack&amp;, const stack&amp;);protected: Sequence c;//底层容器......&#125;; 使用12stack&lt;int&gt; s1;stack&lt;int, list&lt;int&gt;&gt; s2; 关于C++标准库容器Sequence containersarrayvectordequeforward_listlist Container adaptorsstackqueuepriority_queue Associative containerssetmultisetmapmultimap Unordered associative conunordered_setunordered_multisetunordered_mapunordered_multimap 算法… Sortingsortstable_sortpartial_sortpartial_sort_copyis_sortedis_sorted_untilnth_element Binary searchlower_boundupper_boundequal_rangebinary_search Mergemergeinplace_mergeincludesset_unionset_intersectionset_differenceset_symmetric_difference … 推书：Algorithms + Data Structures = Programs(Niklaus Wirth) 确认支持C++11： macro __cplusplus测试：VS2012123456789#include\"stdafx.h\"#include &lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;__cplusplus&lt;&lt;endl; return 0;&#125; Dev-C++ 5123456#include &lt;iostream&gt;int main()&#123; std::cout&lt;&lt;__cplusplus;&#125; 如果是199711，则不支持C++11，需修改编译器如果是201103，则支持C++11 variadic templates(since C++11) 数量不定的模板参数12345678910void print()&#123;&#125;template&lt;typename T, typename... Types&gt;void print(const T&amp; firstArg, const Type&amp;... args)&#123; cout&lt;&lt;firstArg&lt;&lt;endl; print(args...);&#125; Inside variadic templates, sizeof…(arg) yields the number of arguments …就是一个所谓的pack(包)用于template parameters, 就是template parameters pack(模板参数包)用于function parameter types, 就是function parameter types pack(函数参数类型包)用于function parameters, 就是function parameters pack(函数参数包) 使用：1print(7.5, \"hello\", bitset&lt;16&gt;(377), 42); 结果：12347.5hello000000010111100142 auto(since C++11)过去：1234list&lt;string&gt; c;...list&lt;string&gt;::iterator ite;ite = find(c.begin(), c.end(), target); 现在：123list&lt;string&gt; c;...auto ite = find(c.begin(), c.end(), target); 错误：1234list&lt;string&gt; c;...auto ite;//错误ite = find(c.begin(), c.end(), target); ranged-base for(since C++11)1234for(decl : coll)&#123; statement&#125; 1234for(int i : &#123;2, 3, 5, 7, 9, 13, 17, 19&#125;)&#123; cout&lt;&lt; i &lt;&lt; endl;&#125; 1234567891011vector&lt;double&gt; vec;...for(auto elem : vec)//pass by value&#123; cout &lt;&lt; elem &lt;&lt; endl;&#125;for(auto&amp; elem : vec)// pass by reference&#123; elem *= 3;&#125; reference1234567int x=0;int* p = &amp;x;int&amp; r = x;//r代表x。现在r,x都是0int x2 = 5;r = x2;//r不能重新代表其他物体。现在r,x都是5int&amp; r2 = r;//现在r2是5(r2代表r:亦相当于代表x) 从内存上看， 从内存上看 注意： sizeof(r) == sizeof(x) &amp;x = &r; object和其reference的大小相同，地址也相同（全都是假象）Java里头所有变量都是reference 123456789101112131415161718192021222324typedef struct Stag&#123;int a, b, c, d;&#125; S;int main()&#123; double x = 0; double* p = &amp;x;//p指向x，p的值是x的地址 double&amp; r = x;//r代表x,现在r,x都是0 cout &lt;&lt; sizeof(x) &lt;&lt; endl;//8 cout &lt;&lt; sizeof(p) &lt;&lt; endl;//4 cout &lt;&lt; sizeof(r) &lt;&lt; endl;//8 cout &lt;&lt; p &lt;&lt; endl;//0065FDFC cout &lt;&lt; *p &lt;&lt; endl;//0 cout &lt;&lt; x &lt;&lt; endl;//0 cout &lt;&lt; r &lt;&lt; endl;//0 cout &lt;&lt; &amp;x &lt;&lt; endl;//0065FDFC cout &lt;&lt; &amp;r &lt;&lt; endl;//0065FDFC S s; S&amp; rs = s; cout &lt;&lt; sizeof(s) &lt;&lt; endl;//16 cout &lt;&lt; sizeof(rs) &lt;&lt; endl;//16 cout &lt;&lt; &amp;s &lt;&lt; endl;//0065FDE8 cout &lt;&lt; &amp;rs &lt;&lt; endl;//0065FDE8 &#125; object和其reference的大小相同，地址也相同（全都是假象） reference的常见用途12345678void func1(Cls* pobj) &#123;pobj-&gt;xxx();&#125;void func2(Cls obj) &#123;obj.xxx();&#125;////被调用端 写法相同，很好void func3(Cls&amp; obj) &#123;obj.xxx();&#125;//被调用端 写法相同，很好......Cls obj;func1(&amp;obj);//接口不同，困扰fun2(obj);//调用端接口相同，很好func3(obj);//调用端接口相同，很好 reference通常不用于声明变量，而用于参数类型(parameters type)和返回类型(return type)的描述。 以下被视为”same signature”(所以二者不能同时存在)：12double imag(const double&amp; im) &#123;...&#125;double imag(const double im) &#123;...&#125; //Ambiguity 【注】imag(const double&amp; im)为signature, 不含return type.imag(const double&amp; im)后面可以加const, const是函数签名的一部分。所以imag(const double&amp; im)和imag(const double&amp; im) const两个函数可以并存。 对象模型(Object Model):关于vptr 和 vtbl12345678910class A&#123;public: virtual void vfunc1(); virtual void vfunc2(); void func1(); void func2();private: int m_data1, m_data2;&#125;; 12345678class B:public A&#123;public: virtual void vfunc1(); void func2();private: int m_data3;&#125;; 12345678class C:public B&#123;public: virtual void vfunc1(); void func2();private: int m_data1 m_data4;&#125;; 从内存上看 对象模型(Object Model):关于thisTemplate Method 关于this 再谈const const object(data members不得变动) non-const object(data members可变动)const member functions(保证不更改data members) √ √non-const member functions(不保证data members不变) × √ 当成员函数的const和non-const版本同时存在，const object只会（只能）调用const版本，non-const object只会（只能）调用non-const版本。 12const String str(\"hello world\");str.print(); 如果当初设计string::print()时未指明const，那么上行便是经由const object调用non-const member function，会出错。此非所愿。 non-const member functions可调用const member functions，反之则不行，会引发：1(VC)error C2662:cannot convert 'this' pointer from 'const class X' to 'class X &amp;'.Conversion loses qualifiers class template std::basic_string&lt;…&gt;有如下两个member functions:1234567charToperator[](size_type pos) const&#123;....../*不必考虑COW*/&#125;referenceoperator[](size_type pos)&#123;....../*必须考虑COW*/&#125; COW:Copy On Write 对象模型(Object Model):关于Dynamic Binding 静态绑定 动态绑定三个条件： 通过指针 虚函数 向上转型 动态绑定 再谈new和delete::operator new, ::operator delete, ::operator new[], ::operator delete[] new&delete 重载member operator new/delete 重载member operator new/delete 重载member operator new[]/delete[]和上图的区别在于多了一个[]123456class Foo&#123;public: void* operator new[](size_t); void operator delete[](void*, size_t);&#125;; 示例， 接口 示例 示例2 int 4字节，long 4字节，string（里面是个指针）4字节有虚函数就多一个指针（12+4=16） Foo[5] 数组，有5个，12*5=60，第一个记录有5个元素，这个记录的size为4，60+4=64 示例3 重载new(), delete()我们可以重载class member operator new(),写出多个版本，前提是每一个版本的声明都必须有独特的参数列，其中第一参数必须是size_t，其余参数以new所指定的placement arguments为初值。出现于new(……)小括号内的便是所谓placement arguments。 1Foo* pf = new(300, 'c') Foo; 我们也可以重载class member operator delete()（或称此为placement operator delete），写出多个版本，但它们绝不会被delete调用。只有当new所调用的ctor抛出exception，才会调用这些重载版的operator delete()。它只可能这样被调用，主要用来归还未能完全创建成功的object所占用的memory。 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Foo&#123;public: Foo()&#123;cout&lt;&lt;\"Foo::Foo()\" &lt;&lt; endl; &#125; Foo(int)&#123;cout &lt;&lt; \"Foo::Foo(int)\" &lt;&lt; endl; throw Bad();&#125;//class Bad&#123;&#125;; //故意在这儿抛出exception，测试placement operator delete.s //(1)这里就是一般的operator new()的重载 void* operator new(size_t size) &#123; return malloc(size); &#125; //(2)这个就是标准库已提供的placement new()的重载（的形式），（所以此处也模拟standard placement new,就只是传回pointer） void* operator new(size_t size, void* start) &#123; return start; &#125; //(3)这个才是崭新的palcement new void* operator new(size_t size, long extra) &#123; return malloc(size+extra); &#125; //(4)这又是一个placement new void* operator new(size_t size, long extra, char init) &#123; return malloc(size+extra); &#125; //(5)这又是一个placement new, 但故意写错第一参数的type（那必须是size_t以符合正常的operator new） //void* operator new(long extra, char init) //&#123; // [Error]'Operator new' takes type 'size_t'('unsigned int') as first parameter[-fpermissive] // return malloc(extra); //&#125; //以下是搭配上述placement new的各个所谓placement delete. //当ctor发出异常，这儿对应的operator(placement) delete就会被调用. //其用于是释放对应之placement new分配所得的memory. //(1)这儿就是一般的operator delete()的重载 void operator delete(void*,size_t) &#123;cout &lt;&lt; \"operator delete(void*, size_t)\" &lt;&lt; endl;&#125; //(2)这是对应的(2) void operator delete(void*,void*) &#123;cout &lt;&lt; \"operator delete(void*, void*)\" &lt;&lt; endl;&#125; //(3)这是对应的(3) void operator delete(void*, long) &#123;cout &lt;&lt; \"operator delete(void*, long)\" &lt;&lt; endl;&#125; //(4)这是对应的(4) void operator delete(void*, long, char) &#123;cout &lt;&lt; \"operator delete(void*, long, char)\" &lt;&lt; endl;&#125;private: int m_i;&#125;; 测试代码：123456789Foo start;Foo* p1 = new Foo;Foo* p2 = new(&amp;start) Foo;Foo* p3 = new(100) Foo;Foo* p4 = new(100,'a') Foo;Foo* p5 = new(100) Foo(1);//ctor抛出异常Foo* p6 = new(100,'a') Foo(1);Foo* p7 = new(&amp;start) Foo(1);Foo* p8 = new Foo(1); test ctor抛出异常，但G4.9没调用operator delete(void*, long),但G2.9确实调用了。 即使operator delete(…)未能一一对应于operator new(…)，也不会出现任何报错。意思是：放弃处理ctor发出的异常。 basic_string使用new(extra)扩充申请量 basic_string使用new(extra)扩充申请量","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hubojing.github.io/categories/编程语言/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"}]},{"title":"Django博客demo","slug":"django搭建博客","date":"2019-01-11T10:19:51.000Z","updated":"2019-01-13T13:49:37.000Z","comments":true,"path":"2019/01/11/django搭建博客/","link":"","permalink":"https://hubojing.github.io/2019/01/11/django搭建博客/","excerpt":"　　Django-blog-demo笔记。 ","text":"Django-blog-demo笔记。 搭建环境 python 3.7 Django 2.1.5 pycharm 安装 cmd里敲：1pip install Django==2.1.5 创建项目和应用创建项目 在预想安装博客目录下计入cmd，敲：1django-admin startproject myblog 对应目录下生成一个myblog文件夹。 manage.py:与项目进行交互的命令行工具集的入口1python manage.py 查看所有命令。 启动命令：1python manage.py runserver 浏览器127.0.0.1:8000查看效果。 改端口号：1python manage.py runserver 8888 myblog目录 myblog |–__init__.py |–settings.py |–urls.py |–wsgi.py manage.py wsgi.py WSGI(Python Web Server Gateway Interface) Python服务器网关接口 Python应用与Web服务器之间的接口 urls.py URL配置文件 settings.py 项目总配置文件，包含数据库、Web应用、时间等各种配置 __init__.py 内容默认为空 创建应用 打开命令行，进入manage.py同级目录1python manage.py startapp blog 会多一个blog文件夹。 添加应用名到settings.py中的INSTALLED_APPS里123456789INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'blog'] blog目录 blog |–migrations |—-__init__.py |–__init__.py |–admin.py |–apps.py |–models.py |–tests.py |–views.py migrations 数据移植（迁移）模块，内容自动生成 admin.py 该应用的后台管理系统配置 apps.py 应用配置（Django-1.9以后自动生成） models.py 数据模块，使用ORM框架，类似于MVC结构中的Models(模型) test.py 自动化测试模块，在此编写测试脚本（语句） views.py 执行响应的代码所在模块，代码逻辑处理地（项目大部分代码在此） Hello World 打开view.py，输入12345from django.shortcuts import renderfrom django.http import HttpResponsedef index(request): return HttpResponse('Hello World!') 即编辑blog.views 每个相应对应一个函数，函数必须返回一个响应 函数必须存在一个参数，一般约定为request 每个相应（函数）对应一个URL 在urls.py中，输入123456789from django.contrib import adminfrom django.urls import pathimport blog.views as bvurlpatterns = [ path('admin/', admin.site.urls), path('index/', bv.index),] 即编辑urls.py url函数放在urlpatterns列表中 url函数三个参数：URL(正则)，对应方法，名称 运行，输入地址http://localhost:8000/index/ 即可。 第二种URL配置 如果页面很多，都写在根urls.py中就很乱。于是，在根urls.py中引入include，在APP目录下创建urls.py文件，格式与根urls.py相同。 更改后：123456789from django.contrib import adminfrom django.urls import path,includeimport blog.views as bvurlpatterns = [ path('admin/', admin.site.urls), path('index/', include('blog.urls')),] 新blog.urls.py1234567from django.urls import pathfrom . import viewsurlpatterns = [ path('', views.index),] Templates HTML文件使用了Django模板语言（Django Template Language, DTL） 开发第一个Template 在APP的根目录下创建名叫Templates的目录 在该目录下创建HTML文件 在views.py中返回render() html中敲入：12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello blog!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 修改views.py为：12345from django.shortcuts import renderfrom django.http import HttpResponsedef index(request): return render(request,'index.html') 运行查看效果。 DTL初步使用 render()函数中支持一个dict类型参数 该字典是后台传递到模板的参数，键为参数名 在模板中使用来直接使用 修改views.py123...return render(request,'index.html',&#123;'hello':'Hello blog!'&#125;)... 修改html123...&lt;h1&gt;&#123;&#123;hello&#125;&#125;&lt;/h1&gt;... 运行查看效果。 Models 通常，一个Model对应数据库的一张数据表 Django中Models以类的形式表现 它包含了一些基本字段以及数据的一些行为 ORM 对象关系映射（Object Relation Mapping） 实现了对象和数据库之间的映射 隐藏了数据访问的细节，不需要编写SQL语句 编写Models 在应用根目录下创建models.py，并引入models模块 创建类，继承models.Model，该类即是一张数据表 在类中创建字段 字段创建 字段即类里面的属性（变量）1attr = models.CharField(max_length = 64) 生成数据表 命令行中进入manage.py同级目录 执行命令12python manage.py makemigrations app名（可选）python manage.py migrate 不加app名默认给所有app进行数据迁移。 cmd将显示：12345678910111213141516171819202122232425E:\\PythonCode\\myblog&gt;python manage.py makemigrationsMigrations for 'blog': blog\\migrations\\0001_initial.py - Create model ArticleE:\\PythonCode\\myblog&gt;python manage.py migrateOperations to perform: Apply all migrations: admin, auth, blog, contenttypes, sessionsRunning migrations: Applying contenttypes.0001_initial... OK Applying auth.0001_initial... OK Applying admin.0001_initial... OK Applying admin.0002_logentry_remove_auto_add... OK Applying admin.0003_logentry_add_action_flag_choices... OK Applying contenttypes.0002_remove_content_type_name... OK Applying auth.0002_alter_permission_name_max_length... OK Applying auth.0003_alter_user_email_max_length... OK Applying auth.0004_alter_user_username_opts... OK Applying auth.0005_alter_user_last_login_null... OK Applying auth.0006_require_contenttypes_0002... OK Applying auth.0007_alter_validators_add_error_messages... OK Applying auth.0008_alter_user_username_max_length... OK Applying auth.0009_alter_user_last_name_max_length... OK Applying blog.0001_initial... OK Applying sessions.0001_initial... OK 生成数据表 查看 Django会自动在app/migrations/目录下生成移植文件 执行命令查看SQL语句1python manage.py sqlmigrate 应用名 文件id cmd将显示：1234567E:\\PythonCode\\myblog&gt;python manage.py sqlmigrate blog 0001BEGIN;---- Create model Article--CREATE TABLE \"blog_article\" (\"id\" integer NOT NULL PRIMARY KEY AUTOINCREMENT, \"title\" varchar(32) NOT NULL, \"content\" text NULL);COMMIT; 默认sqlite3的数据库在项目根目录下db.sqlite3 查看并编辑db.sqlite3，使用第三方软件，如SQLite Expert Personal 页面呈现数据后台步骤 views.py中import models12article = models.Article.objects.get(pk = 1)render(request, page, &#123;'article':article&#125;) 后端步骤 模板可直接使用对象以及对象的“.”操作 修改html1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&#123;&#123;article.title&#125;&#125;&lt;/h1&gt;&lt;h3&gt;&#123;&#123;article.content&#125;&#125;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 运行，查看http://localhost:8000/index/ AdminDjango自带的一个功能强大的自动化数据管理界面被授权的用户可直接在Admin中管理数据库Django提供了许多针对Admin的定制功能 配置Admin创建用户创建超级用户1python manage.py createsuperuser 之后要求输入用户名邮箱密码 Admin入口访问地址：localhost:8000/admin/ 如需修改成中文版，修改settings.py中LANGUAGE_CODE = ‘zh_Hans’（英文：LANGUAGE_CODE = ‘en-us’） 配置应用在应用下admin.py中引入自身的models模块（或里面的模型类）编辑admin.py12from .models import Articleadmin.site.register(models.Article) 修改数据点击Article超链接进入Article列表页面，按页面指示修改。 修改数据默认显示名称每条都显示的Article object，很不方便，显示文章标题比较好。 在Article类下添加一个方法 根据Python版本选择str(self) (python3以上)或unicode(self) （python2.7） return self.title 博客开发页面设计 博客主页面 博客文章内容页面 博客撰写页面 主页面内容 文章标题列表，超链接 发表博客按钮（超链接） 列表编写思路 取出数据库中所有文章对象 将文章对象们打包成列表，传递到前端 前端页面把文章以标题超链接的形式逐个列出 模板For循环123&#123;%for xx in xxs%&#125;# HTML语句&#123;%endfor%&#125; 修改views.py1234567from django.shortcuts import renderfrom django.http import HttpResponsefrom . import modelsdef index(request): articles = models.Article.objects.all() return render(request,'index.html',&#123;'articles': articles&#125;) 修改html12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt; &lt;a href=\"\"&gt;新文章&lt;/a&gt;&lt;/h1&gt;&#123;% for article in articles %&#125; &lt;a href=\"\"&gt;&#123;&#123;article.title&#125;&#125;&lt;/a&gt; &lt;br/&gt;&#123;% endfor %&#125;&lt;/body&gt;&lt;/html&gt; 页面内容 标题 文章内容 修改文章按钮（超链接） 在templates中新增article_page.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Article Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&#123;&#123;article.title&#125;&#125;&lt;/h1&gt;&lt;br/&gt;&lt;h3&gt;&#123;&#123;article.content&#125;&#125;&lt;/h3&gt;&lt;br/&gt;&lt;br/&gt;&lt;a href=\"\"&gt;修改文章&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 修改views.py12345678910111213141516171819202122232425from django.shortcuts import renderfrom django.http import HttpResponsefrom . import modelsdef index(request): articles = models.Article.objects.all() return render(request,'index.html',&#123;'articles': articles&#125;)def article_page(request, article_id): article=models.Article.objects.get(pk = article_id) return render(request,'article_page.html',&#123;'article':article&#125;)``### URL传递参数 参数写在相应函数中request后，可以有默认值 修改blog下的urls.py```pyfrom django.urls import pathfrom . import viewsurlpatterns = [ path('', views.index), path('article/&lt;article_id&gt;', views.article_page),] 顺便把myblog\\urls.py里的index改成blog（非必要，只是更符合博客url）123456789from django.contrib import adminfrom django.urls import path,includeimport blog.views as bvurlpatterns = [ path('admin/', admin.site.urls), path('blog/', include('blog.urls')),] 运行，输入http://localhost:8000/blog/article/1 查看。 超链接 href后是目标地址，template中可用1&#123;%url 'app_name:url_name' param%&#125; 其中app_name和url_name都在url中配置 再配URLuel函数的名称参数 法一：根urls，写在include()的第二个参数位置，namespace=&#39;blog&#39; 法二：应用下则写在url()的第三个参数位置，name=&#39;article&#39; 主要取决于是否使用include引用了另一个url配置文件 撰写页面 标题编辑栏 文章内容编辑区域 提交按钮 新建edit_page.html1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Edit Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"\" method=\"post\"&gt; &lt;label&gt;文章标题 &lt;input type=\"text\" name=\"title\"/&gt; &lt;/label&gt; &lt;br/&gt; &lt;label&gt;文章内容 &lt;input type=\"text\" name=\"content\"/&gt; &lt;/label&gt; &lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; views.py新增12def edit_page(request): return render(request,'edit_page.html') blog\\urls.py新增1path('edit', views.edit_page), 运行，输入http://localhost:8000/blog/edit 查看。 编辑相应函数 使用request.POST[&#39;参数名&#39;]获取表单数据 models.Article.objects.create(title, content)创建对象 两个编辑页面 思路：新文章为空，修改文章有内容 修改文章页面有文章对象 文章的ID 修改数据 article.title = title article.save() 修改views.py12345678910111213141516171819202122def edit_page(request, article_id): if str(article_id) == '0': return render(request,'edit_page.html') article = models.Article.objects.get(pk=article_id) return render(request, 'edit_page.html', &#123;'article': article&#125;)def edit_action(request): title = request.POST.get('title', 'TITLE') content = request.POST.get('content', 'CONTENT') article_id = request.POST.get('article_id', '0') if article_id == '0': models.Article.objects.create(title=title, content=content) articles = models.Article.objects.all() return render(request, 'index.html', &#123;'articles': articles&#125;) article = models.Article.objects.get(pk=article_id) article.title = title article.content = content article.save() return render(request,'article_page.html', &#123;'article': article&#125;) 修改blog\\urls.py123456urlpatterns = [ path('', views.index), path('article/(?P&lt;article_id&gt;[0-9]+)$', views.article_page,name='article_page'), path('edit/(?P&lt;article_id&gt;[0-9]+)$', views.edit_page,name='edit_page'), path('edit/Action$', views.edit_action,name='edit_action'),] 修改article_page.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Article Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&#123;&#123;article.title&#125;&#125;&lt;/h1&gt;&lt;br/&gt;&lt;h3&gt;&#123;&#123;article.content&#125;&#125;&lt;/h3&gt;&lt;br/&gt;&lt;br/&gt;&lt;a href=\"&#123;% url 'blog:edit_page' article.id %&#125;\"&gt;修改文章&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 修改主页index.html12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt; &lt;a href=\"&#123;% url 'blog:edit_page' 0 %&#125;\"&gt;新文章&lt;/a&gt;&lt;/h1&gt;&#123;% for article in articles %&#125; &lt;a href=\"&#123;% url 'blog:article_page' article.id %&#125;\"&gt;&#123;&#123;article.title&#125;&#125;&lt;/a&gt; &lt;br/&gt;&#123;% endfor %&#125;&lt;/body&gt;&lt;/html&gt; 修改edit_page.gtml12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Edit Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"&#123;% url 'blog:edit_action' %&#125;\" method=\"post\"&gt; &#123;% csrf_token %&#125; &#123;% if article %&#125; &lt;input type=\"hidden\" name=\"article_id\" value=\"&#123;&#123;article.id&#125;&#125;\"/&gt; &lt;label&gt;文章标题 &lt;input type=\"text\" name=\"title\" value=\"&#123;&#123;article.title&#125;&#125;\"/&gt; &lt;/label&gt; &lt;br/&gt; &lt;label&gt;文章内容 &lt;input type=\"text\" name=\"content\" value=\"&#123;&#123;article.content&#125;&#125;\"/&gt; &lt;/label&gt; &lt;br/&gt; &#123;% else %&#125; &lt;input type=\"hidden\" name=\"article_id\" value=\"0\"/&gt; &lt;label&gt;文章标题 &lt;input type=\"text\" name=\"title\"/&gt; &lt;/label&gt; &lt;br/&gt; &lt;label&gt;文章内容 &lt;input type=\"text\" name=\"content\"/&gt; &lt;/label&gt; &lt;br/&gt; &#123;% endif %&#125; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; Templates过滤器 写在模板中，属于Django模板语言 可以修改模板中的变量，从而显示不同的内容 使用1&#123;&#123;value | filter&#125;&#125; e.g.1&#123;&#123;list_nums | length&#125;&#125; 过滤器可叠加：1&#123;&#123;value | filter1 | filter2 | ...&#125;&#125; 修改edit_page.html12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Edit Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"&#123;% url 'blog:edit_action' %&#125;\" method=\"post\"&gt; &#123;% csrf_token %&#125; &lt;input type=\"hidden\" name=\"article_id\" value=\"&#123;&#123;article.id | default:'0'&#125;&#125;\"/&gt; &lt;label&gt;文章标题 &lt;input type=\"text\" name=\"title\" value=\"&#123;&#123;article.title&#125;&#125;\"/&gt; &lt;/label&gt; &lt;br/&gt; &lt;label&gt;文章内容 &lt;input type=\"text\" name=\"content\" value=\"&#123;&#123;article.content&#125;&#125;\"/&gt; &lt;/label&gt; &lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; Django Shell Python交互式命令行程序，自动引入了项目环境，可使用它与项目进行交互 使用123python manage.py shellfrom blog.models import ArticleArticle.objects.all() 可以使用它进行调试 测试未知的方法 Admin增强创建admin配置类 class ArticleAdmin(admin.ModelAdmin) 注册：admin.site.register(Article, ArticleAdmin) 显示其他字段 list_display = (‘title’, ‘content’) list_display同时支持tuple和list 修改admin.py12345678from django.contrib import adminfrom .models import Articleclass ArticleAdmin(admin.ModelAdmin): list_display = ('title', 'content','pub_time')admin.site.register(Article, ArticleAdmin) 修改models.py12345678910from django.db import modelsclass Article(models.Model): title = models.CharField(max_length=32, default='Title') content=models.TextField(null=True) pub_time = models.DateTimeField(auto_now=True) def __str__(self): return self.title 如果是1pub_time = models.DateTimeField(null=True) 则可自己设定时间。 修改完代码记得进行数据移植12python manage.py makemigrationspython manage.py migrate 过滤器 list_filter = (‘pub_time’,) 注意有个逗号 相关资料Django API Reference 代码下载django-blog-demo hexo天坑：遇到 两个大括号 以及 一个大括号一个% 一定放入代码行（如下），这样是不行的。12&#123;&#123;&#125;&#125;&#123;%%&#125; 排查这个bug花了我半个小时…","raw":null,"content":null,"categories":[{"name":"软件开发","slug":"软件开发","permalink":"https://hubojing.github.io/categories/软件开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hubojing.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://hubojing.github.io/tags/Django/"}]},{"title":"新年Flag","slug":"新年Flag","date":"2019-01-01T14:18:16.000Z","updated":"2019-01-06T10:05:28.000Z","comments":true,"path":"2019/01/01/新年Flag/","link":"","permalink":"https://hubojing.github.io/2019/01/01/新年Flag/","excerpt":"　　简短地写一写今年的规划。 ","text":"简短地写一写今年的规划。 元旦快乐！ 2019年刚刚开始，不过我总有一种2019已经结束的错觉…… 去年元旦前夕洋洋洒洒写了不少，2018也有很多事情可写，但可能不是一篇两篇写得下的…… 去年我只立了两条Flag： 1. 每日看足1小时技术类图书 2. 不要熬夜 验收： 第一条算自己基本做到了吧，不过手头还有一叠书没看，不少时候也是利用的碎片化时间阅读。 第二条2018年上半年没做到，下半年基本做到了。 今年的Flag： 1. 不要熬夜，加强锻炼 2. 技术方面基础和实战两头抓 3. 提高算法能力，首先从多做题开始 4. 继续提高英语水平，尤其是计算机英语 5. 研究方向的趋向性研讨 2019年理应是一个自我技术能力快速提高的一年。 之前有朋友提醒我更博，Thanks♪(･ω･)ﾉ。2018年是忙碌的一年，其实也并非从八月起就停更了。只是那段时间折腾，开了一个微信公众号：玩代码，并且打算在上面更完关于OpenCV学习的一个系列笔记。这个系列可能文章比较多，但每篇篇幅较短，质量也可能参差不齐，因为主要是我进行自我查阅和复习使用。我之前没有和任何人提及过该公众号，只是在github上提交了部分代码。感谢各位默默关注。 可以说，公众号目前只是一个我折腾的玩具，技术博客依然是我的主要记录地。不过后期也许在公众号写点技术方面别的东西（比如一些日常写代码的bug或者计算机相关的新闻感想？）技术公众号和技术博客的分界点在哪，还没想好。 不过公众号借助微信的开发平台，很多方面省事省力。贴图也不用担心哪天图就挂了。我前几年写的文章不少配图失效了，而我当时也没有备份，算是找不到了。最初用极简图床丢了一波图，后来用七牛扣了一波钱，现在用VSCode写markdown，图床外链也不能实时显示。现在写文章怕丢图还得自我先备份，着实有些麻烦。关于这方面，还是得想想有没有什么好办法。 感觉没图太单调 2018我的知乎 跟上时代，未来必是人工智能的世界。 2019，扬帆起航吧。","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"年终总结","slug":"年终总结","permalink":"https://hubojing.github.io/tags/年终总结/"}]},{"title":"C++面向对象程序设计（侯捷）笔记","slug":"C-面向对象程序设计（侯捷）笔记","date":"2018-12-27T10:27:25.000Z","updated":"2019-02-01T12:12:33.000Z","comments":true,"path":"2018/12/27/C-面向对象程序设计（侯捷）笔记/","link":"","permalink":"https://hubojing.github.io/2018/12/27/C-面向对象程序设计（侯捷）笔记/","excerpt":"　　侯捷老师带我飞，再学习C++系列。 ","text":"侯捷老师带我飞，再学习C++系列。 前言 再复习C++，现整理笔记如下。（以下【注】为我的注释） 写正规大气的C++代码。感谢侯捷老师！ C++编程简介你应具备的基础 曾学过某种procedural language(C语言) 变量(variables) 类型(types):int, float, char, struct … 作用域(scope) 循环(loops):while, for 流程控制：if-else, switch-case 知道一个程序需要编译、连结才能被执行 知道如何编译和连结（如何建立一个可运行程序） 【注】台湾译法也许有某些不同，如此处“连结”。本笔记不改变作者用词。 我们的目标 培养正规的、大气的编程习惯 以良好的方式编写C++ class(Object Based) class without pointer members – Complex class with pointer members – String 学习Classes之间的关系(Objected Oriented) 继承（inheritance） 复合（composition） 委托（delegation） 你将获得的代码complex.hcomplex-test.cpp string.hstring-test.cpp oop-demo.hoop-test.cpp C++的历史 B语言（1969） C语言（1972） C++语言（1983）(new C -&gt; C with Class -&gt;C++) Java语言 C#语言 C++演化 C++ 98(1.0) C++ 03(TR1, Technical Report 1) C++ 11(2.0) C++ 14 C++:C++语言、C++标准库 Bibliography(书目志) C++ Primer The C++ PROGRAMMING LANGUAGE Effective C++ THE C++ STANDARD LIBRARY STL源码剖析 头文件与类的声明C vs C++,关于数据和函数 C vs C++ C++,关于数据和函数 C++,关于数据和函数 123complex c1(2,1);complex c2;complex* pc = new complex(0,1); 【注】数据可以有很多份，函数只有一份。 123string s1(\"Hello\");string s2(\"World\");string* ps = new string; Object Based(基于对象) vs Object Oriented(面向对象)Object Based:面向的是单一class的设计Object Oriented:面对的是多重classes的设计，classes和classes之间的关系。 我们的第一个C++程序Classes的两个经典分类： Class without pointer member(s)complex Class with pointer member(s)string C++ programs代码基本形式 代码基本形式 延伸文件名（extension file name）不一定是.h或.cpp，也可能是.hpp或其他或甚至无延伸名。 Output, C++ vs. CC++12345678910#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 7; cout&lt;&lt; \"i=\" &lt;&lt; i &lt;&lt; endl; return 0;&#125; C123456789include &lt;stdio.h&gt;int main()&#123; int i = 7; printf(\"i=%d \\n\", i); return 0;&#125; Header(头文件)中的防卫式声明guard(防卫式声明)complex.h123456#ifndef __COMPLEX__#define __COMPLEX__...#endif 【注】如果xxx已经定义过了，则不进入下方的定义。 complex-test.h 1234567891011121314151617181920212223#include &lt;iostream&gt;#include \"complex.h\"using namespace std;int main()&#123; complex c1(2,1); complex c2; cout &lt;&lt; c1 &lt;&lt; endl; cout &lt;&lt; c2 &lt;&lt; endl; c2 = c1 + 5; c2 = 7 + c1; c2 = c1 + c2; c2 += c1; c2 += 3; c2 = -c1; cout &lt;&lt; (c1 == c2) &lt;&lt; endl; cout &lt;&lt; (c1 != c2) &lt;&lt; endl; cout &lt;&lt; conj(c1) &lt;&lt; endl; return 0;&#125; Header(头文件)的布局12345678910111213141516171819202122#ifndef __COMPLEX__#define __COMPLEX__#include&lt;cmath&gt;//forward declarations(前置声明)class ostream;class complex;complex&amp; __doapl (complex* ths, const complex&amp; r);//class declarations(类-声明)class complex&#123; ...&#125;;//class definiton(类-定义)complex::function ...#endif class的声明(declaration)1234567891011121314class complex//class head&#123;//class bodypublic: complex (double r = 0, double i = 0) : re (r), im(i) &#123;&#125; complex&amp; operator += (const complex&amp;); double real () const &#123;return re;&#125; double imag () const &#123;reutn im;&#125;//有些函数在此直接定义，另一些在body之外定义private: double re, im; friend complex&amp; __doapl (complex*, const complex&amp;);&#125;; 使用：12345&#123; complex c1(2,1); complex c2; ...&#125; class template(模板)简介123456789101112131415template&lt;typename T&gt;class complex&#123;public: complex (T r = 0, T i = 0) : re (r), im(i) &#123;&#125; complex&amp; operator += (const complex&amp;); T real () const &#123;return re;&#125; T imag () const &#123;reutn im;&#125;//有些函数在此直接定义，另一些在body之外定义private: T re, im; friend complex&amp; __doapl (complex*, const complex&amp;);&#125;; 使用：12345&#123; complex&lt;double&gt; c1(2.5,1.5); complex&lt;int&gt; c2(2,6); ...&#125; 构造函数inline(内联)函数1234567891011121314class complex&#123;public: complex (double r = 0, double i = 0) : re (r), im(i) &#123;&#125;//函数若在class body内定义完成，便成为inline候选人 complex&amp; operator += (const complex&amp;); double real () const &#123;return re;&#125;//可以inline double imag () const &#123;reutn im;&#125;//可以inlineprivate: double re, im; friend complex&amp; __doapl (complex*, const complex&amp;);&#125;; 使用：12345inline doubleimag(const complex&amp; x)&#123; return x.imag ();&#125; 【注】函数太复杂，就不能inline。 access level(访问级别)1234567891011121314class complex&#123;public: complex (double r = 0, double i = 0) : re (r), im(i) &#123;&#125; complex&amp; operator += (const complex&amp;); double real () const &#123;return re;&#125; double imag () const &#123;reutn im;&#125;private: double re, im; friend complex&amp; __doapl (complex*, const complex&amp;);&#125;; 错误使用：12345&#123; complex c1(2,1); cout &lt;&lt; c1.re; cout &lt;&lt; c1.im;&#125; 正确使用：12345&#123; complex c1(2,1); cout &lt;&lt; c1.real(); cout &lt;&lt; c1.imag();&#125; constructor(ctor,构造函数)1234567891011121314class complex&#123;public: complex (double r = 0, double i = 0)//default argument(默认实参) : re (r), im(i)//initialization list(初值列，初始列) &#123; &#125; complex&amp; operator += (const complex&amp;); double real () const &#123;return re;&#125; double imag () const &#123;reutn im;&#125;private: double re, im; friend complex&amp; __doapl (complex*, const complex&amp;);&#125;; 【注】其他函数也可以有默认值。构造函数没有返回值类型。initialization list(初值列，初始列)上下三行等价于1234complex (double r = 0, double i = 0)&#123; re = r; im = i;&#125; 但建议用初始列方式写。初始化+赋值。初始列就是初始化的阶段。 使用：12345&#123; complex c1(2,1); complex c2;//没有指明，用默认值 complex* p = new complex(4);&#125; 【注】不带指针的类多半不用写析构函数。 ctor(构造函数)可以有很多个 - overloading(重载)123456789101112131415class complex&#123;public: complex (double r = 0, double i = 0) : re (r), im(i) &#123; &#125; complex () : re(0), im(0) &#123; &#125;//？！ complex&amp; operator += (const complex&amp;); double real () const &#123;return re;&#125; double imag () const &#123;reutn im;&#125;private: double re, im; friend complex&amp; __doapl (complex*, const complex&amp;);&#125;; 1234void real(double r)&#123; re = r;&#125; real函数编译后的实际名称可能是：?real@Complex@@QBENXZ?real@Complex@@QAENABN@Z取决于编译器。 【注】重载表面名字相同，其实在编译器内名字不同。 构造函数重载：1234&#123; Complex c1; Complex c2();//写法不同，意思相同&#125; 所以？！处的构造函数不能这样重载。 参数传递与返回值constructor(ctor,构造函数)被放在private区 ctor被放在private区 以下无法使用：12complex c1(2,1);complex c2; 那么是不是说ctor不应该放在private区呢？也不是。 Singleton(单例)设计模式：12345678910111213141516class A&#123;public: static A&amp; getInstance(); setup() &#123;...&#125;private: A(); A(const A&amp; rhs); ...&#125;;A&amp; A::getInstance()&#123; static A a; return a;&#125; 使用：1A::getInstance().setup(); const member functions(常量成员函数)1234567891011121314class complex&#123;public: complex (double r = 0, double i = 0) : re (r), im(i) &#123; &#125; complex&amp; operator += (const complex&amp;); double real () const &#123;return re;&#125; double imag () const &#123;reutn im;&#125;private: double re, im; friend complex&amp; __doapl (complex*, const complex&amp;);&#125;; 正确使用：12345&#123; complex c1(2,1); cout &lt;&lt; c1.real(); cout &lt;&lt; c1.imag();&#125; 【注】不改变数据就加const。 ？！12345&#123; const complex c1(2,1);//我这个值是不能改变的哦 cout &lt;&lt; c1.real();//万一real函数没写const，就可能改data。就会产生矛盾 cout &lt;&lt; c2.imag();&#125; 参数传递：pass by value vs. pass by reference(to const)1234567891011121314class complex&#123;public: complex (double r = 0, double i = 0) : re (r), im(i) &#123; &#125; complex&amp; operator += (const complex&amp;);//传引用速度很快哦，并且不能改我，我加了const哦。如果你改我，编译器就会报错 double real () const &#123;return re;&#125; double imag () const &#123;reutn im;&#125;private: double re, im; friend complex&amp; __doapl (complex*, const complex&amp;);&#125;; 没有const:123456ostream&amp;operator &lt;&lt; (ostream&amp; os, const complex&amp; x)&#123; return os &lt;&lt; '(' &lt;&lt; real (x) &lt;&lt; ',' &lt;&lt; imag (x) &lt;&lt; ')';&#125; 【注】pass by value压到栈里。大的遵循守则，尽量不要pass by value。在C里用指针。C++ pass by reference。如果不希望对方改数据，加const。 使用：1234567&#123; complex c1(2,1); complex c2; c2 += c1; cout &lt;&lt; c2;&#125; 返回值传递：return by value vs. return by reference(to const)1234567891011121314class complex&#123;public: complex (double r = 0, double i = 0) : re (r), im(i) &#123; &#125; complex&amp; operator += (const complex&amp;); double real () const &#123;return re;&#125; double imag () const &#123;reutn im;&#125;private: double re, im; friend complex&amp; __doapl (complex*, const complex&amp;);&#125;; friend(友元)1234567891011121314class complex&#123;public: complex (double r = 0, double i = 0) : re (r), im(i) &#123; &#125; complex&amp; operator += (const complex&amp;); double real () const &#123;return re;&#125; double imag () const &#123;reutn im;&#125;private: double re, im; friend complex&amp; __doapl (complex*, const complex&amp;);&#125;; 使用：1234567inline complex&amp;__doapl (complex* ths, const complex&amp; r)&#123; this-&gt;re += r.re; this-&gt;im += r.im;//自由取得friend的private成员 return *ths;&#125; 【注】friend打破封装。 相同class的各个objects互为friends(友元)12345678910111213class complex&#123;public: complex (double r = 0; double i = 0) : re (r), im (i) &#123; &#125; int func(const complex&amp; param) &#123; return param.re + param.im; &#125;//这个怎么可以直接拿咧~private: double re, im;&#125;; 使用：123456&#123; complex c1(2,1); complex c2; c2.func(c1);&#125; class body外的各种定义(definitions)什么情况下可以pass by reference什么情况下可以return by reference do assignment plus第一参数将会被改动，第二参数不会被改动12345678910111213inline complex&amp;__doapl (complex* ths, const complex&amp; r)&#123; ths-&gt;re += r.re; ths-&gt;im += r.im; return *ths;&#125;inline complex&amp;complex::operator += (const complex&amp; r)&#123; return __doapl (this, r);&#125; 操作符重载与临时对象operator overloading(操作符重载-1，成员函数) this 操作符重载之成员函数 return by reference语法分析传递者无需知道接受者是以reference形式接收。 语法分析 【注】return *ths; 接收端是complex&amp;，不矛盾。 class body外的各种定义(definitions)1234567891011inline doubleimag(const complex&amp; x)&#123; return x.imag ();&#125;inline doublereal(const complex&amp; x)&#123; return x.real ();&#125; 使用：123456&#123; complex c1(2,1); cout &lt;&lt; imag(c1); cout &lt;&lt; real(c1);&#125; operator overloading(操作符重载-2，非成员函数)(无this)为了应对client的三种可能用法，这儿对应开发三个函数。 操作符重载之非成员函数 temp object(临时对象) typename();上图complex这些函数绝不可return by reference,因为它们返回的必定是个local object。 三大函数：拷贝构造，拷贝复制，析构 Class without pointer member(s)complex Class with pointer member(s)string String classstring-test.cpp12345678910int main()&#123; String s1(), String s2(\"hello\"); String s3(s1); cout &lt;&lt; s3 &lt;&lt; endl; s3 = s2; cout &lt;&lt; s3 &lt;&lt; endl;&#125; string.h123456789101112#ifndef __MYSTRING__define __MYSTRING__class String&#123; ...&#125;;String::function(...) ...Global-function(...) ...#endif Big Three, 三个特殊函数Big Three：拷贝构造、拷贝赋值、析构函数【注】拷贝构造、拷贝赋值，在带有指针的情况下，不能用编译器自带的那一套，需要自己编写。 1234567891011class String&#123;public: String(const char* cstr = 0); String(const String&amp; str);//拷贝构造 String&amp; operator=(const String&amp; s);//操作符重载（拷贝赋值） ~String();//析构函数 char* get_c_str() const &#123; return m_data&#125;;//inlineprivate: char* m_data;&#125;; 【注】类似于动态分配的方式，用指针指向字符串，而不要用数组。 ctor和dtor(构造函数和析构函数)123456789101112131415161718inline String::String(const char* cstr = 0)&#123; if(cstr) &#123; m_data = new char[strlen(cstr)+1]; strcpy(m_data, cstr); &#125; else &#123;//未指定初值 m_data = new char[1]; *m_data = '\\0'; &#125;&#125;inline String::~String()&#123; delete[] m_data;&#125; 使用：1234567&#123; String s1(); String s2(\"hello\"); String* p = new String(\"hello\"); delete p;&#125; 【注】离开作用域（一对大括号）时，s1,s2自然而然调用析构函数，p手动调用析构函数。 class with pointer members 必须有 copy ctor 和 copy op=copy ctor(拷贝构造)copy op=(拷贝赋值) e.g.a有一个data，指向Hello\\0b有一个data，指向World\\0 如果使用 default copy ctor 或 default op= 就会形成以下局面b = a;导致b的指针也指向Hello\\0 而World\\0造成memory leak（内存泄漏）这种叫做浅拷贝 cpoy ctor(拷贝构造函数)深拷贝12345inline String::String(const String&amp; str)&#123; m_data = new char[strlen(str.m_data)+1]; strcpy(m_data, str.m_data);&#125; 使用：12345&#123; String s1(\"hello\"); String s2(s1);// String s2 = s1;&#125; copy assignment operator(拷贝赋值函数)【注】类比：原来有一个装水和油的瓶子。现在要赋值，步骤： 倒掉油（杀掉自己） 将瓶子改造成水瓶一样大（重新创造自己） 将水从水瓶倒入新瓶（拷贝过来） 12345678910inline String&amp; String::operator=(const String&amp;)&#123; if(this == &amp;str)//检测自我赋值(self assignment) return *this; delete[] m_data;//杀掉自己 m_data = new char[strlen(str.m_data) + 1];//重新创造自己 strcpy(m_data, str.m_data);//拷贝过来 return *this; &#125; 使用：12345&#123; String s1(\"hello\"); String s2(s1); s2 = s1;&#125; 一定要在 operator= 中检查是否 self assignment【注】这样做不仅是为了提高效率，不做还会影响正确性。 比如， this和rhs的指针指向同一片内存Hello\\0前述operator=的第一件事情就是delete，造成this和rhs指向？？？然后，当企图存取（访问）rhs，产生不确定行为(undefined behavior) output函数123456#include &lt;iostream.h&gt;ostream&amp; operator&lt;&lt;(ostream&amp; os, const String&amp; str)&#123; os &lt;&lt; str.get_c_str(); return os;&#125; 使用：1234&#123; String s1(\"hello\"); cout &lt;&lt; s1;&#125; 堆，栈与内存管理所谓stack(栈)，所谓heap(堆)Stack，是存在于某作用域(scope)的一块内存空间(memory space)。例如当你调用函数，函数本身即会形成一个stack用来放置它所接收的参数，以及返回地址。在函数本体(function body)内声明的任何变量，其所使用的内存块都取自上述stack。 Heap，或谓system heap，是指由操作系统提供的一块global内存空间，程序可动态分配(dynamic allocated)从某中获得若干区块(blocks)。123456class Complex&#123;...&#125;;...&#123; Complex c1(1, 2); Complex* p = new Complex(3);&#125; c1所占用的空间来自stackComplex(3)是个临时对象，其所占用的空间乃是以new自heap动态分配而得，并由p指向。 stack objects 的生命期12345class Complex&#123;...&#125;;...&#123; Complex c1(1, 2);&#125; c1便是所谓stack object，其生命在作用域(scope)结束之后结束。这种作用域内的object，又称为auto object，因为它会被“自动”清理。 stack local objects 的生命期12345class Complex&#123;...&#125;;...&#123; static Complex c2(1, 2);&#125; c2便是所谓的static object，其生命在作用域(scope)结束之后仍然存在，直到整个程序结束。 global objects 的生命期12345678class Complex&#123;...&#125;;...Complex c3(1, 2);int main()&#123; ...&#125; c3便是所谓global object，其生命在整个程序结束之后才结束。也可以把它视为一种static object，其作用域是“整个程序”。 heap objects 的生命期1234567class Complex&#123;...&#125;;...&#123; Complex* p = new Complex; ... delete p;&#125; p所指的便是heap object，其生命在它被deleted之后结束。 12345class Complex&#123;...&#125;;...&#123; Complex* p = new Complex;&#125; 以上为内存泄漏(memory leak)，因为当作用域结束，p所指的heap object仍然存在，但指针p的生命却结束了，作用域之外再也看不到p（也就没机会delete p）。 new:先分配memory,再调用ctor1Complex* pc = new Complex(1, 2); 编译器转化为12345Complex *pc;void* mem = operator new(sizeof(Complex));//分配内存pc = static_cast&lt;Complex*&gt;(mem);//转型pc-&gt;Complex::Complex(1, 2);//构造函数 operator new是一个函数，其内部调用malloc(n)构造函数的全名是1Complex::Complex(pc, 1 ,2); pc即隐藏的参数this。 delete: 先调用dtor,再释放memory123Complex* ps = new Complex(1, 2);...delete ps; 编译器转化为12Complex::~Complex(ps);//析构函数operator delete(ps);//释放内存 delete函数内部调用free(ps) 析构函数先删除内容，delete删除指针 动态分配所得的内存块(memory block),in VCComplex大小为8b，调试模式下会增加灰色的内存块（32+4），并且收尾各有一个cookie（4*2）（用于回收）vc每一块都是16的倍数，所以需要一些填补物(pad) release下没有灰色部分 String大小为4b 动态分配所得的内存块 动态分配所得的arrayvc用一个整数记录数组个数，所以+4 动态分配所得的array array new一定要搭配array delete array new一定要搭配array delete 【注】看清内存泄漏的地方。 扩展补充：类模板，函数模板及其他static静态函数和一般成员函数的区别：静态函数没有this pointer静态函数只能处理静态数据 如设计银行户头的类123456789101112131415class Account&#123;public: static double m_rate;//静态数据 static void set_rate(const double&amp; x)&#123;m_rate = x;&#125;//静态函数&#125;;double Account::m_rate = 8.0;int main()&#123; Account::set_rate(5.0); Account a; a.set_rate(7.0);&#125; 调用static函数的方式有二：（1）通过object调用（2）通过class name调用 把ctor放在private区Singleton1234567891011class A&#123;public: static A&amp; getInstance&#123;return a;&#125;;//取得唯一的自己 setup()&#123;...&#125;private: A();//任何人不能创建它 A(const A&amp; rhs); static A a;//已经创建了一份 ...&#125;; 使用：1A::getInstance().setup(); 如果不用a，但a仍然存在，为避免资源浪费，更好的写法是：Meyers Singleton12345678910111213141516class A&#123;public: static A&amp; getInstance(); setup() &#123;...&#125;private: A(); A(const A&amp; rhs); ...&#125;;A&amp; A::getInstance()&#123; static A a; return a;&#125; 使用：1A::getInstance().setup(); cout1234class _IO_ostream_withassign:public ostream&#123; ...&#125;;extern _IO_ostream_withassign cout; 123456789101112131415161718class ostream:virtual public ios&#123;public: ostream&amp; operator&lt;&lt;(char c); ostream&amp; operator&lt;&lt;(unsigned char c)&#123;return (*this)&lt;&lt;(char)c;&#125; ostream&amp; operator&lt;&lt;(signed char c)&#123;return (*this)&lt;&lt;(char)c;&#125; ostream&amp; operator&lt;&lt;(const char *s); ostream&amp; operator&lt;&lt;(const unsigned char *s) &#123;return (*this) &lt;&lt; (const char*)s;&#125; ostream&amp; operator&lt;&lt;(const signed char *s) &#123;reutrn (*this) &lt;&lt; (const char*)s;&#125; ostream&amp; operator&lt;&lt;(const void *p); ostream&amp; operator&lt;&lt;(int n); ostream&amp; operator&lt;&lt;(unsigned int n); ostream&amp; operator&lt;&lt;(long n); ostream&amp; operator&lt;&lt;(unsigned long n); ...&#125;; class template,类模板1234567891011121314template&lt;typename T&gt;class complex&#123;public: complex(T r = 0, T i = 0):re(r), im(i) &#123;&#125; complex&amp; operator += (const complex) T real() const &#123;return re;&#125; T imag() const &#123;return im;&#125;private: T re, im; friend complex&amp; __doapl(complex*, const complex&amp;);&#125;; 使用：12345&#123; complex&lt;double&gt; c1(2.5, 1.5); complex&lt;int&gt; c2(2, 6); ...&#125; function template, 函数模板12stone r1(2,3),r(3,3),r3;r3 = min(r1, r2); 编译器会对function template进行引数推导(argument deduction)12345template&lt;class T&gt;inline const T&amp; min(const T&amp; a, const T&amp; b)&#123; return b &lt; a ? b : a;&#125; 引数推导的结果，T为stone，于是调用stone::operator&lt;12345678910class stone&#123;public: stone(int w, int h, int we):_w(w), _h(h), _weight(we) &#123;&#125; bool operator&lt; (const strone&amp; rhs) const &#123;return _weight &lt; rhs._weight;&#125;private: int _w, _h, _weight;&#125;; namespace1234namespace std&#123; ...&#125; using directive12345678910#include&lt;iostream.h&gt;using namespace std;int main()&#123; cin &lt;&lt; ...; cout &lt;&lt; ...; return 0;&#125; using declaration12345678910#include&lt;iostream.h&gt;using std::cout;int main()&#123; std::cin&lt;&lt;...; cout&lt;&lt;...; return 0;&#125; 123456789#include&lt;iostream.h&gt;int main()&#123; std::cin&lt;&lt;...; std::cout&lt;&lt;...; return 0;&#125; 更多细节与深入 operator type() const; *explicit complex(…):initialization list{} pointer-like object funtion-like object Namespace template specialization Standard Library variadic template(since C++11) move ctor(since C++11) Rvalue reference(since C++11) auto(since C++11) lambda(since C++11) range-base for loop(since C++11) unordered containers(since C++ 11) … 组合与继承Object Oriented Programming, Object Oriented Design OOP, OOD Inheritance(继承) Composition(复合) Delegation(委托) Compostion(复合)，表示has-aAdapter12345678910111213141516template &lt;class T, class Sequence = deque&lt;T&gt;&gt;class queue&#123; ...protected: Sequence c;//底层容器public: //以下完全利用c的操作函数完成 bool empty() const &#123;return c.empty();&#125; size_type size() const &#123;return c.size();&#125; reference front() &#123;return c.front();&#125; reference back() &#123;return c.back();&#125; //deque是两端可进出，queue是末端进前端出（先进先出） void push(const value_type&amp; x) &#123;c.push_back(x);&#125; void pop() &#123;c.pop_front();&#125;&#125;; 从内存角度看1234567template &lt;class T&gt;class queue&#123;protected: deque&lt;T&gt; c;...&#125;; Sizeof: 40 123456789template &lt;class T&gt;class deque&#123;protected: Itr&lt;T&gt; start; Itr&lt;T&gt; finish; T** map; unsigned int map_size;&#125;; Sizeof: 16 * 2 + 4 + 4 123456789template &lt;class T&gt;struct Itr&#123; T* cur; T* first; T* last; T** node;...&#125;; Sizeof: 4*4 Composition(复合)关系下的构造和析构 复合关系下的构造和析构 构造由内而外Container的构造函数首先调用Component的default构造函数，然后才执行自己。1Container::Container(...):Component()&#123;...&#125;; 析构由外而内Container的析构函数首先执行自己，然后才调用Component的析构函数。1Container:~Container(...)&#123;... ~Component()&#125;; Delegation(委托). Composition by reference.Handle/Body(pImpl)1234567891011121314//file String.hppclass StringRep;class String&#123;public: String(); String(const char* s); String(const String&amp; s); String &amp;operator=(const String&amp; s); ~String();...private: StringRep* rep;//pimpl&#125;; 12345678910111213141516//file String.cpp#include \"String.hpp\"namespace&#123;class StringRep&#123;friend class String; StringRep(const char* s); ~StringRep(); int count; char* rep;&#125;;&#125;String::String()&#123;...&#125;... 这种手法可称为编译防火墙 引用计数 n=3共享同一个Hello，节省内存。 委托 图 Inheritance(继承), 表示is-a1234567891011struct _List_node_base&#123; _List_node_base* _M_next; _List_node_base* _M_prev;&#125;;template&lt;typename _Tp&gt;struct _List_node:public _List_node_base&#123; _Tp _M_data;&#125;; 继承 图 Inheritance(继承)关系下的构造和析构 内存上看 base class的dtor必须是virtual，否则会出现undefined behavior 构造由内而外Derived的构造函数首先调用Base的default构造函数，然后才执行自己。1Derived::Derived(...):Base()&#123;...&#125;; 析构由外而内Derived的析构函数首先执行自己，然后才调用Base的析构函数。1Derived::~Derived(...)&#123;...~Base()&#125;; Inheritance(继承) with virtual functions(虚函数)non-virtual函数：不希望derived class重新定义(override,复写)它。virtual函数：希望derived class重新定义(override，复写)它，它已有默认定义。pure virtual函数：希望derived class一定要重新定义(override)它，对它没有默认定义。 【注】：纯虚函数其实可以有定义，只是本文不提及。 1234567891011class Shape&#123;public: virtual void draw() const = 0;//pure virtual virtual void error(const std::string&amp; msg);//impure virtual int objectID() const;//non-virtual ...&#125;;class Rectangle:public Shape &#123;...&#125;;class Ellipse:public Shape &#123;...&#125;; Template Method 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;class CDocument&#123;public: void OnFileOpen() &#123; //这是个算法，每个cout输出代表一个实际动作 cout &lt;&lt; \"dialog...\" &lt;&lt; endl; cout &lt;&lt; \"check file status...\" &lt;&lt; endl; cout &lt;&lt; \"open file...\" &lt;&lt; endl; Serialize(); cout &lt;&lt; \"close file...\" &lt;&lt; endl; cout &lt;&lt; \"update all views...\" &lt;&lt; endl; &#125; virtual void Serialize() &#123;&#125;;&#125;; 123456789class CMyDoc : public CDocument&#123;public: virtual void Serialize() &#123; //只有应用程序本身才知道如何读取自己的文件（格式） cout &lt;&lt; \"CMyDoc::Serialize()\" &lt;&lt; endl; &#125;&#125;; 12345int main()&#123; CMyDoc myDoc;//假设对应[File/open] myDoc.OnFileOpen();&#125; Inheritance + Composition关系下的构造和析构 继承+复合 第一个问号： 第二个问号：构造函数调用顺序：Component, Base , Derived析构函数则相反。 Delegation(委托) + Inheritance(继承)Observer1234567891011121314151617181920class Subject&#123; int m_value; vector&lt;Observer*&gt; m_views;public: void attach(Observer* obs) &#123; m_views.push_back(obs); &#125; void set_val(int value) &#123; m_value = value; notify(); &#125; void notify() &#123; for(int i = 0; i &lt; m_views.size(); ++i) m_views[i]-&gt;update(this, m_value); &#125;&#125;; 12345class Observer&#123;public: virtual void update(Subject* sub, int value) = 0;&#125;; 委托+继承 Composite Composite 12345class Primitive:public Component&#123;public: Primitive(int val):Component(val) &#123;&#125;&#125;; 1234567class Component&#123; int value;public: Component(int val) &#123; value = val; &#125; virtual void add(Component*) &#123;&#125;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142class Composite:public Component&#123; vector&lt;Component*&gt;c;public: Composite(int val):Component(val) &#123;&#125; void add(Component* elem) &#123; c.push_back(elem); &#125;...&#125;;**Prototype**![Prototype](https://github.com/hubojing/BlogImages/blob/master/C++面向对象程序设计（侯捷）笔记——Prototype.png?raw=true)出自Design Patterns Explained Simply```cpp#include&lt;iostream.h&gt;enum imageType&#123; LSAT, SPOT&#125;;class Image&#123;public: virtual void draw() = 0; static Image *findAndClone(imageType);protected: virtual imageType returnType() = 0; virtual Image* clone() = 0; //As each subclass of Image is declared, it registers its prototype static void addPrototype(Image *image) &#123; _prototypes[_nextSlot++] = image; &#125;private: //addPrototype() saves each registered prototype here static Image* _prototypes[10]; static int _nextSlot;&#125;;Image *Image::prototypes[];//定义int Image::_nextSlot;//定义 123456789//Client calls this public static member function when it needs an instance Image *Image::findAndClone(imageType type)&#123; for(int i = 0; i &lt; _nextSlot; i++) &#123; if(_prototypes[i]-&gt;returnType()) return _prototypes[i]-&gt;clone(); &#125;&#125; 子类123456789101112131415161718192021222324252627282930313233343536373839class LandSatImage:public Image&#123;public: imageType returnType() &#123; return LSAT; &#125; void draw() &#123; cout &lt;&lt; \"LandSatImage::draw\" &lt;&lt; _id &lt;&lt; endl; &#125; //When clone() is called, call the one-argument with a dummy arg Image *clone() &#123; return new LandSatImage(1); &#125;protected: //This is only called from clone() LandSatImage(int dummy) &#123; _id = _count++; &#125;private: //Mechanism for initializing an Image subclass - this causes the default ctor to be called, which registers the subclass's prototype static LandSatImage _landSatImage; //This is only called when the private static data member is inited LandSatImage() &#123; addPrototype(this); &#125; //Nominal \"state\" per instance mechanism int _id; static int _count;&#125;;//Register the subclass's prototypeLandSatImage LandSatImage::_landSatImage;//Initialize the \"state\" per instance mechanismint LandSatImage::_count = 1;","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hubojing.github.io/categories/编程语言/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"}]},{"title":"linux C语言结构体","slug":"linux C语言结构体","date":"2018-07-21T15:42:23.000Z","updated":"2018-07-22T15:45:34.000Z","comments":true,"path":"2018/07/21/linux C语言结构体/","link":"","permalink":"https://hubojing.github.io/2018/07/21/linux C语言结构体/","excerpt":"　　再学C语言，复习&amp;笔记。 ","text":"再学C语言，复习&amp;笔记。 系列顺序：Linux C语言编程基本原理与实践Linux C语言指针与内存Linux C语言结构体 更多Linux知识：一天一点linux 预处理编译的四个步骤：.c文件—&gt;.i文件（预处理）-&gt;.s文件（编译）-&gt;.o文件（汇编）-&gt;可执行文件（链接） gcc -o helloWorld.i helloWorld.c -E-E表示只让helloWorld.c进行预处理 结构体结构体对象所占的空间大小涉及到一个字节对齐的问题。字节对齐的目的是让计算机快速读写，是一个以空间换取时间的方式。结构体对象的大小 = 最后一个成员的偏移量 + 最后一个成员变量的大小 + 填充字节结构体字节对齐准则：当前成员的偏移量必须是成员变量大小的整数倍，不是的话在后面填充字节。最后还要判断结构体大小是不是成员中最大成员类型的整数倍，不是的话还需填充。 例：12345struct data&#123; int a; char b; int b;&#125;; a 4字节，b 1字节，c 4字节计算方法： a的长度为4，为b的长度1的整数倍，故b的偏移量4字节。 b的偏移量+b的长度=5字节，但5不能整除c的长度（4字节），故需填充偏移量到8字节。所以c的偏移量为8。 c的偏移量+c的长度=8+4=12字节，且12字节是最大成员类型（4字节）的整数倍，故结构体所占空间为12字节。 注：C语言结构体和C++结构体定义的区别 C结构体中只能自定义数据类型，不允许有函数。C++结构体可以加入成员函数，且允许该函数是虚函数。所以C结构体没有构造函数、析构函数和this指针。 C结构体对内部成员变量的访问权限只能是public，C++结构体默认是public，可以是public,protected,private三种。 C结构体不可继承，C++结构体可以从其它结构体或类继承。以上是表面区别，实际区别是面向过程和面向对象编程思路的区别：C的结构体只是把数据变量给包裹起来了，并不涉及算法。C++是把数据变量及对这些数据变量的相关算法给封装起来，并且给对这些数据和类不同的访问权限。C语言中没有类的概念，但可通过结构体内创建函数指针实现面向对象思想。 声明定义有区别：12345struct weapon&#123; int price; int atk;&#125;; C语言用struct weapon a;C++可以直接 weapon a; 若C也希望直接声明，则需引入typedef，定义为：12345typedef struct weapon&#123; int price; int atk;&#125;Wea; Wea a; 共用体共用体的作用就使不同的类型的变量共享同一个地址，好处是节省开销，缺点是同一时刻仅仅能存储一个成员。共用体的大小是所有成员中占内存最长的长度，初始化时只能有一个常量。 动态数据结构静态链表每一个结点都是在程序中定义的而不是临时开辟的。12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;struct weapon&#123; int price; int atk; struct weapon \\*next; //指向下一个节点&#125;;int main()&#123; struct weapon a,b,c,\\*head; a.price = 100; a.atk = 100; b.price = 200; b.atk = 200; c.price = 300; c.atk = 300; head = &amp;a; a.next = &amp;b; b.next = &amp;c; c.next = NULL; struct weapon \\*p; p = head; while(p != NULL) &#123; printf(\"%d, %d\\n\", p-&gt;atk, p-&gt;price); p = p-&gt;next; &#125;&#125; 动态链表1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct weapon&#123; int price; int atk; struct weapon \\*next;&#125;;struct weapon * create()&#123; struct weapon * head; struct weapon * p1, *p2;//p1当前结点，p2上一个结点 int n = 0;//记录链表长度 p1 = p2 = (struct weapon*)malloc(sizeof(struct weapon)); scanf(\"%d,%d\",&amp;p1-&gt;price,&amp;p1-&gt;atk); head = NULL; while(p1-&gt;price!=0)//约定价格为0时停止输入 &#123; n++; if(n == 1) &#123; head = p1; &#125; else &#123; p2-&gt;next = p1; &#125; p2 = p1; p1 = (struct weapon*)malloc(sizeof(struct weapon)); scanf(\"%d,%d\",&amp;p1-&gt;price, &amp;p1-&gt;atk); &#125;&#125;int main()&#123; struct weapon *p; p = create(); printf(\"%d,%d\",p-&gt;price,p-&gt;atk); return 0;&#125; 注：更多数据结构知识请参阅《数据结构（C语言版）》。 递归与递推递归：将一个问题规模为n的问题降为规模为(n-1)的问题，然后依次降低规模（层层往下），直至问题得到低规模的解，之后依次带入高规模的问题中（层层往上），最终得到规模为n解。从n -&gt; 1 -&gt; n。递推：先构造解决一个低的规模问题，然后依次（层层往上）推导出高规模的问题解。从1 -&gt; n。","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hubojing.github.io/categories/编程语言/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://hubojing.github.io/tags/Linux/"},{"name":"C","slug":"C","permalink":"https://hubojing.github.io/tags/C/"}]},{"title":"Linux C语言指针与内存","slug":"Linux C语言指针与内存","date":"2018-07-20T15:31:33.000Z","updated":"2018-07-22T15:44:10.000Z","comments":true,"path":"2018/07/20/Linux C语言指针与内存/","link":"","permalink":"https://hubojing.github.io/2018/07/20/Linux C语言指针与内存/","excerpt":"　　再学C语言，复习&amp;笔记。 ","text":"再学C语言，复习&amp;笔记。 系列顺序：Linux C语言编程基本原理与实践Linux C语言指针与内存Linux C语言结构体 更多Linux知识：一天一点linux gdb调试工具的使用gdb -help 查看gdb用法gcc -g main.c -o main.out 编译命令gdb ./main.out 调试命令l （list）列出代码（按回车显示全部）break + 行号 打断点start 开始单步调试n 执行下一行p a 打印a变量在内存中的情况s 进入调用函数内部bt 查看函数堆栈f 1 表示切换函数栈(切换到编号为1的函数)q 退出调试 demomain.c123456789101112131415161718#include &lt;stdio.h&gt;void change(int *a, int *b)&#123; int temp; temp = *a; *a = *b; *b = temp;&#125;int main()&#123; int a = 5; int b = 3; change(&amp;a, &amp;b); printf(\"a = %d\\n, b = %d\\n\", a, b); return 0; &#125; main2.c123456789101112131415161718#include &lt;stdio.h&gt;void change(int a, int b)&#123; int temp; temp = a; a = b; b = temp;&#125;int main()&#123; int a = 5; int b = 3; change(a, b); printf(\"a = %d\\n, b = %d\\n\", a, b); return 0; &#125; 调试main2.c： 调试main2.c 注意change函数传入的是a=5,b=3这两个数值。 调试main.c: 调试main.c 注意change函数传入的是两个地址。 指针与内存32位主机——32位总线（2^32个字节）最多只能放4G内存条。2^10*2^10*2^10^2^2=1024*1024*1024*4字节=1024*1024*4K=1024*4M=4G 2^30=G2^40=T 内存分配 系统内核（48位以上） 栈（暂时存储首先执行的程序状态） 自由可分配内存（可动态分配内存） 堆 数据段（声明一些全局变量或者声明一些常量） 代码段（程序源代码编译后存放在此） C语言语法是不允许直接操作代码段的。 函数调用信息保存在栈(stack)中。 变量的本质是什么？ 变量名它只是一个代号，变量的本质就是内存。 指针保存的是什么？ 指针保存的就是内存地址。 int *pa=&amp;a 指将a的地址传给pa。 p pa看到的是a的地址（&amp;a）。p &amp;pa才能看到pa本身的地址。 GCC会对内存变量分配进行优化：同一种变量类型会放到一块儿。静态变量、常量、全局变量存于内存的数据段（数据段位置高于代码段）。栈区域（最接近系统控制的内存空间）保存的是函数的运行状态：函数执行到哪一个命令？每一个变量保存的什么值？等等。 地址分配：代码,数据段是从下往上分配(先低地址，后高地址)，即：先声明的函数地址小，后声明的函数地址大；栈是从上往下分配(先高地址，后低地址) 函数中静态变量、局部变量区别:局部变量在栈(相对数据段而言的高地址)中，而静态变量在数据段(低地址)中。所以在多次调用函数时，静态变量不会被重新初始化。或者这么说，静态变量的生存周期和数据段相同，局部变量生存时间受调用函数时，所属函数进栈出栈的影响而会重新初始化。全局变量和静态变量都在数据段中，但静态变量是某个函数特有的。 函数指针函数指针格式：返回值类型 (*变量名)(形参列表);p pa指找到数据的内存地址（a的地址）；p *pa指找到pa中的数据；p &amp;pa指找到pa本身的地址。quadrate在代码段时，p quadrate 函数的内存地址(quadrate )p *quadrate 在地址前加*，表示通过地址取值 int quadrate(int a);是一个函数int （*pquadrate)(int a)=&quadrate;则是指向这个函数的指针int s=(*pquadrate)(a)可以调用函数 字符串与数组x/3d 地址 gdb调试打印内存：x代表打印，3代表打印长度，d代表十进制输出例： x/3d 0x7fffffffde14x/6cb c:字符形式 :b byte为单位 数组是指针常量，指针是指针变量。数组当作内存地址输入的话，可以直接当作参数传进去，不用加&amp;取址符。 栈内存中，gcc编译会作内存优化： 使同一数据结构的变量在一起； 先定义的变量内存地址会小于后定义的； 只有堆内存和栈内存可以写入数据，代码段的内存编译以后无法修改。例：char *str=”world”;scanf(“%s”, str);将报错。因为”world”是一个常量，在代码段中，不可更改。char str[]=”hello”;scanf(“%s”, str);正确。str在栈或堆中，可修改。","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hubojing.github.io/categories/编程语言/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://hubojing.github.io/tags/Linux/"},{"name":"C","slug":"C","permalink":"https://hubojing.github.io/tags/C/"}]},{"title":"Linux C语言编程基本原理与实践","slug":"Linux C语言编程基本原理与实践","date":"2018-07-17T14:10:51.000Z","updated":"2018-07-22T15:43:44.000Z","comments":true,"path":"2018/07/17/Linux C语言编程基本原理与实践/","link":"","permalink":"https://hubojing.github.io/2018/07/17/Linux C语言编程基本原理与实践/","excerpt":"　　再学C语言，复习&amp;笔记。 ","text":"再学C语言，复习&amp;笔记。 系列顺序：Linux C语言编程基本原理与实践Linux C语言指针与内存Linux C语言结构体 更多Linux知识：一天一点linux 常用指令sudo管理员权限sudo apt-get update 更新资源（安装软件前最好先更新资源）sudo apt-get install vim(软件名称) 安装某软件cd ~ 进入home目录pwd 显示当前目录路径ls 显示当前文件夹下所有文件夹及文件ls -l 进入当前目录的文件夹目录后查看当前文件夹包含的文件/文件夹的类型、创建时间、用户权限、用户和用户组（最前面是“d”为文件夹；“-”为普通类型的文件）touch + 文件名 新建文件rm + 文件名 删除文件mkdir + 目录名 新建目录vi(vim) + 文件名 使用vim编辑文件clear 清洁屏幕cc -v 检查编译器gcc -v 检查编译器 VIM命令模式：dd 删除整行i 在光标前面插入a 在光标后面插入x 删除单个字符Shift + a 行尾插入Shift + i 行首插入o 下一行插入Shift + o 上行插入:$ 跳到代码末尾 第一个Linux C程序编译文件：1cc a.c 会得到a.out编译文件后查看文件权限：rw-：可读、可写rwx:可读、可写、可执行三个rwx 1创建用户 2与创建用户在同一个用户组 3任意用户运行文件：“.” 当前路径“./” 当前路径下的文件执行文件：./a.out 多文件操作sp max.c 新建max.c文件(窗口打开多个文件)ctrl + w +下箭头 跳转到下一个编辑框ctrl + w +下箭头 跳转到上一个编辑框对应行数+d+d 剪切光标下相应行数的程序9dd（代码占九行，剪切代码）按p粘贴在剪切板的程序set nu 打开行号:wqa 保存所有文件并退出123gcc hello.c -o hello.out 指定编译文件（-o 给编译后的文件重命名）cp a.c b.c 拷贝文件：将a.c拷贝到b.ccat a.c 查看源代码程序 分开编译：1gcc -c 文件名.c -o 文件名.o 函数可以先编译成.o文件，然后再和主文件一起编译成可执行文件。在源代码多的时候可以提高效率。例如：12345678gcc -c max.c -o max.ogcc max.o hello.c./a.outcp max.c min.crm a.outgcc-c min.c -o min.o gcc gcc max.o min.o hello.c./a.out gcc编译流程分为4步：预处理(Pre-Processing) －&gt; 编译(Compling) -&gt; 汇编(Assembling) -&gt; 连接(Linking)预处理：处理#include、#define、#ifdef 等宏命令编译：把预处理完的文件编译为汇编程序.s汇编：把汇编程序.s编译为.o二进制文件链接：把多个二进制文件.o集合（链接）成一个可执行文件 使用别人的静态库.o文件(机器码，无法查看原代码)可以创建.h文件，然后在源程序中#include&lt;文件名.h&gt;来引用。 hello.c12345678910111213#include &lt;stdio.h&gt;#include \"max.h\"#include \"min.h\"int main()&#123; int a1 = 33; int a2 = 21; int maxNum = max(a1, a2); int minNum = min(a1, a2); printf(\"%d,%d\\n\", maxNum, minNum); return 0;&#125; max.c12345678int max(int a, int b)&#123; if(a &gt; b)&#123; return a; &#125;else&#123; return b; &#125;&#125; min.c12345678int min(int a, int b)&#123; if(a &lt; b)&#123; return a; &#125;else&#123; return b; &#125;&#125; max.h1int max(int a, int b); min.h1int min(int a, int b); makeFile的编写与使用make工具可以将大型的开发项目分成若干个模块。make工具可以很清晰和很快捷的编译和整理源文件。 rm *.o 表示删除所有.o文件make -v 检查make版本vi Makefile 编译修改过的部分输出文件：源文件一个tab gcc命令从上到下逐层求精eg:123456hello.out:max.o min.o hello.c gcc max.o min.o hello -o hello.outmax.o:max.c gcc -c max.cmin.o:min.c gcc -c min.c 最后用make命令执行 重复使用make时，中间生成过的文件不需要再生成，没有修改过的文件不用再编译，会直接跳过该段代码，所以更加节省编译时间。 gcc-c 参数的意义：-c 参数是将源代码编译成“目标文件 .o”，不进行连接后面多个目标文件可通过-o链接成可执行文件。不使用这个参数时gcc会直接进行编译链接，生成可执行文件。 main函数详解123456# main函数的完整形式int main（int argc，char* argv[]）&#123; printf(\"hello world\\n\"); return 0;&#125; gcc main.c -o main.out &amp;&amp; ./ main.outecho \\$? 执行成功则返回0 参数123456789int main(int argc,char* argv[])&#123; printf(\"argc is %d\\n\",argc); int i; for(i=0;i&lt;argv;i++)&#123; printf(\"argv[%d] is %s\\n\",i,argv[i]); &#125; return 0;&#125; ./out.c -l -s asd qwe 输出为：123456argc is 5argv[0] is ./m3.outargv[1] is -largv[2] is -aargv[3] is asdargv[4] is qwe 标准输入流输出流以及错误流cio.c1234567891011121314#include &lt;stdio.h&gt; //标准输入输出/*stdinstdoutstderr*/int main()&#123; printf(\"hello world!\\n\"); //输出功能由标准输出流完成，printf是系统封装后的 int a; scanf(\"%d\", &amp;a); //标准输入流，错误流是系统出错的时候的 printf(\"input value is : %d\\n\", a); return 0;&#125; 在输入a.out时，程序执行，系统给程序提供了一个进程，当程序启动时，系统也提供给程序一系列的指针。linux将所有的外设（摄像头，打印机等），都视为文件。当启动应用程序时候，会产生三个文件（stdin，stdout，stderr，即标准输入，输出，错误流）。默认情况下，输入流就是键盘，stdout默认为显示器，可切换为网卡或者打印机。 12printf(\"Please input the value a:\\n\");fprintf(stdout, \"please input the value a:\\n\"); 因为stdout默认是显示器，上两句就是等价的，printf其实就是fprintf封装后得到的。同理，scanf和fscanf等价：12scanf(\"%d\", &amp;a);fscanf(stdin, \"%d\", &amp;a); 错误流：12345if(a &lt; 0)&#123;fprintf(stderr, \"the value must &gt; 0\\n\");return 1;&#125;return 0; 通过返回值1和0,让程序知道出错了。再次编译cc cio.c -o a2.out，我们运行a2.out，输入2则正常执行，当输入-1，则有对应的提示，即错误流发挥作用。其实Linux这个很大的系统，就是由这些类似的小工具完成的。当等于0是为正确，错的话为其他值。标准的输入流，输出流，以及错误流还可以重定向。 Linux几乎可以用于任何领域，这里我们不得不提出linux的通道，管道起到了很重要的作用，不同应用程序之间要配合使用，就需要用到管道。先说输入流，输出流和错误流的重定向机制：12345678910#include &lt;stdio.h&gt;int main()&#123;printf(\"input the int value i:\\n\"); \\\\printf其实对fprintf的封装，是从标准输出流（即stdout）来输出这个过程scanf(\"%d\", &amp;i); //默认输入流是键盘printf(\"input the int value j:\\n\");scanf(\"%d\", &amp;j);printf(\"i+j=%d\\n\", i+j);&#125; cc main.c得到a.out，运行a.out，我们分别输入3和5输入到终端。我们标准输出流是1，输出入是0。&gt;&gt; 标准输出流重新定向符123./a.out 1&gt;&gt; a.txt 输出到a.txt（默认为1，可不写1）./a.out &gt;&gt; a.txt 内容追加下方./a.out &gt; a.txt 内容覆盖 执行命令后，分别输入3回车后再输入5。再使用命令cat a.txt，可以看到已经输出到文件里的内容。错误流重定向：1&gt;标准输出流重定向 2&gt;标准错误流重定向./a.out 1&gt;t.txt 2&gt;f.txt 将正确的输出流重定向输出到t.txt，错误的输出流重定向输出到f.txt &lt;&lt; 标准输入流重新定向符1./a.out &lt; input.txt 将input.txt的内容作为输入流传递给程序a.out 综合使用标准输出流、标准错误流、标准输入流1./a.out 1&gt;t.txt 2&gt;f.txt &lt;input.txt 管道原理及应用ls / 查看根目录ls /etc/ 查看Linux默认配置目录ls /etc/ | grep 关键字符 将etc文件输出到一个管道|管道eg. 要查找某个目录下有多少个文件名包含“ab”，可以写1ls /etc/ | grep ab 将前一个程序输出流重定向到grep，通过管道得到需要的内容。ps -e | grep sshps查看当前的进程，当前操作系统是否开启ssh进程 管道使用demo程序avg.c，求任意个数的平均值：12345678910#include &lt;stdio.h&gt;int main()&#123; int sum, n; scanf(\"%d,%d\", &amp;sum, &amp;n); float v = sum / n; printf(\"v = %f\\n\", v); return 0;&#125; cc avg.c -o avg.out 再写一个统计输入的程序input.c：123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; int flag = 1; int i; int count = 0; int sum = 0; while(flag)&#123; scanf(\"%d\", &amp;i); if(0==i)&#123; break; &#125; count++; sum+=i; &#125;printf(\"%d,%d\\n\",sum,count);return 0;&#125; cc input.c -o input.out结合使用以上两个程序，将所有数据进行统计，执行input.out，之后通过管道经过avg.out计算平均值。./input.out | ./avg.out以上就是通过管道，将两个小程序连接起来得到更复杂的程序的过程。","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hubojing.github.io/categories/编程语言/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://hubojing.github.io/tags/Linux/"},{"name":"C","slug":"C","permalink":"https://hubojing.github.io/tags/C/"}]},{"title":"读取24位bmp像素数据（带透明通道）","slug":"读取24位bmp像素数据（带透明通道）","date":"2018-05-26T02:21:38.000Z","updated":"2018-05-28T11:34:05.000Z","comments":true,"path":"2018/05/26/读取24位bmp像素数据（带透明通道）/","link":"","permalink":"https://hubojing.github.io/2018/05/26/读取24位bmp像素数据（带透明通道）/","excerpt":"　　一种读取24位bitmap资源的全部像素数据（加透明通道）的方法。 ","text":"一种读取24位bitmap资源的全部像素数据（加透明通道）的方法。 相关知识BMP文件的数据按照从文件头开始的先后顺序分为四个部分：◆ 位图文件头(bmp file header)： 提供文件的格式、大小等信息◆ 位图信息头(bitmap information)：提供图像数据的尺寸、位平面数、压缩方式、颜色索引等信息◆ 调色板(color palette)：可选，如使用索引来表示图像，调色板就是索引与其对应的颜色的映射表◆ 位图数据(bitmap data)：图像数据区24位和32位不需要调色板。 提取像素原理24位，除去位图信息头后的剩余部分就是所需的像素信息。需注意的是，它的像素数据按照BGR排列，且数据从位图左下方开始，从左到右，从下到上存储。并且24位位图是没有透明通道的。 但我需要将其转换为RGB排列，且从上到下读取数据。另外我需要能显示透明色，也就是说，将24位位图转换为32位位图，即读取数据时增加一个透明通道（设置为0则透明）。 代码以下是我写的实现该功能的粗糙代码。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071BYTE* GetImageData(CBitmap* cBitmap)&#123; BITMAP bmp; cBitmap-&gt;GetBitmap(&amp;bmp); HBITMAP hbm = (HBITMAP)*cBitmap; HDC hDC = ::GetDC(NULL); LONG width = bmp.bmWidth * 4; LONG height = bmp.bmHeight; //定义位图信息 BITMAPINFO bi; bi.bmiHeader.biSize = sizeof(bi.bmiHeader); bi.bmiHeader.biWidth = bmp.bmWidth; bi.bmiHeader.biHeight = bmp.bmHeight; bi.bmiHeader.biPlanes = 1; bi.bmiHeader.biBitCount = 32; bi.bmiHeader.biCompression = BI_RGB; bi.bmiHeader.biSizeImage = width * height; bi.bmiHeader.biClrUsed = 0; bi.bmiHeader.biImportant = 0; //获取位图数据 BYTE* lpvBits = new BYTE[width * height]; ::ZeroMemory(lpvBits, width * height); ::GetDC(NULL); ::GetDIBits(hDC, hbm, 0, height, lpvBits, &amp;bi, DIB_RGB_COLORS); BYTE buffer = 0; BYTE* pData=new BYTE[width * height]; int temp = 0; for(int i= height - 1;i &gt;= 0; --i) &#123; for(int j=0;j &lt; width; ++j) &#123; if(j % 4 == 0) &#123; BYTE tempBR = 0; tempBR = lpvBits[width * i + j];//b赋给temp lpvBits[width * i + j] = lpvBits[width * i + j + 2];//r赋给b lpvBits[width * i + j + 2] = tempBR;//temp赋给r &#125; if(j % 4 == 3)//透明通道 &#123; if(lpvBits[width * i + j - 3] == 255 &amp;&amp; lpvBits[width * i + j - 2] == 255 &amp;&amp; lpvBits[width * i + j - 1] == 255) &#123; lpvBits[width * i + j] == 0; &#125; else &#123; lpvBits[width * i + j] == 255; &#125; &#125; buffer = lpvBits[width * i + j]; memcpy(&amp;pData[temp++], &amp;buffer, 1); &#125; &#125; if(lpvBits != 0) &#123; delete lpvBits; lpvBits = 0; &#125; ::ReleaseDC(NULL, hDC); DeleteObject(cBitmap); return pData;&#125;","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hubojing.github.io/categories/编程语言/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"}]},{"title":"bmp保存和imagelist读取","slug":"bmp保存和imagelist读取","date":"2018-05-21T14:46:06.000Z","updated":"2018-05-21T14:53:51.000Z","comments":true,"path":"2018/05/21/bmp保存和imagelist读取/","link":"","permalink":"https://hubojing.github.io/2018/05/21/bmp保存和imagelist读取/","excerpt":"　　代码整理。 ","text":"代码整理。 bmp保存123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117bool SaveBitmapToFile(CBitmap* bitmap, LPSTR lpFileName) &#123; HBITMAP hBitmap; // 为刚才的屏幕位图句柄 HDC hDC; //设备描述表 int iBits; //当前显示分辨率下每个像素所占字节数 WORD wBitCount; //位图中每个像素所占字节数 DWORD dwPaletteSize = 0, //定义调色板大小 dwBmBitsSize, //位图中像素字节大小 dwDIBSize, //位图文件大小 dwWritten; //写入文件字节数 BITMAP Bitmap; //位图属性结构 BITMAPFILEHEADER bmfHdr; //位图文件头结构 BITMAPINFOHEADER bi; //位图信息头结构 LPBITMAPINFOHEADER lpbi; //指向位图信息头结构 HANDLE fh, //定义文件 hDib, //分配内存句柄 hPal, //调色板句柄 hOldPal = NULL; //计算位图文件每个像素所占字节数 hBitmap = (HBITMAP)*bitmap; hDC = CreateDC(\"DISPLAY\",NULL,NULL,NULL); iBits = GetDeviceCaps(hDC, BITSPIXEL) * GetDeviceCaps(hDC, PLANES); DeleteDC(hDC); if (iBits &lt;= 1) wBitCount = 1; else if (iBits &lt;= 4) wBitCount = 4; else if (iBits &lt;= 8) wBitCount = 8; else if (iBits &lt;= 24) wBitCount = 24; else if (iBits &lt;= 32) wBitCount = 32; //计算调色板大小 if (wBitCount &lt;= 8) dwPaletteSize = (1 &lt;&lt; wBitCount) * sizeof (RGBQUAD); //设置位图信息头结构 GetObject(hBitmap, sizeof (BITMAP), (LPSTR)&amp;Bitmap); bi.biSize = sizeof (BITMAPINFOHEADER); bi.biWidth = Bitmap.bmWidth; bi.biHeight = Bitmap.bmHeight; bi.biPlanes = 1; bi.biBitCount = wBitCount; bi.biCompression = BI_RGB; bi.biSizeImage = 0; bi.biXPelsPerMeter = 0; bi.biYPelsPerMeter = 0; bi.biClrUsed = 0; bi.biClrImportant = 0; dwBmBitsSize = ((Bitmap.bmWidth * wBitCount+31) / 32) * 4 * Bitmap.bmHeight; //为位图内容分配内存 hDib = GlobalAlloc(GHND, dwBmBitsSize + dwPaletteSize + sizeof (BITMAPINFOHEADER)); lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDib); *lpbi = bi; // 处理调色板 hPal = GetStockObject(DEFAULT_PALETTE); if (hPal) &#123; hDC = ::GetDC(NULL); hOldPal = ::SelectPalette(hDC, (HPALETTE)hPal, FALSE); RealizePalette(hDC); &#125; // 获取该调色板下新的像素值 GetDIBits(hDC, hBitmap, 0, (UINT) Bitmap.bmHeight, (LPSTR)lpbi + sizeof (BITMAPINFOHEADER) + dwPaletteSize, (LPBITMAPINFO)lpbi, DIB_RGB_COLORS); //恢复调色板 if (hOldPal) &#123; SelectPalette(hDC, (HPALETTE)hOldPal, TRUE); RealizePalette(hDC); ::ReleaseDC(NULL, hDC); &#125; //创建位图文件 fh = CreateFile(lpFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL); if (fh == INVALID_HANDLE_VALUE) return FALSE; // 设置位图文件头 bmfHdr.bfType = 0x4D42; // \"BM\" dwDIBSize = sizeof (BITMAPFILEHEADER) + sizeof (BITMAPINFOHEADER) + dwPaletteSize + dwBmBitsSize; bmfHdr.bfSize = dwDIBSize; bmfHdr.bfReserved1 = 0; bmfHdr.bfReserved2 = 0; bmfHdr.bfOffBits = (DWORD)sizeof (BITMAPFILEHEADER) + (DWORD)sizeof (BITMAPINFOHEADER) + dwPaletteSize; // 写入位图文件头 WriteFile(fh, (LPSTR)&amp;bmfHdr, sizeof(BITMAPFILEHEADER), &amp;dwWritten, NULL); // 写入位图文件其余内容 WriteFile(fh, (LPSTR)lpbi, dwDIBSize, &amp;dwWritten, NULL); //清除 GlobalUnlock(hDib); GlobalFree(hDib); CloseHandle(fh); return TRUE; &#125; 调用方法：SaveBitmapToFile(cbm, “1.bmp”); imagelist读取bmp123456789101112131415161718192021222324252627void GetImage(CImageList&amp; imglist, CBitmap&amp; dist ,int num)&#123;CClientDC dc(NULL);IMAGEINFO ii;imglist.GetImageInfo(num, &amp;ii);int nWidth = ii.rcImage.right - ii.rcImage.left;int nHeight = ii.rcImage.bottom - ii.rcImage.top;dist.CreateCompatibleBitmap(&amp;dc, nWidth, nHeight);CDC memDC;memDC.CreateCompatibleDC(&amp;dc);CBitmap* pOldBitmap = memDC.SelectObject(&amp;dist);memDC.FillSolidRect(0, 0, nWidth, nHeight, RGB(255,255,255) );imglist.Draw(&amp;memDC, num, CPoint(0, 0), ILD_NORMAL);memDC.SelectObject(pOldBitmap);memDC.DeleteDC();::DeleteObject(ii.hbmImage);::DeleteObject(ii.hbmMask);&#125; 代码整理自互联网。","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hubojing.github.io/categories/编程语言/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"}]},{"title":"Python开发简单爬虫","slug":"Python开发简单爬虫","date":"2018-03-11T07:42:37.000Z","updated":"2018-03-12T15:16:26.000Z","comments":true,"path":"2018/03/11/Python开发简单爬虫/","link":"","permalink":"https://hubojing.github.io/2018/03/11/Python开发简单爬虫/","excerpt":"　　人生苦短，Python当歌。 ","text":"人生苦短，Python当歌。 简单爬虫架构 简单爬虫架构 简单爬虫架构——运行流程 运行流程 URL管理器和实现方法 URL管理器：管理待抓取URL集合和已抓取URL集合 URL管理器 实现方式 实现方式 网页下载器和urllib2模块 网页下载器：将互联网上URL对应的网页下载到本地的工具 网页下载器 Python的几种网页下载器 urllib2——Python官方基础模块 requests——第三方包更强大 urllib2下载网页的三种方法以下代码基于Python2。 最简洁方法url—&gt;urllib2.urlopen(url) 代码12345678910import urllib2# 直接请求response = urllib2.urlopen('http://www.baidu.com')# 获取状态码，如果是200表示获取成功print response.getcode()# 读取内容cont = response.read() 法2：添加data、http header urllib2法2 代码123456789101112import urllib2# 创建Request对象request = urllib2.Request(url)#添加数据request.add_data('a','1')#添加http的headerrequest.add_header('User-Agent','Mozilla/5.0')# 发送请求获取结果response = urllib2.urlopen(request) 法3：添加特殊情景的处理器 urllib2法3 代码12345678910111213import urllib2, cookielib#创建cookie容器cj = cookielib.CookieJar()# 创建1个openeropener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))# 给urllib2安装openerurllib2.install_opener(opener)# 使用带有cookie的urllib2访问网页response = urllib2.urlopen(\"http://www/baidu.com/\") Python3代码Python版本：3.7123456789101112131415161718192021222324252627# coding:utf8from urllib import requestimport http.cookiejarurl=\"http://www.baidu.com\"print('第一种方法')response1=request.urlopen(url)print(response1.getcode())print(len(response1.read()))print('第二种方法')req=request.Request(url)req.add_header('user-agent','Mozilla/5.0')response2=request.urlopen(req)print(response2.getcode())print(len(response2.read()))print('第三种方法')cj=http.cookiejar.CookieJar()opener=request.build_opener(request.HTTPCookieProcessor(cj))request.install_opener(opener)response3=request.urlopen(url)print(response3.getcode())print(cj)print(response3.read()) 注意：python3要使用urllib.request替换urllib2。 网页解析器和BeautifulSoup第三方模块 网页解析器：从网页中提取有价值数据的工具 网页解析器 Python的几种网页解析器 几种网页解析器 结构化解析-DOM(Document Object Model)树 DOM Beautiful Soup安装官方文档：https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html 安装：pip install beautifulsoup4 安装 pip install bs4 安装bs4 Beautiful Soup语法 BS语法 eg.1&lt;a href=&apos;123.html&apos; class=&apos;article_link&apos;&gt; Python &lt;/a&gt; 节点名称：a节点属性：href=’123.html’节点属性：class=’article_link’节点内容：Python 代码创建BeautifulSoup对象12345678from bs4 import BeautifulSoup# 根据HTML网页字符串创建BeautifulSoup对象soup = BeautifulSoup(html_doc,# HTML文档字符串'html.parser'# HTML解析器from_encoding='utf8'# HTML文档的编码) 搜索节点（find_all,find）1234567891011# 方法：find_all(name, attrs, string)# 查找所有标签为a的节点soup.find_all('a')# 查找所有标签为a，链接符合/view/123.htm形式的节点soup.find_all('a', href='/view/123.htm')soup.find_all('a', href=re.compile(r'/view/\\d+\\.htm'))# 查找所有标签为div，class为abc，文字为Python的节点soup.find_all('div', class_='abc', string='Python') 访问节点信息12345678910# 得到节点：&lt;a href='1.html'&gt;Python&lt;/a&gt;#获取查找到的节点的标签名称node.name# 获取查找到的a节点的href属性node['href']# 获取查找到的a节点的链接文字node.get_text() Python3测试12345678910111213141516171819202122232425262728293031323334353637# coding:utf8from bs4 import BeautifulSoupimport rehtml_doc = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;Elsie&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"soup=BeautifulSoup(html_doc, 'html.parser')print('获取所有的链接')links = soup.find_all('a')for link in links: print(link.name, link['href'], link.get_text()) print('获取lacie的链接')link_node = soup.find('a', href='http://example.com/lacie')print(link_node.name, link_node['href'], link_node.get_text())print('正则匹配')link_node = soup.find('a', href=re.compile(r\"ill\"))print(link_node.name, link_node['href'], link_node.get_text())print('获取p段落文字')p_node = soup.find('p', class_=\"title\")print(p_node.name, p_node.get_text()) 结果： 结果 爬取百度百科1000个页面的数据分析确定目标—&gt;分析目标（URL格式、数据格式、网页编码）—&gt;编写代码—&gt;执行爬虫 目标：百度百科Python词条相关词条网页——标题和简介 入口页：http://baike.baidu.com/item/Python/ URL格式： 词条页面URL：/item/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6 数据格式： 标题： 123 &lt;dd class=&quot;lemmaWgt-lemmaTitle-title&quot;&gt;&lt;h1&gt;***&lt;/h1&gt;&lt;/dd&gt; 简介： 1&lt;div class=&quot;lemma-summary&quot; label-module=&quot;lemmaSummary&quot;&gt;***&lt;/div&gt; 页面编码：UTF-8 易错处及解决 url易变，以后需结合最新url修改正则表达式或总入口url。 若只能爬取到一条数据，注意有些url是没有summary的，需添加 1234summary_node = soup.find('div', class_='lemma-summary')#添加判空判断if summary_node is None:return outputer.html为空时，检查代码outputer代码是否有误。这种情况通常是data为空，可以断点调试一下，定位问题。比如我的问题在html_parser中_get_new_data函数中将lemma-summary写为了lemmasummary。 outputer.html乱码时，检查编码问题。Python3将编码写在open里。123456789101112131415fout = open('output.html', 'w', encoding='utf-8') fout.write(\"&lt;html&gt;\") fout.write(\"&lt;body&gt;\") fout.write(\"&lt;table&gt;\") for data in self.datas: fout.write(\"&lt;tr&gt;\") fout.write(\"&lt;td&gt;%s&lt;/td&gt;\" % data['url']) fout.write(\"&lt;td&gt;%s&lt;/td&gt;\" % data['title']) fout.write(\"&lt;td&gt;%s&lt;/td&gt;\" % data['summary']) fout.write(\"&lt;/tr&gt;\") fout.write(\"&lt;/table&gt;\") fout.write(\"&lt;/body&gt;\") fout.write(\"&lt;/html&gt;\") fout.close() 结果 经测试，爬1000个页面用时为12min（比较慢），全部爬取成功。 控制台 爬虫数据 输出的html html 全部代码下载地址https://github.com/hubojing/PythonSpider 感谢慕课平台。","raw":null,"content":null,"categories":[{"name":"软件开发","slug":"软件开发","permalink":"https://hubojing.github.io/categories/软件开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hubojing.github.io/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://hubojing.github.io/tags/爬虫/"}]},{"title":"计算机图形学学习笔记","slug":"计算机图形学学习笔记","date":"2018-03-05T13:55:05.000Z","updated":"2020-12-01T06:00:51.621Z","comments":true,"path":"2018/03/05/计算机图形学学习笔记/","link":"","permalink":"https://hubojing.github.io/2018/03/05/计算机图形学学习笔记/","excerpt":"　　　　每周一点图形学重启，不弃坑。。。。。。　　几年之后的最新：多边形图像转换补完   　　","text":"每周一点图形学重启，不弃坑。。。。。。 几年之后的最新：多边形图像转换补完 帧缓冲器及分辨率帧缓冲器每一个存储单元的位长决定了一幅画面上能同时显示的不同灰度的数目或颜色的种类。如果是单色，则每个像素只需要1Bit表示；如果是16色，则每个像素需要4Bit(2^4=16)表示；如果是256色，则每个需要1个字节（8位，2^8=256）表示；如果是65536（64K）色，则每个像素需要2个字节（16位，2^16=64K）表示；如果是16777216（16.7M）色，则每个需要3个字节（24位，2^24=16.7M）表示（24位真彩色）。 举例：显卡有2MB显存，当分辨率是1024x768时，可支持的色彩数又是多少？2MB=2x1024x1024=2097152(字节)1024x768=786432(个像素)每个像素如果需要3个字节表示，将超过2MB显存，最多只需要2个字节表示，故只能支持64K色彩数。 题目：显示颜色64K，分辨率为1024*1024的显示器，至少需要的帧缓存容量为(C)A.1MB B.3MB C.2MB D.512KB 解：显示颜色64K，故每个像素需要2个字节表示。1024x1024=1048576(个像素)，1048576x2=2097152(字节)2097152/1024/1024=2MB 二维图形变换两大基本工具：向量分析 图形变换 向量分析向量线性组合w=a1v1+a2v2+…+anvn 仿射组合a1+a2+…+am=1 凸组合a1+a2+…+am=1i=1,2,…,m ai≥0 点积a=(a1,a2) b=(b1,b2)a·b=a1b1+a2b2点积最重要的应用是计算两个向量的夹角或者两条直线的夹角。b·c=|b||c|cosθcosθ=(b·c)/(|b||c|)=b的单位向量·c的单位向量b·c &gt; 0 θ &lt; 90°b·c = 0 θ = 90°b·c &lt; 0 θ &gt; 90° 如何设计一个算法描述任意两篇新闻的相似性？用一个向量来描述一篇新闻。当夹角的余弦接近1时，相似，归为一类。夹角余弦越小，两条新闻越不相关。 叉积 叉积公式 axb和a、b两个向量都正交 axb的长度等于由a和b决定的平行四边形面积axb=|a||b|sinθ利用叉积求平面的法向量 图形变换将程序中用于描述对象几何信息的数值和那些用于表示对象中大小和位置的数值区分开来。前者通常被看作一个建模（modeling）的任务，后者是一个观察（viewing）的任务。图形显示的过程是几何（对象）模型在不同坐标系之间的映射变换。 分类世界坐标系用最适合手中问题的坐标系来描述对象，并且可以自动的缩放和平移图形，使得其能正确地在屏幕窗口中显示。建模坐标系（局部坐标系）建模坐标系独立于世界坐标系来定义物体的几何特性观察坐标系观察坐标系主要用于从观察者的角度对整个世界坐标系内的对象进行重新定位和描述。依据观察窗口的方向和形状在世界坐标系中定义的坐标系成为观察坐标系。观察坐标系用于指定图形的输出范围。二维观察变换的一般方法是在世界坐标系中指定一个观察坐标系统，以该系统为参考通过选定方向和位置来指定矩形剪裁窗口。设备坐标系适合特定输出设备输出对象的坐标系。比如屏幕坐标系。在多数情况下，对于每一个具体的显示设备，都有一个单独的坐标系统。设备坐标是整数。规范化坐标系规范化坐标系独立于设备，能容易地转变为设备坐标系，是一个中间坐标系。为使图形软件能在不同的设备之间移植，采用规范化坐标，坐标轴取值范围是0-1。 二维变换变换图形就是要变换图形的几何关系，即改变顶点的坐标；同时，保持图形的原拓扑关系不变。仿射变换（Affine Transformation或Affine Map）是一种二维坐标到二维坐标之间的线性变换。（1）“平直性”。即：直线经过变换之后依然是直线（2）“平行性”。即：平行线依然是平行线，且直线上点的位置顺序不变） 齐次坐标如n维向量（p1,p2,…,pn）表示为（hp1,hp2,…,hpn,h），其中h称为哑坐标。普通坐标与齐次坐标的关系为“一对多”：普通坐标×h→齐次坐标齐次坐标÷h→普通坐标当h = 1时产生的齐次坐标称为“规格化坐标”，因为前n个坐标就是普通坐标系下的n维坐标 基本几何变换 平移变换 12x*=x+Txy*=y+Ty 比例变换 12x*=x·Sxy*=y·Sy 对称变换（反射变换/镜像变换） 旋转变换 1234x*=rcos(α+θ)=rcosαcosθ-rsinαsinθy*=rsin(α+θ)=rcosasinθ+rsinαcosθx*=xcosθ-ysinθy*=xsinθ+ycosθ 错切变换 12x*=x+cyy*=bx+y 坐标系变换1.平移变换2.旋转变换相对任意参考点的二维几何变换比例、旋转变换等均与参考点相关。如要对某个参考点（xf，yf）作二维几何变换，其变换过程如下：a、将固定点移至坐标原点，此时进行平移变换b、针对原点进行二维几何变换c、进行反平移，将固定点又移回到原来的位置二维变换矩阵 二维变换矩阵 二维变换矩阵说明 窗口视区变换窗口：世界坐标系中药显示的区域成为窗口。视区：窗口映射到显示器（设备）上的区域称为视区。观察变换（Viewing Transformation），将窗口到视区的变换处理。 窗口视区变换 窗口到视区的映射是基于一个等式，即对每一个在世界坐标下的点（x,y），产生屏幕坐标系中的一个点（sx,sy）。12sx=A*x+Csy=B*y+D A、B、C、D为常数 映射关系 公式 公式 三维图形几何变换三维空间中某点的变换可以表示成点的齐次坐标与四阶的三维变换矩阵相乘： 三维变换矩阵 T3D 基本变换平移变换 三维平移 比例变换局部比例变换 局部比例变换 整体比例变换 整体比例变换 旋转变换绕z轴旋转θ 三维绕z旋转 绕x轴旋转 三维绕x旋转 绕y轴旋转 三维绕y旋转 对称变换关于坐标平面的对称xoy:[x’ y’ z’ 1] = [x y -z 1]yoz:[x’ y’ z’ 1] = [-x y z 1]zox:[x’ y’ z’ 1] = [x -y z 1] 关于坐标轴对称x:[x’ y’ z’ 1] = [x -y -z 1]y:[x’ y’ z’ 1] = [-x y -z 1]z:[x’ y’ z’ 1] = [-x -y z 1] 投影变换在二维平面上显示三维物体的解决方法：投影变换。 平面几何投影分类 正投影根据投影面与坐标轴的夹角又可分为两类：三视图和正轴侧图。当投影面与某一坐标轴垂直时，得到的投影为三视图，这时投影方向与这个坐标轴的方向一致；否则，得到的投影为正轴侧图。 三视图的计算具体计算步骤如下：a、确定三维物体上各点的位置坐标；b、引入齐次坐标，求出所作变换相应的变换矩阵；c、将所作变换用矩阵表示，通过运算求得三维物体上各点经变换后的点坐标值；d、由变换后得到的二维点绘出三维物体投影后的三视图 主视图投影变换矩阵：[x’ y’ z’ 1] = [x 0 z 1] 俯视图投影变换矩阵：[x’ y’ z’ 1] = [x y 0 1]为了使俯视图与主视图都画在一个平面内，就要使H面绕x轴顺时针转90°，即应有一个旋转变换。为了使主视图和俯视图有一定的间距，还要使H面沿z方向平移一段距离-z0，有一个平移矩阵。所以，最终俯视图投影变换矩阵：[x’ y’ z’ 1] = [x y -(y+z0） 1] 侧视图为了使侧视图与主视图也在一个平面内，就要使W面绕z轴正转90°，有一个旋转矩阵。为使主视图和侧视图有一定的间距，还要使W面沿负x方向平移一段距离-x0，有一个平移矩阵。所以，最终侧视图投影变换矩阵：[x’ y’ z’ 1] = [-(y+z0) 0 z 1] 三个视图中的y’均为0，表明三个视图均落在xoz面上。 正轴测图正轴测有等轴测、正二测和正三测三种：当投影面与三个坐标轴之间的夹角都相等时为等轴测当投影面与两个坐标轴之间的夹角相等时为正二测当投影面与三个坐标轴之间的夹角都不相等时为正三测变换矩阵为：123x*=xcosγ-ysinγy*=0z*=-xsinγsinα-ycosγsina+zcosα 透视投影 T3D 其中的[p,q,r]能产生透视变换的效果 一点透视灭点：聚焦的那个点 多点透视多个灭点 构造二点透视的一般步骤如下：（1）将物体平移到适当位置l、m、n（2）将物体绕y轴旋转θ角（3）进行透视变换（4）最后向xoy面做正投影，即得二点透视图 构造三点透视的一般步骤如下：（1）将物体平移到适当位置（2）将物体绕y轴旋转θ角（3）再绕x轴旋转α角（4）进行透视变换（5）最后向xoy面做正投影，即得三点透视图 光栅图形学算法研究内容 直线段的扫描转换算法 多边形的扫描转换与区域填充算法 裁剪算法 反走样算法 消隐算法 直线段的扫描转换算法P0（x0,y0） P1(x1,y1)y=kx+bk=(y1-yo)/(x1-x0) (x1≠x0)假设x已知，即从x的起点xo开始，沿x方向前进一个像素（步长=1），可以计算出相应的y值。因为像素的坐标是整数，所以y值要进行取整处理。如何把数学上的一个点扫描转换一个屏幕像素点？如：P（1.7, 0.8）—(取整)—&gt;P(1, 0)P(1.7, 0.8) -(+0.5)-&gt; p(2.2, 1.3)P(2.2, 1.3) -(取整)-&gt; p(2, 1)为提高效率，减小计算量，要把乘法消掉。 直线绘制的三个著名的常用算法 数值微分法（DDA） 中点画线法 Bresenham算法 数值微分DDA（Digital Differential Analyzer）引进图形学中一个重要思想——增量思想直线斜率小于1：x=x+1y=y+k(注意y+0.5化为整数)直线斜率大于1：x=x+1/ky=y+1（注意x+0.5化为整数） DDA算法代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void CDrawLinesDlg::DDALine(int iBeginX, int iBeginY, int iEndX, int iEndY, COLORREF col)&#123; CDC *pDC = GetDC(); pDC-&gt;TextOut(450, 18, _T(\"DDA画线成功！\")); float x, y, dx, dy, k, r; float xm, ym; dx = iEndX - iBeginX; dy = iEndY - iBeginY; k = dy / dx; r = dx / dy;//r为斜率倒数 x = iEndX; y = iEndY; xm = iBeginX; ym = iBeginY; if (abs(dx) &gt; abs(dy))//斜率小于1 &#123; if (iBeginX &lt;= iEndX) &#123; x = iBeginX; xm = iEndX; y = iBeginY; ym = iEndY; &#125; while(x &lt;= xm) &#123; y = y + k; pDC-&gt;SetPixel(x, (int)(y + 0.5), col); ++x; &#125; &#125; else//斜率大于1 &#123; if (iBeginY &lt;= iEndY) &#123; x = iBeginX; xm = iEndX; y = iBeginY; ym = iEndY; &#125; while (y &lt;= ym) &#123; x = x + r; pDC-&gt;SetPixel((int)(x + 0.5), y, col); ++y; &#125; &#125;&#125; 中点画线法核心思想：考虑斜率小于1，若x每次+1，y值要么+1，要么不+1。直线一般式方程；Ax+By+C=0设y+1和y之间的中点M，把M带入方程。d=Ax+By+Cd &lt; 0 M在直线下方 选上面那个点(y+1)d &gt; 0 M在直线上方 选下面那个点(y) 中点画线法代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101void CDrawLinesDlg::MidLine(int iBeginX, int iBeginY, int iEndX, int iEndY, COLORREF col)&#123; CDC *pDc = GetDC(); pDc-&gt;TextOut(450, 18, _T(\"中点画线法成功！\")); int d1, d2, d; int num = 0; int p, p1, q, q1; int x = iBeginX; int y = iBeginY; int a = iBeginY - iEndY; int b = iEndX - iEndY; int dx = abs(iBeginX - iEndX); int dy = abs(iBeginY - iEndY); //第二、四象限 if (((iEndX - iBeginX &gt;= 0) &amp;&amp; (iEndY - iBeginY&lt;0)) || ((iEndX - iBeginX &lt;= 0) &amp;&amp; (iEndY - iBeginY&gt;0))) &#123; //从第四象限到第二象限 if ((iEndX - iBeginX &lt;= 0) &amp;&amp; (iEndY - iBeginY &gt; 0)) &#123; a = -a; b = -b; x = iEndX; y = iEndY; &#125; //斜率小于1 if (dx &gt;= dy) &#123; num = dx;//以x轴为基准 p = 1; p1 = 0; q = 1; q1 = -1; d = 2 * a - b;//初始值 d2 = 2 * a;//当大于0时的增量 d1 = 2 * (a - b);//当小于0时的增量 &#125; else &#123; num = dy;//以y轴为基准 p = 1; p1 = -1; q = 0; q1 = -1; d = a - 2 * b; d1 = -(2 * b); d2 = 2 * (a - b); &#125; &#125; else//第一、三象限 &#123; if ((iEndX - iBeginX &lt;= 0) &amp;&amp; (iEndY - iBeginY &lt; 0)) &#123; a = -a; b = -b; x = iEndX; y = iEndY; &#125; if (dx &gt;= dy) &#123; num = dx; p = 1; p1 = 1; q = 1; q1 = 0; d = 2 * a + b; d1 = 2 * a; d2 = 2 * (a + b); &#125; else &#123; num = dy; p = 0; p1 = 1; q = 1; q1 = 1; d = a + 2 * b; d2 = 2 * b; d1 = 2 * (a + b); &#125; &#125; pDc-&gt;SetPixel(x, y, col); for (int i = 0; i &lt;= num; ++i) &#123; if (d &lt; 0)//d(new)=d(old)+A+B 选Pu(上面一点) &#123; x += p; y += p1; d += d2; &#125; else//d(new)=d(old)+A 选Pd(下面一点) &#123; x += q; y += q1; d += d1; &#125; pDc-&gt;SetPixel(x, y, col); &#125;&#125; Bresenham算法 算法步骤 Bresenham算法代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void CDrawLinesDlg::BresenhamLine(int iBeginX, int iBeginY, int iEndX, int iEndY, COLORREF col)&#123; CDC *pDC = GetDC(); pDC-&gt;TextOut(450, 18, _T(&quot;Bresenham画线成功！&quot;)); int dx = abs(iEndX - iBeginX); int dy = abs(iEndY - iBeginY); int x = iBeginX; int y = iBeginY; int stepX = 1; int stepY = 1; if (iBeginX &gt; iEndX) //从右向左画 &#123; stepX = -1; &#125; if (iBeginY &gt; iEndY)//从下往上画 &#123; stepY = -1; &#125; if (dx &gt; dy) //斜率大于1 &#123; int e = dy * 2 - dx; for (int i = 0; i &lt;= dx; i++) &#123; pDC-&gt;SetPixel(x, y, col); x += stepX; e += dy; if (e &gt;= 0) &#123; y += stepY; e -= dx; &#125; &#125; &#125; else//斜率小于1 &#123; int e = 2 * dx - dy; for (int i = 0; i &lt;= dy; i++) &#123; pDC-&gt;SetPixel(x, y, col); y += stepY; e += dx; if (e &gt;= 0) &#123; x += stepX; e -= dy; &#125; &#125; &#125;&#125; 三者区别：DDA是浮点数加法，中点画线是整数加法，Bresenham不判断大小，是判断符号。 多边形扫描转换多边形的扫描转换和区域填充这个问题是怎么样在离散的像素集上表示一个连续的二维图形多边形有两种重要的表示方法：顶点表示和点阵表示顶点表示是用多边形的顶点序列来表示多边形。这种表示直观、几何意义强、占内存少，易于进行几何变换但由于它没有明确指出哪些像素在多边形内，故不能直接用于面着色 点阵表示是用位于多边形内的像素集合来刻画多边形。这种表示丢失了许多几何信息（如边界、顶点等），但它却是光栅显示系统显示时所需的表示形式。 涉及两个问题：1、 如果知道边界，能否求出哪些像素在多边形内？2、 如果知道多边形内部的像素，反过来如何求多边形的边界？——得不到，不是计算机图形学问题，属于图像识别领域 光栅图形的一个基本问题是把多边形的顶点表示转换为点阵表示。这种转换称为多边形的扫描转换。多边形分为凸多边形、凹多边形、含内环的多边形等凸多边形：任意两顶点间的连线均在多边形内凹多边形：任意两顶点间的连线有不在多边形内含内环的多边形：多边形内包含多边形 现在的问题：知道多边形的边界，如何找到多边形内部的点，即把多边形内部填上颜色 X-扫描线算法基本思想：按照扫描线顺序，计算扫描线与多边形的相交区间，再用要求的颜色显示这些区间的像素，即完成填充工作区间的端点可以通过计算扫描线与多边形边界线的交点获得步骤：1、 确定多边形所占有的最大扫描线数，得到多边形顶点的最小和最大y值（ymin和ymax）2、 从y = ymin到y = ymax，每次用一条扫描线进行填充3、 对一条扫描线填充的过程分为四步：a. 求交：计算扫描线与多边形各边的交点b. 排序：把所有交点按递增顺序进行排序c. 交点配对：第一个与第二个，第三个与第四个d. 区间填色：把这些相交区间内的像素置成不同于背景色的填充色 当扫描线与多边形顶点相交时，交点的取舍问题（交点的个数应保证为偶数个）解决方案：1、 若共享顶点的两条边分别落在扫描线的两边，交点只算一个2、 若共享顶点的两条边在扫描线的同一边，这时交点作为零个或两个检查共享顶点的两条边的另外两个端点的y值，按这两个y值中大于交点y值的个数来决定交点数为了计算每条扫描线与多边形各边的交点，最简单的方法是把多边形的所有边放在一个表中。在处理每条扫描线时，按顺序从表中取出所有的边，分别与扫描线求交。该算法效率低。求交计算量很大。但排序、配对、填色总是要的。 改进的x扫描线算法扫描转换算法重要意义是提出了图形学里两个重要的思想：1、 扫描线2、 增量思想 三方面改进：1、 在处理一条扫描线时，仅对与它相交的多边形的边（有效边）进行求交运算2、 考虑扫描线的连贯性，即当前扫描线与各边的交点顺序与下一条扫描线与各边的交点顺序很可能相同或非常相似3、 最后考虑多边形的连贯性，即当某条边与当前扫描线相交时，它很可能也与下一条扫描线相交 为了避免求交运算，需引入一套特殊的数据结构：1、 活性边表（AET）：把与当前扫描线相交的边称为活性边，并把他们按与扫描线交点x坐标递增的顺序存放在一个链表中。2、结点内容：x：当前扫描线与边的交点坐标△x：从当前扫描线到下一条扫描线间x的增量ymax：该边所交的最高扫描线的坐标值ymaxnext：指向下一条边的指针 随着扫描线的移动，扫描线与多边形的交点和上一次交点相关：设边的直线斜率为kk = △y/△x = (yi+1 - yi) / (xi+1 - xi)xi+1 - xi = 1/kxi+1 = xi + 1/k(1/k即为增量)即△x = 1/k 另外需要知道一条边何时不再与下一条扫描线相交，以便及时把它从有效边表中删除出去，避免下一步无谓计算。 为了方便活性边表的建立与更新，需构造一个新边表（NET），用来存放多边形的边的信息，步骤：1、构造一个纵向链表，链表长度为多边形所占有的最大扫描线数，链表的每个节点，称为一个吊桶，对应多边形覆盖的每一条扫描线2、NET挂在与该边低端y值相同的扫描线桶中。即存放在该扫描线第一次出现的边ymax：该边的ymaxxmin：该边较低点的x坐标值xmin1/k：该边的斜率1/knext：指向下一条具有相同较低端y坐标的边的指针每做一次新的扫描线时，要对已有的边进行三个处理：1、是否被去除掉2、如果不被去除，第二就要对它的数据进行更新。即更新它的x值，x+ 1/k3、看有没有新的边进来，新的边在NET里，可插入排序插进来该算法避免了求交运算。缺点：无法实现对未知边界的区域填充。 边缘填充算法基本思想：按任意顺序处理多边形的每条边。在处理每条边时，首先求出该边与扫描线的交点，然后将每一条扫描线上交点右方的所有像素取补。多边形的所有边处理完毕后，填充即完成。算法简单，但对复杂模型，每一像素可能被访问多次。输入和输出量比有效边算法大得多。 为了减少边缘填充法访问像素的次数，可采用栅栏填充算法。 栅栏填充算法栅栏指的是一条过多边形顶点且与扫描线垂直的直线。它把多边形分为两半。在处理每条边与扫描线的交点时，将交点与栅栏之间的像素取补。 边界标志算法帧缓冲器中对多边形的每条边进行直线扫描转换，即对多边形边界所经过的像素打上标志。然后再采用和扫描线算法类似的方法将位于多边形内的各个区段着上所需颜色。由于边界标志算法不必建立维护边表以及对它进行排序，所以边界标志算法更适合硬件实现，这时它的执行速度比有序边表算法快一至两个数量级。 区域填充算法区域——指已经表示成点阵形式的填充图形，是像素的集合。区域填充是指将区域内的一点（常称种子点）赋予给定颜色，然后将这种颜色扩展到整个区域内的过程。区域可采用内点表示和边界表示两种表示形式。区域填充算法要求区域是连通的。区域可分为4向连通区域（上下左右）和8向连通区域（上下左右、左上、左下、右上、右下）。 简单四连通种子填充算法（区域填充递归算法）原理：假设在多边形区域内部有一像素已知，由此出发找到区域内的所有像素，用一定的颜色或灰度来填充。假设区域采用边界定义，即区域边界上所有像素均具有某个特定值，区域内部所有像素均不取这一特定值，而边界外的像素则可具有与边界相同的值。使用栈结构来实现简单的种子填充算法：种子像素入栈，当栈非空时重复以下操作：1、 栈顶像素出栈2、 将出栈像素置成要填充色3、 按左、上、右、下顺序检查与栈像素相邻 的四个像素，若其中某个像素不在边界且未置成填充色，则把该像素入栈 不足：1、 有些像素入栈多次，降低算法效率；栈结构占空间2、 递归执行，算法简单，但效率不高。区域内每一像素都引进一次递归，进/出栈，费时费内存3、 改进算法，减少递归次数，提高效率可采用区域填充的扫描线算法 多边形的扫描转换与区域填充算法小结 基本思想不同多边形扫描转换是指将多边形的顶点表示转化为点阵表示区域填充只改变区域的填充颜色，不改变区域表示方法 基本条件不同在区域填充算法中，要求给定区域内一点作为种子点，然后从这一点根据连通性将新的颜色扩散到整个区域扫描转换多边形是从多边形的边界（顶点）信息出发，利用多种形式的连贯性进行填充的烧苗转换区域填充的核心是知道多边形的边界，要得到多边形内部的像素集，有多种方法。其中扫描线算法是利用一套特殊的数据结构，避免求交，然后一条条扫描线确定。区域填充条件更强一些，不但知道边界，而且还知道区域内的一点，可以利用四连通或八连通区域不断往外扩展。 填充一个定义的区域的选择包括：选择实区域颜色或图案填充方式选择某种颜色和图案 这些填充选择可应用于多边形区域或用曲线边界定义的区域；此外，区域可用多种画笔、颜色和透明度参数来绘制。 反走样以上待填坑 裁剪算法使用计算机处理图形信息时，计算机内部存储的图像往往比较大，而屏幕显示的只是图形的一部分。因此需要确定图形哪些部分落在显示区之内，哪些落在显示区之外。这个选择的过程称为裁剪。最简单的裁剪方法是把各种图形扫描转换为点之后，再判断点是否在窗口内。 点的裁剪对于任意一点P(x, y)若满足下列两个不等式：xleft ≤ x ≤ xrightybottom ≤ y ≤ ytop则点P在矩形窗口内；否则在矩形窗口外但判断图形中每个点是否在窗口内，太费时，一般不可取 直线段的裁剪直线段裁剪算法是复杂图形裁剪的基础直线段和剪裁窗口的可能关系： 完全落在窗口内 完全落在窗口外 与窗口边界相交要裁剪一条直线段，首先要判断：（1）它是否完全落在裁剪窗口内？（2）它是否完全在窗口外？（3）如果不满足以上两个条件，则计算它与一个或多个裁剪边界的交点常用的裁剪算法有三种：Cohen-Sutherland、中点分割法、Liang-Barsky裁剪算法 Cohen-Sutherland算法本算法又称为编码裁剪算法，基本思想： 若点p1和p2完全在裁剪窗口内“简取”之 若点p1(x1, y1)和p2(x2, y2)均在窗口外，且满足下列四个条件之一：x1 &lt; xleft 且 x2 &lt; xleftx1 &gt; xright 且 x2 &gt; xrighty1 &lt; ybottom 且 y2 &lt; ybottomy1 &lt; ytop 且 y2 &lt; ytop 这四种类型的直线，“简弃”之 既不满足“简取”也不满足“简弃”需要对直线段按交点进行分段，分段后判断直线是“简取”还是“简弃”每条线段的端点都赋以四位二进制码D3D2D1D0，编码规则如下：若x &lt; xleft ，则D0=1，否则为0若x &gt; xright ，则D1=1，否则为0若y &lt; ybottom ，则D2=1，否则为0若y &lt; ytop ，则D3=1，否则为0 Cohen-Sutherland算法 窗口及其延长线构成了9个区域。根据编码规则：D0对应窗口左边界D1对应窗口右边界D2对应窗口下边界D3对应窗口上边界 裁剪一条线段时，先求出端点p1和p2的编码code1和code2，然后进行二进制“或”运算和“与”运算。（1）若code1|code2=0，对直线段简取之（2）若code1&amp;code2≠0，对直线段简弃之（3）若上述两条件均不成立需求出直线段与窗口边界的交点在交点处把线段一分为二 比较适合两种情况：一是大部分线段完全可见；二是大部分线段完全不可见 存在的问题： 最坏情况 或：0001 | 0100 = 0101与：0001 &amp; 0100 = 0000最坏情况下，被裁剪线段与窗口4条边计算交点，然后所得的裁剪结果却可能是全部舍弃。 中点分割算法和Cohen-Sutherland算法一样，首先对直线段的端点进行编码。把线段和窗口的关系分成三种情况： 完全在窗口内 完全在窗口外 和窗口有交点 核心思想：通过二分逼近来确定直线段与窗口的交点。注意：1. 若中点不在窗口内，则把中点和离窗口边界最远点构成的线段丢掉，以线段上的另一点和该中点再构成线段求其中点。 图1 如中点再窗口内，则又以中点和最远点构成线段，并求其中点，直到中点与窗口边界的坐标值在规定的误差范围内相等。 图2 中点分割算法会不会无限循环二分下去？不会。因为屏幕像素有限。 假如屏幕分辨率是1024*1024，请问被裁减线段最多被分割几次？10次。 Liang-Barsky算法主要思想：（1）用参数方程表示一条直线 用参数方程表示一条直线 x = x1 + u · (x2 - x1) = x1 + △x · uy = y1 + u · (y2 - y1) = y1 + △y · u(0 ≤ u ≤ 1) （2）把被裁剪的红色直线段看成是一条有方向的线段，把窗口的四条边分成两类：入边和出边裁剪结果的线段起点是直线和两条入边的交点以及始端点三个点里最前面的一个点，即参数u最大的那个点；裁剪线段的终点是和两条出边的交点以及端点最后面的一个点，取参数u最小的那个点。 梁算法的主要思想 即取图中的绿点。 注意，当u从负无穷到正无穷遍历直线时，首先对裁剪窗口的两条边界直线（下边和左边）从外面向里面移动，再对裁剪窗口两条边界直线（上边和右边）从里面向外面移动。 梁算法 如果用u1, u2分别表示线段（u1 ≤ u2）可见部分的开始和结束u1 = max(0, u1, ub)u2 = min(1, ut, ur) 若窗口如下 梁算法之窗口 xleft ≤ x1 + u · △x ≤ xrightybottom ≤ y1 + u · △y ≤ ytop 简单的推导变形后： 梁算法推导1 梁算法推导2 （1）分析Pk = 0的情况若P1 = P2 = 0 P1=P2=0 平行于y轴 若P3 = P4 = 0 P3=P4=0 平行于x轴 任何平行于窗口某边界的直线，其Pk=0 如果还满足qk &lt; 0 pk=0, qk 则线段完全在边界外，应舍弃 如果qk ≥ 0 ，则进一步判断 (2)当pk ≠ 0 时：当pk &lt; 0时线段从裁剪边界延长线的外部延伸到内部，是入边交点当pk &gt; 0时线段从裁剪边界延长线的内部延伸到外部，是出边交点 线段和窗口边界一共有四个交点，根据pk的符号，就知道哪两个是入交点，哪两个是出交点 当pk &lt; 0时：对应入边交点当pk &gt; 0时：对应出边交点 一共四个u值，再叫上u=0、u=1两个端点值，总共六个值 把pk &lt; 0的两个u值和0比较去找最大的，把pk &gt; 0的两个u值和1比较去找最小的，这样得到两个端点的参数值。 uk = qk / pk (pk≠0， k = 1,2,3,4)uk是窗口边界及其延长线的交点的对应参数值 umax =max(0, uk|pk &lt; 0, uk|pk &lt; 0)umin =min(0, uk|pk &gt; 0, uk|pk &gt; 0, 1) 注意：pk &lt; 0，代表入边；pk &gt; 0代表出边 umax &gt; umin，则直线段在窗口外，删除该直线若umax≤umin，将umax和umin代回直线参数方程，即求出直线与窗口的两实交点坐标。x = x1 + u·(x2 - x1)y = y1 + u·(y2 - y1) 注意：因为对于实交点0≤u≤1，因此umax不能小于0，umin不能大于1 步骤 梁算法步骤 多边形裁剪Sutherland-Hodgeman多边形裁剪思想：将边界看作整体，每次用窗口的一条边对要裁剪的多边形和中间结果多边形进行裁剪。分而治之的思想。缺点：只适合凸多边形 过程： 多边形裁剪 顶点处理四种情况： 顶点处理 文字裁剪 串精度裁剪当字符串中的所有字符都在裁剪窗口内时，就全部保留它，否则舍弃整个字符串。 字符精度裁剪裁剪时，任何与窗口有重叠或落在窗口边界以外的字符都被裁减掉。 笔画/像素精度裁剪将笔划分解成直线段对窗口作裁剪。判断字符串中各字符的哪些像素、笔划的哪一部分在窗口内，保留窗口内部分，裁减掉窗口外的部分。 消隐算法…未完待续","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"https://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://hubojing.github.io/tags/计算机图形学/"}]},{"title":"BCG网格控件增删移动","slug":"BCG网格控件增删移动","date":"2018-03-03T15:21:49.000Z","updated":"2018-03-03T15:47:28.000Z","comments":true,"path":"2018/03/03/BCG网格控件增删移动/","link":"","permalink":"https://hubojing.github.io/2018/03/03/BCG网格控件增删移动/","excerpt":"　　一个小demo——CBCGPGridCtrl网格控件增加行、删除行、上下移动行。 ","text":"一个小demo——CBCGPGridCtrl网格控件增加行、删除行、上下移动行。 代码初始化1234567891011121314151617181920212223242526272829303132BOOL CtestDlg::OnInitDialog()&#123; CBCGPDialog::OnInitDialog(); // Set the icon for this dialog. The framework does this automatically // when the application's main window is not a dialog SetIcon(m_hIcon, TRUE); // Set big icon SetIcon(m_hIcon, FALSE); // Set small icon // TODO: Add extra initialization here CRect rect(0, 0, 400, 400); m_pGridCtrl = new CBCGPGridCtrl; m_pGridCtrl-&gt;Create(WS_CHILD, rect, this, 1); m_pGridCtrl-&gt;ShowWindow(SW_SHOW); m_pGridCtrl-&gt;InsertColumn(0, _T(\"name\"), 40); m_pGridCtrl-&gt;InsertColumn(1, _T(\"sex\"), 40); CBCGPGridRow* pRow = new CBCGPGridRow; m_pGridCtrl-&gt;AddRow(pRow); CBCGPGridItem* pNameItem = pRow-&gt;CreateItem(0, 0); pRow-&gt;AddItem(pNameItem); pNameItem-&gt;SetValue(\"Nancy\"); CBCGPGridItem* pSexItem = pRow-&gt;CreateItem(0, 1); pRow-&gt;AddItem(pSexItem); pSexItem-&gt;AddOption(\"男\"); pSexItem-&gt;AddOption(\"女\"); pSexItem-&gt;SetValue(\"男\");//默认值为“男” return TRUE; // return TRUE unless you set the focus to a control&#125; 增加行12345678910111213void CtestDlg::OnBnClickedBtnAdd()&#123; CBCGPGridRow* pRow = new CBCGPGridRow; m_pGridCtrl-&gt;AddRow(pRow); int iRow = pRow-&gt;GetRowId(); CBCGPGridItem* pNameItem = pRow-&gt;CreateItem(iRow, 0); pRow-&gt;AddItem(pNameItem); CBCGPGridItem* pSexItem = pRow-&gt;CreateItem(iRow, 1); pRow-&gt;AddItem(pSexItem); pSexItem-&gt;AddOption(\"男\"); pSexItem-&gt;AddOption(\"女\"); pSexItem-&gt;SetValue(\"男\");&#125; 删除行12345678910111213void CtestDlg::OnBnClickedBtnDelete()&#123; CBCGPGridRow* pRow = m_pGridCtrl-&gt;GetCurSel(); if (!pRow) &#123; return; &#125; int iRow = pRow-&gt;GetRowId(); m_pGridCtrl-&gt;RemoveRow(iRow); CBCGPGridRow* pPreRow = m_pGridCtrl-&gt;GetRow(iRow - 1); m_pGridCtrl-&gt;AdjustLayout(); m_pGridCtrl-&gt;SetCurSel(pPreRow);&#125; 上移行12345678910111213141516171819202122232425void CtestDlg::OnBnClickedBtnMoveUp()&#123; CBCGPGridRow* pRow = m_pGridCtrl-&gt;GetCurSel(); if (!pRow) &#123; return; &#125; int iRow = pRow-&gt;GetRowId(); CBCGPGridRow* pNewRow = new CBCGPGridRow; m_pGridCtrl-&gt;InsertRowBefore(iRow - 1, pNewRow); CBCGPGridItem* pNameItem = pNewRow-&gt;CreateItem(0, 0); pNewRow-&gt;AddItem(pNameItem); pNameItem-&gt;SetValue(pRow-&gt;GetItem(0)-&gt;GetValue()); CBCGPGridItem* pSexItem = pNewRow-&gt;CreateItem(0, 1); pNewRow-&gt;AddItem(pSexItem); pSexItem-&gt;AddOption(\"男\"); pSexItem-&gt;AddOption(\"女\"); pSexItem-&gt;SetValue(pRow-&gt;GetItem(1)-&gt;GetValue()); m_pGridCtrl-&gt;RemoveRow(iRow + 1); m_pGridCtrl-&gt;AdjustLayout(); m_pGridCtrl-&gt;SetCurSel(iRow - 1);&#125; 下移行123456789101112131415161718192021222324252627void CtestDlg::OnBnClickedBtnMoveDown()&#123; CBCGPGridRow* pRow = m_pGridCtrl-&gt;GetCurSel(); if (!pRow) &#123; return; &#125; int iRow = pRow-&gt;GetRowId(); CBCGPGridRow* pNewRow = new CBCGPGridRow; m_pGridCtrl-&gt;InsertRowAfter(iRow+1, pNewRow); CBCGPGridItem* pNameItem = pNewRow-&gt;CreateItem(0, 0); pNewRow-&gt;AddItem(pNameItem); pNameItem-&gt;SetValue(pRow-&gt;GetItem(0)-&gt;GetValue()); CBCGPGridItem* pSexItem = pNewRow-&gt;CreateItem(0, 1); pNewRow-&gt;AddItem(pSexItem); pSexItem-&gt;AddOption(\"男\"); pSexItem-&gt;AddOption(\"女\"); pSexItem-&gt;SetValue(pRow-&gt;GetItem(1)-&gt;GetValue()); m_pGridCtrl-&gt;RemoveRow(iRow); m_pGridCtrl-&gt;AdjustLayout(); m_pGridCtrl-&gt;SetCurSel(iRow+1);&#125; 注意 pRow可以有多种方式创建，可以先new CBCGPGridRow后再AddRow到网格控件对象m_pGridCtrl中。也可以直接 m_pGridCtrl-&gt;CreateRow();。不过CBCGPGridItem不可以直接new，只能通过 CBCGPGridItem* pNameItem = pRow-&gt;CreateItem(iRow, 0)来得到。 m_pGridCtrl-&gt;RemoveRow(iRow);操作后若想继续选中现有某行，需要 m_pGridCtrl-&gt;AdjustLayout();来调整布局刷新网格，再调用SetCurSel实现选中操作。 InsertRowBefore和InsertRowAfter的两个参数是：被插入行（在该行前或后插入新行），新插入行数据指针CBCGPGridRow* pRow。","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hubojing.github.io/categories/编程语言/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"}]},{"title":"Android Studio配置JDK","slug":"AndroidStudio配置JDK","date":"2018-02-23T15:18:25.000Z","updated":"2018-02-23T15:34:32.000Z","comments":true,"path":"2018/02/23/AndroidStudio配置JDK/","link":"","permalink":"https://hubojing.github.io/2018/02/23/AndroidStudio配置JDK/","excerpt":"　　Android Studio配置内嵌JDK。 ","text":"Android Studio配置内嵌JDK。 今天发现JDK环境变量没有配置好。 我没有专门去下载java，在下载Android Studio时，会自带内嵌的JDK。 打开File-OtherSettings-DefaultProjectStructure，可看到AS已自动勾选Use embedded JDK，而且是官方推荐的做法。 JDK选项 以下是配置环境变量的操作。 java 1.8以后就无需CLASSPATH环境变量了。 我们只需配置JAVA_HOME和PATH即可。 JAVA_HOME C:\\AndroidStudio\\jre (JDK安装目录) 在PATH后新增： %JAVA_HOME%\\bin %JAVA_HOME%\\jre\\bin 测试一下： 在cmd中查看java版本。 测试 成功。","raw":null,"content":null,"categories":[{"name":"软件开发","slug":"软件开发","permalink":"https://hubojing.github.io/categories/软件开发/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://hubojing.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"https://hubojing.github.io/tags/Java/"}]},{"title":"递归中的return","slug":"递归中的return","date":"2018-02-22T08:38:03.000Z","updated":"2018-02-23T05:22:02.000Z","comments":true,"path":"2018/02/22/递归中的return/","link":"","permalink":"https://hubojing.github.io/2018/02/22/递归中的return/","excerpt":"　　浅谈递归。 ","text":"浅谈递归。 递归的核心是重复和嵌套。 看到的一个惊人比喻来解释什么是递归： 古之欲明明德于天下者，先治其国；欲治其国者，先齐其家；欲齐其家者，先修其身；欲修其身者，先正其心；欲正其心者，先诚其意；欲诚其意者，先致其知，致知在格物。物格而后知至，知至而后意诚，意诚而后心正，心正而后身修，身修而后家齐，家齐而后国治，国治而后天下平。 可以理解为调用自身的过程，最外层函数是“明德于天下”，每一层传入的参数依次是治国、齐家、修身、正心、诚意、致知、格物。然后再从最内层逐层返回。 如果文言比较难理解，看到的另外一个好解释，以查字典作比： 我们使用的词典，本身就是递归，为了解释一个词，需要使用更多的词。当你查一个词，发现这个词的解释中某个词仍然不懂，于是你开始查这第二个词，可惜，第二个词里仍然有不懂的词，于是查第三个词，这样查下去，直到有一个词的解释是你完全能看懂的，那么递归走到了尽头，然后你开始后退，逐个明白之前查过的每一个词，最终，你明白了最开始那个词的意思。 本文的右上方配图很直观说明了递归的层次关系。现放大如下： 递归层次 但递归不该是无限的。所以，这样的比喻欠妥： 从前有座山，山里有个庙，庙里有个老和尚，他在讲：从前有座山，山里有个庙，庙里有个老和尚，他在讲：…… 因为这个调用自身的情况没有尽头，也就是没有返回条件。如果是实际情况估计会内存溢出。 所以递归中的返回条件是很重要的，常以程序里的return示之。所以要看清，return后是返回到了哪里。笼统地说，遇到return就会跳出函数。细致一点，return是返回到被调用处。在递归函数里，遇到return退出了这一次的调用，回到被调用处即上一层调用递归处。 eg.12345678910111213141516bool Traverse()&#123; if(满足条件) &#123; return true; &#125; else &#123; bool bFlag = Traverse();//递归 if(bFlag == true) &#123; return true; &#125; &#125; return false;&#125; 梳理这段代码。干脆，把“满足条件”设为“中彩票”吧。第一次进入Traverse()函数，如果中了彩票，就返回true，跳出Traverse()函数。如果没中彩票，就调用递归（即第二次进入Traverse()函数）。 在第二次Traverse()函数里，如果中了彩票就返回true,跳出第二次Traverse()函数，返回到被调用处，即bool bFlag=Traverse();这里，此时，bFlag的值为true。接着判断bFlag的值是否为true，如果为true，则返回true，跳出第一次Traverse()函数。这样子Traverse()函数的调用才算结束。在第二次Traverse()函数里，如果没中彩票，就调用递归（即进入第三次Traverse()函数）。 在第三次Traverse()函数里…… 会发现第n+1次和第n次的调用方法是一样一样的。不过既然递归次数应该有限，那么也就是说，经过x次递归后，必中彩票。（x是有限次） 例子归例子，我们知道，现实生活中彩票依概率满足“无限递归”（编程里不被允许），x依概率趋近于无穷大。 其中需要引起重视的是，1234if(bFlag == true)&#123; return true;&#125; 这个判断在很多时候是非常重要的。因为子递归时多数场合需得到该层递归的返回值，来判断究竟是再次递归呢，还是已得到目标值返回到上一层。 如果是不需要返回值的递归，就易懂得多了。 eg.12345678910111213int iAge = 0;void Grow()&#123; iAge++; if(iAge &gt; 18) &#123; cout&lt;&lt;&quot;成年啦！&quot;&lt;&lt;endl; &#125; else &#123; Grow(); &#125;&#125; 虽然没有用return返回要求值，但实质一样，通过条件语句及递归调用自身累加类变量iAge，得到了所需值。 浅谈递归，如有错误，不吝赐教。^_^ 相关：什么是递归？（抖机灵太多……）","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"https://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"}]},{"title":"ffmpeg开发环境搭建","slug":"ffmpeg开发环境搭建","date":"2018-02-22T02:23:51.000Z","updated":"2018-02-22T03:36:49.000Z","comments":true,"path":"2018/02/22/ffmpeg开发环境搭建/","link":"","permalink":"https://hubojing.github.io/2018/02/22/ffmpeg开发环境搭建/","excerpt":"　　VS2013+ffmpeg开发环境搭建。 ","text":"VS2013+ffmpeg开发环境搭建。 下载 https://ffmpeg.zeranoe.com/builds/ Static版本包含ffmpeg.exe 、ffplay.exe 、ffprobe.exe，相关的DLL已经被编译到exe里。 Shared版本除了ffmpeg.exe , ffplay.exe , ffprobe.exe之外还有一些DLL，exe体积很小，在运行时到相应的DLL中调用功能。 Dev开发者（developer）版本，包含了库文件xxx.lib以及头文件xxx.h，不含exe文件。 这里选择下载Shared版本和Dev版本。（ffmpeg.exe 、ffplay.exe 、ffprobe.exe可以直接通过命令行运行使用） 或者直接下载我打包好的环境配置文件：http://download.csdn.net/download/hubojing/10254452（csdn现在没免费的了，就勾了最低的2分） 配置 将dev版本文件夹中的Include和lib目录复制到所需工程项目目录下，并在工程属性中设置附加包含目录$(ProjectDir)\\include和附加库目录$(ProjectDir)\\lib。 将share版本文件夹中bin目录下对应的所有dll复制到项目路径下。 附加依赖项填入（根据所需）avcodec.libavdevice.libavfilter.libavformat.libavutil.libpostproc.libswresample.libswscale.lib 由于ffmpeg是C语言所写，include头文件时需使用extern “C”标明。 测试1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;extern &quot;C&quot;&#123;#include &lt;libavformat/avformat.h&gt;#include &lt;libavutil/dict.h&gt;&#125;;int main(int argc, char **argv)&#123; AVFormatContext *fmt_ctx = NULL; AVDictionaryEntry *tag = NULL; int ret; if (argc != 2) &#123; printf(&quot;usage: %s &lt;input_file&gt;\\n&quot; &quot;example program to demonstrate the use of the libavformat metadata API.\\n&quot; &quot;\\n&quot;, argv[0]); system(&quot;pause&quot;); return 1; &#125; if ((ret = avformat_open_input(&amp;fmt_ctx, argv[1], NULL, NULL))) return ret; while ((tag = av_dict_get(fmt_ctx-&gt;metadata, &quot;&quot;, tag, AV_DICT_IGNORE_SUFFIX))) printf(&quot;%s=%s\\n&quot;, tag-&gt;key, tag-&gt;value); avformat_close_input(&amp;fmt_ctx);&#125; 测试结果： test 至此，开发环境已就位。 参考：vs2013+ffmpeg开发环境搭建 资料：FFMPEG视音频编解码零基础学习方法ffmpeg官方文档","raw":null,"content":null,"categories":[{"name":"软件开发","slug":"软件开发","permalink":"https://hubojing.github.io/categories/软件开发/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"https://hubojing.github.io/tags/ffmpeg/"}]},{"title":"联想Y400拆机","slug":"联想Y400拆机","date":"2018-02-20T07:48:29.000Z","updated":"2018-02-20T10:40:50.000Z","comments":true,"path":"2018/02/20/联想Y400拆机/","link":"","permalink":"https://hubojing.github.io/2018/02/20/联想Y400拆机/","excerpt":"　　记一次失败的拆机T_T ","text":"记一次失败的拆机T_T 根源：笔记本卡慢，想加一块ssd和一根内存。（其实就是想看看里面长啥样） 过程：不停卸螺丝。。。。。。不停扒壳子。。。。。。不停清灰！ 咳咳，四年没有清过灰 背面 打开后盖 整体结构 拿下内存条，原装配的是DDR3 4G。所以是再加一根4G呢，还是干脆换一根8G呢 内存条 可以加2根内存条，联想Y400预留了一个mSATA接口，可以加装mSATA接口的SSD。 内存和ssd 好贵啊啊啊啊啊啊啊啊啊啊啊啊https://item.jd.com/3749477.html 原装三星硬盘，据说现在被希捷收购了。硬盘盒上有一层防静电锡纸。没拍的D面盖板上也有薄薄的铝板，起电磁屏蔽作用。 硬盘 光驱，莫名其妙的坏掉了……没修好 光驱 看向光驱位内部，可以看到常规接口 接口 到处还有一些防震海绵，绝缘胶布，整体而言还是比较干净整洁的。但是，屏幕转轴很容易断啊。打开后盖，转轴就是碎的……我整了好久才让笔记本屏幕能正常打开，但已经不能灵活合上盖子了。就是这样： 机械故障 问题出在 屏轴 由于固定它的塑料壳碎了，转动屏幕它就自由转动，抵到后方的电路板，估计抵坏了左侧音响的音频放大部分电路。一开始直接没声了，倒腾半天有声音了，然后让杂音消了，但声音不能正常放大了。 无知者无畏，秉着玩跨了再拼回去的探索精神，本打算都给拆了的。然而螺丝不给面子，滑丝打不开……………………连风扇的螺丝都没找到合适规格的十字口螺丝刀拧开。看来干不了维修→_→失败的拆机，基本就没有拆……忽悠你们点进来 拼回去了还能用，还可以，除了我的JBL专业音响T_T。清灰效果不明显啊，还是要一键还原啊。希望小Y再坚持几年不垮 好了不拆了！弄得一手灰╭(╯^╰)╮谁和我组队打个游戏赢几盘排解一下 附一篇正儿八经的拆机","raw":null,"content":null,"categories":[{"name":"数码","slug":"数码","permalink":"https://hubojing.github.io/categories/数码/"}],"tags":[{"name":"硬件","slug":"硬件","permalink":"https://hubojing.github.io/tags/硬件/"}]},{"title":"域名更换公告","slug":"公告","date":"2018-02-18T16:40:50.000Z","updated":"2018-03-30T15:34:41.000Z","comments":true,"path":"2018/02/19/公告/","link":"","permalink":"https://hubojing.github.io/2018/02/19/公告/","excerpt":"　　本博客域名还原为https://hubojing.github.io/　　域名http://hubojing.me/已弃用。由于更换域名，原有每篇文章浏览量被清空。　　特此公告。　　小博客点击一万五啦(づ￣ 3￣)づ，谢谢各位的来访。  　　    　　 ","text":"本博客域名还原为https://hubojing.github.io/ 域名http://hubojing.me/已弃用。由于更换域名，原有每篇文章浏览量被清空。 特此公告。 小博客点击一万五啦(づ￣ 3￣)づ，谢谢各位的来访。","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"公告","slug":"公告","permalink":"https://hubojing.github.io/tags/公告/"}]},{"title":"OpenCV3.4.0编译","slug":"OpenCV3-4-0编译","date":"2018-01-28T14:18:39.000Z","updated":"2018-01-30T14:56:38.000Z","comments":true,"path":"2018/01/28/OpenCV3-4-0编译/","link":"","permalink":"https://hubojing.github.io/2018/01/28/OpenCV3-4-0编译/","excerpt":"　　OpenCV文件编译及问题记录。 ","text":"OpenCV文件编译及问题记录。 目前最新OpenCV官网发布最新版为3.4.0（2017年12月23日发布）。 OpenCV库使用方法下载地址：https://github.com/opencv/opencv/releases/tag/3.4.0或https://sourceforge.net/projects/opencvlibrary/ 法一：使用官方提供的已编译好的文件优点：方便快捷缺点：版本限制选择opencv-3.4.0-vc14_vc15.exe，下载完成后可以直接打开解压，即可在自己的项目中直接使用。具体步骤为： 配置环境变量打开电脑右键属性-高级系统设置-环境变量，Path中新增：E:\\opencv\\build\\x64\\vc14\\bin，（此处为解压对应目录）。 引入相应头文件、库文件、链接库打开自己的工程，右键属性-配置属性-VC++目录-包含目录，新增：E:\\opencv\\build\\include\\opencvE:\\opencv\\build\\include\\opencv2E:\\opencv\\build\\include 库目录，新增：E:\\opencv\\build\\x64\\vc14\\lib（注意修改为你解压对应的目录）。 链接器-输入-附加依赖项，新增：opencv_world340d.lib点击确定即可。至此所有准备工作就绪，可以愉快地编译自己的工程啦。 但想如此一劳永逸解决问题，需符合以下特点：你的VS版本是VC14（2015）或VC15（2017）。另附几种对应关系：Microsoft Visual Studio 6.0: VC6.0Microsoft Visual Studio 2002： VC7.0Microsoft Visual Studio 2003： VC7.1Microsoft Visual Studio 2005： VC8.0Microsoft Visual Studio 2008： VC9.0Microsoft Visual Studio 2010： VC10.0Microsoft Visual Studio 2012： VC11.0Microsoft Visual Studio 2013： VC12.0Microsoft Visual Studio 2014： VC13.0Microsoft Visual Studio 2015： VC14.0Microsoft Visual studio 2017： VC15.0 由于我使用VS2013，因此无法使用该方法。（当然，可以自行下载VS2015的运行库）。我使用法二。 法二：自行编译下载源码Source code并解压下载CMake下载地址：https://cmake.org/download/选择相应操作系统版本，例如我选择Windows win64-x64 Installer。安装，打开bin\\cmake-gui.exe。 使用CMake在Where is the source code中选择OpenCV解压目录，如：E:/opencv-3.4.0/opencv-3.4.0。一般可以在解压目录下新建一个build文件夹，用来存放编译生成的文件。于是，在Where to build the binaries中填入该路径，如：E:/opencv-3.4.0/opencv-3.4.0/build。（也可自行选择路径） 点击Configure，选择所需环境，如：Visual Studio 12 2013。进入漫长的等待。如果区域有红色出现，需再次点击Configure，直到全部变成白色。 第一次Configure后：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102General configuration for OpenCV 3.4.0 ===================================== Version control: unknown Platform: Timestamp: 2018-01-29T14:29:24Z Host: Windows 10.0.16299 AMD64 CMake: 3.10.2 CMake generator: Visual Studio 12 2013 CMake build tool: C:/Program Files (x86)/MSBuild/12.0/bin/MSBuild.exe MSVC: 1800 CPU/HW features: Baseline: SSE SSE2 requested: SSE2 Dispatched code generation: SSE4_1 SSE4_2 FP16 AVX requested: SSE4_1 SSE4_2 AVX FP16 AVX2 SSE4_1 (3 files): + SSE3 SSSE3 SSE4_1 SSE4_2 (1 files): + SSE3 SSSE3 SSE4_1 POPCNT SSE4_2 FP16 (2 files): + SSE3 SSSE3 SSE4_1 POPCNT SSE4_2 FP16 AVX AVX (5 files): + SSE3 SSSE3 SSE4_1 POPCNT SSE4_2 AVX C/C++: Built as dynamic libs?: YES C++11: YES C++ Compiler: C:/software/vs2013/VC/bin/cl.exe (ver 18.0.21005.1) C++ flags (Release): /DWIN32 /D_WINDOWS /W4 /GR /EHa /D _CRT_SECURE_NO_DEPRECATE /D _CRT_NONSTDC_NO_DEPRECATE /D _SCL_SECURE_NO_WARNINGS /Gy /bigobj /Oi /fp:fast /arch:SSE /arch:SSE2 /wd4127 /wd4251 /wd4324 /wd4275 /wd4512 /wd4589 /MP12 /MD /O2 /Ob2 /DNDEBUG /Zi C++ flags (Debug): /DWIN32 /D_WINDOWS /W4 /GR /EHa /D _CRT_SECURE_NO_DEPRECATE /D _CRT_NONSTDC_NO_DEPRECATE /D _SCL_SECURE_NO_WARNINGS /Gy /bigobj /Oi /fp:fast /arch:SSE /arch:SSE2 /wd4127 /wd4251 /wd4324 /wd4275 /wd4512 /wd4589 /MP12 /MDd /Zi /Ob0 /Od /RTC1 C Compiler: C:/software/vs2013/VC/bin/cl.exe C flags (Release): /DWIN32 /D_WINDOWS /W3 /D _CRT_SECURE_NO_DEPRECATE /D _CRT_NONSTDC_NO_DEPRECATE /D _SCL_SECURE_NO_WARNINGS /Gy /bigobj /Oi /fp:fast /arch:SSE /arch:SSE2 /MP12 /MD /O2 /Ob2 /DNDEBUG /Zi C flags (Debug): /DWIN32 /D_WINDOWS /W3 /D _CRT_SECURE_NO_DEPRECATE /D _CRT_NONSTDC_NO_DEPRECATE /D _SCL_SECURE_NO_WARNINGS /Gy /bigobj /Oi /fp:fast /arch:SSE /arch:SSE2 /MP12 /MDd /Zi /Ob0 /Od /RTC1 Linker flags (Release): /machine:X86 /INCREMENTAL:NO /debug Linker flags (Debug): /machine:X86 /debug /INCREMENTAL ccache: NO Precompiled headers: YES Extra dependencies: 3rdparty dependencies: OpenCV modules: To be built: calib3d core dnn features2d flann highgui imgcodecs imgproc ml objdetect photo python_bindings_generator shape stitching superres ts video videoio videostab Disabled: js world Disabled by dependency: - Unavailable: cudaarithm cudabgsegm cudacodec cudafeatures2d cudafilters cudaimgproc cudalegacy cudaobjdetect cudaoptflow cudastereo cudawarping cudev java python2 python3 viz Applications: tests perf_tests apps Documentation: NO Non-free algorithms: NO Windows RT support: NO GUI: Win32 UI: YES VTK support: NO Media I/O: ZLib: build (ver 1.2.11) JPEG: build (ver 90) WEBP: build (ver encoder: 0x020e) PNG: build (ver 1.6.34) TIFF: build (ver 42 - 4.0.9) JPEG 2000: build (ver 1.900.1) OpenEXR: build (ver 1.7.1) Video I/O: Video for Windows: YES DC1394: NO FFMPEG: NO avcodec: NO avformat: NO avutil: NO swscale: NO avresample: NO GStreamer: NO DirectShow: YES Parallel framework: Concurrency Trace: YES (with Intel ITT) Other third-party libraries: Lapack: NO Eigen: NO Custom HAL: NO NVIDIA CUDA: NO OpenCL: YES (no extra features) Include path: E:/opencv-3.4.0/opencv-3.4.0/3rdparty/include/opencl/1.2 Link libraries: Dynamic load Python (for build): NO Java: ant: NO JNI: NO Java wrappers: NO Java tests: NO Matlab: NO Install to: E:/opencv-3.4.0/opencv-3.4.0/build/install-----------------------------------------------------------------Configuring done 此时可能出现常见问题：1234567891011FFMPEG: Download: opencv_ffmpeg.dllCMake Warning at cmake/OpenCVDownload.cmake:190 (message): FFMPEG: Download failed: 28;&quot;Timeout was reached&quot;FFMPEG: Download: opencv_ffmpeg_64.dllCMake Warning at cmake/OpenCVDownload.cmake:190 (message): FFMPEG: Download failed: 28;&quot;Timeout was reached&quot;IPPICV: Download: ippicv_2017u3_win_ia32_general_20170822.zipCMake Warning at cmake/OpenCVDownload.cmake:190 (message): IPPICV: Download failed: 28;&quot;Timeout was reached&quot; 总之就是有文件下载不成功。根据CMake的提示，打开build下的CMakeDownloadLog.txt，上面写着：123456789101112131415161718192021use_cache &quot;E:/opencv-3.4.0/opencv-3.4.0/.cache&quot;do_copy &quot;opencv_ffmpeg.dll&quot; &quot;3ae76b105113d944984b2351c61e21c6&quot; &quot;https://raw.githubusercontent.com/opencv/opencv_3rdparty/66b1fed06cf3510235f367f96aa26da5cb234a15/ffmpeg/opencv_ffmpeg.dll&quot; &quot;E:/opencv-3.4.0/opencv-3.4.0/build/3rdparty/ffmpeg&quot;#missing &quot;E:/opencv-3.4.0/opencv-3.4.0/build/3rdparty/ffmpeg/opencv_ffmpeg.dll&quot;#check_md5 &quot;E:/opencv-3.4.0/opencv-3.4.0/.cache/ffmpeg/3ae76b105113d944984b2351c61e21c6-opencv_ffmpeg.dll&quot;#mismatch_md5 &quot;E:/opencv-3.4.0/opencv-3.4.0/.cache/ffmpeg/3ae76b105113d944984b2351c61e21c6-opencv_ffmpeg.dll&quot; &quot;299b46e2c4cf8047b0ef420c9a61c6ef&quot;#delete &quot;E:/opencv-3.4.0/opencv-3.4.0/.cache/ffmpeg/3ae76b105113d944984b2351c61e21c6-opencv_ffmpeg.dll&quot;#cmake_download &quot;E:/opencv-3.4.0/opencv-3.4.0/.cache/ffmpeg/3ae76b105113d944984b2351c61e21c6-opencv_ffmpeg.dll&quot; &quot;https://raw.githubusercontent.com/opencv/opencv_3rdparty/66b1fed06cf3510235f367f96aa26da5cb234a15/ffmpeg/opencv_ffmpeg.dll&quot;do_copy &quot;opencv_ffmpeg_64.dll&quot; &quot;cf3bb5bc9d393b022ea7a42eb63e794d&quot; &quot;https://raw.githubusercontent.com/opencv/opencv_3rdparty/66b1fed06cf3510235f367f96aa26da5cb234a15/ffmpeg/opencv_ffmpeg_64.dll&quot; &quot;E:/opencv-3.4.0/opencv-3.4.0/build/3rdparty/ffmpeg&quot;#missing &quot;E:/opencv-3.4.0/opencv-3.4.0/build/3rdparty/ffmpeg/opencv_ffmpeg_64.dll&quot;#check_md5 &quot;E:/opencv-3.4.0/opencv-3.4.0/.cache/ffmpeg/cf3bb5bc9d393b022ea7a42eb63e794d-opencv_ffmpeg_64.dll&quot;#mismatch_md5 &quot;E:/opencv-3.4.0/opencv-3.4.0/.cache/ffmpeg/cf3bb5bc9d393b022ea7a42eb63e794d-opencv_ffmpeg_64.dll&quot; &quot;3ab964d23e60d2b961737a8bb556bd45&quot;#delete &quot;E:/opencv-3.4.0/opencv-3.4.0/.cache/ffmpeg/cf3bb5bc9d393b022ea7a42eb63e794d-opencv_ffmpeg_64.dll&quot;#cmake_download &quot;E:/opencv-3.4.0/opencv-3.4.0/.cache/ffmpeg/cf3bb5bc9d393b022ea7a42eb63e794d-opencv_ffmpeg_64.dll&quot; &quot;https://raw.githubusercontent.com/opencv/opencv_3rdparty/66b1fed06cf3510235f367f96aa26da5cb234a15/ffmpeg/opencv_ffmpeg_64.dll&quot;do_copy &quot;ffmpeg_version.cmake&quot; &quot;ec59008da403fb18ab3c1ed66aed583b&quot; &quot;https://raw.githubusercontent.com/opencv/opencv_3rdparty/66b1fed06cf3510235f367f96aa26da5cb234a15/ffmpeg/ffmpeg_version.cmake&quot; &quot;E:/opencv-3.4.0/opencv-3.4.0/build/3rdparty/ffmpeg&quot;#check_md5 &quot;E:/opencv-3.4.0/opencv-3.4.0/build/3rdparty/ffmpeg/ffmpeg_version.cmake&quot;#match_md5 &quot;E:/opencv-3.4.0/opencv-3.4.0/build/3rdparty/ffmpeg/ffmpeg_version.cmake&quot; &quot;ec59008da403fb18ab3c1ed66aed583b&quot;do_unpack &quot;ippicv_2017u3_win_ia32_general_20170822.zip&quot; &quot;8a7680ae352c192de2e2e34936164bd0&quot; &quot;https://raw.githubusercontent.com/opencv/opencv_3rdparty/dfe3162c237af211e98b8960018b564bc209261d/ippicv/ippicv_2017u3_win_ia32_general_20170822.zip&quot; &quot;E:/opencv-3.4.0/opencv-3.4.0/build/3rdparty/ippicv&quot;#check_md5 &quot;E:/opencv-3.4.0/opencv-3.4.0/.cache/ippicv/8a7680ae352c192de2e2e34936164bd0-ippicv_2017u3_win_ia32_general_20170822.zip&quot;#mismatch_md5 &quot;E:/opencv-3.4.0/opencv-3.4.0/.cache/ippicv/8a7680ae352c192de2e2e34936164bd0-ippicv_2017u3_win_ia32_general_20170822.zip&quot; &quot;c7fcfb626b50daa8bd728b7598328455&quot;#delete &quot;E:/opencv-3.4.0/opencv-3.4.0/.cache/ippicv/8a7680ae352c192de2e2e34936164bd0-ippicv_2017u3_win_ia32_general_20170822.zip&quot;#cmake_download &quot;E:/opencv-3.4.0/opencv-3.4.0/.cache/ippicv/8a7680ae352c192de2e2e34936164bd0-ippicv_2017u3_win_ia32_general_20170822.zip&quot; &quot;https://raw.githubusercontent.com/opencv/opencv_3rdparty/dfe3162c237af211e98b8960018b564bc209261d/ippicv/ippicv_2017u3_win_ia32_general_20170822.zip&quot; 可以看到文本中记录了下载链接，于是在浏览器中复制上述链接，自行下载好这几个文件到文本指向的路径中。比如：我缺的三个文件是：opencv_ffmpeg.dll，需放到：E:/opencv-3.4.0/opencv-3.4.0/build/3rdparty/ffmpeg。下载链接：https://raw.githubusercontent.com/opencv/opencv_3rdparty/66b1fed06cf3510235f367f96aa26da5cb234a15/ffmpeg/opencv_ffmpeg.dllopencv_ffmpeg_64.dll，需放到：E:/opencv-3.4.0/opencv-3.4.0/build/3rdparty/ffmpeg。下载链接：https://raw.githubusercontent.com/opencv/opencv_3rdparty/66b1fed06cf3510235f367f96aa26da5cb234a15/ffmpeg/opencv_ffmpeg_64.dllippicv_2017u3_win_ia32_general_20170822.zip，注意：需在压缩包前加上文件的hash值，即压缩名变为hash值-原名。提供一个在线查看哈希值的网站：http://www.atool.org/file_hash.php ，需要的是MD5 Hash。需放到：E:/opencv-3.4.0/opencv-3.4.0/build/3rdparty/ippicv。（然而并没有生成ippicv文件夹）下载链接：https://raw.githubusercontent.com/opencv/opencv_3rdparty/dfe3162c237af211e98b8960018b564bc209261d/ippicv/ippicv_2017u3_win_ia32_general_20170822.zip建议科学上网后下载，不然网速感人。不过还是不匹配。根据大佬提示，CMake3.10.2没有downloader.cmake，干脆……不要这三个文件了……修改E:\\opencv-3.4.0\\opencv-3.4.0\\3rdparty\\ffmpeg中的ffmpeg.cmake，如下：12345678910111213141516171819202122232425262728293031323334353637# Binary branch name: ffmpeg/master_20171009# Binaries were created for OpenCV: 8ac2c5d620b467d3f22802e96c88ddde6da707afset(FFMPEG_BINARIES_COMMIT &quot;66b1fed06cf3510235f367f96aa26da5cb234a15&quot;)set(FFMPEG_FILE_HASH_BIN32 &quot;3ae76b105113d944984b2351c61e21c6&quot;)set(FFMPEG_FILE_HASH_BIN64 &quot;cf3bb5bc9d393b022ea7a42eb63e794d&quot;)set(FFMPEG_FILE_HASH_CMAKE &quot;ec59008da403fb18ab3c1ed66aed583b&quot;)function(download_win_ffmpeg script_var) set($&#123;script_var&#125; &quot;&quot; PARENT_SCOPE) # set(ids BIN32 BIN64 CMAKE) # set(name_BIN32 &quot;opencv_ffmpeg.dll&quot;) # set(name_BIN64 &quot;opencv_ffmpeg_64.dll&quot;) # set(name_CMAKE &quot;ffmpeg_version.cmake&quot;) # set(FFMPEG_DOWNLOAD_DIR &quot;$&#123;OpenCV_BINARY_DIR&#125;/3rdparty/ffmpeg&quot;) # set(status TRUE) # foreach(id $&#123;ids&#125;) # ocv_download(FILENAME $&#123;name_$&#123;id&#125;&#125; # HASH $&#123;FFMPEG_FILE_HASH_$&#123;id&#125;&#125; # URL # &quot;$ENV&#123;OPENCV_FFMPEG_URL&#125;&quot; # &quot;$&#123;OPENCV_FFMPEG_URL&#125;&quot; # &quot;https://raw.githubusercontent.com/opencv/opencv_3rdparty/$&#123;FFMPEG_BINARIES_COMMIT&#125;/ffmpeg/&quot; # DESTINATION_DIR $&#123;FFMPEG_DOWNLOAD_DIR&#125; # ID FFMPEG # RELATIVE_URL # STATUS res) # if(NOT res) # set(status FALSE) # endif() # endforeach() # if(status) # set($&#123;script_var&#125; &quot;$&#123;FFMPEG_DOWNLOAD_DIR&#125;/ffmpeg_version.cmake&quot; PARENT_SCOPE) # endif()endfunction() 修改E:\\opencv-3.4.0\\opencv-3.4.0\\3rdparty\\ippicv中的ippicv.cmake，如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function(download_ippicv root_var) # set($&#123;root_var&#125; &quot;&quot; PARENT_SCOPE) # # Commit SHA in the opencv_3rdparty repo # set(IPPICV_COMMIT &quot;dfe3162c237af211e98b8960018b564bc209261d&quot;) # # Define actual ICV versions # if(APPLE) # set(OPENCV_ICV_PLATFORM &quot;macosx&quot;) # set(OPENCV_ICV_PACKAGE_SUBDIR &quot;ippicv_mac&quot;) # if(X86_64) # set(OPENCV_ICV_NAME &quot;ippicv_2017u3_mac_intel64_general_20170822.tgz&quot;) # set(OPENCV_ICV_HASH &quot;c1ebb5dfa5b7f54b0c44e1917805a463&quot;) # else() # set(OPENCV_ICV_NAME &quot;ippicv_2017u3_mac_ia32_general_20170822.tgz&quot;) # set(OPENCV_ICV_HASH &quot;49b05a669042753ae75895a445ebd612&quot;) # endif() # elseif((UNIX AND NOT ANDROID) OR (UNIX AND ANDROID_ABI MATCHES &quot;x86&quot;)) # set(OPENCV_ICV_PLATFORM &quot;linux&quot;) # set(OPENCV_ICV_PACKAGE_SUBDIR &quot;ippicv_lnx&quot;) # if(X86_64) # set(OPENCV_ICV_NAME &quot;ippicv_2017u3_lnx_intel64_general_20170822.tgz&quot;) # set(OPENCV_ICV_HASH &quot;4e0352ce96473837b1d671ce87f17359&quot;) # else() # set(OPENCV_ICV_NAME &quot;ippicv_2017u3_lnx_ia32_general_20170822.tgz&quot;) # set(OPENCV_ICV_HASH &quot;dcdb0ba4b123f240596db1840cd59a76&quot;) # endif() # elseif(WIN32 AND NOT ARM) # set(OPENCV_ICV_PLATFORM &quot;windows&quot;) # set(OPENCV_ICV_PACKAGE_SUBDIR &quot;ippicv_win&quot;) # if(X86_64) # set(OPENCV_ICV_NAME &quot;ippicv_2017u3_win_intel64_general_20170822.zip&quot;) # set(OPENCV_ICV_HASH &quot;0421e642bc7ad741a2236d3ec4190bdd&quot;) # else() # set(OPENCV_ICV_NAME &quot;ippicv_2017u3_win_ia32_general_20170822.zip&quot;) # set(OPENCV_ICV_HASH &quot;8a7680ae352c192de2e2e34936164bd0&quot;) # endif() # else() # return() # endif() # set(THE_ROOT &quot;$&#123;OpenCV_BINARY_DIR&#125;/3rdparty/ippicv&quot;) # ocv_download(FILENAME $&#123;OPENCV_ICV_NAME&#125; # HASH $&#123;OPENCV_ICV_HASH&#125; # URL # &quot;$&#123;OPENCV_IPPICV_URL&#125;&quot; # &quot;$ENV&#123;OPENCV_IPPICV_URL&#125;&quot; # &quot;https://raw.githubusercontent.com/opencv/opencv_3rdparty/$&#123;IPPICV_COMMIT&#125;/ippicv/&quot; # DESTINATION_DIR &quot;$&#123;THE_ROOT&#125;&quot; # ID IPPICV # STATUS res # UNPACK RELATIVE_URL) # if(res) # set($&#123;root_var&#125; &quot;$&#123;THE_ROOT&#125;/$&#123;OPENCV_ICV_PACKAGE_SUBDIR&#125;&quot; PARENT_SCOPE) # endif()endfunction() 再重新Configure两次，Generate一次，成功。 用VS2013编译打开OpenCV.sln编译，debug-Win32调试器。 添加到所需工程根据法一：添加环境变量：E:\\opencv-3.4.0\\opencv-3.4.0\\build\\install\\x86\\vc12\\binVS包含目录：E:\\opencv-3.4.0\\opencv-3.4.0\\build\\install\\includeE:\\opencv-3.4.0\\opencv-3.4.0\\build\\install\\include\\opencvE:\\opencv-3.4.0\\opencv-3.4.0\\build\\install\\include\\opencv2库目录：E:\\opencv-3.4.0\\opencv-3.4.0\\build\\install\\x86\\vc12\\lib链接器：opencv_calib3d340d.libopencv_core340d.libopencv_dnn340d.libopencv_features2d340d.libopencv_flann340d.libopencv_highgui340d.libopencv_imgcodecs340d.libopencv_imgproc340d.libopencv_ml340d.libopencv_objdetect340d.libopencv_photo340d.libopencv_shape340d.libopencv_stitching340d.libopencv_superres340d.libopencv_video340d.libopencv_videoio340d.libopencv_videostab340d.lib 测试比较两张图片的不同之处。123456789101112131415161718192021222324252627#include &lt;cv.h&gt; #include &lt;highgui.h&gt; #include &lt;stdio.h&gt; int main()&#123; IplImage *pSrc = cvLoadImage(&quot;1.jpg&quot;, 1); CvSize size = cvSize(600, 376);//区域大小 cvSetImageROI(pSrc, cvRect(0, 0, size.width, size.height));//设置源图像ROI IplImage* pDest1 = cvCreateImage(size, pSrc-&gt;depth, pSrc-&gt;nChannels);//创建目标图像 cvCopy(pSrc, pDest1); //复制图像 cvResetImageROI(pDest1);//源图像用完后，清空ROI cvSaveImage(&quot;Image_1.jpg&quot;, pDest1);//保存目标图像 cvSetImageROI(pSrc, cvRect(0, 393, size.width, size.height));//设置源图像ROI IplImage* pDest2 = cvCreateImage(size, pSrc-&gt;depth, pSrc-&gt;nChannels);//创建目标图像 cvCopy(pSrc, pDest2); //复制图像 cvResetImageROI(pDest2);//源图像用完后，清空ROI cvSaveImage(&quot;Image_2.jpg&quot;, pDest2);//保存目标图像 IplImage *dst; dst = cvCreateImage(cvGetSize(pDest1), pDest1-&gt;depth, pDest1-&gt;nChannels); cvAbsDiff(pDest1, pDest2, dst); cvNamedWindow(&quot;Compare_Images&quot;, 1); cvShowImage(&quot;Compare_Images&quot;, dst); cvWaitKey(); return 0;&#125; 以上程序转自http://blog.csdn.net/cooelf/article/details/24663097 可成功编译和运行，到此，基础环境算是磕磕绊绊搭建好了。","raw":null,"content":null,"categories":[{"name":"软件开发","slug":"软件开发","permalink":"https://hubojing.github.io/categories/软件开发/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://hubojing.github.io/tags/OpenCV/"}]},{"title":"微信自动跳一跳","slug":"微信自动跳一跳","date":"2018-01-06T09:03:53.000Z","updated":"2018-01-14T15:43:45.000Z","comments":true,"path":"2018/01/06/微信自动跳一跳/","link":"","permalink":"https://hubojing.github.io/2018/01/06/微信自动跳一跳/","excerpt":"　　技术探讨微信跳一跳自动实现（C++版）。 ","text":"技术探讨微信跳一跳自动实现（C++版）。 免责声明：请勿用于刷分，由此导致的分数被屏蔽、微信被封号后果自负。 近来微信跳一跳很火，手动玩的最高纪录才150分，而最常见的情况是10分以内就挂，由此萌生了是否能技术实现的想法。当然，对刷分并不感兴趣，只是想学习下各位大佬们的代码。知乎上这个话题已经炸开了锅，python版满天飞，这里是一个C++实现。（物理外挂简直丧心病狂(〝▼皿▼)） 适用范围：Android 原理借助adb电脑通过 adb 与Android手机互联。为了捕捉屏幕信息，需要截图：adb shell screencap -p 图片路径借助adb pull 图片路径提交到本地。12345void ADBHelper::CapScreen()&#123; system(\"adb shell screencap -p /sdcard/JumpByJump.png\"); system(\"adb pull /sdcard/JumpByJump.png\");&#125; 模拟滑动事件adb shell input swipe x1 y1 x2 y2 time，即从点[x1,y1]滑动到点[x2,y2]，以及滑动时间（或者说是这儿的触摸时间）。这里我们不需要滑动到别处，因此可设置定点。123456void ADBHelper::jump(int pressTime)&#123; char cmd[256] = &#123; 0 &#125;; sprintf_s(cmd, \"adb shell input swipe 320 410 320 410 %d\", pressTime); system(cmd);&#125; 计算距离根据勾股定理，计算棋子目前所处位置到下一点（方块中心）的距离。所以就需要考虑如何获取当前位置和目标点坐标。这也是该技术探讨的核心所在。这里用到了OpenCV库来识别位置。（当初OpenCV、OpenGL傻傻分不清） 最傻瓜手动点击棋子位置和目标位置，获取坐标。 优点：思路简单，准确度还可以。缺点：操作麻烦，需手动跟进目标，自动化程度低。 稍改进自动获取棋子位置，利用棋子颜色和方块较大的色差来做文章是很多帖子的思路。然后手动点击目标位置。 较上述方案点击次数减少一半，但依然麻烦。 比较好利用图像处理知识，自动获取两点坐标。如果想自动获取坐标，可以看到，立方体的性状是正方体和圆柱居多，立方体只需记录最上方和最右方的点的位置，取最上方的横坐标和最右方的纵坐标即得中心点坐标。其它很多算法下方链接已附。 AI神经网络截取样本进行训练，然后让其自动跳跳跳。 暂时只实现了前2种…… 设置参数可以发现触摸时间越长，跳动距离越远。最简单的假设就是线性关系。distance=timek=distance(1/k)，令1/k=parameter，即所需参数。我们经测试显示，parameter值在本程序和手机环境（分辨率1920×1080）中1.15比较合适。通过设置参数，计算出触摸时间。 代码流程代码主体建立在参考里的jump1jump项目（借用了adb、cv库和相关的dll），进行了一些修改。 入口123456int main(int argc, char* argv[])&#123; JumpByJump jumper; jumper.CarryOut(); return 0;&#125; JumpByJump是主要的处理类，定义如下：1234567891011121314151617181920class JumpByJump&#123;public: JumpByJump(); ~JumpByJump(); double m_parameter; void CarryOut();//执行操作 void ReadImage();//读取截图 CvPoint LocateChess();//棋子定位 void ShowScreen();//刷新屏幕 double m_targetPosX; double m_targetPosY; double m_sourcePosX; double m_sourcePosY;private: IplImage* m_image; IplImage* m_imgChessModel; IplImage* m_matchResult;&#125;; 第一次鼠标点击回调函数，获取棋子坐标-&gt;第一次鼠标点击回调函数，获取目标点坐标-&gt;计算两点距离-&gt;调用adb模拟触摸跳跃-&gt;等待截图-&gt;捕捉屏幕-&gt;读取截图-&gt;显示在电脑屏幕上12345678910111213141516171819202122232425262728293031void onClick(int event, int x, int y, int flags, void* param)&#123; if (event != CV_EVENT_LBUTTONUP) &#123; return; &#125; JumpByJump* jumper = (JumpByJump*)param; if (m_iCount % 2 == 0) &#123; cout &lt;&lt; \"棋子坐标：\" &lt;&lt; \"(\" &lt;&lt; x &lt;&lt; \",\" &lt;&lt; y &lt;&lt; \")\" &lt;&lt; endl; jumper-&gt;m_sourcePosX = x; jumper-&gt;m_sourcePosY = y; m_iCount++; &#125; else &#123; cout &lt;&lt; \"目标点坐标：\" &lt;&lt; \"(\" &lt;&lt; x &lt;&lt; \",\" &lt;&lt; y &lt;&lt; \")\" &lt;&lt; endl; jumper-&gt;m_targetPosX = x; jumper-&gt;m_targetPosY = y; // CvPoint chessLoc = jumper-&gt;LocateChess(); double distance = sqrt(powf(jumper-&gt;m_targetPosX - jumper-&gt;m_sourcePosX, 2) + powf(jumper-&gt;m_targetPosY - jumper-&gt;m_sourcePosY, 2)); ADBHelper::jump(distance * m_parameter); Sleep(1000);//等待截图 ADBHelper::CapScreen(); jumper-&gt;ReadImage(); jumper-&gt;ShowScreen(); m_iCount++; &#125;&#125; 执行函数:捕捉屏幕-&gt;读取截图-&gt;获取棋子坐标-&gt;电脑显示模拟画面-&gt;刷新画面1234567void JumpByJump::CarryOut()&#123; ADBHelper::CapScreen(); ReadImage(); UpdateScreen(); cvWaitKey(0);&#125; cvWaitKey()函数的功能是不断刷新图像，频率时间为delay，单位为ms。 定位两点位置是核心关键。（手动设置两点则无需该函数）123456789101112CvPoint JumpByJump::LocateChess()&#123; cvMatchTemplate(m_image, m_imgChessModel, m_matchResult, CV_TM_SQDIFF); double min_val = 0, max_val = 0; CvPoint min_loc, max_loc, chessPt; cvMinMaxLoc(m_matchResult, &amp;min_val, &amp;max_val, &amp;min_loc, &amp;max_loc); cvRectangle(m_image, min_loc, cvPoint(min_loc.x + m_imgChessModel-&gt;width, min_loc.y + m_imgChessModel-&gt;height), cvScalar(0, 0, 255), 2); cout &lt;&lt; \"棋子当前坐标：\" &lt;&lt; \"(\" &lt;&lt; min_loc.x &lt;&lt; \",\" &lt;&lt; min_loc.y&lt;&lt;\")\" &lt;&lt; endl; chessPt = cvPoint(min_loc.x + m_imgChessModel-&gt;width / 2, min_loc.y + m_imgChessModel-&gt;height); return chessPt;&#125; opencv 模板匹配(cvMatchTemplate)模板匹配是通过在输入图像上滑动模板图像块对实际的图像块和输入图像进行匹配，并且可以利用函数cvMinMaxLoc()找到最佳匹配的位置。 示例手动2点版 控制台 成绩 （最后点的时候手滑了…正常几百上千应该可以的） 下载所有工程文件和代码可在此处下载：JumpByJump 参考jump1jump人人都能看懂的“跳一跳”平民算法 附知乎热帖：怎样实现微信小游戏跳一跳的外挂？","raw":null,"content":null,"categories":[{"name":"软件开发","slug":"软件开发","permalink":"https://hubojing.github.io/categories/软件开发/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://hubojing.github.io/tags/OpenCV/"}]},{"title":"神转折2017","slug":"神转折2017","date":"2017-12-30T18:12:03.000Z","updated":"2017-12-30T19:11:57.000Z","comments":true,"path":"2017/12/31/神转折2017/","link":"","permalink":"https://hubojing.github.io/2017/12/31/神转折2017/","excerpt":"　　原来人生的转折点不必精心安排，它会以一种不经意的形式降临，不假思索甚至有些任性。 ","text":"原来人生的转折点不必精心安排，它会以一种不经意的形式降临，不假思索甚至有些任性。 年末的这几天，看着学妹也登上学校的最高领奖台，由衷地高兴，时间总归是不会辜负努力的人。但就是这几天，她私信我考研后的不知所措和对未来的迷茫，突然觉得每个人的经历是何等的相似，我们都在走前人走过的路。去年此时，一边迎来的是周围的飘飘然的称赞和掌声，一边迎来的是无尽的未知和沉甸甸的思索。还记得自己在留下纪念照片时只附上了几个字：道阻且长。 人生总有几个关键时间点让我铭记，2017将是其中之一。 按照时间顺序，做个简单的梳理吧。由于这儿是技术博客，我尽量围绕技术相关的事情叙述。 这一年，我考研失败了。我曾经以为自己如果失败了，会非常矫情地大哭一场。然而事实是出奇地平静，仿佛只是微风吹皱了水面起了一点儿涟漪。然后人生就开始出现我从没预想到的变化…… 作为一个理工科学生，自始至终我都将通信视作高端、复杂的代表，甚至有人把通信当信仰（这真是非常热爱了）。在大学四年里，我一直以为自己会按部就班的学习然后工作成为一名通信工程师……虽然在找工作以前，我从来没去真正了解过通信工程师的职责所在，我甚至不知道自己是否真正喜欢这一行，现在想来，真是too young too naive。直到考研结束后去就业市场逛了一逛，投了一波简历，参加了一些单位的面试。我不知道自己那时是否清楚了喜欢哪一行，但我明确知道了自己不喜欢哪些工作。印象最深的莫过于去某家事业单位应聘通信相关的工作，薪水颇高，起初听起来让人十分心动，父母也很有意愿。但毕竟是要把自己卖了，我怎么也得了解一下行情不是。查找了很多这方面的帖子，阅读了很多通信人的生涯。我突然发现这种工作和我心中的通信不太一样，我无法选择去过那种年纪轻轻就混吃等死的养老生活，没有追求，没有动力，没有发展，也不喜欢去深山老林实地勘测画图或者是夜半三更去蹲机房，感觉心中的通信神话一下子就跌入了深渊，这从不是我想要的生活。甚至因为自己不想去那家事业单位，前前后后和父母争辩过多次，最终慢慢让他们感受到了，我是认真的，他们也尊重我的想法。那段时间渐渐开始反复询问自己，到底喜欢什么。然后……画风就变了，简历求职意向再也看不到通信相关，取而代之是各种程序猿的工作。实事求是的说，一方面是IT业正当红，另一方面也是更重要的，我突然想起当年自己报志愿时第一志愿就是计算机专业，是临到最后两天，发现通信录取分数高于计算机专业感觉应该更好些，而当时以为通信就是计算机（所以论事先调研不妄自推测的重要性）而入了通信坑。四年里，曾有过对所学课程的质疑，但我一直将这种和兴趣有所偏离等价于没有理解知识本身的精髓。我还记得，其实当听到一种观点，通信工程约等于硬件，计算机专业约等于软件时，我就已经发现自己可能走错了，但正因有考研这个缓冲剂可以推迟这些考虑，让我心安理得地度过了这四年。 但我并不后悔和通信结缘的这四年，让我感觉自己反而是赚了，毕竟通信无处不在，而以后也能说一句，通信的那些我也是玩过的哟（此处是一个傲娇的表情）。通信将会一直是我心中高级和神圣的代名词。由于有通信工程的底子，我发现转入计算机真的不算太难。很多组成原理的知识，其实在通信工程里以微机原理甚至通信原理的形式出现了，而计算机网络、数据结构、数据库这些也都学过。而C语言的编程基础，总归还是有一些的。计算机三级当初自学的一些知识也很有用。其它的诸如matlab、Linux等课程的学习反而能增益自身。做一个了解硬件的软件工程师，也很酷。 六月，穿上学士服，我毕业了。机缘巧合，我来到现在的公司。 工作带给我的震撼，从四月实习开始。 由于毕竟非科班出身，那时对开发的认识还非常浅薄。之前因为兴趣建立了这个博客，学习html、css、js，接触github，听说找工作最火的是java就跟风去学java，感觉app做出来成就感立显就把毕设定为app设计，可是怎么也想不到，最后竟然会去做C++开发，并且打算走下去。这真是从来没有出现在之前的人生规划里。有时候自己都要感谢自己找工作时任性了一把，完全不去想什么规划什么未来什么大公司什么稳定，只是选择一个有挑战、真正符合兴趣、能感到快乐的工作而已（好了我知道这其实也很难）。可能有时候不是在计划内才踏实，顺其自然佛系一点，也会有出其不意的惊喜。四月份实习时，从C++基础开始，当时刚接触MFC，我还去搜了一下这是个什么东东，后来网上一片人说这是个过时玩意儿，我当时很不解，那干嘛还学？学校图书馆甚至几乎借不到MFC字样的书（后来才知道，原来这属于VC范畴……）只有后来工作了一段时间，才慢慢开始体会其蕴含的思想，那么多公司至今还使用它不是没有道理的。 很巧也很幸运，从面试到实习到入组，有一个人见证我的成长，就是我的老大。老大是我的上级，更是我的师父。面试时，他问我很多我的项目上技术的细节问题（很多是通信方面的），我觉得他很厉害。实习期时，啥都不懂的我觉得所有的问题都问不倒他，很厉害。入组后，在编码设计时犯迷糊他的指导总是一针见血，让我少走很多弯路，很厉害。所以他这么厉害当初怎么会愿意选择我……现在想来，对于那时一个没什么C++基础的人，能找到一份C++开发的工作，何其幸哉。 还有一位同事，相识于面试，一起经过实习，一起进入同一个部门，共同走过试用期。在刚入公司很懵懂的时候，有一个人始终和你是同一战线，也是很幸运的事情。那段时间，两个人总是一起分享实习试用期间各种心情，共同讨论编程的问题，甚至吃饭的时候我们还会讨论当时要做的一个大作业的代码问题。虽然后来由于对自身规划不同，人各有志，她不愿意继续程序媛的生活，选择了离职，但是当初她先面试后跑回来告诉我们面试官问的很细不要招架不住的贴心、中午下班后还停留在工位上讨论技术问题、微信上吐槽分享心情的时光总是非常令人想念。 更加细节的技术总结写在了公司的工作总结里，这儿就不提了。 这是我的生命中的第一份工作，6个月以来，经历了第一次加班，第一次绩效奖励的惊喜，第一次绩效扣分的失落，第一份需求的完成，第一份文件的评审，第一次与这么多比我大的人一起合作。 我感到快乐，这就是我工作的理由。虽然工资不多，但我每天都在写代码的过程中获得成就感和点滴能力提升的快感（虽然有时也会因为缺陷改不动而焦虑失落），让我感觉自己写出来的东西是有价值的。公司里连董事长都坚持写代码，和员工讨论技术问题，我很佩服。同事们也都很关照包容我，让我快乐地做一个公司年龄最小的程序媛哈哈（趁着新一波的应届生还没来临之前赶紧体会）。所以我竟然会时不时冒出想加班的念头（随后怀疑自己怕是傻了吧）。 再谈C++，其实我觉得自己可能还没什么资格谈论它。它可能确实很难，但这样好像更容易激发我的好胜心。慢慢接触越多，C++的魅力就越能体现，它原来可以做那么多的事情。总有人问我，当程序员不累吗？呐，做自己热爱的事情怎么会感觉累？就像我现在写这篇文章都不想去睡觉一样。 工作以前，我觉得工作了的人和学生的生活是天壤之别，简直没有共同语言。当自己也成为一个社会人时，才感觉其实社会也不是那么可怕，而自己的生活虽说有了新变化，但本质里还是当初那个愿意追求所爱的青年，只是可能更加成熟理智些罢了。就像我写在云村里的一条动态一样：“有时会庆幸考研失败，没有一条路到黑，让我足够冷静下来，认真去想清楚，我到底喜欢的是什么，可以无悔地热爱一生。拼搏确实不该盲目，否则只是肤浅地让自己感动，这大概是17于我的意义吧。想来这一年的跌宕起伏，不由嘴角上扬。原来人生的转折点不必精心安排，它会以一种不经意的形式降临，不假思索甚至有些任性。”我才发现，我喜欢的从来不是一劳永逸的安稳，而是未知带来的无尽可能性。 唯一的不悦来自自身，深感编程能力的不足与工程和业务能力的匮乏。内心十分渴望成为一名合格的程序员，然后真正配得上软件工程师的“工程师”三个字。所以，辞旧迎新之际，希望2018实现一个具体的要求：每日看足1小时技术类图书，以及不要熬夜。 写于2017年12月31日凌晨2点","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"年终总结","slug":"年终总结","permalink":"https://hubojing.github.io/tags/年终总结/"}]},{"title":"知识杂记","slug":"知识杂记","date":"2017-11-25T13:49:36.000Z","updated":"2017-12-07T15:22:32.000Z","comments":true,"path":"2017/11/25/知识杂记/","link":"","permalink":"https://hubojing.github.io/2017/11/25/知识杂记/","excerpt":"　　每个月的流量大多贡献给查资料了，学习果然是件烧钱的事情啊（正经脸） ","text":"每个月的流量大多贡献给查资料了，学习果然是件烧钱的事情啊（正经脸） 清空手机谷歌浏览器缓存的二十几个网页，也做一个简单的知识回顾。 使用CImage加载PNG的一般方法 打开stdafx.h添加#include&lt;atlimage.h&gt;； 定义一个CImage类对象，调用CImage::Load方法装载一个外部图像文件； 调用CImage::Draw方法绘制图像。 eg.(待测试)12345678910CRect rc;m_picCtrl.GetClientRect(&amp;rc);SetWindowPos(this, 0, 0, 320, 80, SWP_SHOWWINDOW);CString strTemp;strTemp.Format(_T(&quot;%d%d&quot;), rc.right, rc.bottom);CImage image;image.Load(_T(&quot;D:\\\\1.png&quot;));CDC* pDc = m_picCtrl.GetWindowDC();//获取设备句柄image.Draw(pDc-&gt;m_hDC, rc);UpdateWindow(); MFC tab控件 创建一个对话框，放tab控件，将控件添加变量m_tabCtrl 再创建两个对话框，修改属性Border:none，Style:Child 在tabDlg中添加两个对话框类变量 12CDialog1 m_dlg1;CDialog2 m_dlg2; 在tabDlg的OnInitDialog()函数中添加： 123456789101112131415161718CRect rect;m_tabCtrl.GetClientRect(&amp;rect);rect.top+=20;rect.bottom-=1;rect.left+1=1;rect.right-=2;m_tabCtrl.InsertItem(0,\"第一页\");m_tabCtrl.InsertItem(1,\"第二页\");m_dlg1.Create(IDD_DIALOG1,&amp;m_tabCtrl);//或者Create(IDD_DIALOG1,GetDlgItem(IDC_TAB));m_dlg2.Create(IDD_DIALOG2,&amp;m_tabCtrl);m_dlg1.ShowWindow(&amp;rect);m_dlg2.ShowWindow(&amp;rect);m_dlg1.ShowWindow(true);m_dlg2.ShowWindow(false); 在tabDlg中添加TCN_SELECHANGE消息 123456789101112131415void CtabDlg::OnTcnSelchangeTab1(NMHDR *PNMHDR, LRSULT *pResult)&#123; switch(m_tabCtrl.GetCurSel()) &#123; case 0: m_dlg1.ShowWindow(true); m_dlg2.SWP_SHOWWINDOW(false); break; case1: m_dlg1.ShowWindow(false); m_dlg2.ShowWindow(true); break; &#125; *pResult = 0;&#125; 安全函数strtok_swcstok_s 在MFC对话框中显示html网页创建对话框时勾选html对话框，添加控件变量m_html;然后在OnInitDialog()中添加1m_html.Navigate(\"www.baidu.com\"); CXImage的使用另成一篇。 限制只启动一个exe12345if(FindWindow(NULL,\"caption\")！= 0)&#123; MessageBox(\"程序已运行！\"); return;&#125; PCE.jshttps://jamesfriend.com.au/pce-js/mobile/ MFC复选框法一：12CButton* pBtn=(CButton*)GetDlgItem(IDC_CHECK1);int state = pBtn-&gt;GetCheck(); state==0 复选框没有被选中state==1 复选框被选中state==2 不确定（只有button有BS_3STATE或BS_AUTO3STATE style时才可用）设置状态：12CButton* pBtn=(CButton*)GetDlgItem(IDC_CHECK1);int state = pBtn-&gt;GetCheck(1); 法二：1234if(BST_CHECKED == IsDlgButtonChecked(IDC_CHECK1))&#123; //对应操作&#125; 使用BS_AUTOCHECKBOX、BS_AUTORADIOBUTTON、BS_AUTO3STATE、BS_CHECKBOX、BS_RADIOBUTTON或BS_3STATE样式创建的按钮的返回值可以是如下值之一：BST_CHECKED 按钮被选中BST_UNCHECKED 按钮未被选中BST_INDETERMINATE 不确定，按钮灰显（只有button有BS_3STATE或BS_AUTO3STATE style时才可用） 法三：为控件添加BOOL变量m_delete;12345void CTestDlg::DoDataExchange(CDataExchange *pDX)&#123; CTestDlg::DoDataExchange(pDX); DDX_Check(pDX,IDC_CHECK1,m_delete);&#125; 关于“不允许指针指向不完整的类类型”问题分析神贴必看，自从看过后，再也没犯过这个错，我不会说脑海里都是作者满满的嘲讽笑声的http://m.blog.csdn.net/luna84/article/details/50380186 树节点遍历1234567891011121314Traverse(m_tree, hChild)&#123; HTREEITEM hChild = m_tree.GetChildren(hItem); while(hChild) &#123; bool temp=Traverse(m_tree,hChild); if(temp==true) &#123; return true; &#125; hChild=m_tree.GetNextSiblingItem(hChild); &#125; return false;&#125; 遍历Vector的几种方法C++11法一：1234for(size_t i=0;i&lt;vec.size();++i)&#123; int iTemp = vec[i];&#125; 法二：1234for(auto it = vec.begin();it!=vec.end();++it)&#123; int iTemp = *it;&#125; 法三：1234for(int i:vec)&#123; int iTemp = i;&#125; 法四：123for_each(vec.begin(),vec.end(),[](int i)&#123;int iTemp = i;&#125;); 表达式的副作用http://www.cnblogs.com/shiguangshuo/p/5236962.html 理解递归另成一篇。 屏蔽回车和ESE123456789101112BOOL CTestDlg::PreTranslateMessage(MSG* pMsg)&#123; if(pMsg-&gt;message==WM_KEYDOWN) &#123; if(pMsg-&gt;wParam==VK_RETURN||pMsg-&gt;wParam==VK_ESCAPE) &#123; return true; &#125; &#125; return CDialogEx::PreTranslateMessage(pMsg);&#125; MFC查找特定后缀文件法一：12345678910111213141516171819CFileFind findfile;CString strPath;CString strName;CString strFilePath;BOOL bRet=findfile.FindFile(strPath+_T(\"*.txt\"));//以.txt为例if(!bRet)&#123;MessageBox(_T(\"无此文件！\"));&#125;while(bRet)&#123;bRet=findfile.FindNextFile();strName=findfile.GetFileTitle();strFilePath=findfile.GetFilePath();if(//操作)&#123;//所需操作;&#125;&#125; 法二：12345678910111213vector&lt;CString&gt; fileList;WIN32_FIND_DATA wfd;CString sPath=_T(\"*.txt\");HANDLE hFile=FindFirstFile(sPath.GetBuffer(),&amp;wfd);if(INVALID_HANDLE_VALUE==hFile)&#123;TRACE(_T(\"不合法！\\n\"));return;&#125;do&#123;fileList.push_back(wfd.cFileName);TRACE(\"%s\\n\",wfd.cFileName);&#125;while(FindNextFile(hFile,&amp;wfd)); 使用WIN32_FIND_DATA好像存在内存释放的问题。 为CDHtmlDialog添加滚动条初始化中添加以下代码即可。1SetHostFlags(DOCHOSTUIFLAG_NO3DBORDER|DOCHOSTUIFLAG_DIALOG); Notepad++ 没有自动补全敲代码好累…","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hubojing.github.io/categories/编程语言/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"},{"name":"MFC","slug":"MFC","permalink":"https://hubojing.github.io/tags/MFC/"}]},{"title":"PC评测","slug":"PC评测","date":"2017-11-21T12:57:10.000Z","updated":"2017-12-13T13:23:00.000Z","comments":true,"path":"2017/11/21/PC评测/","link":"","permalink":"https://hubojing.github.io/2017/11/21/PC评测/","excerpt":" 　　　　传统的贴图集。　　　　　　 ","text":"传统的贴图集。 配置详情 配置 其中显示器、光驱用的旧的。其它都是最近的新货，价钱请看组装PC。（夸一句冠捷显示器和漫步者音响质量真的很好） 集合 最便宜的GTX1060 6G上图（迷之塑料感） 显卡 显卡的金手指正反各有一根短一截，网上说是为了热插拔防止电涌情况发生。 跑分 跑分 娱乐大师跑分系列。很满足了……软件优化还是有效的，华硕主板自带软件可以自动超频，很方便，1600x 3.6主频自动超频到3.9，其它优化项调一调，跑分就升了六千分…… CPU CPU-Z （目前是3.89，别超了再伤了CPU，怎么得都是性能过剩啊哈哈哈） 评测 和i7-6700k对比，明显单处理器性能比不上i7-6700k，多线程完爆i7-6700k。 经历了闪龙-&gt;速龙-&gt;羿龙-&gt;锐龙…一个穷字贯穿始末 主板本来准备买华硕小板的，觉得性价比高，大板多出来的功能一般也用不到，然而京东价格战玩的很妙，守了几个月的小板套餐不降反升，价格竟然超过了大板……那我索性买大板得了。 主板 内存条宇瞻（Apacer） 黑豹玩家系列 DDR4 台式机内存 2400 8G 实测不翻车对于内存条 只想说一个字 贵 内存条 SSD ssd ssd 感觉很好了 显卡 GPU-Z 装机（一新一旧）AMD类型的散热器真是极难操作，非常难为我这样的柔弱女子(^▽^)记录一下：电源4+4pin CPU供电，20+4pin主板供电，6+2pin 独显供电。 新机：主板检测卡00（无任何其它数字的跳转）明明就是表示一切正常……百度都说是CPU或主板的问题，吓得我再想该怎么退货了，直到突然点亮。 旧机：主板检测卡68这确实是CPU的问题。我拿速龙的CPU去试，偷了懒没加散热器，结果……几秒后CPU烫手不能碰，主板也跟着热了。CPU不知道烧了没哦。上羿龙还是68，我都不敢多连通几秒就断电源。后经检查，是CPU上的硅胶涂多了，硅胶一小部分连到了两个针脚，擦除就好。 主板检测卡E1内存条的问题，最常见的就是金手指没擦干净。 成品 背部走线 换成了背部走线，还是没什么美感。。。 局部 （默默更换了电源的朝向。。。） 总结：满足了一个想要高配又没钱的青年人的装机愿望。。。","raw":null,"content":null,"categories":[{"name":"数码","slug":"数码","permalink":"https://hubojing.github.io/categories/数码/"}],"tags":[{"name":"硬件","slug":"硬件","permalink":"https://hubojing.github.io/tags/硬件/"}]},{"title":"Hexo多机同步","slug":"hexo多机同步","date":"2017-11-19T15:03:40.000Z","updated":"2019-09-14T08:25:11.000Z","comments":true,"path":"2017/11/19/hexo多机同步/","link":"","permalink":"https://hubojing.github.io/2017/11/19/hexo多机同步/","excerpt":"　　　　　　　Hexo多机同步简明教程。　　2019年9月更新　　　　 ","text":"Hexo多机同步简明教程。 2019年9月更新 老方法-较笨拙（写于2017年）起因：由于装了新电脑，就想搬到新电脑上写博客，但同时要求旧电脑也能同步更新和撰写。方法：主要是利用版本控制工具，将源文件上传到github，实现从github上同步repo更新。一般来说，有两种较常用的方法，一是新建原有repo的分支，二是新建一个放源文件的repo。由于之前手动备份md文件到github时我已有一个单独的repo，故采取法二。 hexo大致原理用过hexo的人都会发现，本地hexo文件和github上的文件是不同的。本地hexo保存的是.md文件，github上保存的是生成的html文件。所以直接clone github上的项目是不可行的。根据上次的分析，我们已知，_config.yml，theme/，source/，scaffolds/，package.json，.gitignore，是关注的重点。 新电脑hexo搭建工作 下载nodejs 下载git(记录一下版本，很多bug都是因为版本的原因造成)3.hexo五步法搭建hexo（具体可见博文hexo搭建再记录，或hexo.io） 至此，hexo环境完成。 ssh秘钥生成和添加因为是新电脑，需要将新生成的ssh添加到github ssh key中才可以使用。（具体可见博文SSH+Github就这么连） 拷贝数据文件从旧电脑上的blog文件夹中拷贝_config.yml，theme/，source/，scaffolds/，package.json，.gitignore。其它不用，因为会在hexo g &amp;&amp; hexo d中产生。 重装npm及插件如果你安装的是最新版的git（2.15）和nodejs（V8.9.1），npm install将会自动安装好部署所需的插件。否则就差什么补什么。在这里容易出各种错采坑。 部署和旧电脑一样的步骤部署即可。1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 同步刷新一般在部署前会在本地预览无误后再提交。但每做一次就要重新hexo g生成相当麻烦。好在有一个很酷的插件可以及时更新页面：1npm install hexo-browsersync --save 在localhost:4000就会同步更新你的本地修改啦。 多机同步两台电脑不能总是把源文件拷来拷去的吧，又或者万一哪天数据丢失了怎么办？ 于是我将hexo根目录下的source文件放到github上的source项目里同步更新，这样无论在哪台电脑上都可以下载最新的文件使用。 进入source文件夹，右键git bash git init初始化本地仓库 git add . 添加当前目录文件到暂存区域 git commit -m &quot;&lt;备注信息&gt;&quot; 提交到本地仓库 git push -u origin master 提交到远程仓库 不过我最后一句命令出错，原因是找不到origin，大概是仓库指定不明确。我想到使用github desktop也许更方便，于是就用它将source仓库clone到本地hexo文件夹下，并且删除原有文件，放入现有源文件。最后commit和push。 至此，多机同步实现。 失误操作github强制更新，原来的commit数600+没有了。连带着的小绿点也没了。现在的github展示页不好看了T_T 新方法-较快捷（写于2019年）因为Github私有仓库现在可以免费使用了，所以可以把整个hexo文件全部备份到Github上，而不是只备份文章。 旧电脑需要做什么 将博客根目录全部push到Github具体地，先在Github上新建仓库。在博客根目录：git initgit remote add origin http://xxxxxxxx(远程仓库地址)添加文件git add提交到暂存区git commit -m &quot;说明&quot;推送到远程仓库git push -u origin master(以后只需git push) 新电脑需要做什么 下载nodejs 下载Git 添加SSH到Github 安装Hexo 新建博客根目录 git init git remote add origin http://xxxxxxxx(远程仓库地址) git fetch --all git reset --hard oridin/master 安装各种Hexo插件（页面同步刷新之类的） 每次发布博客后需同步 git pull git add . git commit -m &quot;说明&quot; git push -u origin master(以后只需git push) 目前存在的问题2017年同步也出现了这个问题，就是强制更新的问题，会导致Git删除历史更新记录。如今这种方法依然存在这种问题。不过不影响写作，只是Github仓库的历史记录每次只会显示在最近一次机器上更新的全部历史记录，导致Github contributions的绿点丢失不少。究其原因是根目录下两台机器的.deploy_git文件不同，但简单合并会报错。Hexo git deployer 删除了提交历史记录该怎么整？这篇文章也证实了我的想法。 所以在这次同步以前，我先截了图，纪念一下这2年的提交数……马上就从Github contributions消失了。 博客提交数 参考资料https://blog.csdn.net/dxxzst/article/details/76135750","raw":null,"content":null,"categories":[{"name":"博客","slug":"博客","permalink":"https://hubojing.github.io/categories/博客/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hubojing.github.io/tags/Hexo/"}]},{"title":"栈","slug":"栈","date":"2017-11-14T14:50:51.000Z","updated":"2018-01-14T09:15:58.000Z","comments":true,"path":"2017/11/14/栈/","link":"","permalink":"https://hubojing.github.io/2017/11/14/栈/","excerpt":"　　　　　　 　　c++实现栈记录。　　　　　　　 ","text":"c++实现栈记录。 基础版MyStack.h1234567891011121314151617181920212223#ifndef MYSTACK_H#define MYSTACK_Hclass MyStack&#123;public: MyStack(int size); //分配内存初始化栈空间，设定栈容量，栈顶 ~MyStack(); //回收栈空间内存 bool stackEmpty(); //判定栈是否为空，为空则返回true，非空返回false bool stackFull(); //判定栈是否已满，为满返回true，不满返回false void clearStack(); //清空栈 int stackLength(); //已有元素的个数 bool push(char elem); //元素入栈，栈顶上升 bool pop(char &amp;elem); //元素出栈，栈顶下降 void stackTraverse(bool isFromButtom); //遍历栈中所有元素private: char* m_pBuffer; //栈空间指针 int m_iSize; //栈容量 int m_iTop; //栈顶，栈中元素个数&#125;;#endif MyStack.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include \"MyStack.h\"#include &lt;iostream&gt;using namespace std;MyStack::MyStack(int size)&#123; m_iSize = size; m_pBuffer = new char[size]; m_iTop = 0;&#125;MyStack::~MyStack()&#123; delete[]m_pBuffer;&#125;bool MyStack::stackEmpty()&#123; if (0 == m_iTop)//if(m_iTop==0) &#123; return true; &#125; return false;&#125;bool MyStack::stackFull()&#123; if (m_iTop == m_iSize)//&gt;= &#123; return true; &#125; return false;&#125;void MyStack::clearStack()&#123; m_iTop = 0;&#125;int MyStack::stackLength()&#123; return m_iTop;&#125;bool MyStack::push(char elem)&#123; if (stackFull()) &#123; return false; &#125; m_pBuffer[m_iTop] = elem; m_iTop++;//指向空位置 return true;&#125;// char MyStack::pop()// &#123;// if (stackEmpty())// &#123;// throw 1;// &#125;// else// &#123;// m_iTop--;// return m_pBuffer[m_iTop];// &#125;// &#125;bool MyStack::pop(char &amp;elem)&#123; if (stackEmpty()) &#123; return false; &#125; m_iTop--; elem = m_pBuffer[m_iTop]; return true;&#125;void MyStack::stackTraverse(bool isFromButtom)&#123; if (isFromButtom) &#123; for (int i = 0; i &lt; m_iTop; i++) &#123; cout &lt;&lt; m_pBuffer[i] &lt;&lt; \",\"; &#125; &#125; else &#123; for (int i = m_iTop - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; m_pBuffer[i] &lt;&lt; \",\"; &#125; &#125;&#125; demo.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include \"stdlib.h\"#include \"MyStack.h\"using namespace std;/*************************************************************************//* 栈类 要求： MyStack(int size); //分配内存初始化栈空间，设定栈容量，栈顶 ~MyStack(); //回收栈空间内存 bool stackEmpty(); //判定栈是否为空，为空则返回true，非空返回false bool stackFull(); //判定栈是否已满，为满返回true，不满返回false void clearStack(); //清空栈 int stackLength(); //已有元素的个数 void push(char elem); //元素入栈，栈顶上升 char pop(char &amp;elem); //元素出栈，栈顶下降 void stackTraverse(); //遍历栈中所有元素 目的：掌握栈的实现原理和运行机制*//*************************************************************************/int main(void)&#123; MyStack *pStack = new MyStack(5); pStack-&gt;push('h');//底 pStack-&gt;push('e'); pStack-&gt;push('l'); pStack-&gt;push('l'); pStack-&gt;push('o');//顶 pStack-&gt;stackTraverse(true); char elem = 0; pStack-&gt;pop(elem); cout &lt;&lt; endl; cout &lt;&lt; elem &lt;&lt; endl; //pStack-&gt;clearStack(); pStack-&gt;stackTraverse(false); cout &lt;&lt; pStack-&gt;stackLength() &lt;&lt; endl; if (pStack-&gt;stackEmpty()) &#123; cout &lt;&lt; \"栈为空\" &lt;&lt; endl; &#125; if (pStack-&gt;stackFull()) &#123; cout &lt;&lt; \"栈为满\" &lt;&lt; endl; &#125; delete pStack; pStack = NULL; system(\"pause\"); return 0;&#125; 运行 result 中级版——复杂数据类型Coordinate.h若数据类型较复杂，例如数据类型为Coordinate123456789101112131415#ifndef COORDINATE_H#define COORDINATE_Hclass Coordinate&#123;public: Coordinate(int x = 0, int y = 0); void printCoordinate();private: int m_iX; int m_iY;&#125;;#endif Coordinate.cpp1234567891011121314#include \"Coordinate.h\"#include &lt;iostream&gt;using namespace std;Coordinate::Coordinate(int x, int y)&#123; m_iX = x; m_iY = y;&#125;void Coordinate::printCoordinate()&#123; cout &lt;&lt; \"(\" &lt;&lt; m_iX &lt;&lt; \",\" &lt;&lt; m_iY &lt;&lt; \")\" &lt;&lt; endl;&#125; demo.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include \"stdlib.h\"#include \"MyStack.h\"using namespace std;/*************************************************************************//* 栈 要求： 1.定义Coordinate坐标类 2.改造栈类，使其可以使用于坐标类 目的：灵活掌握栈机制，理解抽象数据类型在栈中的应用*//*************************************************************************/int main(void)&#123; MyStack *pStack = new MyStack(5); pStack-&gt;push(Coordinate(1, 2)); pStack-&gt;push(Coordinate(3, 4)); pStack-&gt;stackTraverse(true); pStack-&gt;stackTraverse(false); cout &lt;&lt; pStack-&gt;stackLength() &lt;&lt; endl; if (pStack-&gt;stackEmpty()) &#123; cout &lt;&lt; \"栈为空\" &lt;&lt; endl; &#125; if (pStack-&gt;stackFull()) &#123; cout &lt;&lt; \"栈为满\" &lt;&lt; endl; &#125; delete pStack; pStack = NULL; system(\"pause\"); return 0;&#125; 运行结果(1,2)(3,4)(3,4)(1,2)2 高级版——类模板去掉MyStack.cpp MyStack.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#ifndef MYSTACK_H#define MYSTACK_Htemplate &lt;typename T&gt;class MyStack&#123;public: MyStack(int size); //分配内存初始化栈空间，设定栈容量，栈顶 ~MyStack(); //回收栈空间内存 bool stackEmpty(); //判定栈是否为空，为空则返回true，非空返回false bool stackFull(); //判定栈是否已满，为满返回true，不满返回false void clearStack(); //清空栈 int stackLength(); //已有元素的个数 bool push(T elem); //元素入栈，栈顶上升 bool pop(T &amp;elem); //元素出栈，栈顶下降 void stackTraverse(bool isFromButtom); //遍历栈中所有元素private: T *m_pBuffer; //栈空间指针 int m_iSize; //栈容量 int m_iTop; //栈顶，栈中元素个数&#125;;template&lt;typename T&gt;MyStack&lt;T&gt;::MyStack(int size)&#123; m_iSize = size; m_pBuffer = new T[size]; m_iTop = 0;&#125;template&lt;typename T&gt;MyStack&lt;T&gt;::~MyStack()&#123; delete[]m_pBuffer;&#125;template&lt;typename T&gt;bool MyStack&lt;T&gt;::stackEmpty()&#123; if (0 == m_iTop)//if(m_iTop==0) &#123; return true; &#125; return false;&#125;template&lt;typename T&gt;bool MyStack&lt;T&gt;::stackFull()&#123; if (m_iTop == m_iSize)//&gt;= &#123; return true; &#125; return false;&#125;template&lt;typename T&gt;void MyStack&lt;T&gt;::clearStack()&#123; m_iTop = 0;&#125;template&lt;typename T&gt;int MyStack&lt;T&gt;::stackLength()&#123; return m_iTop;&#125;template&lt;typename T&gt;bool MyStack&lt;T&gt;::push(T elem)&#123; if (stackFull()) &#123; return false; &#125; m_pBuffer[m_iTop] = elem; m_iTop++;//指向空位置 return true;&#125;template&lt;typename T&gt;bool MyStack&lt;T&gt;::pop(T &amp;elem)&#123; if (stackEmpty()) &#123; return false; &#125; m_iTop--; elem = m_pBuffer[m_iTop]; return true;&#125;template&lt;typename T&gt;void MyStack&lt;T&gt;::stackTraverse(bool isFromButtom)&#123; if (isFromButtom) &#123; for (int i = 0; i &lt; m_iTop; i++) &#123; cout &lt;&lt; m_pBuffer[i]; &#125; &#125; else &#123; for (int i = m_iTop - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; m_pBuffer[i]; &#125; &#125;&#125;#endif Coordinate.h12345678910111213141516171819#ifndef COORDINATE_H#define COORDINATE_H#include &lt;ostream&gt;using namespace std;class Coordinate&#123; friend ostream &amp;operator&lt;&lt;(ostream &amp;out, Coordinate &amp;coor);public: Coordinate(int x = 0, int y = 0); void printCoordinate();private: int m_iX; int m_iY;&#125;;#endif Coordinate.cpp1234567891011121314151617181920#include \"Coordinate.h\"#include &lt;iostream&gt;using namespace std;Coordinate::Coordinate(int x, int y)&#123; m_iX = x; m_iY = y;&#125;void Coordinate::printCoordinate()&#123; cout &lt;&lt; \"(\" &lt;&lt; m_iX &lt;&lt; \",\" &lt;&lt; m_iY &lt;&lt; \")\" &lt;&lt; endl;&#125;ostream &amp;operator&lt;&lt;(ostream &amp;out, Coordinate &amp;coor)&#123; out &lt;&lt;\"(\" &lt;&lt; coor.m_iX &lt;&lt; \",\" &lt;&lt; coor.m_iY &lt;&lt; \")\" &lt;&lt; endl; return out;&#125; demo.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include \"stdlib.h\"#include \"MyStack.h\"#include \"Coordinate.h\"using namespace std;/*************************************************************************//* 栈 类模板 要求： 将普通栈制造为类模板栈，使其可以适用于任何数据类型 目的：灵活掌握栈机制，理解抽象数据类型在栈中的应用*//*************************************************************************/int main(void)&#123; MyStack&lt;char&gt; *pStack = new MyStack&lt;char&gt;(5); pStack-&gt;push('h'); pStack-&gt;push('l'); pStack-&gt;stackTraverse(true); pStack-&gt;stackTraverse(false); cout &lt;&lt; pStack-&gt;stackLength() &lt;&lt; endl; if (pStack-&gt;stackEmpty()) &#123; cout &lt;&lt; \"栈为空\" &lt;&lt; endl; &#125; if (pStack-&gt;stackFull()) &#123; cout &lt;&lt; \"栈为满\" &lt;&lt; endl; &#125; delete pStack; pStack = NULL; system(\"pause\"); return 0;&#125; 运行结果 结果 应用——进制转换demo.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include \"stdlib.h\"#include \"MyStack.h\"#include \"Coordinate.h\"using namespace std;/*************************************************************************//* 栈应用——数制转换 描述：输入任意的十进制正整数N，分别输出该整数N的二进制、八进制、十六进制的数 公式：N=(N div d) * d + N mod d (div表示整除，mod表示求余) (1348)(十进制) = (2504)(八进制) = (544)(十六进制) = (10101000100)(二进制) 短除法 N N div 8 N mod 8 1348 168 4 168 21 0 21 2 5 2 0 2 N N div 16 N mod 16 1348 84 4 84 5 4 5 0 5 目的：通过实例灵活掌握栈机制的使用技巧 *//*************************************************************************/#define BINARY 2#define OCTONARY 8#define HEXADECTMAL 16int main(void)&#123; MyStack&lt;int&gt; *pStack = new MyStack&lt;int&gt;(30); int N = 1348; int mod = 0; while (N != 0) &#123; mod = N % OCTONARY; pStack-&gt;push(mod); N = N / OCTONARY; &#125; pStack-&gt;stackTraverse(false); delete pStack; pStack = NULL; system(\"pause\"); return 0;&#125; 上述可使用于二进制、八进制，但对于十六进制还有些瑕疵。改进一下：123456789101112131415161718192021222324252627282930313233343536#define BINARY 2#define OCTONARY 8#define HEXADECTMAL 16int main(void)&#123; char num[] = \"0123456789ABCDEF\"; MyStack&lt;int&gt; *pStack = new MyStack&lt;int&gt;(30); int N = 2016; int mod = 0; while (N != 0) &#123; mod = N % HEXADECTMAL; pStack-&gt;push(mod); N = N / HEXADECTMAL; &#125;// pStack-&gt;stackTraverse(false); // for (int i = pStack-&gt;stackLength() - 1; i &gt;= 0; i--)// &#123;// num[pStack[i]]// &#125; int elem = 0; while (!pStack-&gt;stackEmpty()) &#123; pStack-&gt;pop(elem); cout &lt;&lt; num[elem]; &#125; delete pStack; pStack = NULL; system(\"pause\"); return 0;&#125; 输出：7E0 应用——括号匹配1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include \"stdlib.h\"#include \"MyStack.h\"#include \"Coordinate.h\"using namespace std;/*************************************************************************//* 栈应用——括号匹配 描述：任意输入一组括号，可以判断括号是否匹配 字符串示例：[()] [()()] [()[()]] [[()] 目的：通过实例灵活掌握栈机制的使用技巧 *//*************************************************************************/int main(void)&#123; MyStack&lt;char&gt; *pStack = new MyStack&lt;char&gt;(30); MyStack&lt;char&gt; *pNeedStack = new MyStack&lt;char&gt;(30); char str[] = \"[()]]\"; char currentNeed = 0; for (int i = 0; i &lt; strlen(str); i++) &#123; if (str[i] != currentNeed) &#123; pStack-&gt;push(str[i]); switch (str[i]) &#123; case '[': if (currentNeed != 0) &#123; pNeedStack-&gt;push(currentNeed); &#125; currentNeed = ']'; break; case '(': if (currentNeed != 0) &#123; pNeedStack-&gt;push(currentNeed); &#125; currentNeed = ')'; break; default: cout &lt;&lt; \"字符串括号不匹配\" &lt;&lt; endl; system(\"pause\"); return 0; &#125; &#125; else &#123; char elem; pStack-&gt;pop(elem); if (!pNeedStack-&gt;pop(currentNeed)) &#123; currentNeed = 0; &#125; &#125; &#125; if (pStack-&gt;stackEmpty()) &#123; cout &lt;&lt; \"字符串括号匹配\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"字符串括号不匹配\" &lt;&lt; endl; &#125; delete pStack; pStack = NULL; delete pNeedStack; pNeedStack = NULL; system(\"pause\"); return 0;&#125; 感觉示例代码存在问题，default后没有释放内存，存在内存泄漏。 更好的思路：一个MyStack即可，判断是否为左括号，是就push；否则是右括号，若不匹配，则cout不匹配，匹配则pop。最后栈是否为空，空则匹配。","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hubojing.github.io/categories/编程语言/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"},{"name":"数据结构","slug":"数据结构","permalink":"https://hubojing.github.io/tags/数据结构/"}]},{"title":"windows软件使用小技巧","slug":"windows软件使用小技巧","date":"2017-11-12T10:19:56.000Z","updated":"2018-05-01T11:18:15.000Z","comments":true,"path":"2017/11/12/windows软件使用小技巧/","link":"","permalink":"https://hubojing.github.io/2017/11/12/windows软件使用小技巧/","excerpt":" 　　　　　　小问题解决方案记录集。　　 　　　　 ","text":"小问题解决方案记录集。 word打开提示setup error（win7） The setup controller has encountered a problem during install. Please review the log files for further informatin on the error. 解决方法：重装不起作用。到C:\\Program Files\\Common Files\\Microsoft Shared\\OFFICE12\\Office Setup Controller，将这个文件夹删除，就不再出现提示了。 （word2007） 各软件最近历史始终为空（win7） 最近打开的文件没有记录 解决方法：在“运行”中输入gpedit.msc，在树中依次展开到以下项目，用户配置——管理模板——任务栏和开始菜单，在左侧的任务栏和开始菜单窗口找到并双击打开“不要保留最近打开文档的记录”项目，打开“不要保留最近打开文档的记录”属性界面，在“设置”选项卡中选择“已禁用”，最后单击“确定”按钮让设置生效。 文件夹左边栏没有桌面选项（win7） 比如点击我的电脑显示在左侧的文件夹没有桌面 解决方法：找到桌面的路径，eg.C:\\Users\\lenovo\\Desktop，在收藏夹上右击，选择“将当前位置添加到收藏夹”。（记得点击收藏夹旁的三角展开才看得到） 完全卸载VS最近将VS安装目录里的中文换成英文后，VS就打不开了……重新安装也无法选择安装路径。原因是原版VS未卸载。 解决方法：完全卸载方式： 解压你的vs2013的安装包(iso格式) cd到解压后的文件夹 vs_ultimate.exe /uninstall /force U盘格式转换U盘单个4G以上的文件在ntfs格式下才可以放入。convert命令FAT32转NTFS（不影响硬盘数据）12convert i:/fs:ntfs# i为disk盘符","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"https://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://hubojing.github.io/tags/Windows/"}]},{"title":"队列","slug":"队列","date":"2017-11-12T08:39:06.000Z","updated":"2017-11-12T09:37:21.000Z","comments":true,"path":"2017/11/12/队列/","link":"","permalink":"https://hubojing.github.io/2017/11/12/队列/","excerpt":" 　　 　　 　c++实现环形队列记录。　　 　　 　　 　　 ","text":"c++实现环形队列记录。 MyQueue.h1234567891011121314151617181920212223242526//环形队列C++实现#ifndef MYQUEUE_H#define MYQUEUE_Hclass MyQueue&#123;public: MyQueue(int queueCapacity); //InitQueue(&amp;Q) 创建队列 virtual ~MyQueue(); //DestroyQueue(&amp;Q) 销毁队列 void ClearQueue(); //ClearQueue(&amp;Q) 清空队列 bool QueueEmpty() const; //QueueEmpty(Q) 判空队列 bool QueueFull() const; //QueueFull(Q) 判满队列 int QueueLength() const; //QueueLength(Q) 队列长度 bool EnQueue(int element); //EnQueue(&amp;Q, element) 新元素入队 bool DeQueue(int &amp;element); //DeQueue(&amp;Q, &amp;element) 首元素出队 void QueueTraverse(); //QueueTraverse(Q, visit()) 遍历队列private: int *m_pQueue; //队列数组指针 int m_iQueueLen; //队列元素个数 int m_iQueueCapacity; //队列数组容量 int m_iHead; int m_iTail;&#125;;#endif 注释为C语言版。 MyQueue.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include \"MyQueue.h\"#include &lt;iostream&gt;using namespace std;MyQueue::MyQueue(int queueCapacity)&#123; m_iQueueCapacity = queueCapacity; m_pQueue = new int[m_iQueueCapacity]; ClearQueue();&#125;MyQueue::~MyQueue()&#123; delete[]m_pQueue; m_pQueue = NULL;&#125;void MyQueue::ClearQueue()&#123; m_iHead = 0; m_iTail = 0; m_iQueueLen = 0;&#125;bool MyQueue::QueueEmpty() const&#123; if (m_iQueueLen == 0) &#123; return true; &#125; else &#123; return false; &#125;// return m_iQueueLen == 0 ? true : false;&#125;int MyQueue::QueueLength() const&#123; return m_iQueueLen;&#125;bool MyQueue::QueueFull() const&#123; if (m_iQueueLen==m_iQueueCapacity) &#123; return true; &#125; return false;&#125;bool MyQueue::EnQueue(int element)&#123; if (QueueFull()) &#123; return false; &#125; else &#123; m_pQueue[m_iTail] = element; m_iTail++; m_iTail = m_iTail%m_iQueueCapacity; m_iQueueLen++; return true; &#125;&#125;bool MyQueue::DeQueue(int &amp;element)&#123; if (QueueEmpty()) &#123; return false; &#125; else &#123; element = m_pQueue[m_iHead]; m_iHead++; m_iHead = m_iHead%m_iQueueCapacity; m_iQueueLen--; return true; &#125;&#125;void MyQueue::QueueTraverse()&#123; cout &lt;&lt; endl; for (int i = m_iHead; i &lt; m_iQueueLen + m_iHead; i++) &#123; cout &lt;&lt; m_pQueue[i%m_iQueueCapacity] &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125; demo.cpp1234567891011121314151617181920212223242526272829303132333435363738394041//实现环形队列#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include \"MyQueue.h\"using namespace std;int main(void)&#123; MyQueue *p = new MyQueue(4); p-&gt;EnQueue(1); p-&gt;EnQueue(2); p-&gt;EnQueue(3); p-&gt;EnQueue(4); p-&gt;EnQueue(5);//判满 p-&gt;QueueTraverse(); int e = 0; p-&gt;DeQueue(e); cout &lt;&lt; e &lt;&lt; endl; p-&gt;DeQueue(e); cout &lt;&lt; endl; cout &lt;&lt; e &lt;&lt; endl; p-&gt;QueueTraverse(); p-&gt;ClearQueue(); p-&gt;QueueTraverse(); p-&gt;EnQueue(10); p-&gt;EnQueue(20); p-&gt;QueueTraverse(); delete p; p = NULL; system(\"pause\"); return 0;&#125; 运行结果 demo 若对象成员较复杂：比如为Custeomer类 Customer.h1234567891011121314151617#ifndef CUSTOMER_H#define CUSTOMER_H#include &lt;string&gt;using namespace std;class Customer&#123;public: Customer(string name = \"\", int age = 0); void printInfo() const;private: string m_strName; int m_iAge;&#125;;#endif Customer.cpp12345678910111213141516#include&lt;iostream&gt;#include \"Customer.h\"using namespace std;Customer::Customer(string name, int age)&#123; m_strName = name; m_iAge = age;&#125;void Customer::printInfo() const&#123; cout &lt;&lt; \"姓名：\" &lt;&lt; m_strName &lt;&lt; endl; cout &lt;&lt; \"年龄：\" &lt;&lt; m_iAge &lt;&lt; endl; cout &lt;&lt; endl;&#125; MyQueue.h修改1234#include \"Customer.h\" bool EnQueue(Customer element); //EnQueue(&amp;Q, element) 新元素入队 bool DeQueue(Customer &amp;element); //DeQueue(&amp;Q, &amp;element) 首元素出队 Customer *m_pQueue; //队列数组指针 MyQueue.cpp修改1234567891011121314151617181920bool MyQueue::EnQueue(Customer element)bool MyQueue::DeQueue(Customer &amp;element)MyQueue::MyQueue(int queueCapacity)&#123; m_iQueueCapacity = queueCapacity; m_pQueue = new Customer[m_iQueueCapacity]; ClearQueue();&#125;void MyQueue::QueueTraverse()&#123; cout &lt;&lt; endl; for (int i = m_iHead; i &lt; m_iQueueLen + m_iHead; i++) &#123; m_pQueue[i%m_iQueueCapacity].printInfo(); cout &lt;&lt; \"前面还有\" &lt;&lt; (i - m_iHead) &lt;&lt; \"人\" &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125; demo.cpp123456789101112131415161718192021222324252627282930313233//实现环形队列#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include \"MyQueue.h\"#include \"Customer.h\"using namespace std;int main(void)&#123; MyQueue *p = new MyQueue(4); Customer c1(\"zhangsan\", 20); Customer c2(\"lisi\", 30); Customer c3(\"wangwu\", 10); p-&gt;EnQueue(c1); p-&gt;EnQueue(c2); p-&gt;EnQueue(c3); p-&gt;QueueTraverse(); Customer c4(\"\", 0); p-&gt;DeQueue(c4); c4.printInfo(); p-&gt;QueueTraverse(); delete p; p = NULL; system(\"pause\"); return 0;&#125; 运行结果 result","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hubojing.github.io/categories/编程语言/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"},{"name":"数据结构","slug":"数据结构","permalink":"https://hubojing.github.io/tags/数据结构/"}]},{"title":"WatchYourPC","slug":"WatchYourPC","date":"2017-10-24T15:22:20.000Z","updated":"2017-10-24T15:22:20.000Z","comments":true,"path":"2017/10/24/WatchYourPC/","link":"","permalink":"https://hubojing.github.io/2017/10/24/WatchYourPC/","excerpt":" 　　 　　写了一个小玩具，自动记录每次开机时间。　 　　　　 ","text":"写了一个小玩具，自动记录每次开机时间。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;windows.h&gt;#include &lt;ctime&gt;#include &lt;fstream&gt;#include &lt;tchar.h&gt;#include &lt;string&gt;using namespace std;string getTime()&#123; time_t nowTime; time(&amp;nowTime); struct tm t; localtime_s(&amp;t, &amp;nowTime); char chYear[64], chMonth[64], chDay[64], chHour[64], chMin[64], chSec[64]; int iYear = t.tm_year + 1900; int iMonth = t.tm_mon + 1; int iDay = t.tm_mday; int iHour = t.tm_hour; int iMin = t.tm_min; int iSec = t.tm_sec; _itoa_s(iYear, chYear, sizeof(chYear), 10); _itoa_s(iMonth, chMonth, sizeof(chMonth), 10); _itoa_s(iDay, chDay, sizeof(chDay), 10); _itoa_s(iHour, chHour, sizeof(chHour), 10); _itoa_s(iMin, chMin, sizeof(chMin), 10); _itoa_s(iSec, chSec, sizeof(chSec), 10); string sYear = chYear; string sMonth = chMonth; string sDay = chDay; string sHour = chHour; string sMin = chMin; string sSec = chSec; string sTmp; sTmp = \"开机时间记录：\" + sYear + \"年\" + sMonth + \"月\" + sDay + \"日\" + sHour + \"时\" + sMin + \"分\" + sSec + \"秒\"; return sTmp;&#125;int main()&#123; //写入txt ofstream fout(\"D:\\\\WatchYourPC.txt\", ios::app); string time = getTime(); fout &lt;&lt; time &lt;&lt; endl; CHAR pathtofile[MAX_PATH] = &#123; 0 &#125;; HMODULE GetModH = GetModuleHandle(NULL); GetModuleFileName(GetModH, (LPWSTR)pathtofile, sizeof(pathtofile)); //写入注册表 HKEY hKey; RegOpenKeyEx(HKEY_CURRENT_USER, _T(\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\"), 0, KEY_SET_VALUE, &amp;hKey); int iLen = sizeof(pathtofile); RegSetValueEx(hKey, _T(\"WatchYourPC\"), 0, REG_SZ, (const unsigned char*)pathtofile, iLen); RegCloseKey(hKey); return 0;&#125; 效果 效果","raw":null,"content":null,"categories":[{"name":"软件开发","slug":"软件开发","permalink":"https://hubojing.github.io/categories/软件开发/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"}]},{"title":"C++封装exe以及资源更新","slug":"封装exe以及资源更新","date":"2017-10-12T14:46:29.000Z","updated":"2017-10-13T14:38:02.000Z","comments":true,"path":"2017/10/12/封装exe以及资源更新/","link":"","permalink":"https://hubojing.github.io/2017/10/12/封装exe以及资源更新/","excerpt":" 　　 　　 　CDHtmlDialog、UpdateResource、ShellExecute用法简记。　　 　　 　　 ","text":"CDHtmlDialog、UpdateResource、ShellExecute用法简记。 C++封装exe目标：一个网页，想以exe呈现。法一：使用webbrowser控件工具箱右键Group Box，[选择项]-[COM组件]-[Microsoft Web Browser]。初始化中，1m_webbrowser.Navigate(_T(\"file:///D:/test.htm\"),NULL,NULL,NULL,NULL); 法二：新建MFC，勾选html对话框。（实质是内嵌了一个webbrowser控件）初始化中，1Navigate(_T(\"www.hubojing.me\")); MFC编译后会自动生成exe文件。 12345678 void Navigate( LPCTSTR lpszURL, DWORD dwFlags = 0, LPCTSTR lpszTargetFrameName = NULL, LPCTSTR lpszHeaders = NULL, LPVOID lpvPostData = NULL, DWORD dwPostDataLen = 0 ); 详见https://msdn.microsoft.com/zh-cn/library/fyhfs9yd.aspx CDHtmlDialoghtml对话框继承了CDHtmlDialog，和CDialog不同之处是包含了一个HTML资源。如何在CDHtmlDialog中引用html资源的方法 UpdateResource用法12345678BOOL WINAPI UpdateResource( _In_ HANDLE hUpdate, _In_ LPCTSTR lpType, _In_ LPCTSTR lpName, _In_ WORD wLanguage, _In_opt_ LPVOID lpData, _In_ DWORD cbData); 参数一的句柄利用 BeginUpdateResource 来获得。参数二 资源类型 详见https://msdn.microsoft.com/en-us/library/windows/desktop/ms648009(v=vs.85).aspxeg.html为RT_HTML，对话框为RT_DIALOG。参数三是要插入的资源的资源ID，常用MAKEINTRESOURCE(ID)形式。注意在使用前#define IDC_XXXX_XXXX 105定义（要和资源本身ID号相同），否则报错。参数四是一个指向资源指针，注意只能是Unicode格式。参数五是资源的大小size。 官方例子：https://msdn.microsoft.com/en-us/library/windows/desktop/ms648008(v=vs.85).aspx#_win32_Updating_Resourceseg.该版比2008版msdn有小更改，现在的更清晰明了。 Updating Resources目标：将Hand.exe中的dialog box资源插入到Foot.exe。过程：1.使用LoadLibrary函数加载Hand.exe。2.使用FindResource和LoadResource函数定位和加载dialog box资源。3.使用LockResource函数获得一个指向dialog box资源的指针。4.使用BeginUpdateResource函数打开一个Foot.exe的更新句柄。5.使用UpdateResource函数从Hand.exe复制dialog box资源到Foot.exe。6.使用EndUpdateResource函数来完成更新。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576HGLOBAL hResLoad; // handle to loaded resourceHMODULE hExe; // handle to existing .EXE fileHRSRC hRes; // handle/ptr. to res. info. in hExeHANDLE hUpdateRes; // update resource handleLPVOID lpResLock; // pointer to resource dataBOOL result;#define IDD_HAND_ABOUTBOX 103#define IDD_FOOT_ABOUTBOX 110// Load the .EXE file that contains the dialog box you want to copy.hExe = LoadLibrary(TEXT(\"hand.exe\"));if (hExe == NULL)&#123; ErrorHandler(TEXT(\"Could not load exe.\")); return;&#125;// Locate the dialog box resource in the .EXE file.hRes = FindResource(hExe, MAKEINTRESOURCE(IDD_HAND_ABOUTBOX), RT_DIALOG);if (hRes == NULL)&#123; ErrorHandler(TEXT(\"Could not locate dialog box.\")); return;&#125;// Load the dialog box into global memory.hResLoad = LoadResource(hExe, hRes);if (hResLoad == NULL)&#123; ErrorHandler(TEXT(\"Could not load dialog box.\")); return;&#125;// Lock the dialog box into global memory.lpResLock = LockResource(hResLoad);if (lpResLock == NULL)&#123; ErrorHandler(TEXT(\"Could not lock dialog box.\")); return;&#125;// Open the file to which you want to add the dialog box resource.hUpdateRes = BeginUpdateResource(TEXT(\"foot.exe\"), FALSE);if (hUpdateRes == NULL)&#123; ErrorHandler(TEXT(\"Could not open file for writing.\")); return;&#125;// Add the dialog box resource to the update list.result = UpdateResource(hUpdateRes, // update resource handle RT_DIALOG, // change dialog box resource MAKEINTRESOURCE(IDD_FOOT_ABOUTBOX), // dialog box id MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), // neutral language lpResLock, // ptr to resource info SizeofResource(hExe, hRes)); // size of resource infoif (result == FALSE)&#123; ErrorHandler(TEXT(\"Could not add resource.\")); return;&#125;// Write changes to FOOT.EXE and then close it.if (!EndUpdateResource(hUpdateRes, FALSE))&#123; ErrorHandler(TEXT(\"Could not write changes to file.\")); return;&#125;// Clean up.if (!FreeLibrary(hExe))&#123; ErrorHandler(TEXT(\"Could not free executable.\")); return;&#125; ShellExecute用法12345678ShellExecute(HWND hwnd, //父窗口句柄LPCSTR lpOperation, //操作类型LPCSTR lpFile, //要进行操作的文件或路径LPCSTR lpParameters, //当lpOperation为“explore”时指定要传递的参数，通常设为NULLLPCSTR lpDirectory, //指定默认目录，通常设为NULLINT nShowCmd //文件打开的方式，以通常方式还是最大化或最小化显示) eg：ShellExecute(NULL,”open”,”calc.exe”,NULL,NULL,SW_SHOWNORMAL);//调用计算器ShellExecute(NULL,”open”,”NOTEPAD.EXE”,NULL,NULL,SW_SHOWNORMAL);//调用记事本 详见https://msdn.microsoft.com/en-us/library/windows/desktop/bb762153(v=vs.85).aspx","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hubojing.github.io/categories/编程语言/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"}]},{"title":"Hexo搭建再记录","slug":"hexo搭建再记录","date":"2017-10-08T14:17:33.000Z","updated":"2017-10-12T18:36:14.000Z","comments":true,"path":"2017/10/08/hexo搭建再记录/","link":"","permalink":"https://hubojing.github.io/2017/10/08/hexo搭建再记录/","excerpt":"    　　  　　  　博客部署莫名崩了…重新搭建  　  　问题突然解决　　  　有新收获　　","text":"博客部署莫名崩了…重新搭建 问题突然解决 有新收获 hexo五步法安装hexo所需的node.js和git不再赘述。在所需目录下git bash，输入以下五步即可生成本地博客页面。12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 1 2 4-1 4-2 5 在浏览器中输入localhost:4000即可查看本地页面。 localhost 我们看一看生成了哪些文件。 blog 根目录里生成了一个名为”blog“的文件夹。 blog文件夹下 1是node.js的模块，2是模板，3是源文件，4是主题，5是git用来忽略生成文件的，6是hexo配置文件，7是数据文件，8是各种包?。1中已有： node_modules 这是目前我本地已安装的插件： 所需的插件 问题：国庆假期部署不上来，hexo d后正常跑文件然后卡住，许久（感觉至少半小时+）报错：fatal: sha1 file ‘‘ write error: Broken pipe 此前只进行过2种不常用操作：1.一次merge2.更改了博客本地目录电脑的管理员用户名 说一下我做过的抢救：1.三次revert回滚操作——没用感谢iny的pull request，让我对git命令行操作又了解了一些，并且熟悉了github客户端操作。这次的问题不是merge的问题。为什么如此肯定呢？ 2.重设ssh——也许起到了作用既然和merge无关，只可能和访问权限有关了。那ssh全部清空重设，github上的公钥也清空重来。注意：像我这样部署到github和coding的，别忘了coding也要重设ssh。不过还是部署失败。真是迷一般的问题哟。影响放假心情，文章写好了发不出去的苦恼…… 2.再次搭建——助攻我将原有博客文件放入hexo1文件夹中。按照上述五步法再次搭建了一个新的博客放入hexo文件夹，复制相关文件（merge前）后再次部署依然不奏效。但是！！！此时再次部署hexo1中的老博客，出现 强制升级 强制升级！ 此时博客终于是成功部署了。迷一样的问题，迷一样的解决。我都准备保留文章放弃其他所有换新（心疼好不容易再次冲破五千的浏览量差点又要归零）的。 但是有没有什么不同之处呢？有。请看： 新博客 现在commit数只有6次。以前有372次，被冲掉了。（新瓶装旧酒→→）估计是它以为是新项目了吧，删除了之前的commit记录。被冲掉竟然有一点开心，因为原来370+次刚开始都是特别小的不值得提交的改动，浪费版本号或者新增一条无意义的记录都是不恰当的行为。（新手重灾区==） 另外，这几天解决这个问题时，顺带终于是解了惑——为什么github上的项目和本地文件不同，压根用不了git pull和git push命令。也离年初立的flag：看懂主题文件，修改出自己满意的主题风格更近一步。 关于多机同步，这是个好帖子：https://www.zhihu.com/question/21193762 需要拷贝到另一台电脑必备的文件：_config.yml，theme/，source/，scaffolds/，package.json，.gitignore","raw":null,"content":null,"categories":[{"name":"博客","slug":"博客","permalink":"https://hubojing.github.io/categories/博客/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hubojing.github.io/tags/Hexo/"}]},{"title":"组装PC","slug":"组装PC","date":"2017-09-17T15:52:22.000Z","updated":"2017-12-13T12:37:04.000Z","comments":true,"path":"2017/09/17/组装PC/","link":"","permalink":"https://hubojing.github.io/2017/09/17/组装PC/","excerpt":"    　　  　　炒房不如炒ssd和内存条如果有人一年前买入三十万根内存条……　　　　　　","text":"炒房不如炒ssd和内存条如果有人一年前买入三十万根内存条…… 现需组装一台台式机。目标：高性能要求：大型游戏（看门狗系列……）、程序员办公需求（编译速度提升）、能做和3D有关的工作所需设备： 除显示器、主机机箱、键鼠、音响、散热器暂不考虑外的一切硬件。预算：暂定5k~6k吧，优先考虑性能 最终已入：电源：长城（GreatWall） 额定600W HOPE-7000DS电源 （60cm超长输出线/主动式PFC/静音风扇）京东价：339链接：https://item.jd.com/1237194.html 硬盘（机械+固态）：希捷(SEAGATE)酷鱼系列 1TB 7200转64M SATA3 台式机机械硬盘(ST1000DM010)京东价：295链接：https://item.jd.com/3843702.html 三星(SAMSUNG) 850 EVO 250G SATA3 固态硬盘京东价：649链接：https://item.jd.com/1279827.html 内存条：宇瞻（Apacer） 黑豹玩家系列 DDR4 台式机内存 2400 8G京东价：539链接：https://item.jd.com/10209750055.html CPU:锐龙 AMD Ryzen 5 1600X 处理器6核AM4接口 3.6GHz 盒装 主板：华硕（ASUS）PRIME B350-PLUS 主板（AMD B350/socket AM4） CPU主板套装京东价：2298链接：https://item.jd.com/4060505.html#crumb-wrap 显卡：铭瑄（MAXSUN）GTX1060终结者6G 1506-1708/8000MHz/6G/192bit GDDR5 PCI-E 3.0显卡京东价：1899链接：https://item.jd.com/3377596.html 共计：6019 感谢所有人的意见！更新清单：华硕 PRIME B350M-A 主板+锐龙 AMD Ryzen5 1600X CPU主板套装京东价：2259链接：http://item.jd.com/4817560.html 内存条：十铨（Team）Elite系列 DDR4 2133 8GB 台式机内存 x 2京东价：499 x 2 = 998链接：https://item.jd.com/1269597.html#none 独立显卡：微星 MSI GTX 1050 Ti GAMING X 4G 128BIT GDDR5 PCI-E 3.0 显卡京东价：1299链接：https://item.jd.com/3977224.html 或 索泰（ZOTAC）GeForce GTX1050Ti-4GD5 X-GAMING OC 1354-1468MHz/7008MHz 4G/128bit GDDR5 PCI-E显卡京东价：1299链接：https://item.jd.com/3528459.html 硬盘：东芝(TOSHIBA) A100系列 240G SATA3固态硬盘京东价：599链接：https://item.jd.com/3219717.html#crumb-wrap 希捷(SEAGATE)酷鱼系列 1TB 7200转64M SATA3 台式机机械硬盘(ST1000DM010)京东价：329链接：https://item.jd.com/3843702.html#crumb-wrap 电源：长城（GreatWall） 额定600W HOPE-7000DS电源 （60cm超长输出线/主动式PFC/静音风扇）京东价：369链接：https://item.jd.com/1237194.html 总计：5853 （旧单已作废）看了一下午，列个清单：CPU：锐龙 AMD Ryzen 7 1700 处理器8核AM4接口 3.0GHz 盒装京东价：2199链接：https://item.jd.com/3885181.html 主板：华硕（ASUS）TUF B350M-PLUS GAMING 主板（AMD B350/socket AM4）京东价：799链接：https://item.jd.com/5001445.html#crumb-wrap 或 技嘉（GIGABYTE）AB350M-Gaming 3 主板 (AMD B350/Socket AM4) （送散热+硅胶）京东价：699链接：https://item.jd.com/4482434.html#none 内存条：十铨（Team） DDR4 2400 4GB 台式机内存 两根京东价：279*2=558链接：https://item.jd.com/1801667.html 或十铨（Team） DDR4 2400 8GB 台式机内存 一根（以后再双通道）京东价：509https://item.jd.com/1801660.html 本想8Gx2的，可是现在的内存条是不是太贵了点。。。 独立显卡：七彩虹（Colorful）iGame1060 烈焰战神S-6GD5 Top GTX1060 1594-1809MHz/8008MHz 6G/192bit GDDR5游戏显卡京东价：2099链接：https://item.jd.com/3342660.html#crumb-wrap 硬盘：西部数据(WD)日常存储解决方案 (蓝盘1TB HDD + Green系列120G SSD)京东价：666https://item.jd.com/4242118.html 电源：长城（GreatWall） 额定600W HOPE-7000DS电源 （60cm超长输出线/主动式PFC/静音风扇）京东价：369链接：https://item.jd.com/1237194.html 散热硅胶：酷冷至尊（CoolerMaster）黄金导热硅脂京东价：19.9链接：https://item.jd.com/100391.html还是电脑维修店里几块钱的便宜…… 总计：6690 继续观望总之未来要吃土 非常欢迎各位大神给意见~","raw":null,"content":null,"categories":[{"name":"数码","slug":"数码","permalink":"https://hubojing.github.io/categories/数码/"}],"tags":[{"name":"硬件","slug":"硬件","permalink":"https://hubojing.github.io/tags/硬件/"}]},{"title":"网件R7000评测","slug":"网件R7000评测","date":"2017-09-12T15:20:00.000Z","updated":"2017-09-13T16:10:26.000Z","comments":true,"path":"2017/09/12/网件R7000评测/","link":"","permalink":"https://hubojing.github.io/2017/09/12/网件R7000评测/","excerpt":" 　　等了一个月不降价，昨天到货今天就降价。。。。。。　　 ","text":"等了一个月不降价，昨天到货今天就降价。。。。。。 前言：11日到货，12日凌晨R8000就降价，比R7000只贵100元。 求我的心理阴影面积？ 开包 包裹 评测文里总是要拍一下包装，来证明自己是亲测不是盗图。。。。。。（忽略粉粉的码） 实物 正面 背面 开盒 内含 接口 外观 AC1900智能无线路由器R7000 × 1 天线 × 3 安装指导 × 1 电源适配器 × 1实拍，无滤镜，无P图！让你看到一个真实的关机状态没绚丽闪光的买家秀。 不拍了，安路由器五分钟，拍照半小时…… 安装 把天线装上只能逆时针旋转……这个反人道的设计 拔掉原来的路由器 拔掉光猫电源 再插上光猫电源（why？重新接入网路？） 连上新路由器 插上新路由器电源 按下新路由器开关 等待指示灯闪到正常 连上网线这样就安好了… 设置打开浏览器，第一次会自动进入，以后需输入：www.routerlogin.net访问。傻瓜式设置（二次截图使图片有些高糊）： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 参数抱着了解的态度，不能当小白… AC1900 Nighthawk R7000 双频千兆无线路由器博通双核1G处理器 256M内存 并发双频 5个千兆端口 USB3.0 双USB接口 动态QoS ReadyCLOUD 网件R7000上市时间是2014年6月R7000P上市时间是2017年R8500上市时间是2015年末R9000上市时间是2016年 接着了解一些参数：传输频段：2.4G频段和5G频段:2.4G 穿透性好 传输距离近5G穿透性差 传输距离远 R7000 2.4G最高600M(200Mbps x 3)5G最高1300M（433Mbps x 3）（电视能搜到5G频段、笔记本却搜不到…） 无线桥接：无线桥接技术是一种局域网络无线连接的技术，是无线射频技术和传统的有线网桥技术相结合的产物，它可以无缝地将相隔数十公里的局域网络连接在一起，创建统一的企业或城域网络系统。在最简单的网络构架中，网桥的以太网端口连接到局域网中的某个集线器或交换机上，信号发射端口则通过电缆和天线相连接；通过这样的方式实现网络系统的扩展。无线路由器的好处是：无需连接网线，手机、电脑同时共享网络。缺点是：有效距离短，还会被墙壁等障碍物屏蔽或减弱讯号。简单地说就是使用多个路由器扩大无线网络的范围。 WPS：路由器中WPS是由Wi-Fi联盟所推出的全新Wi-Fi安全防护设定(Wi-Fi Protected Setup)标准，该标准推出的主要原因是为了解决长久以来无线网络加密认证设定的步骤过于繁杂艰难之弊病，使用者往往会因为步骤太过麻烦，以致干脆不做任何加密安全设定，因而引发许多安全上的问题。WPS用于简化Wi-Fi无线的安全设置和网络管理。它支持两种模式：个人识别码(PIN)模式和按钮(PBC)模式。只要网卡支持WPS，路由也支持，只要电脑上点击WPS配对，然后按一下路由器上的WPS系统会自动的在两个设备之间建立连接，这种方式比输入密码更方便，更安全。 Qos：QoS（Quality of Service）服务质量，是网络的一种安全机制, 是用来解决网络延迟和阻塞等问题的一种技术。 在正常情况下，如果网络只用于特定的无时间限制的应用系统，并不需要QoS，比如Web应用，或E-mail设置等。但是对关键应用和多媒体应用就十分必要。当网络过载或拥塞时，QoS 能确保重要业务量不受延迟或丢弃，同时保证网络的高效运行。QoS限速对局域网内各个IP地址进行流量控制，以达到稳定而优质的上网的目的。这个功能对局域网内使用P2P下载占用大量带宽的情形有非常好的改善。 传输标准：IEEE 802.11n；IEEE 802.11g；IEEE 802.11b；IEEE 802.11.ac；IEEE 802.11.a这个没什么说的。。。 电源 12V 3.5A 内网穿透：内网穿透即NAT穿透，网络连接时术语，计算机是局域网内时，外网与内网的计算机节点需要连接通信，有时就会出现不支持内网穿透。就是说映射端口,能让外网的电脑找到处于内网的电脑,提高下载速度。不管是内网穿透还是其他类型的网络穿透，都是网络穿透的统一方法来研究和解决。端口映射，其实就是常说的NAT地址转换的一种，其功能就是把在公网的地址转翻译成私有地址， 采用路由方式的ADSL宽带路由器拥有一个动态或固定的公网IP，ADSL直接接在HUB或交换机上，所有的电脑共享上网。在局域网内部的任一PC或服务器上运行到花生壳内网穿透客户端，此时域名解析到的IP地址是局域网网关出口处的公网IP地址，再在网关处做端口映射指向监控设备即可。 R7000不支持内网穿透。 R7000P比R7000多一个MU-MIMOMU-MIMO：“Multi-User Multiple-Input Multiple-Output”的缩写，“多用户多入多出技术”，让路由器同时与多个设备沟通的技术。 网速测试100M光纤 1笔记本： laptop 1台式： pc 相比以前的TP老路由器，网速一脸满足… 一天下来，路由器有点发热。查了下，R7000是BCM芯片，ARM架构CPU，性能高但发热较大。三天线，比较公认的信号强覆盖广的一款家用路由，整体兼容性好。另外，路由器还是白色好看（→_→） 今天有个网易云好友私信我节日快乐。。。一脸懵圈，遂百度9.13程序员节 一年中的第256天，2^8次方。。。。。。好吧 节日快乐","raw":null,"content":null,"categories":[{"name":"数码","slug":"数码","permalink":"https://hubojing.github.io/categories/数码/"}],"tags":[{"name":"硬件","slug":"硬件","permalink":"https://hubojing.github.io/tags/硬件/"}]},{"title":"魅蓝Note6评测","slug":"魅蓝Note6评测","date":"2017-09-03T07:41:50.000Z","updated":"2017-09-03T07:41:50.000Z","comments":true,"path":"2017/09/03/魅蓝Note6评测/","link":"","permalink":"https://hubojing.github.io/2017/09/03/魅蓝Note6评测/","excerpt":" 　　一篇如同水贴的评测。　　 ","text":"一篇如同水贴的评测。 评测对象：9月1日上新的魅族新品魅蓝note6骁龙625 3GB+32GB 4000mAh价格：1299定位：青年良品 （翻译：又穷又天真） 外观官方参数 图片一手拍摄，全无PS。包装： 外包装 拆封1： 拆封1 拆封2： 拆封2 正面： 正面 背面： 背面 （就是忍不住想打个码）名称解释：TD-LTE，即LTE-TDD，Time Division Long Term Evolution（分时长期演进），LTE是基于OFDMA技术、由3GPP组织制定的全球通用标准，包括FDD和TDD两种模式用于成对频谱和非成对频谱。IMEI，International Mobile Equipment Identity，是国际移动设备身份码的缩写，国际移动装备辨识码，是由15位数字组成的”电子串号”，它与每台移动电话机一一对应，而且该码是全世界唯一的。双卡双待手机会有两个IMEI，IMEI和IMSI存在一一对应的关系。因为双卡双待手机两个卡槽都能插SIM卡，在GSM蜂窝通信网络中被看作是集成在一起的两个设备，所以会被分配有2个IMEI码。MEID，移动设备识别码(Mobile Equipment Identifier)是CDMA手机的身份识别码，也是每台CDMA手机或通讯平板唯一的识别码。通过这个识别码，网络端可以对该手机进行跟踪和监管。输入 *#06# IMEI即手机串号。 问题来了，IMEI和MEID都可看作手机的身份证，区别在哪？答：IMEI是GSM网络制式专用的身份编码，MEID是CDMA网络制式专用的身份识别编码，IMEI是一组纯数字的，而MEID是以字母开头的十六进制编码。使用不同制式的手机就会显示不同的码。 当手机被盗的时候，如知道IEMI码，可以通过手机供应商进行手机锁定，即：获知被盗之后的手机号码，中止手机的通话功能，获知手机的方位。但……一般情况下，供应商不会对个人或单位提出的定位或锁定手机的请求进行受理。 SN码，Serial Number的缩写，有时也叫SerialNo，手机SN号一般指的是软件注册码信息，也就是产品序列号，产品序列是为了验证“产品的合法身份”而引入的一个概念，它是用来保障用户的正版权益，享受合法服务的；一套正版的产品只对应一组产品序列号。别称：机器码、认证码、注册申请码等。 使用Nano-SIM卡，真的麻烦……手残党还是不要自己剪卡了，得去营业厅更换。SIM-&gt;microSIM-&gt;NanoSIM，为了优化内存和主板排布，更轻薄。然后现实是……人们买了厂商费尽心思打造的更超薄的手机然后再去加个手机壳……so interesting CMIIT ID，即无线电发射设备型号核准代码。 初始UI设计 UI1 UI2 可以看到，系统出厂安装的第三方软件：手机百度、京东、微博、今日头条、淘宝、秒拍。自带的软件例如音乐、视频、读书、便签、工具箱等应用还是做得很不错的，感觉魅族特制的音乐有点虾米风，UI做得还是很简洁的，挺耐看，就是评论不堪入目……另，工具箱里的镜子好评…… 底部是经典的腰圆键，轻触返回上级，按压Home，长按压出语音助手。 存储： 存储 32G有29G总容量不错了，没有特别臃肿。不过可用才21G，自带软件还是挺占地。 P.S.可以截图的地方为什么要拍照？。。。突然地我问自己。不禁想起了这张图： 吐槽截图 跑分鲁大师现实配置： 配置 性能总分： 总分 这个分数还是配得起这个价钱吧。CPU想让625赶上820，还是不可能的。手机CPU性能天梯图 体验总分： 体验 VR检测： VR 安兔兔为了公平公正，自然不能只跑一个地方 总分 配置： 配置 手机设置里存储显示是29G，鲁大师和安兔兔都显示的是22G，有一丝诡异的感觉。。。相差的内存被空气吃掉了 再看一眼CPU CPU 当然，还有官方拿出的“疾速双摄”……同时段小米也鼓吹“变焦双摄”……主观来说不错，各种照相模式丰富，滤镜较多，贴纸都有了，不用安B612了…… 所以为什么说这是一篇水贴的评测，因为我实在写不出“魅蓝Note6主摄引入只在旗舰机上出现的索尼IMX362/三星2L7模组，1200W+500W双彩后置镜头组合，F/1.9超大光圈。 除了双摄，算法方面，魅蓝耗费重金打造的虹软双摄技术，官方称可针对人像背景虚化和暗光多帧降噪功能进行优化，大幅提升虚化真实度。据悉，每台魅蓝Note6需支付1美元给虹软公司。但在实际体验过程中，虚化会抹掉一些前景细节，自然程度仍旧有待提升。Dual PD极速对焦技术，让Note6对焦速度快达0.03s，实际对比体验中，魅蓝对焦速度惊人，甚至超过iPhone 7。其他方面，在光亮条件下，Note6的色彩还原、高光曝光控制与白平衡都有着不错表现，更偏写实风格。但HDR合成反应速度较慢，且在自拍模式下，色彩饱和度不高。夜拍环境中，魅蓝表现噪点控制强、亮度高，但是亮度细节会有曝光过度的问题，暗部细节丰富。Note6的慢镜头功能提供给用户更有有趣的拍摄方式，但是该模式下，噪点明显偏多。”这都归结于我对摄影没有很多的研究。当然摄影听起来就很有艺术气息…… 游戏表现上，我觉得把玩王者荣耀不卡当成一个标杆是不科学的，因为一个几百块的手机都能做到。不过比较个帧率还是可行的。 都学小米搞饥饿营销……为什么不出4G+64G版？？？说好的1699在哪里？说好的蓝色在哪里……听说黑色也没了 总评：作为千元机，CPU、ROM、RAM、电池容量、相机像素这几个我看重的硬指标基本令人满意。以及，我不适合写软文。 规定1500左右的价位，其实就性价比而言，不追求品牌，只追求性能的话，360的N5S可能最佳（前提是官方参数是真实不参假的），奈何360全家桶实在让人望而生畏……小米同等价位的性能也是比较高的，但考虑到使用者之前深受小米折磨，于是不再考虑。联想性价比也高，可惜好像放弃手机这一块了。若只考虑品牌，华为或荣耀最佳。兼顾品牌和性能，又需上市时间较近，只剩魅族可选了。 最后，手机停留在我手上时间太短(2h)，无法检测电池和通话等耗时操作。 另外，我对一加5神机充满好奇，稳居各大评测前3是一种怎样的体验？","raw":null,"content":null,"categories":[{"name":"数码","slug":"数码","permalink":"https://hubojing.github.io/categories/数码/"}],"tags":[{"name":"硬件","slug":"硬件","permalink":"https://hubojing.github.io/tags/硬件/"}]},{"title":"三维坐标旋转","slug":"三维坐标旋转","date":"2017-08-31T15:53:44.000Z","updated":"2017-08-31T16:25:38.000Z","comments":true,"path":"2017/08/31/三维坐标旋转/","link":"","permalink":"https://hubojing.github.io/2017/08/31/三维坐标旋转/","excerpt":" 　　 　　　　由上一篇引发的续问。　　 　　　　　　 ","text":"由上一篇引发的续问。 其实上一篇的想法都是为了这个问题进行铺垫：已知任意三维坐标系中一条线上两点坐标AB，及该线绕A点任意方向旋转后B’的坐标，求B点经过怎样的变换（如先绕x轴旋转多少度，再绕y轴转多少度，再绕z轴绕多少度）得到B’。 弄清楚这个问题前，首先需要声明一点：三维空间中，旋转角不能单纯的认为是某点关于x、y、z轴的旋转角度的线性叠加。 认清这一点后，就应老实放弃向每个平面做投影算旋转角的错误方法。 旋转说穿了是矩阵的相乘。 然后从特殊情况入手，再从特殊到一般。 特殊情况：1.旋转轴是x轴2.旋转轴是y轴3.旋转轴是z轴 一般情况：旋转轴是任意直线 推导过程网上很多资料，其中，绕x、y、z轴的公式见三维空间中的旋转 ，markdown写数学公式太麻烦了。 旋转轴是任意直线，参考三维旋转矩阵的计算 回到开头问题，既然已知B和B’，和A三点组成一个面，求出它的法向量，结合BB’中垂线，可算出该点的旋转轴向量。将该向量平移到原点处，再使用欧拉角计算旋转向量，进而得到所需要的x、y、z轴旋转角度（这是有顺序的）。这种方法得到的角度如果旋转顺序不同，则得到的解不同。当然最后别忘了反平移回去。四元数的形式看起来简单些，可惜四元数里的角度不是所希望的关于x、y、z轴的三个角度值。","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"https://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"3D","slug":"3D","permalink":"https://hubojing.github.io/tags/3D/"}]},{"title":"三维坐标系变换","slug":"三维坐标系变换","date":"2017-08-29T14:23:54.000Z","updated":"2017-08-29T16:01:18.000Z","comments":true,"path":"2017/08/29/三维坐标系变换/","link":"","permalink":"https://hubojing.github.io/2017/08/29/三维坐标系变换/","excerpt":" \n\n　　关于三维坐标变换的一些思考。　　　从两条相交直线说起。　　　　","text":"关于三维坐标变换的一些思考。 从两条相交直线说起。 从最简单的情况入手，求空间两条相交直线AB、BC的夹角，AB和BC相交于B点，已知ABC三点三维坐标。假设两条直线向量分别为a(x1,y1,z1),b(x2,y2,z2),根据公式cosα=a·b/(|a|*|b|)=(x1x2+y1y2+z1z2)/[√(x1^2+y1^2+z1^2)+√(x2^2+y2^2+z2^2)] 可直接求得。 情况变一变：以此两条直线中的某一条为基准（为z’轴），求另一条直线关于基准线的x’、y’、z’轴（新的基准坐标系）夹角。 如果不用矩阵的做法，求解很复杂：以AB为新的坐标系Z’轴为例，O为原坐标系原点。B’(0,0,0)，可求AB点距离s，则A’(0,0,s)。这还是比较容易的，关键是求C’坐标。首先要求z轴和AB之间的各种角度，想象从Z轴先延x轴平移绕x轴旋转，再延y轴平移绕y轴旋转，最后延z轴平移绕z轴旋转。同理，C点做同类运动，得到C’。千辛万苦得到C’还没完，再将B’C’分别向x’o’y’、y’o’z’、z’o’x’面投影，求关于基准线的夹角。方可算出所求。 很明显，这种方法显然不适用在3D中。这个问题其实等价于将世界坐标系转换为物体坐标系。,矩阵的作用就发挥广大。 令原坐标系为M=(i,j,k)T（转置），变换后N=(i’,j’,k’)T，i=(1,0,0),j=(0,1,0),k=(0,0,1)原坐标系中一点P为(x,y,z)，则P’=((x,y,z)-O’)N^(-1) N^(-1)指N的逆矩阵 (若N为正交矩阵，无需求逆矩阵，求转置矩阵即可。) 推导：∵P=O+(x,y,z)M=O’+(x’,y’,z’)N∴(x’,y’,z’)=((x,y,z)M+(O-O’))N^(-1)此时O’=(0，0，0),并带入M，则上式得证。 综上所述，讨论的情况实质就是进行了坐标系的转换。目的是求C’坐标，假设A(a1,b1,c1),B(a2,b2,c2),C(a3,b3,c3),那么根据公式C’=((a3,b3,c3)-(a2,b2,c2))N^(-1)，问题就转化为求N。记N=MK，K=M^(-1)N，也就是说，K是将i,j,k装换为i’,k’,j’的变换矩阵。N^(-1)=(MK)^(-1)=K^(-1)M^(-1)∴(x’,y’,z’)=((x,y,z)M+(O-O’))K^(-1)M^(-1)=((x,y,z)+(-O’))K^(-1) K=N 怎么求K呢？ 可以参考这篇文章图形学1-三维坐标系间的变换矩阵推导 看似也挺麻烦，其实推导占据了大量篇幅，真正使用时直接套就好了。","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"https://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"3D","slug":"3D","permalink":"https://hubojing.github.io/tags/3D/"}]},{"title":"古风自动造句器","slug":"古风自动造句器","date":"2017-08-10T14:56:49.000Z","updated":"2017-08-10T14:56:49.000Z","comments":true,"path":"2017/08/10/古风自动造句器/","link":"","permalink":"https://hubojing.github.io/2017/08/10/古风自动造句器/","excerpt":" \n\n　　小桥流水肯定有人家，　　两人对坐必须在饮茶。　　为何提笔再难描绘出风雅。　　\n　　一个C++古风自动写诗器。V1.1上线　　【注意：有背景音乐！】","text":"小桥流水肯定有人家， 两人对坐必须在饮茶。 为何提笔再难描绘出风雅。 一个C++古风自动写诗器。V1.1上线 【注意：有背景音乐！】 灵感来自 古风 今天看到这个，突然就想到文中提到的这个想法不难实现哇~那自己实现一个玩玩儿吧，主要就是个产生随机数的问题嘛~ V1.0上代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172void CPoetryDlg::OnBnClickedOk()&#123; // TODO: 在此添加控件通知处理程序代码 CStdioFile file; CString strLine, strtemp; char *single[68]; char *wanted[8]; if (!file.Open(_T(\"d:\\\\1.txt \"), CFile::modeRead)) &#123; return; &#125; int row = 0; while (file.ReadString(strLine)) &#123; char *str = strLine.GetBufferSetLength(strLine.GetLength()); char *p; int i = 0, k = 0; char *buf; if (strLine != \"\") &#123; for (p = strtok_s(str, \"、\", &amp;buf); p != NULL; p = strtok_s(NULL, \"、\", &amp;buf)) &#123; single[i] = p; i++; &#125; &#125; CString strSum = \"\"; srand((unsigned)time(NULL)); for (int m = 0; m &lt; 6; m++) &#123; int j = random(68); wanted[m] = single[j]; strtemp = wanted[m]; strSum= strSum + strtemp; &#125; strSum = strSum + \"\\r\\n\"; for (int m = 0; m &lt; 4; m++) &#123; int j = random(68); wanted[m] = single[j]; strtemp = wanted[m]; strSum = strSum + strtemp; &#125; strSum = strSum + \"\\r\\n\"; for (int m = 0; m &lt; 5; m++) &#123; int j = random(68); wanted[m] = single[j]; strtemp = wanted[m]; strSum = strSum + strtemp; &#125; strSum = strSum + \"\\r\\n\"; for (int m = 0; m &lt; 4; m++) &#123; int j = random(68); wanted[m] = single[j]; strtemp = wanted[m]; strSum = strSum + strtemp; &#125; SetDlgItemText(IDC_EDIT2,strSum); SetDlgItemText(IDC_EDIT1, \"烟、倾、萧、墨、歌、弦、痴、泠、幽、离、覆、寂、情、思、恋、醉、浅、尘、念、葬、负、梦、韶、陌、落、琴、夜、君、殇、朱砂、韶华、江南、烟雨、迷离、红尘、寂寞、繁华、风华、苍老、红颜、天下、彼岸、伊人、青丝、白首、陌上、千年、倾城、断弦、长歌、悲欢、沧海、天涯、尘缘、情殇、忘川、碧落、奈何、指尖、长安、青鸾、凤凰、桃花、海棠、红妆、婆娑、轻狂、未央\"); &#125; file.Close();&#125; 当然了，这个代码写的非常的粗糙，很多可以改进之处，我就是特别想先看到一个能运行的结果，后续再来慢慢改咯~丑陋的V1.0 1 2 P.S.哈哈哈哈哈哈好想笑这自动生成的诗句 这个时候背景音乐应该是浮夸 随便赋几首机器作诗：未央忘川梦千年长安韶尘缘君幽繁华风华夜梦离红妆海棠烟寂痴 海棠白首伊人悲欢负歌红妆迷离苍老覆韶华红妆尘缘萧寂寞墨奈何歌白首 彼岸覆迷离浅烟雨伊人长安倾城碧落倾未央倾奈何韶华陌上天下迷离朱砂千年 苍老覆红妆陌长安青鸾繁华红尘落殇迷离轻狂海棠思梦恋倾凤凰浅 可以改进的地方：1.分成动词、名词 单字、双字 放在多个txt中读取2.四个暴力循环可以改一改……看着太扎心了3.可以增加重复词审查过滤4.扩大词库5.按现代诗、古诗字数韵律等分配每个循环里的约束条件 V1.1因为数组不定长，换成vector实现。同时扩大了词库，换了种句式…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112CStdioFile file; CString strLine, strtemp; std::vector&lt;CString&gt;Word; std::vector&lt;CString&gt;Selected; if (!file.Open(_T(\"d:\\\\1.txt \"), CFile::modeRead)) &#123; ASSERT(FALSE); return; &#125; while (file.ReadString(strLine)) &#123; int len = strLine.GetLength(); char *str = strLine.GetBufferSetLength(strLine.GetLength()); char *p; int i = 0, k = 0; char *buf; if (strLine != \"\") &#123; for (p = strtok_s(str, \"、\", &amp;buf); p != NULL; p = strtok_s(NULL, \"、\", &amp;buf)) &#123; Word.push_back(p); i++; &#125; &#125; CString strSum = \"\"; srand((unsigned)time(NULL)); for (int m = 0; m &lt; 3; m++) &#123; int j = random(i); Selected.push_back(Word.at(j)); strtemp = Selected.at(m); strSum= strSum + strtemp; &#125; strSum = strSum + \"，\"; for (int m = 3; m &lt; 7; m++) &#123; int j = random(i); Selected.push_back(Word.at(j)); strtemp = Selected.at(m); strSum = strSum + strtemp; &#125; strSum = strSum + \"，\"; strSum = strSum + \"\\r\\n\"; for (int m = 7; m &lt; 10; m++) &#123; int j = random(i); Selected.push_back(Word.at(j)); strtemp = Selected.at(m); strSum = strSum + strtemp; &#125; strSum = strSum + \"，\"; for (int m = 10; m &lt; 13; m++) &#123; int j = random(i); Selected.push_back(Word.at(j)); strtemp = Selected.at(m); strSum = strSum + strtemp; &#125; strSum = strSum + \"，\"; strSum = strSum + \"\\r\\n\"; for (int m = 13; m &lt; 18; m++) &#123; int j = random(i); Selected.push_back(Word.at(j)); strtemp = Selected.at(m); strSum = strSum + strtemp; &#125; strSum = strSum + \"，\"; for (int m = 18; m &lt; 20; m++) &#123; int j = random(i); Selected.push_back(Word.at(j)); strtemp = Selected.at(m); strSum = strSum + strtemp; &#125; strSum = strSum + \"，\"; strSum = strSum + \"\\r\\n\"; for (int m = 20; m &lt; 23; m++) &#123; int j = random(i); Selected.push_back(Word.at(j)); strtemp = Selected.at(m); strSum = strSum + strtemp; &#125; strSum = strSum + \"？\"; strSum = strSum + \"\\r\\n\"; for (int m = 23; m &lt; 25; m++) &#123; int j = random(i); Selected.push_back(Word.at(j)); strtemp = Selected.at(m); strSum = strSum + strtemp; &#125; strSum = strSum + \"。\"; SetDlgItemText(IDC_EDIT2,strSum); TCHAR szBuf[1264]; FILE *pfile; fopen_s(&amp;pfile,\"d:\\\\library.txt\", \"r\"); fread(szBuf, 1, 1262, pfile); SetDlgItemText(IDC_EDIT1, szBuf); fclose(pfile); &#125; file.Close(); V1.1 字符串尾的烫烫烫烫烫还没解决 随机散文诗：环佩离海棠，悲欢情墨红颜，古道回推敲，萧瑟繁华梳妆，寂寥绮罗簌簌桑麻墨，青梅尘缘，花蕊墨城郭？白露陌上。 烟读碧绿，顾青鸾青丝古墓，楚楚故里尺素，念情殇柳眉，伊人亮尘缘挥毫古墓，簌簌伽蓝，寂寥萧尘埃？桑麻知否。 枝桠年华尘埃，经纬竹婆娑伽蓝，一觅古筝笑靥，沧海寺轩窗，泠五岳勾勒磐石江，桑麻寂，一觅知否袅袅？萧瑟瑶池。 羌笛绮罗剑鞘，枯藤乌艄断弦琴，绮罗朱砂萧，寺参差寒蝉，一抹长安水墨朱砂踌躇，寂凤凰，渔樵红烛垂钓？长歌芭蕉。 哈哈哈哈哈看起来好有文化的样子 附上一首吐槽古风乱象的歌：","raw":null,"content":null,"categories":[{"name":"软件开发","slug":"软件开发","permalink":"https://hubojing.github.io/categories/软件开发/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"},{"name":"MFC","slug":"MFC","permalink":"https://hubojing.github.io/tags/MFC/"}]},{"title":"树","slug":"树","date":"2017-07-23T13:16:43.000Z","updated":"2019-06-19T09:22:02.000Z","comments":true,"path":"2017/07/23/树/","link":"","permalink":"https://hubojing.github.io/2017/07/23/树/","excerpt":"　　大热天敲代码与看书更配哦　　 ","text":"大热天敲代码与看书更配哦 数据结构系列栈 https://hubojing.github.io/2017/11/14/%E6%A0%88/队列 https://hubojing.github.io/2017/11/12/%E9%98%9F%E5%88%97/线性表 https://hubojing.github.io/2019/06/12/%E7%BA%BF%E6%80%A7%E8%A1%A8/ 二叉树的链式存储结构1234typedef struct BiTNode&#123; ElemType data;//数据域 struct BiTNode *lchild, *rchild;//左、右孩子指针&#125;BiTNode, *BiTree; 二叉树的遍历例： 1 2 3 4 5 6 先序遍历（PreOrder）根-&gt;左-&gt;右1234567void PreOrder(BiTree T)&#123; if (T != NULL)&#123; visit(T);//访问根节点 PreOrder(T-&gt;lchild);//递归遍历左子树 PreOrder(T-&gt;rchild);//递归遍历右子树 &#125;&#125; 124635 中序遍历（InOrder）左-&gt;根-&gt;右1234567void InOrder(BiTree T)&#123; if (T != NULL)&#123; InOrder(T-&gt;lchild);//递归遍历左子树 visit(T);//访问根节点 InOrder(T-&gt;rchild);//递归遍历右子树 &#125;&#125; 264135 后序遍历（PostOrder）左-&gt;右-&gt;根12345678void PostOrder(BiTree T)&#123; if (T != NULL) &#123; PostOrder(T-&gt;lchild);//递归遍历左子树 PostOrder(T-&gt;rchild);//递归遍历右子树 visit(T);//访问根节点 &#125;&#125; 642531 时间复杂度都是O(n)，空间复杂度为O(n)。 中序遍历的非递归算法123456789101112131415void InOrder2(BiTree T)&#123; //二叉树中序遍历的非递归算法，算法需要借助一个栈 InitStack(S); BiTree p = T; //初始化栈；p是遍历指针 while (p || !IsEmpty(S))&#123; //栈不空或p不空时循环 if (p)&#123; //根指针进展，遍历左子树 Push(S, p); //每遇到非空二叉树先向左走 p = p-&gt;lchild; &#125; else&#123; //根指针退栈，访问根节点，遍历右子树 Pop(S, p); visit(p); //退栈，访问根节点 p = p-&gt;rchild; //再向右子树走 &#125; &#125;&#125; 二叉树的层次遍历123456789101112131415161718void LevelOrder(BiTree T)&#123; InitQueue(Q);//初始化辅助队列 BiTree p; EnQueue(Q, T);//将根结点入队 while (!IsEmpty(Q))&#123;//队列不空循环 DeQueue(Q, p);//队头元素出队 visit(p);//访问当前p所指向结点 if (p-&gt;lchild != NULL) &#123; EnQueue(Q, p-&gt;lchild);//左子树不空，则左子树入队列 &#125; if (p-&gt;rchild != NULL) &#123; EnQueue(Q, p-&gt;rchild);//右子树不空，则右子树入队列 &#125; &#125;&#125; 树的存储结构双亲表示法123456789#define MAX_TREE_SIZE 100 //树中最多结点数typedef struct&#123; //树的结点定义 ElemType data; //数据元素 int parent; //双亲位置域&#125;PTNode;typedef struct&#123; //树的类型定义 PTNode nodes[MAX_TREE_SIZE]; //双亲表示 int n; //结点数&#125;PTree; 求结点的孩子时需遍历整个结构。 孩子表示法12345678910111213141516typedef struct CTNode //孩子结点&#123; int child; struct CTNode *next;&#125;*ChildPtr;typedef struct&#123; TElemType data; ChildPtr firstchild;//孩子链表头指针&#125;CTBox;typedef struct&#123; CTBox nodes[MAX_TREE_SIZE]; int n, r; //结点数和根的位置&#125;CTree; 求结点的双亲时需遍历N个结点中孩子链表指针域所指向的N个孩子链表。 孩子兄弟表示法（二叉树表示法）12345typedef struct CSNode&#123; ElemType data; //数据域 struct CSNode *firstchild, *nextsibling; //第一个孩子和右兄弟指针&#125;CSNode, *CSTree; 易查找结点的孩子，若为每个结点增设一个parent域指向其父节点，则查找结点的父结点也很方便。 树转换为二叉树的规则：每个结点左指针指向它的第一个孩子结点，右指针指向它在树中的相邻兄弟结点，可表示为“左孩子右兄弟”。由于根节点没有兄弟，所以由树转换而得的二叉树没有右子树。 例： 一颗具体的树 转换后 C++实现数组实现tree.h12345678910111213141516171819#ifndef TREE_H#define TREE_Hclass Tree&#123;public: Tree(int size, int *pRoot); ~Tree(); int *SearchNode(int nodeIndex); bool AddNode(int nodeIndex, int direction, int *pNode); bool DeleteNode(int nodeIndex, int *pNode); void TreeTraverse();private: int *m_pTree; int m_iSize;&#125;;#endif tree.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include \"tree.h\"using namespace std;Tree::Tree(int size, int *pRoot)&#123; m_iSize = size; m_pTree = new int[size]; for (int i = 0; i &lt; size; ++i) &#123; m_pTree[i] = 0; &#125; m_pTree[0] = *pRoot;&#125;Tree::~Tree()&#123; delete[]m_pTree; m_pTree = NULL;&#125;int *Tree::SearchNode(int nodeIndex)&#123; if (nodeIndex &lt; 0 || nodeIndex &gt;= m_iSize) &#123; return NULL; &#125; if (m_pTree[nodeIndex] == 0) &#123; return NULL; &#125; return &amp;m_pTree[nodeIndex];&#125;bool Tree::AddNode(int nodeIndex, int direction, int *pNode)&#123; if (nodeIndex &lt; 0 || nodeIndex &gt;= m_iSize) &#123; return false; &#125; if (m_pTree[nodeIndex] == 0) &#123; return false; &#125; if (direction == 0) &#123; if (nodeIndex * 2 + 1 &gt;= m_iSize) &#123; return false; &#125; if (m_pTree[nodeIndex * 2 + 1] != 0) &#123; return false; &#125; m_pTree[nodeIndex * 2 + 1] = *pNode; &#125; if (direction == 1) &#123; if (nodeIndex * 2 + 2 &gt;= m_iSize) &#123; return false; &#125; if (m_pTree[nodeIndex * 2 + 2] != 0) &#123; return false; &#125; m_pTree[nodeIndex * 2 + 2] = *pNode; &#125;&#125;bool Tree::DeleteNode(int nodeIndex, int *pNode)&#123; if (nodeIndex &lt; 0 || nodeIndex &gt;= m_iSize) &#123; return false; &#125; if (m_pTree[nodeIndex] == 0) &#123; return false; &#125; *pNode = m_pTree[nodeIndex]; m_pTree[nodeIndex] = 0; return true;&#125;void Tree::TreeTraverse()&#123; for (int i = 0; i &lt; m_iSize; ++i) &#123; cout &lt;&lt; m_pTree[i] &lt;&lt; \" \"; &#125;&#125; demo.cpp123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include \"tree.h\"using namespace std;int main()&#123; int root = 1; Tree *pTree = new Tree(10, &amp;root); int node1 = 2; int node2 = 3; int node3 = 4; int node4 = 5; int node5 = 6; int node6 = 7; pTree-&gt;AddNode(0, 0, &amp;node1); pTree-&gt;AddNode(0, 1, &amp;node2); pTree-&gt;AddNode(1, 0, &amp;node3); pTree-&gt;AddNode(1, 1, &amp;node4); pTree-&gt;AddNode(2, 0, &amp;node5); pTree-&gt;AddNode(2, 1, &amp;node6); pTree-&gt;TreeTraverse(); int *p = pTree-&gt;SearchNode(2); cout &lt;&lt; endl &lt;&lt; \"node = \" &lt;&lt; *p &lt;&lt; endl; delete pTree; return 0;&#125; 链表实现Node.h1234567891011121314151617181920#ifndef NODE_H#define NODE_Hclass Node&#123;public: Node(); Node *SearchNode(int nodeIndex); void DeleteNode(); void PreoderTraversal(); void InorderTraversal(); void PostorderTraversal(); int index; int data; Node *pLChild; Node *pRChild; Node *pParent;&#125;;#endif Node.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include \"Node.h\"#include &lt;stdlib.h&gt;#include &lt;iostream&gt;using namespace std;Node::Node()&#123; index = 0; data = 0; pLChild = NULL; pRChild = NULL; pParent = NULL;&#125;Node *Node::SearchNode(int nodeIndex)&#123; if (this-&gt;index == nodeIndex) &#123; return this; &#125; Node *temp = NULL; if (this-&gt;pLChild != NULL) &#123; if (this-&gt;pLChild-&gt;index == nodeIndex) &#123; return this-&gt;pLChild; &#125; else &#123; temp = this-&gt;pLChild-&gt;SearchNode(nodeIndex); if (temp != NULL) &#123; return temp; &#125; &#125; &#125; if (this-&gt;pRChild != NULL) &#123; if (this-&gt;pRChild-&gt;index == nodeIndex) &#123; return this-&gt;pRChild; &#125; else &#123; temp = this-&gt;pRChild-&gt;SearchNode(nodeIndex); return temp; &#125; &#125; return NULL;&#125;void Node::DeleteNode()&#123; if (this-&gt;pLChild != NULL) &#123; this-&gt;pLChild-&gt;DeleteNode(); &#125; if (this-&gt;pRChild != NULL) &#123; this-&gt;pRChild-&gt;DeleteNode(); &#125; if (this-&gt;pParent != NULL) &#123; if (this-&gt;pParent-&gt;pLChild == this) &#123; this-&gt;pParent-&gt;pLChild = NULL; &#125; &#125; if (this-&gt;pParent != NULL) &#123; if (this-&gt;pParent-&gt;pRChild == this) &#123; this-&gt;pParent-&gt;pRChild = NULL; &#125; &#125; delete this;&#125;void Node::PreoderTraversal()&#123; cout &lt;&lt; this-&gt;index &lt;&lt; \" \" &lt;&lt; this-&gt;data &lt;&lt; endl; if (this-&gt;pLChild != NULL) &#123; this-&gt;pLChild-&gt;PreoderTraversal(); &#125; if (this-&gt;pRChild != NULL) &#123; this-&gt;pRChild-&gt;PreoderTraversal(); &#125;&#125;void Node::InorderTraversal()&#123; if (this-&gt;pLChild != NULL) &#123; this-&gt;pLChild-&gt;InorderTraversal(); &#125; cout &lt;&lt; this-&gt;index &lt;&lt; \" \" &lt;&lt; this-&gt;data &lt;&lt; endl; if (this-&gt;pRChild != NULL) &#123; this-&gt;pRChild-&gt;InorderTraversal(); &#125;&#125;void Node::PostorderTraversal()&#123; if (this-&gt;pLChild != NULL) &#123; this-&gt;pLChild-&gt;PostorderTraversal(); &#125; if (this-&gt;pRChild != NULL) &#123; this-&gt;pRChild-&gt;PostorderTraversal(); &#125; cout &lt;&lt; this-&gt;index &lt;&lt; \" \" &lt;&lt; this-&gt;data &lt;&lt; endl;&#125; tree.h12345678910111213141516171819202122#ifndef TREE_H#define TREE_H#include \"Node.h\"class Tree&#123;public: Tree(); ~Tree(); Node *SearchNode(int nodeIndex); bool AddNode(int nodeIndex, int direction, Node *pNode); bool DeleteNode(int nodeIndex, Node *pNode); void PreoderTraversal(); void InorderTraversal(); void PostorderTraversal();private: Node *m_pRoot;&#125;;#endif tree.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include \"tree.h\"#include &lt;stdlib.h&gt;Tree::Tree()&#123; m_pRoot = new Node();&#125;Tree::~Tree()&#123; DeleteNode(0, NULL); // m_pRoot-&gt;DeleteNode();&#125;Node *Tree::SearchNode(int nodeIndex)&#123; return m_pRoot-&gt;SearchNode(nodeIndex);&#125;bool Tree::AddNode(int nodeIndex, int direction, Node *pNode)&#123; Node *temp = SearchNode(nodeIndex); if (temp == NULL) &#123; return false; &#125; Node *node = new Node(); if (node == NULL) &#123; return false; &#125; node-&gt;index = pNode-&gt;index; node-&gt;data = pNode-&gt;data; node-&gt;pParent = temp; if (direction == 0) &#123; temp-&gt;pLChild = node; &#125; if (direction == 1) &#123; temp-&gt;pRChild = node; &#125; return true;&#125;bool Tree::DeleteNode(int nodeIndex, Node *pNode)&#123; Node *temp = SearchNode(nodeIndex); if (temp == NULL) &#123; return false; &#125; if (pNode != NULL) &#123; pNode-&gt;data = temp-&gt;data; &#125; temp-&gt;DeleteNode(); return true;&#125;void Tree::PreoderTraversal()&#123; m_pRoot-&gt;PreoderTraversal();&#125;void Tree::InorderTraversal()&#123; m_pRoot-&gt;InorderTraversal();&#125;void Tree::PostorderTraversal()&#123; m_pRoot-&gt;PostorderTraversal();&#125; demo.cpp1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include \"tree.h\"using namespace std;int main()&#123; Node *node1 = new Node(); node1-&gt;index = 1; node1-&gt;data = 5; Node *node2 = new Node(); node2-&gt;index = 2; node2-&gt;data = 4; Node *node3 = new Node(); node3-&gt;index = 3; node3-&gt;data = 3; Node *node4 = new Node(); node4-&gt;index = 4; node4-&gt;data = 2; Node *node5 = new Node(); node5-&gt;index = 5; node5-&gt;data = 1; Node *node6 = new Node(); node6-&gt;index = 6; node6-&gt;data = 7; Tree *tree = new Tree(); tree-&gt;AddNode(0, 0, node1); tree-&gt;AddNode(0, 1, node2); tree-&gt;AddNode(1, 0, node3); tree-&gt;AddNode(1, 1, node4); tree-&gt;AddNode(2, 0, node5); tree-&gt;AddNode(2, 1, node6); tree-&gt;DeleteNode(6, NULL); tree-&gt;PostorderTraversal(); delete tree; return 0;&#125; 参考数据结构教材数据结构与算法——普通树的定义与C++实现C++树（兄弟孩子结构实现）VC++ 树的孩子兄弟表示法使用C++ 和 孩子兄弟表示法实现树孩子兄弟表示法实现树","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hubojing.github.io/categories/编程语言/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"},{"name":"数据结构","slug":"数据结构","permalink":"https://hubojing.github.io/tags/数据结构/"}]},{"title":"树状控件与列表控件交互以及XML的解析","slug":"树状控件与列表控件交互以及XML的解析","date":"2017-07-20T15:04:43.000Z","updated":"2017-09-10T08:47:42.000Z","comments":true,"path":"2017/07/20/树状控件与列表控件交互以及XML的解析/","link":"","permalink":"https://hubojing.github.io/2017/07/20/树状控件与列表控件交互以及XML的解析/","excerpt":"　　自查笔记。　　　　　 ","text":"自查笔记。 方法记录MSXML相关创建对象1234567891011121314MSXML2::IXMLDOMDocumentPtr pDoc;HRESULT hr = pDoc.CreateInstance(_uuidof(MSXML2::DOMDocument60));if(!pDoc)&#123; ASSERT(FALSE); return;&#125;_variant_t varOut((bool)TRUE);varOut = pDoc-&gt;load(xmlPath);if ((bool)varOut == FALSE)&#123; ::MessageBox(NULL, \"Wrong!\", \"提示\", MB_ICONERROR);&#125; 获取根节点12MSXML2::IXMLDOMElementPtr pNode;pNode = pDoc-&gt;GetdocumentElement(); 获取属性（法一）1234567891011121314151617MSXML2::IXMLDOMNamedNodeMapPtr pAttrMap;MSXML2::IXMLDOMNodePtr pAttrItem;MSXML2::IXMLDOMNodeListPtr pNodeList = pNode-&gt;GetchildNodes();long Len = pNodeList-&gt;Getlength();for (int i = 0; i &lt; Len; ++i)&#123; MSXML2::IXMLDOMElementPtr pChildNode = (MSXML2::IXMLDOMElementPtr)pNodeList-&gt;Getitem(i); pChildNode-&gt;get_attributes(&amp;pAttrMap); long count; pAttrMap-&gt;get_length(&amp;count); if (count) &#123; pAttrMap-&gt;get_item(0, &amp;pAttrItem); _variant_t variantItemName; pAttrItem-&gt;get_nodeTypedValue(&amp;variantItemName); &#125;&#125; 获取属性（法二）1234567891011121314151617181920212223MSXML2::IXMLDOMNodeListPtr pList = pRoot-&gt;GetchildNodes();int iCount = pList-&gt;Getlength();for (int i = 0; i &lt; iCount; ++i)&#123; MSXML2::IXMLDOMElementPtr pItem = (MSXML2::IXMLDOMElementPtr)pList-&gt;item[i]; MSXML2::IXMLDOMNamedNodeMapPtr pAttrMap = pItem-&gt;Getattributes(); MSXML2::IXMLDOMNodePtr pAttrItem; for (int att = 0; att &lt; pAttrMap-&gt;length; ++att) &#123; pAttrItem = pAttrMap-&gt;Getitem(att); strTemp = (LPCTSTR)pAttrItem-&gt;GetnodeName(); _variant_t value; value = pAttrItem-&gt;GetnodeValue(); if (strTemp == \"某属性名1\") &#123; //需要进行的操作 &#125; if (strTemp == \"某属性名2\") &#123; //需要进行的操作 &#125; &#125;&#125; 删除节点连同子节点一起删 pChildNode-&gt;GetParentNode()-&gt;removeChild(pChildNode); 树控件相关插入HTREEITEM ht = m_tree.InsertItem((_bstr_t)variantValue, 1, 1, ht, TVI_LAST);依次是：插入的数据，树前图标点击前，树前图标点击后，父节点，插在最后。 存入数据m_tree.SetItemData(ht,(DWORD_PTR)数据); 获得根节点HTREEITEM hRoot=m_tree.GetRootItem(); 展开树m_tree.Expand(ht,TVE_EXPAND); 获取选中树HTREEITEM ChooseItem = m_tree.GetSelectedItem();获取数据数据类型animal pStructure = (数据类型animal)m_tree.GetitemData(ChooseItem); 列表控件相关插入m_list.InsertItem(i,(LPCTSTR)数据,i); 存入数据m_list.SetItemData(i,(DWORD_PTR)数据); 删除全部项m_list.DeleteAllItems(); 在列表最后插入int iRow = m_list.GetItemCount();m_list.InsertItem(iRow, text, 0);text 插入的文本 0表示imagelist中的第一个图片imagelist是由一幅幅image拼起来的长图列表 其它C++相关MessageBoxMessageBox分为win API 和 MFC封装两种。win API:::MessageBox(1, 2, 3, 4);1为父窗口句柄，常用NULL2为显示的字符串3为标题栏显示的字符串4为图标icon 有四种：MB_ICONERROR,MB_ICONINFORMATION,MB_ICONWARNING,MB_ICONQUESTION 父对话框给子对话框传值如果子对话框是模态对话框，那么子对话框是无法在弹出后调用父对话框的控件变量的。只能在DoModal之前，通过一个子对话框的自定义成员变量传递过去。eg.CxxDlg dlg;UpdateData(TRUE);dlg.m_str=m_edit;dlg.DoModal(); 一种不良的方式：父对话框 BookDlg 子对话框TitleDlg在父对话框中 TitleDlg dlg(this);在子对话框中 CBookDlg parent = (CBookDlg)GetParent();然后就可以使用了：CString text=pParent-&gt;m_sentence;m_sentence是父对话框类的成员变量 父窗口引用子窗口变量在父窗口中 xxxDlg dlg;if(dlg.DoModal() == IDOK){//操作} 在子对话框显示图片给自对话框添加OnInitDlg()添加OnPaint()(记得加WM_ONPAINT消息)在OnInitDlg中加载图片，在OnPanint()中重绘图片。（在初始化里重绘是不行的） vector添加头文件#include vector容器，std::vector&lt;类型*&gt; name; push_back添加元素。遍历元素使用迭代器iterator，for循环vector&lt;数据类型&gt;::iterator it;for(it=数据.begin();it!=数据.end();it++){ //操作 Break;} map添加头文件#include std::map&lt;CString, std::vector&lt;信息&gt;&gt;一个CString对应一个vector。查询时也是先遍历（迭代器）再比较，it-&gt;first指代返回关键字，it-&gt;second指代数据。 父子循环父子循环遍历时避免使用相同的变量名。 几个函数检查路径合法性 PathFileExists(path)，使用它需要加上头文件#include “shlwapi.h”字符连接 CString str;str.Format((“%s%s\\%s\\“),path,”第三层”,”第四层”));复制文件CopyFile(原完整带后缀路径，复制后的带后缀完整目的路径,TRUE); 该函数有返回值比较1234if(strTemp.Compare(\"相比较的字符串\")==0)&#123;//操作&#125; 创建临时文件夹123456789101112TCHAR Temp[512];GetTempPath(512, Temp);CString strTempPath;strTempPath.Format(\"%s\\\\Mydata\", Temp);if (!PathFileExists(strTempPath))&#123; if (!CreateDirectory(strTempPath, NULL)) &#123; ASSERT(FALSE); return; &#125;&#125; 复制文件夹及子文件写一个函数CopyDiretory(CString source, CString target)12345678910111213141516171819202122&#123; CFileFind finder;bool bWorking = finder.FindFile(source);while (bWorking)&#123; bWorking = finder.FindNextFile(); if (finder.IsDirectory() &amp;&amp; !finder.IsDots()) &#123; copyDiretory(finder.GetFilePath(), target + \"\\\\\" + finder.GetFileName(); &#125; else &#123; Bool temp = CopyFile(finder.GetFilePath(), target + \"\\\\\" + finder.GetFileName(), FALSE); if (temp == 0) &#123; MessageBox(\"复制失败！\"); return; &#125; &#125;&#125; &#125; 删除文件目录及子文件夹写一个DeleteDirectory函数1234567891011121314151617181920CFileFind finder;CString path;path.Format(\"%s\\\\*.*\", directorypath);BOOL bWorking = finder.FindFile(path);while (bWorking)&#123; bWorking = finder.FindNextFile(); if (finder.IsDirectory() &amp;&amp; !finder.IsDots()) &#123; DeleteDirectory(finder.GetFilePath()); RemoveDirectory(finder.GetFilePath();) &#125; else &#123; DeleteFile(finder.GetFilePath()); &#125; finder.Close(); RemoveDirectory(directoryPath); return 0;&#125; 文件遍历1234567891011121314151617181920CFileFind finder;CString strName;BOOL bWorking = finder.FindFile(path);std::vector&lt;CString&gt;a;while (bWorking)&#123; bWorking = finder.FindNextFile(); strName = finder.GetFileName(); a.push_back(strName);//获取全部文件名 vector&lt;CString&gt;::iterator it; for (it = a.begin(); it != a.end(); it++) &#123; if ((*it) == strFileName) &#123; //需要的处理代码 break; &#125; &#125;&#125; 截取字符串12345678910char* temp = new char[260];::GetCurrentDirectory(260, temp);//得到的是DWord型CString strTempDir = temp;char* str = strTempDir.GetBuffer(strTempDir.GetLength() + 1);char* delim = \"\\\\\";char* buf;char* p1 = strtok_s(str, delim, &amp;buf);char*p2 = strtok_s(NULL, delim, &amp;buf);CString strp1 = (_bstr_t)p1;CString strp2 = (_bstr_t)p2; 循环截取123456789101112131415161718char* str = strName.GetBuffer(strName.GetLength() + 1);char* delim = \"\\\\\";char* buf;int count = 0;for (int i = 0; str[i]; i++)&#123; if (str[i] == *delim) &#123; count++; &#125; char* p = strtok_s(str, delim, *buf); for (int j = 0; j &lt; count; j++) &#123; p = strtok_s(NULL, delim, &amp;buf); &#125; CString strp = (_bstr_t)p;&#125; 禁用GetDlgItem(IDC_Text)-&gt;EnableWindow(FALSE); 调用exe法一：UINT temp=WinExec(strPath,SW_SHOWNORMAL);法二：123456789101112131415STARTUPINFO si;memset(&amp;si, 0, sizeof(STARTUPINFO));si.cb = sizeof(STARTUPINFO);si.dwFlags = STARTF_USESHOWWINDOW;si.wShowWindow = SW_SHOW;PROCESS_INFORMATION pi;BOOL bDemoPro = CreateProcess(path, NULL, NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, &amp;pi);if (!bDemoPro)&#123; ASSERT(FALSE);&#125;WaitForSingleObject(pi.hProcess, INFINITE);CloseHandle(pi.hThread);CloseHandle(pi.hProcess); 窗口缩放.h文件中：protected:afx_msg void OnSize(UINT nType,int cx, int cy);POINT old;CRect m_rect; .cpp文件中：ON_WM_SIZE() 在OnInitDialog()中：123GetClientRect(&amp;m_rect);//初始大小old.x = m_rect.right - m_rect.left;old.y = m_rect.bottom - m_rect.top; 在OnSize函数中：123456789101112131415161718192021222324252627282930313233&#123; CDialog::OnSize(nTpye, cx, cy); //TODO float fsp[2]; POINT Newp; CRect rectNow; GetClientRect(&amp;rectNow); Newp.x = rectNow.right - rectNow.left; Newp.y = rectNow.bottom - rectNow.top; fsp[0] = (float)Newp.x / old.x; fsp[1] = (float)Newp.y / old.y; CRect Rect; int woc; CPoint OldTLPoint, TLPoint;//左上 CPoint OldBRPoint, BRPoint;//右下 HWND hwndChild = ::GetWindow(m_hWnd, GW_CHILD);//列出所有控件 while (hwndChild) &#123; woc = ::GetDlgCtrlID(hwndChild); GetDlgItem(woc)-&gt;GetWindowRect(Rect); ScreenToClient(Rect); OldTLPoint = Rect.TopLeft(); TLPoint.x = long(OldTLPoint.x*fsp[0]); TLPoint.y = long(OldTLPoint.y*fsp[1]); OldBRPoint = Rect.BottomRight(); BRPoint.x = long(OldBRPoint.x*fsp[0]); BRPoint.y = long(OldBRPoint.y*fsp[1]); Rect.SetRect(TLPoint, BRPoint); GetDlgItem(woc)-&gt;MoveWindow(Rect, TRUE); hwndChild = ::GetWindow(hwndChild, GW_HWNDNEXT); &#125; old = Newp;&#125; 更新数据UpdateData(TRUE);//更新值到界面UpdateData(FALSE);//更新界面到值 数据类型转换 int转CStringiRow是int型，number是CString型。CString number;number.Format(“%d”, iRow); 2._variant_t转int_variant_t a;int b;b=_ttoi((LPCTSTR)(_bstr_t)a); MSDN参考MSXMLMSXML API 历史记录 https://msdn.microsoft.com/zh-cn/library/ms762314(v=vs.85).aspx MSXML SDK 概述 https://msdn.microsoft.com/zh-cn/library/ms760399(v=vs.85).aspx TreeControl控件使用 CTreeCtrl https://msdn.microsoft.com/zh-cn/library/8ws6dh1y(v=vs.120).aspx ListControl控件使用 CListCtrl https://msdn.microsoft.com/zh-cn/library/cc468276(v=vs.71).aspx创建列表控件 (List Control) https://msdn.microsoft.com/zh-cn/library/cc451545(v=vs.71).aspx 现有一个XML文档如下：12345678910111213141516&lt;root&gt; &lt;Node world = \"生命\"&gt; &lt;Node animal = “动物\"&gt; &lt;Node aniname = \"熊猫\"&gt; &lt;/Node&gt; &lt;Node aniname = \"兔子\"&gt; &lt;/Node&gt; &lt;/Node&gt; &lt;Node plant = \"植物\"&gt; &lt;Node planame = \"仙人掌\"&gt; &lt;/Node&gt; &lt;Node planame = \"玫瑰\"&gt; &lt;/Node&gt; &lt;/Node&gt; &lt;/Node&gt;&lt;/root&gt; 要求在树状控件上显示如下：–root—-动物—-植物 在树状控件上点击“动物”，在列表控件上出现1 熊猫2 兔子 同理，点击“植物”，在列表控件上出现1 仙人掌2 玫瑰 思维碰撞之前的思路：先SelectedSingleNode(“/Node/Node”)，定位到动物这一层。然后获得该结点的属性即aniname，插入树状控件。接着指向其兄弟结点，将兄弟结点（植物）的属性同样插入树状控件。如果新插入结点，可能需递归（但都是在动物同层面）。因为并没有将“熊猫”“兔子”插入树状控件，因此无法使用m_tree.GetChildItem(ht)获取。所以我想通过“动物”植物“的aniname和planame来反过来查找对应xml里的结点pNode（这里存在问题how to find it?遍历xml找同样的名字？Item能和node存在对应关系么）。找到后，只需GetChildNode之类获取孩子结点，再插入到列表控件中（也就是和列表控件交互实际是列表控件在和xml直接交互，树控件只起到选择某个item，对应到xml中）。简单说来：选择树结点-&gt;获得该xml对应结点-&gt;获得每一个孩子结点-&gt;获得孩子结点的文本和其他路径属性-&gt;通过列表插入 就算是为树状控件和列表控件设置一个类或者一个结构，先要把xml所需的信息全部放入。毕竟投射到树状控件的结点并非全部结点，最重要的是列表控件所需结点不在树状控件中。那么添加删除时，对应的类或结构也应相应操作，是否繁琐。但感觉之前用树控件用错了，只是获取了文本，数据并没传入。 又过了一天。思路变为：为不直接操作XML，应创建一个结构体，利用MSXML解析XML将信息放入结构体中，在后续树状控件和列表控件操作时都调用该结构体而非XML。 前面那么多废话，其实说白了就是要自己生成一棵树，数据来源是xml，通过MSXML获得每个结点信息，自己生成的树中只包含所需要的xml片段信息，之后树控件根据指针来获得选择结点的孩子结点。xml解析的最关键之处，就是如何将xml文件内容解析成内存中的可用、易用的程序数据—DOM(Document Object Model)树。DOM其实就是多叉树，每个节点只需知道自己的第一个子节点（first child）和下一个兄弟节点（next sibling），即可实现元素数据的解析。 理一理六层结构：map-&gt;分类节点-&gt;vector-&gt;n个小节点-&gt;结构体-&gt;xml 如果要求分类节点就一层，是完全OK的。但如果要求分类下面还需要小分类，这就很不ok了。换为两个结构体：1）小节点结构体-&gt;xml2)分类节点结构体-&gt;vector-&gt;1) 发现六层结构办不到时，仿佛多米诺骨牌立到最后几块，突然看到最开始的一段里有一块距离放远了……但换成双结构体其实改动也没太多，又好像把那块出差错的给换了块适合长度的，整个链条还是能补完整的。思维过山车 跌宕起伏","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hubojing.github.io/categories/编程语言/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"},{"name":"MFC","slug":"MFC","permalink":"https://hubojing.github.io/tags/MFC/"},{"name":"XML","slug":"XML","permalink":"https://hubojing.github.io/tags/XML/"}]},{"title":"求购","slug":"求购","date":"2017-07-18T14:55:44.000Z","updated":"2017-07-18T14:55:44.000Z","comments":true,"path":"2017/07/18/求购/","link":"","permalink":"https://hubojing.github.io/2017/07/18/求购/","excerpt":" \n\n 　　　　　　这贴适合又不适合卡吧老司机进来　　　　　　","text":"这贴适合又不适合卡吧老司机进来 不是组装电脑！让你失望了[微笑] 直连光猫 直连光猫 连接路由器 路由器 这还是最快的信道 100M的钱 10M的同等感受 1.求推路由器100M光纤 家用 连Wifi设备还比较多 需跨墙要求：性能好 性能好 性能好 性价比高 2.求推电视音响要求：音质好 音质好 音质好 重低音强（低音炮！）价格……当然性价比越高越好……价位……高中低各给一款参考？ 能直接给京东链接最好了…… 。。。。。。 之所以不去卡吧等土豪吧发帖，当然是 因为 穷 默默想起几年前的一首诗三千预算进卡吧 加钱加到九万八 八核 E5 装上去 四路Titan抱回家4K 屏幕组三屏 万元水冷温度压 固态硬盘装三块 硬盘内存使劲加 键鼠必花几千元 耳机手柄三千八 还有机箱六千元 红星炸弹劈劈啪 —华丽的分界线— 一天不能同时留2个Flag是真的总有一个会打脸比如上一篇写的 今天说好写MSHTML例子的 结果今天先被MSXML弄昏了昨晚去云村留Flag说早睡 总要做到一个吧真的！我要早点睡觉！不过12点！！！ 附上两张公司厕所励志图………………………… 1 2 各位看到的大神们晚安~我要做一只美丽的小菜鸟⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄","raw":null,"content":null,"categories":[{"name":"数码","slug":"数码","permalink":"https://hubojing.github.io/categories/数码/"}],"tags":[{"name":"硬件","slug":"硬件","permalink":"https://hubojing.github.io/tags/硬件/"}]},{"title":"一个MFC利用MSXML解析XML的最简例子","slug":"一个MFC利用MSXML解析XML的最简例子","date":"2017-07-13T13:14:26.000Z","updated":"2017-07-16T15:48:31.000Z","comments":true,"path":"2017/07/13/一个MFC利用MSXML解析XML的最简例子/","link":"","permalink":"https://hubojing.github.io/2017/07/13/一个MFC利用MSXML解析XML的最简例子/","excerpt":"\n　　　　　　如题。　　　　　　","text":"如题。 代码系统自带MSXML6.dll，在C盘system32下。先要导入文件，定义使用空间。 12#import &lt;msxml6.dll&gt;using namespace MSXML2; 为三个编辑框分别添加变量m_strId,m_strAuthor,m_strTitle。 主要代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475void CXMLDlg::OnBnClickedBtncreate()&#123; // TODO: 在此添加控件通知处理程序代码 UpdateData(); MSXML2::IXMLDOMDocumentPtr pDoc; MSXML2::IXMLDOMElementPtr xmlRoot; //创建DOMDocument对象 HRESULT hr = pDoc.CreateInstance(__uuidof(MSXML2::DOMDocument60)); //根节点的名称为Book //创建元素并添加到文档中 xmlRoot = pDoc-&gt;createElement((_bstr_t)\"Book\"); //设置属性 xmlRoot-&gt;setAttribute(\"id\", (_variant_t)m_strId); pDoc-&gt;appendChild(xmlRoot); MSXML2::IXMLDOMElementPtr pNode; //添加“author”元素 pNode = pDoc-&gt;createElement((_bstr_t)\"Author\"); pNode-&gt;Puttext((_bstr_t)m_strAuthor); xmlRoot-&gt;appendChild(pNode); //添加“Title”元素 pNode = pDoc-&gt;createElement(\"Title\"); pNode-&gt;Puttext((_bstr_t)m_strTitle); xmlRoot-&gt;appendChild(pNode); //如果不存在就建立,存在就覆盖 pDoc-&gt;save(\"text.xml\");&#125;void CXMLDlg::OnBnClickedBtnload()&#123; // TODO: 在此添加控件通知处理程序代码 MSXML2::IXMLDOMDocumentPtr pDoc; HRESULT hr = pDoc.CreateInstance(__uuidof(MSXML2::DOMDocument60)); //加载文件 pDoc-&gt;load(\"text.xml\"); MSXML2::IXMLDOMNodePtr pNode; //在树中查找名为Book的节点,\"//\"表示在任意一层查找 pNode = pDoc-&gt;selectSingleNode(\"//Book\"); MSXML2::DOMNodeType nodeType; //得到节点类型 pNode-&gt;get_nodeType(&amp;nodeType); //节点名称 CString strName; strName = (char *)pNode-&gt;GetnodeName(); //节点属性,放在链表中 MSXML2::IXMLDOMNamedNodeMapPtr pAttrMap = NULL; MSXML2::IXMLDOMNodePtr pAttrItem; _variant_t variantValue; pNode-&gt;get_attributes(&amp;pAttrMap); long count; count = pAttrMap-&gt;get_length(&amp;count); pAttrMap-&gt;get_item(0, &amp;pAttrItem); //取得节点的值 pAttrItem-&gt;get_nodeTypedValue(&amp;variantValue); m_strId = (char *)(_bstr_t)variantValue; UpdateData(FALSE);&#125;void CXMLDlg::OnBnClickedBtnclear()&#123; // TODO: 在此添加控件通知处理程序代码 m_temp = \"\"; SetDlgItemText(IDC_EDIT1, m_temp); SetDlgItemText(IDC_EDIT2, m_temp); SetDlgItemText(IDC_EDIT3, m_temp);&#125; 效果生成的XML: XML 界面： 界面 报错1. 报错 之前也遇到过类似情况。 解决：Unicode in the Windows APIConventions for Function Prototypes 简单说来，是因为随着版本更替，老规则渐渐不使用，现在的字符多是Unicode字符集，为了各版本的兼容，最好的方法是使用TEXT宏。即将程序改为：123456789if (!SUCCEEDED(hr)) &#123; MessageBox(_T(\"无法创建DOMDocument对象，请检查是否安装了MS XML Parser 运行库!\")); return; &#125; 即能编译通过。 2. 报错2 这个DOMDocument40是什么？同样的程序，WIN7电脑就可以编译通过，WIN10就报错？要换成DOMDocument60才行。 答：MSXML SDK版本不同造成的差异。 参考MFC中利用MSXML解析XML文档","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hubojing.github.io/categories/编程语言/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"},{"name":"MFC","slug":"MFC","permalink":"https://hubojing.github.io/tags/MFC/"},{"name":"XML","slug":"XML","permalink":"https://hubojing.github.io/tags/XML/"}]},{"title":"新闻杂谈","slug":"勒索病毒","date":"2017-06-29T15:26:53.000Z","updated":"2017-06-29T15:26:53.000Z","comments":true,"path":"2017/06/29/勒索病毒/","link":"","permalink":"https://hubojing.github.io/2017/06/29/勒索病毒/","excerpt":"给Petya病毒差评，比永恒之蓝的用户体验差太多了，竟然没有简体中文版！！！　　 ","text":"给Petya病毒差评，比永恒之蓝的用户体验差太多了，竟然没有简体中文版！！！ 三条新闻 巴铁狗带今天看新闻巴铁终于被拆了……还记得当初第一回看到这个新概念视频时还觉得超酷的，然而仔细一想就漏洞百出。黑科技常有，但在众人提出质疑后却给不出解决方案的情况下一意孤行就很不地道。只能说是打着科研旗号骗国家钱的玩意儿…… 之前报道：【微软惊呆：Win 10源代码泄漏！】外媒Theregister获得消息称，Win10源代码目前在网上被大量泄漏，这些源代码大小超过32TB。据悉，这些代码在今年三月左右在微软内部系统当中流出，包含Win10硬件驱动程序源码及USB和Wi-Fi协议栈等，获得源代码的黑客将可以查找系统中的漏洞用来破坏全球Windows系统.. ​ 标题我都想好了：震惊！！Windows系统将走向开源 国产自主研发加速 最新消息：微软承认遭泄露，不过只有1.2G。（这就很不新闻了） 最近勒索病毒又升级了……吓得我又去看看自己win10升级没…… Petya病毒对勒索对象的加密，分为以下7个步骤：遍历所有驱动器，对每个驱动器创建一个线程并行加密 -&gt; 生成AES-128密钥key -&gt; 遍历磁盘文件，用key对其进行AES加密 -&gt; 从程序中获取一个公钥pubkey（内置固定） -&gt; 用pubkey加密key，得到ekey -&gt; 将ekey写入README.TXT -&gt; 释放key WanaCrypt0r勒索蠕虫完全分析报告","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/tags/杂谈/"}]},{"title":"HOOPS记录","slug":"HOOPS记录","date":"2017-06-25T14:54:44.000Z","updated":"2017-06-25T14:54:44.000Z","comments":true,"path":"2017/06/25/HOOPS记录/","link":"","permalink":"https://hubojing.github.io/2017/06/25/HOOPS记录/","excerpt":" HOOPS初学概念小记（自用笔记）。　　 ","text":"HOOPS初学概念小记（自用笔记）。 HOOPS 3D Application Framework (HOOPS/3dAF)官网描述With HOOPS Visualize, you can rapidly produce eye-popping graphics across both mobile and desktop platforms. At its core, HOOPS Visualize provides a flexible, hierarchical scene management engine capable of handling a range of graphics entities, together with a sophisticated graphics pipeline and high-performance graphics and interaction handling algorithms. It also delivers advanced capabilities to accelerate your application development, including an animation engine, clash detection, multi-plane sectioning, and large model visualization. HOOPS 基本图元和属性支持 几 何 Images, Unicode Text, Points, Lines, Polygons, Polylines, Polycylinders, NURBS curves, NURBS surfaces, Arcs, Ellipses, Circles, Tristrips, Trifans, Indexed Facesets, Cutting Planes, Capping Geometry几何属性Color, Transparency, Textures, Visibility, Patterns (Facet,edge 和 Line), Color Ramps, Lighting Interpolation, Selectability渲染属性Shaded, Analytic Hidden Line, Wireframe,Color Maps, Various Color Ramping Algorithms, Window Background Coloring edges包含polygons,shells,meshes.faces包含shells和meshes.markers 单独的点. 标记marker 可作为注释来使用 当放大和缩小时标记的大小是不变的 标记的大小是朝向相机的，它并不旋转 HOOPS MVO （MVO分别是Model、View、Operator的缩写） 段结构 HDB HBaseModel：处理在包含库下的段 HBaseView：处理在驱动段下的段和实例 HbaseOperator：处理图形用户界面/事件循环· 相机操作· 几何对象操作· 选择 3D应用程序中经常用到的函数 保存应用程序数据 绘制应用程序数据 管理应用程序数据 相机 选择 坐标 查询 驱动器设置 shell官网描述3D applications typically represent 3D objects with an “indexed face set” or “polygon-point mesh”. In Visualize, such primitives are called ‘shells’. A shell defines the boundary surface of an object in 3D using a set of planar polygons. Polygons can be multi-sided and can include holes. A shell is defined as an array of vertices (3D points) and an array of indices into the vertex array that define each polygonal face. HOOPS Visualize supports a wide range of advanced functionality relating to shells, including the ability to select, highlight, and modify individual sub-entities (faces, edges, and vertices). Attributes such as normals, colors, and texture coordinates can also be set at the sub-entity level to enable a variety of complex shading and display. Shell 一系列连通的Face / Wire的集合。线、面的集合，能位于实体外，也能在内部形成空洞。一个体含一个悬挂面，一个体内嵌许多和外表面相连的面都称为shell。 shell attributes属性1.Vertex markers2.Silhouette（外表面）/perimeter/hard/adjacent edges3.Cut edges/faces4.Attributes on subparts5.Smooth shading6.Advanced rendering selection官网描述The Visualize libraries provide multiple operations for selection and several advanced highlighting techniques. Selection Control over what is targeted for selection is configurable: Segments in the scene graph can be marked as available for selectionThe selection level can be specified – entity, geometry, segment, or segment tree. Selection of individual vertices, edges and faces can be configuredThe number of selected items to search for is configurableThe selection proximity can be used to select the nearest item on screen within a screen-based toleranceSelections can be made of all items inside and outside a drag box, inside arbitrary screen regions defined by polylines or polygons, by a volume of 3D space, and by an arbitrary triangle mesh in 3D for clash/collision detection. 坐标系（Coordinate Systems）对象（Object）-&gt;世界（World）-&gt;(-&gt;视点ViewPoint)-&gt;外窗口（Outer Window）-&gt;像素（Pixel） 参考资料理解矩阵（一）理解矩阵（二）理解矩阵（三）HOOPS基础培训课程1HOOPS基础培训课程2HOOPS基础培训课程3HOOPS_MFC应用程序向导","raw":null,"content":null,"categories":[{"name":"软件开发","slug":"软件开发","permalink":"https://hubojing.github.io/categories/软件开发/"}],"tags":[{"name":"3D","slug":"3D","permalink":"https://hubojing.github.io/tags/3D/"}]},{"title":"MFC+多线程+进度条+复制文件（夹）","slug":"MFC-多线程-进度条-复制文件（夹）","date":"2017-06-15T10:00:17.000Z","updated":"2017-06-15T10:25:01.000Z","comments":true,"path":"2017/06/15/MFC-多线程-进度条-复制文件（夹）/","link":"","permalink":"https://hubojing.github.io/2017/06/15/MFC-多线程-进度条-复制文件（夹）/","excerpt":"　　MFC，多线程+进度条+复制文件（夹）小程序。 ","text":"MFC，多线程+进度条+复制文件（夹）小程序。 多线程： 做一个MFC对话框程序。 点击开始按钮，程序启动一个工作线程，复制指定的文件夹到目标位置。 同时在更新进度条，反映当前的复制进度（按文件数量计算进度）。 点击停止按钮时终止，但需要保证当前正在复制的文件得以复制完成。 工作线程访问主线程需要使用消息机制，不能直接访问。 主界面不能锁死，停止按钮需要随时可以响应点击。 整体思路：在开始按钮里的响应函数中创建一个线程，在线程里复制，通过消息机制更新进度条，在消息机制的函数中和复制过程关联显示进度。 需要解决的问题：1.怎么创建线程2.怎么更新进度条3.怎么将编辑框中输入的路径被copyfile函数读取到4.怎么获取文件个数（遍历）5.怎么把进度条和复制文件进度关联（通过文件个数 进度条范围设置为0-文件数量长度 步长为1 完成一次复制加一次）6.点击取消怎么保证当前正在复制的文件得以复制完成 获取个数：递归遍历整个文件夹，然后递归复制文件到目的文件夹。在递归遍历整个文件夹的时候，就可以拿到整个文件夹的大小以及文件数量。 传递进度数据，用postmessage到该进度条的窗口，在进度条窗口获取该消息 设置SetPos，updatedata该控件。一个对话框里有个进度条控件，当线程接收到数据（文件的总大小和收到的大小）postmessage给对话框，对话框的PreTranslateMessage(MSG* pMsg)截取该消息设置进度条控件（范围和增量，setpos）。 我的方案：关键代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130//复制函数void CopyDirectory(CString source, CString target, CCopyFoldersDlg * pDlg) &#123; CreateDirectory(target,NULL); CFileFind finder; CString path; path.Format(_T(\"%s\\\\*.*\"),source); BOOL bWorking = finder.FindFile(path); while (bWorking) &#123; bWorking = finder.FindNextFile(); if (finder.IsDirectory() &amp;&amp; !finder.IsDots()) &#123; CopyDirectory(finder.GetFilePath(), target+_T(\"\\\\\")+finder.GetFileName(), pDlg); //递归 &#125; else &#123; WaitForSingleObject(pDlg-&gt;hEvent,INFINITE); CopyFile(finder.GetFilePath(), target+_T(\"\\\\\")+finder.GetFileName(), FALSE); count++; pDlg-&gt;PostMessage(WM_USER_PROCESS, count); Sleep(50); &#125; &#125; &#125;VOID GetInfo(CString csPath, long&amp; FoldersNum, long&amp; FilesNum) &#123; SetCurrentDirectory(csPath); CFileFind finder; BOOL bWorking = finder.FindFile(_T(\"*.*\")); while(bWorking) &#123; bWorking = finder.FindNextFile(); if(finder.IsDots()) &#123; continue; &#125; else if(finder.IsDirectory()) &#123; ++FoldersNum; GetInfo(finder.GetFilePath(), FoldersNum, FilesNum); &#125; else &#123; ++FilesNum; &#125; &#125; &#125; //复制线程DWORD WINAPI CCopyFoldersDlg::CopyFolders(LPVOID pParam)&#123; CCopyFoldersDlg* pDlg = (CCopyFoldersDlg*)pParam; if (!pDlg) &#123; return 0; &#125; ResetEvent(pDlg-&gt;hExit); long FoldersNum = 0; long FilesNum = 0; GetInfo(pDlg-&gt;m_SrcPath,FoldersNum, FilesNum); pDlg-&gt;m_Progress.SetRange(0, FilesNum); pDlg-&gt;m_Progress.SetStep(1); CopyDirectory(pDlg-&gt;m_SrcPath, pDlg-&gt;m_DesPath, pDlg); SetEvent(pDlg-&gt;hExit); return 0;&#125;LRESULT CCopyFoldersDlg::Do_process(WPARAM wParam, LPARAM lParam) &#123; wParam += 1; m_Progress.SetPos(wParam); return 0; &#125; void CCopyFoldersDlg::OnStart() &#123; UpdateData(true); if ((m_SrcPath.IsEmpty() &amp;&amp; m_DesPath.IsEmpty())) &#123; MessageBox(\"路径不能为空！\"); return; &#125; else &#123; //创建线程 hThread = CreateThread(NULL, 0, CopyFolders, this, 0, NULL); hEvent = CreateEvent(NULL, TRUE, TRUE, NULL); CloseHandle(hThread); &#125;&#125;void CCopyFoldersDlg::OnStop() &#123; m_iStatus++; if (m_iStatus % 2 == 0) &#123; SetEvent(hEvent); &#125; else &#123; ResetEvent(hEvent); &#125; &#125;void CCopyFoldersDlg::OnTimer(UINT_PTR nIDEvent) &#123; CDialog::OnTimer(nIDEvent); &#125; 完整代码：.cpp文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316// CopyFoldersDlg.cpp : implementation file//#include \"stdafx.h\"#include \"CopyFolders.h\"#include \"CopyFoldersDlg.h\"#include \"windows.h\"#ifdef _DEBUG#define new DEBUG_NEW#undef THIS_FILEstatic char THIS_FILE[] = __FILE__;#endifstatic int count = 0; #define WM_USER_PROCESS (WM_USER+101) void CopyDirectory(CString source, CString target,CWnd * pWndMsg); /////////////////////////////////////////////////////////////////////////////// CAboutDlg dialog used for App Aboutclass CAboutDlg : public CDialog&#123;public: CAboutDlg();// Dialog Data //&#123;&#123;AFX_DATA(CAboutDlg) enum &#123; IDD = IDD_ABOUTBOX &#125;; //&#125;&#125;AFX_DATA // ClassWizard generated virtual function overrides //&#123;&#123;AFX_VIRTUAL(CAboutDlg) protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV support //&#125;&#125;AFX_VIRTUAL// Implementationprotected: //&#123;&#123;AFX_MSG(CAboutDlg) //&#125;&#125;AFX_MSG DECLARE_MESSAGE_MAP()&#125;;CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)&#123; //&#123;&#123;AFX_DATA_INIT(CAboutDlg) //&#125;&#125;AFX_DATA_INIT&#125;void CAboutDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialog::DoDataExchange(pDX); //&#123;&#123;AFX_DATA_MAP(CAboutDlg) //&#125;&#125;AFX_DATA_MAP&#125;BEGIN_MESSAGE_MAP(CAboutDlg, CDialog) //&#123;&#123;AFX_MSG_MAP(CAboutDlg) // No message handlers //&#125;&#125;AFX_MSG_MAPEND_MESSAGE_MAP()/////////////////////////////////////////////////////////////////////////////// CCopyFoldersDlg dialogCCopyFoldersDlg::CCopyFoldersDlg(CWnd* pParent /*=NULL*/) : CDialog(CCopyFoldersDlg::IDD, pParent)&#123; //&#123;&#123;AFX_DATA_INIT(CCopyFoldersDlg) m_SrcPath = _T(\"\"); m_DesPath = _T(\"\"); //&#125;&#125;AFX_DATA_INIT // Note that LoadIcon does not require a subsequent DestroyIcon in Win32 m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);&#125;void CCopyFoldersDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialog::DoDataExchange(pDX); //&#123;&#123;AFX_DATA_MAP(CCopyFoldersDlg) DDX_Control(pDX, IDC_PROGRESS, m_Progress); DDX_Text(pDX, IDC_EDIT1, m_SrcPath); DDX_Text(pDX, IDC_EDIT2, m_DesPath); //&#125;&#125;AFX_DATA_MAP&#125;BEGIN_MESSAGE_MAP(CCopyFoldersDlg, CDialog) //&#123;&#123;AFX_MSG_MAP(CCopyFoldersDlg) ON_WM_SYSCOMMAND() ON_WM_PAINT() ON_WM_QUERYDRAGICON() ON_BN_CLICKED(IDC_START, OnStart) ON_BN_CLICKED(IDC_STOP, OnStop) ON_MESSAGE(WM_USER_PROCESS, Do_process) ON_WM_TIMER() //&#125;&#125;AFX_MSG_MAPEND_MESSAGE_MAP()/////////////////////////////////////////////////////////////////////////////// CCopyFoldersDlg message handlersBOOL CCopyFoldersDlg::OnInitDialog()&#123; CDialog::OnInitDialog(); // Add \"About...\" menu item to system menu. // IDM_ABOUTBOX must be in the system command range. ASSERT((IDM_ABOUTBOX &amp; 0xFFF0) == IDM_ABOUTBOX); ASSERT(IDM_ABOUTBOX &lt; 0xF000); CMenu* pSysMenu = GetSystemMenu(FALSE); if (pSysMenu != NULL) &#123; CString strAboutMenu; strAboutMenu.LoadString(IDS_ABOUTBOX); if (!strAboutMenu.IsEmpty()) &#123; pSysMenu-&gt;AppendMenu(MF_SEPARATOR); pSysMenu-&gt;AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu); &#125; &#125; // Set the icon for this dialog. The framework does this automatically // when the application's main window is not a dialog SetIcon(m_hIcon, TRUE); // Set big icon SetIcon(m_hIcon, FALSE); // Set small icon // TODO: Add extra initialization here return TRUE; // return TRUE unless you set the focus to a control&#125;void CCopyFoldersDlg::OnSysCommand(UINT nID, LPARAM lParam)&#123; if ((nID &amp; 0xFFF0) == IDM_ABOUTBOX) &#123; CAboutDlg dlgAbout; dlgAbout.DoModal(); &#125; else &#123; CDialog::OnSysCommand(nID, lParam); &#125;&#125;// If you add a minimize button to your dialog, you will need the code below// to draw the icon. For MFC applications using the document/view model,// this is automatically done for you by the framework.void CCopyFoldersDlg::OnPaint() &#123; if (IsIconic()) &#123; CPaintDC dc(this); // device context for painting SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0); // Center icon in client rectangle int cxIcon = GetSystemMetrics(SM_CXICON); int cyIcon = GetSystemMetrics(SM_CYICON); CRect rect; GetClientRect(&amp;rect); int x = (rect.Width() - cxIcon + 1) / 2; int y = (rect.Height() - cyIcon + 1) / 2; // Draw the icon dc.DrawIcon(x, y, m_hIcon); &#125; else &#123; CDialog::OnPaint(); &#125;&#125;// The system calls this to obtain the cursor to display while the user drags// the minimized window.HCURSOR CCopyFoldersDlg::OnQueryDragIcon()&#123; return (HCURSOR) m_hIcon;&#125;//复制函数void CopyDirectory(CString source, CString target, CCopyFoldersDlg * pDlg) &#123; CreateDirectory(target,NULL); CFileFind finder; CString path; path.Format(_T(\"%s\\\\*.*\"),source); BOOL bWorking = finder.FindFile(path); while (bWorking) &#123; bWorking = finder.FindNextFile(); if (finder.IsDirectory() &amp;&amp; !finder.IsDots()) &#123; CopyDirectory(finder.GetFilePath(), target+_T(\"\\\\\")+finder.GetFileName(), pDlg); //递归 &#125; else &#123; WaitForSingleObject(pDlg-&gt;hEvent,INFINITE); CopyFile(finder.GetFilePath(), target+_T(\"\\\\\")+finder.GetFileName(), FALSE); count++; pDlg-&gt;PostMessage(WM_USER_PROCESS, count); Sleep(50); &#125; &#125; &#125;VOID GetInfo(CString csPath, long&amp; FoldersNum, long&amp; FilesNum) &#123; SetCurrentDirectory(csPath); CFileFind finder; BOOL bWorking = finder.FindFile(_T(\"*.*\")); while(bWorking) &#123; bWorking = finder.FindNextFile(); if(finder.IsDots()) &#123; continue; &#125; else if(finder.IsDirectory()) &#123; ++FoldersNum; GetInfo(finder.GetFilePath(), FoldersNum, FilesNum); &#125; else &#123; ++FilesNum; &#125; &#125; &#125; //复制线程DWORD WINAPI CCopyFoldersDlg::CopyFolders(LPVOID pParam)&#123; CCopyFoldersDlg* pDlg = (CCopyFoldersDlg*)pParam; if (!pDlg) &#123; return 0; &#125; ResetEvent(pDlg-&gt;hExit); long FoldersNum = 0; long FilesNum = 0; GetInfo(pDlg-&gt;m_SrcPath,FoldersNum, FilesNum); pDlg-&gt;m_Progress.SetRange(0, FilesNum); pDlg-&gt;m_Progress.SetStep(1); CopyDirectory(pDlg-&gt;m_SrcPath, pDlg-&gt;m_DesPath, pDlg); SetEvent(pDlg-&gt;hExit); return 0;&#125;LRESULT CCopyFoldersDlg::Do_process(WPARAM wParam, LPARAM lParam) &#123; wParam += 1; m_Progress.SetPos(wParam); return 0; &#125; void CCopyFoldersDlg::OnStart() &#123; UpdateData(true); if ((m_SrcPath.IsEmpty() &amp;&amp; m_DesPath.IsEmpty())) &#123; MessageBox(\"路径不能为空！\"); return; &#125; else &#123; //创建线程 hThread = CreateThread(NULL, 0, CopyFolders, this, 0, NULL); hEvent = CreateEvent(NULL, TRUE, TRUE, NULL); CloseHandle(hThread); &#125;&#125;void CCopyFoldersDlg::OnStop() &#123; m_iStatus++; if (m_iStatus % 2 == 0) &#123; SetEvent(hEvent); &#125; else &#123; ResetEvent(hEvent); &#125; &#125;void CCopyFoldersDlg::OnTimer(UINT_PTR nIDEvent) &#123; CDialog::OnTimer(nIDEvent); &#125; .h文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// CopyFoldersDlg.h : header file//#if !defined(AFX_COPYFOLDERSDLG_H__BADF1BD0_296B_4FED_96F7_BCD2628D4B03__INCLUDED_)#define AFX_COPYFOLDERSDLG_H__BADF1BD0_296B_4FED_96F7_BCD2628D4B03__INCLUDED_#if _MSC_VER &gt; 1000#pragma once#endif // _MSC_VER &gt; 1000/////////////////////////////////////////////////////////////////////////////// CCopyFoldersDlg dialogclass CCopyFoldersDlg : public CDialog&#123;// Constructionpublic: CCopyFoldersDlg(CWnd* pParent = NULL); // standard constructor HANDLE hThread; HANDLE hEvent; HANDLE hExit; static DWORD WINAPI CopyFolders(LPVOID pParam); int m_iStatus; // Dialog Data //&#123;&#123;AFX_DATA(CCopyFoldersDlg) enum &#123; IDD = IDD_COPYFOLDERS_DIALOG &#125;; CProgressCtrl m_Progress; CString m_SrcPath; CString m_DesPath; //&#125;&#125;AFX_DATA // ClassWizard generated virtual function overrides //&#123;&#123;AFX_VIRTUAL(CCopyFoldersDlg) protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV support //&#125;&#125;AFX_VIRTUAL// Implementationprotected: HICON m_hIcon; // Generated message map functions //&#123;&#123;AFX_MSG(CCopyFoldersDlg) virtual BOOL OnInitDialog(); afx_msg void OnSysCommand(UINT nID, LPARAM lParam); afx_msg void OnPaint(); afx_msg HCURSOR OnQueryDragIcon(); afx_msg void OnStart(); afx_msg void OnStop(); afx_msg LRESULT CCopyFoldersDlg::Do_process(WPARAM wParam,LPARAM lParam); afx_msg void OnTimer(UINT_PTR nIDEvent); //&#125;&#125;AFX_MSG DECLARE_MESSAGE_MAP()&#125;;//&#123;&#123;AFX_INSERT_LOCATION&#125;&#125;// Microsoft Visual C++ will insert additional declarations immediately before the previous line.#endif // !defined(AFX_COPYFOLDERSDLG_H__BADF1BD0_296B_4FED_96F7_BCD2628D4B03__INCLUDED_) 界面： 界面 另一种方案（大同小异）：.cpp文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303// FileCopyNumDlg.cpp : implementation file//#include \"stdafx.h\"#include \"FileCopyNum.h\"#include \"FileCopyNumDlg.h\"#define WM_COPYFILE_NOTIFY_NUM WM_USER+1#define WM_COPYFILE_NOTIFY_SUM WM_USER+8#ifdef _DEBUG#define new DEBUG_NEW#undef THIS_FILEstatic char THIS_FILE[] = __FILE__;#endif/////////////////////////////////////////////////////////////////////////////// CAboutDlg dialog used for App Aboutclass CAboutDlg : public CDialog&#123;public: CAboutDlg();// Dialog Data //&#123;&#123;AFX_DATA(CAboutDlg) enum &#123; IDD = IDD_ABOUTBOX &#125;; //&#125;&#125;AFX_DATA // ClassWizard generated virtual function overrides //&#123;&#123;AFX_VIRTUAL(CAboutDlg) protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV support //&#125;&#125;AFX_VIRTUAL// Implementationprotected: //&#123;&#123;AFX_MSG(CAboutDlg) //&#125;&#125;AFX_MSG DECLARE_MESSAGE_MAP()&#125;;CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)&#123; //&#123;&#123;AFX_DATA_INIT(CAboutDlg) //&#125;&#125;AFX_DATA_INIT&#125;void CAboutDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialog::DoDataExchange(pDX); //&#123;&#123;AFX_DATA_MAP(CAboutDlg) //&#125;&#125;AFX_DATA_MAP&#125;BEGIN_MESSAGE_MAP(CAboutDlg, CDialog) //&#123;&#123;AFX_MSG_MAP(CAboutDlg) // No message handlers //&#125;&#125;AFX_MSG_MAPEND_MESSAGE_MAP()/////////////////////////////////////////////////////////////////////////////// CFileCopyNumDlg dialogCFileCopyNumDlg::CFileCopyNumDlg(CWnd* pParent /*=NULL*/) : CDialog(CFileCopyNumDlg::IDD, pParent)&#123; //&#123;&#123;AFX_DATA_INIT(CFileCopyNumDlg) m_sourcePath = _T(\"\"); m_desPath = _T(\"\"); //&#125;&#125;AFX_DATA_INIT // Note that LoadIcon does not require a subsequent DestroyIcon in Win32 m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);&#125;void CFileCopyNumDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialog::DoDataExchange(pDX); //&#123;&#123;AFX_DATA_MAP(CFileCopyNumDlg) DDX_Control(pDX, IDC_PROGRESS1, m_progress); DDX_Text(pDX, IDC_EDIT1, m_sourcePath); DDX_Text(pDX, IDC_EDIT2, m_desPath); //&#125;&#125;AFX_DATA_MAP&#125;BEGIN_MESSAGE_MAP(CFileCopyNumDlg, CDialog) //&#123;&#123;AFX_MSG_MAP(CFileCopyNumDlg) ON_WM_SYSCOMMAND() ON_WM_PAINT() ON_WM_QUERYDRAGICON() ON_BN_CLICKED(IDC_BTN_CHOOSEFILE1, OnBtnChoosefile1) ON_BN_CLICKED(IDC_BTN_CHOOSEFILE2, OnBtnChoosefile2) ON_BN_CLICKED(IDC_BTN_PAUSE, OnBtnPause) ON_BN_CLICKED(IDC_BTN_RESUME, OnBtnResume) ON_WM_TIMER() ON_BN_CLICKED(IDC_BTN_BEGIN, OnBtnBegin) ON_MESSAGE(WM_COPYFILE_NOTIFY_NUM, OnCopyFileNotifyNum) ON_MESSAGE(WM_COPYFILE_NOTIFY_SUM, OnCopyFileNotifySum) //&#125;&#125;AFX_MSG_MAPEND_MESSAGE_MAP()/////////////////////////////////////////////////////////////////////////////// CFileCopyNumDlg message handlersBOOL CFileCopyNumDlg::OnInitDialog()&#123; CDialog::OnInitDialog(); // Add \"About...\" menu item to system menu. // IDM_ABOUTBOX must be in the system command range. ASSERT((IDM_ABOUTBOX &amp; 0xFFF0) == IDM_ABOUTBOX); ASSERT(IDM_ABOUTBOX &lt; 0xF000); CMenu* pSysMenu = GetSystemMenu(FALSE); if (pSysMenu != NULL) &#123; CString strAboutMenu; strAboutMenu.LoadString(IDS_ABOUTBOX); if (!strAboutMenu.IsEmpty()) &#123; pSysMenu-&gt;AppendMenu(MF_SEPARATOR); pSysMenu-&gt;AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu); &#125; &#125; // Set the icon for this dialog. The framework does this automatically // when the application's main window is not a dialog SetIcon(m_hIcon, TRUE); // Set big icon SetIcon(m_hIcon, FALSE); // Set small icon // TODO: Add extra initialization here m_num = 0; m_sum = 0; m_progress.SetRange(0, 100); m_progress.SetPos(0); return TRUE; // return TRUE unless you set the focus to a control&#125;void CFileCopyNumDlg::OnSysCommand(UINT nID, LPARAM lParam)&#123; if ((nID &amp; 0xFFF0) == IDM_ABOUTBOX) &#123; CAboutDlg dlgAbout; dlgAbout.DoModal(); &#125; else &#123; CDialog::OnSysCommand(nID, lParam); &#125;&#125;// If you add a minimize button to your dialog, you will need the code below// to draw the icon. For MFC applications using the document/view model,// this is automatically done for you by the framework.void CFileCopyNumDlg::OnPaint() &#123; if (IsIconic()) &#123; CPaintDC dc(this); // device context for painting SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0); // Center icon in client rectangle int cxIcon = GetSystemMetrics(SM_CXICON); int cyIcon = GetSystemMetrics(SM_CYICON); CRect rect; GetClientRect(&amp;rect); int x = (rect.Width() - cxIcon + 1) / 2; int y = (rect.Height() - cyIcon + 1) / 2; // Draw the icon dc.DrawIcon(x, y, m_hIcon); &#125; else &#123; CDialog::OnPaint(); &#125;&#125;// The system calls this to obtain the cursor to display while the user drags// the minimized window.HCURSOR CFileCopyNumDlg::OnQueryDragIcon()&#123; return (HCURSOR) m_hIcon;&#125;void CFileCopyNumDlg::OnBtnChoosefile1() &#123; CFileDialog dlg(TRUE); if(IDOK==dlg.DoModal()) &#123; strSourceFile=dlg.GetPathName(); &#125; SetDlgItemText(IDC_EDIT1,strSourceFile); &#125;void CFileCopyNumDlg::OnBtnChoosefile2() &#123; CFileDialog dlg(TRUE); if(IDOK==dlg.DoModal()) &#123; strNewFile=dlg.GetPathName(); &#125; SetDlgItemText(IDC_EDIT2,strSourceFile); &#125;void CFileCopyNumDlg::OnBtnBegin() &#123; UpdateData(TRUE); hThread = CreateThread(NULL, 0, ThreadProc_Copy, this, 0, NULL); hEvent = CreateEvent(NULL, TRUE, TRUE, NULL); &#125;DWORD WINAPI CFileCopyNumDlg::ThreadProc_Copy(LPVOID lpParam)&#123; double num = 0; double sum = 0; CString SourcePath = ((CFileCopyNumDlg*)lpParam)-&gt;m_sourcePath; CString DesPath = ((CFileCopyNumDlg*)lpParam)-&gt;m_desPath + L\"\\\\\"; CFileFind findcount; BOOL bRet = findcount.FindFile(((CFileCopyNumDlg*)lpParam)-&gt;m_sourcePath + CString(\"\\\\*.*\")); while (bRet) &#123; bRet = findcount.FindNextFile(); if (findcount.IsDirectory()) &#123; continue; &#125; else &#123; ((CFileCopyNumDlg*)lpParam)-&gt;PostMessage(WM_COPYFILE_NOTIFY_SUM); &#125; &#125; findcount.Close(); CFileFind find; bRet = find.FindFile(((CFileCopyNumDlg*)lpParam)-&gt;m_sourcePath + CString(\"\\\\*.*\")); while (bRet) &#123; bRet = find.FindNextFile(); if (find.IsDirectory()) &#123; continue; &#125; else &#123; ((CFileCopyNumDlg*)lpParam)-&gt;m_sourcePath = find.GetFilePath(); ((CFileCopyNumDlg*)lpParam)-&gt;m_desPath = DesPath + find.GetFileName(); WaitForSingleObject(((CFileCopyNumDlg*)lpParam)-&gt;hEvent,INFINITE); CopyFile(((CFileCopyNumDlg*)lpParam)-&gt;m_sourcePath, ((CFileCopyNumDlg*)lpParam)-&gt;m_desPath, FALSE); ((CFileCopyNumDlg*)lpParam)-&gt;PostMessage(WM_COPYFILE_NOTIFY_NUM); &#125; &#125; AfxMessageBox(\"复制成功!\"); return 0 ;&#125;void CFileCopyNumDlg::OnBtnPause() &#123; ResetEvent(hEvent); &#125;void CFileCopyNumDlg::OnBtnResume() &#123; SetEvent(hEvent);&#125;void CFileCopyNumDlg::OnTimer(UINT nIDEvent) &#123; // TODO: Add your message handler code here and/or call default CDialog::OnTimer(nIDEvent);&#125;afx_msg LRESULT CFileCopyNumDlg::OnCopyFileNotifyNum(WPARAM wParam, LPARAM lParam)&#123; m_num++; m_progress.SetPos(int(m_num / m_sum * 100)); return 0;&#125;afx_msg LRESULT CFileCopyNumDlg::OnCopyFileNotifySum(WPARAM wParam, LPARAM lParam)&#123; m_sum++; return 0;&#125; .h文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// FileCopyNumDlg.h : header file//#if !defined(AFX_FILECOPYNUMDLG_H__02EF2204_005C_4A21_A048_ED73C9CD1F34__INCLUDED_)#define AFX_FILECOPYNUMDLG_H__02EF2204_005C_4A21_A048_ED73C9CD1F34__INCLUDED_#if _MSC_VER &gt; 1000#pragma once#endif // _MSC_VER &gt; 1000/////////////////////////////////////////////////////////////////////////////// CFileCopyNumDlg dialogclass CFileCopyNumDlg : public CDialog&#123;// Constructionpublic: CFileCopyNumDlg(CWnd* pParent = NULL); // standard constructor// Dialog Data //&#123;&#123;AFX_DATA(CFileCopyNumDlg) enum &#123; IDD = IDD_FILECOPYNUM_DIALOG &#125;; CProgressCtrl m_progress; CString m_sourcePath; CString m_desPath; //&#125;&#125;AFX_DATA // ClassWizard generated virtual function overrides //&#123;&#123;AFX_VIRTUAL(CFileCopyNumDlg) protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV support //&#125;&#125;AFX_VIRTUAL// Implementationprotected: HICON m_hIcon; // Generated message map functions //&#123;&#123;AFX_MSG(CFileCopyNumDlg) virtual BOOL OnInitDialog(); afx_msg void OnSysCommand(UINT nID, LPARAM lParam); afx_msg void OnPaint(); afx_msg HCURSOR OnQueryDragIcon(); afx_msg void OnBtnChoosefile1(); afx_msg void OnBtnChoosefile2(); afx_msg void OnBtnPause(); afx_msg void OnBtnResume(); afx_msg void OnTimer(UINT nIDEvent); afx_msg void OnBtnBegin(); afx_msg LRESULT OnCopyFileNotifyNum(WPARAM wParam, LPARAM lParam); afx_msg LRESULT OnCopyFileNotifySum(WPARAM wParam, LPARAM lParam); //&#125;&#125;AFX_MSG DECLARE_MESSAGE_MAP()public: // LPCTSTR lpExistingPathName; //源文件 //LPCTSTR lpNewPathName; //目标文件 HANDLE hThread; //线程句柄 HANDLE hEvent; //复制暂停事件 CString strSourceFile; CString strNewFile; double m_num; double m_sum; static DWORD WINAPI ThreadProc_Copy(LPVOID lpParam);//线程函数&#125;;//&#123;&#123;AFX_INSERT_LOCATION&#125;&#125;// Microsoft Visual C++ will insert additional declarations immediately before the previous line.#endif // !defined(AFX_FILECOPYNUMDLG_H__02EF2204_005C_4A21_A048_ED73C9CD1F34__INCLUDED_) 这里写图片描述","raw":null,"content":null,"categories":[{"name":"软件开发","slug":"软件开发","permalink":"https://hubojing.github.io/categories/软件开发/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"},{"name":"MFC","slug":"MFC","permalink":"https://hubojing.github.io/tags/MFC/"}]},{"title":"MFC网页分析程序","slug":"MFC网页分析程序","date":"2017-06-14T14:45:38.000Z","updated":"2017-10-12T13:37:46.000Z","comments":true,"path":"2017/06/14/MFC网页分析程序/","link":"","permalink":"https://hubojing.github.io/2017/06/14/MFC网页分析程序/","excerpt":"   　　 　　　　开发一个网页分析程序，可以抓取特定网页的内容，加以分析之后将结果保存至数据库。\n　　V1.5上线，保存至sqlite数据库用时2分13秒。\n　　\n　　\n　　","text":"开发一个网页分析程序，可以抓取特定网页的内容，加以分析之后将结果保存至数据库。 V1.5上线，保存至sqlite数据库用时2分13秒。 网页分析程序具体要求描述如下： 1. 使用http技术获取一个博客的首页http://blog.csdn.net/jiangsheng 2. 分析这个网页的内容，从中找到博客中每一篇文章的链接。 3. 通过这些链接，获取文章的正文网页，从内容中提取文章的标题和文章的内容。 4. 将文章的标题与内容分别保存至数据库。 5. 布局要求：提供一个列表框和一个多行文本框。列表框中显示从数据库中获取的文章标题列表；当点击列表框中的某一篇文章时，在文本框中显示该文章的内容。 获取源码因为需多次调用获取源码功能，将它放入一个函数中。 12345678910111213141516171819202122232425262728293031323334353637383940CString CGetWebDlg::DownloadCodes(CString path)&#123; CInternetSession session; CHttpFile *file = NULL; CString strURL = path; CString strHtml = _T(\"\"); //存放网页数据 try &#123; file = (CHttpFile*)session.OpenURL(strURL); &#125; catch (CInternetException *m_pException) &#123; file = NULL; m_pException-&gt;m_dwError; m_pException-&gt;Delete(); session.Close(); MessageBox(\"网络连接错误！\", \"提示\"); &#125; CString strLine; char sRecived[1024]; if (file != NULL) &#123; while (file-&gt;ReadString((LPTSTR)sRecived, 1024) != NULL) &#123; strHtml += sRecived; &#125; &#125; else &#123; AfxMessageBox(_T(\"失败！\")); &#125; session.Close(); file-&gt;Close(); delete file; file = NULL; strHtml = ConvertUtf8ToGBK(strHtml);//源码转换 return strHtml;&#125; 编码问题注意网页编码问题，因此需要格式转换，编写一个函数：1234567891011121314151617void ConvertUtf8ToGBK(CString &amp;strUtf8)&#123; int len=MultiByteToWideChar(CP_UTF8, 0, (LPCTSTR)strUtf8, -1, NULL,0); unsigned short * wszGBK = new unsigned short[len+1]; memset(wszGBK, 0, len * 2 + 2); MultiByteToWideChar(CP_UTF8, 0, (LPCTSTR)strUtf8, -1, (LPWSTR)wszGBK, len); len = WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)wszGBK, -1, NULL, 0, NULL, NULL); char *szGBK=new char[len + 1]; memset(szGBK, 0, len + 1); WideCharToMultiByte (CP_ACP, 0, (LPCWSTR)wszGBK, -1, szGBK, len, NULL,NULL); strUtf8 = szGBK; delete[] szGBK; delete[] wszGBK;&#125; 显示源码 有些类似网页爬虫的感觉。 由于我刚开始是用VC6.0创建项目，现在用VS2013打开，因此，提示报错：error MSB8031: Building an MFC project for a non-Unicode character set is deprecated. You must change the project property to Unicode or download an additional library. See http://go.microsoft.com/fwlink/p/?LinkId=286820 for more information. 解决：用于多字节字符编码 (MBCS) 的 MFC 库 (DLL) 不再包含于 Visual Studio 中，但是可用作插件，可以在任何装有 Visual Studio Professional、Visual Studio Premium 或 Visual Studio Ultimate 的计算机上下载和安装。下载地址：https://www.microsoft.com/zh-cn/download/details.aspx?id=40770 解析为了接下来的操作，我去学正则表达式了……还是学习html解析库 htmlcxx官方HtmlCxx用户手册 HTMLCXX下载htmlcxx库http://sourceforge.net/projects/htmlcxx/并解压。 编译打开htmlcxx.vcproj，右键属性，配置属性-C/C++-代码生成-运行库：多线程调试 DLL (/ MDd)进行编译。编译会报错，将1const char *signature = \" \"; 改为1const char *signature = \" \\xEF\\xBB\\xBF\"; 即可编译成功。 导入把生成的htmlcxx.lib和html文件夹拷贝到所需的工程中。即：在所开发项目文件夹中，新建”htmlcxx“文件，里面添加两个子文件夹”lib“和”include“。将编译好的htmlcxx.lib拷贝到lib文件夹，将html文件夹中所有的.h头文件和ParserSax.tcc添加到include文件夹。添加库文件htmlcxx.lib到项目中，具体说来： 在VS工程中，添加c/c++工程中外部头文件及库的基本步骤： 1、添加工程的头文件目录：工程—属性—配置属性—c/c++—常规—附加包含目录：加上头文件存放目录。 2、添加文件引用的lib静态库路径：工程—属性—配置属性—链接器—常规—附加库目录：加上lib文件存放目录。 然后添加工程引用的lib文件名：工程—属性—配置属性—链接器—输入—附加依赖项：加上lib文件名。 3、添加工程引用的dll动态库：把引用的dll放到工程的可执行文件所在的目录下。注意：第一步可以不用，直接在工程里加入动态库的头文件，在使用代码处引用这个头文件。 所开发的项目的头文件中添加以下内容：1234567#include &lt;string&gt;#include \"htmlcxx/include/ParserDom.h\" using namespace std;using namespace htmlcxx; #pragma comment(lib,\"htmlcxx.lib\") 测试官方测试代码：123456789101112131415161718192021222324252627282930313233#include &lt;htmlcxx/html/ParserDom.h&gt; ... //Parse some html code string html = \"&lt;html&gt;&lt;body&gt;hey&lt;/body&gt;&lt;/html&gt;\"; HTML::ParserDom parser; tree&lt;HTML::Node&gt; dom = parser.parseTree(html); //Print whole DOM tree cout &lt;&lt; dom &lt;&lt; endl; //Dump all links in the tree tree&lt;HTML::Node&gt;::iterator it = dom.begin(); tree&lt;HTML::Node&gt;::iterator end = dom.end(); for (; it != end; ++it) &#123; if (it-&gt;tagName() == \"A\") &#123; it-&gt;parseAttributes(); cout &lt;&lt; it-&gt;attributes(\"href\"); &#125; &#125; //Dump all text of the document it = dom.begin(); end = dom.end(); for (; it != end; ++it) &#123; if ((!it-&gt;isTag()) &amp;&amp; (!it-&gt;isComment())) &#123; cout &lt;&lt; it-&gt;text(); &#125; &#125; 然而…… 加入#include”iostream”头文件即可。 修改为：123456if (it-&gt;tagName() == \"A\") &#123; it-&gt;parseAttributes(); std::pair&lt;bool, std::string&gt; pa = it-&gt;attribute(\"href\"); cout &lt;&lt; pa.second; &#125; 编译通过。 还有其他的库也可以用，比如使用MSHTML解析HTML页面 比如LIBXML2库使用指南 还可以用正则表达式写库…… 突然发现 原来的计划里有COM组件 XML和HTML 数据库访问技术 都没怎么接触过 补补补 在填坑的路上不能止步… 参考C++ 使用Htmlcxx解析Html内容(VS编译库文件)html与xml解析库htmlcxx使用过程中的若干问题及解决方案c++ hmtlcxx 学习之旅 MSHTML 因为最近用过MSXML，就试试MSHTML。学有余力的话，htmlcxx之后还是想玩一下… https://msdn.microsoft.com/en-us/library/aa741317(v=vs.85).aspx 蒋晟-关于MSHTML https://msdn.microsoft.com/zh-cn/library/mshtml(v=vs.110).aspx MSHTML导入系统中自带了mshtml，和msxml一样，在C盘windows/system32中可找到。 如何导入 先看MSDN…… MSDN-MSHTML 再看各种搜集的文章 http://bbs.csdn.net/topics/330214041 http://www.cnblogs.com/speedmancs/archive/2010/08/11/1797442.html http://blog.csdn.net/jinyaba/article/details/17097323 https://social.msdn.microsoft.com/Search/zh-CN?query=MSHTML&amp;pgArea=header&amp;emptyWatermark=true&amp;ac=4#refinementChanges=117&amp;pageNumber=1&amp;showMore=false https://wenku.baidu.com/view/d571abc4ec3a87c24028c4bb.html http://www.codeguru.com/cpp/i-n/ieprogram/article.php/c4385/Lightweight-HTML-Parsing-Using-MSHTML.htm http://www.yesky.com/403/1938403.shtml?qq-pf-to=pcqq.c2c http://www.bianceng.cn/Programming/vc/201411/46771.htm https://wenku.baidu.com/view/299bba4a336c1eb91a375df5.html 思路：下载源码和获取链接是两个独立函数，会被多次调用。先获取首页源码，div id=”archive_list” 遍历该div获取各月份归档链接，再使用多线程（48个线程？？？）进入每个归档链接里下载源码，获取源码中h1的每篇文章标题,保存到数据库。 虽然有两种方法，一种通过归档获得链接，一种通过翻页获得链接，但根据本html特点，明显通过翻页要简洁方便一些，因为翻页的链接是有规律的，可通过循环搞定。每页5篇直接获得正文链接，比从归档获得少一层。两核4个逻辑处理器，所以是开2个线程好还是4个好呢…… 获取每篇正文链接，下载源码，解析得正文，保存到数据库。最后从数据库中提取标题和正文显示到对应窗口(使用ADO)。 解析过程创建1.使用CoCreateInstance创建一个接口1HRESULT hr = CoCreateInstance(CLSID_HTMLDocument, NULL, CLSCTX_INPROC_SERVER, IID_IHTMLDocument2, (void**)&amp;pDoc); 2.创建一个COM中的数组，将HTML字符串写到数组中 a）SafeArrayCreateVector:函数用来创建一个对应的数组结构。函数有三个参数，第一个参数表示数组中元素类型，一般给VT_VARIANT表示它是一个自动类型，第二个参数数组元素起始位置的下标，对于VC来说，数组元素总是从0开始，所以这个位置一般给0，第三个参数是数组的维数，在这将它作为一个字符数组，所以是一个一维数组。b）SafeArrayAccessData：允许用户操作这个数组，在需要读写这个数组时都需要调用这个函数，以便获取这个数组的操作权。它有两个参数，第一个参数是数组变量，第二个参数是一个输出参数，当调用这个函数成功，会提供一个缓冲区，操作这个缓冲区就相当于操作了这个数组。c）SafeArrayUnaccessData：每当操作数组完成时需要调用这个函数，函数与SafeArrayAccessData配套使用，用来回收这个权限，并使对数组的操作生效。 调用接口的write方法，将接口与HTML字符串绑定 12345678SAFEARRAY* psa = SafeArrayCreateVector(VT_VARIANT, 0, 1);VARIANT *param;bstr_t bsData = (LPCTSTR)strHtml;hr = SafeArrayAccessData(psa, (LPVOID*)&amp;param);param-&gt;vt = VT_BSTR;param-&gt;bstrVal = (BSTR)bsData;hr = pDoc-&gt;write(psa);hr = SafeArrayUnaccessData(psa); 目标： 1234&lt;span class=&quot;link_title&quot;&gt;&lt;a href=&quot;/jiangsheng/article/details/9870241&quot;&gt;选择剪贴板格式顺序 &lt;/a&gt;&lt;/span&gt; 整个 \\&lt;span> \\&lt;/span> 是元素， \\&lt;span> 是标签，class是属性名，link_title是属性值，“选择剪贴板格式顺序”是文本。 元素遍历至少两种方法：法一：获取了HTML文档的IID_IHTMLDocument2接口后，开始遍历：1.get_all方法获取所有标签节点，这个函数通过一个输出参数输出IHTMLElementCollection类型的接口指针2.用IHTMLElementCollection接口的get_length方法获取标签的总数量，据此写一个循环，在循环进行元素的遍历3.循环中用IHTMLElementCollection接口的item方法进行迭代，获取各元素对应的IDispatch接口指针4.调用IDispatch接口指针的QueryInterface方法生成对应的IHTMLElement接口。通过这个接口获取元素的各种信息 以下已能成功获取标题：12345678910111213141516171819202122232425262728293031323334353637383940void CGetWebDlg::EnumElements(IHTMLDocument2* pDoc)&#123; CComPtr&lt;IHTMLElementCollection&gt; pCollection; pDoc-&gt;get_all(&amp;pCollection); if (NULL == pCollection) &#123; return; &#125; VARIANT varName; CString strText; long len = 0; pCollection-&gt;get_length(&amp;len); for (int i = 0; i &lt; len; i++) &#123; varName.vt = VT_I4; varName.lVal = i; CComPtr&lt;IHTMLElement&gt; pElement; CComPtr&lt;IDispatch&gt; pDisp; pCollection-&gt;item(varName, varName, &amp;pDisp); if (NULL == pDisp) &#123; continue; &#125; pDisp-&gt;QueryInterface(IID_IHTMLElement, (LPVOID*)&amp;pElement); if (NULL != pElement) &#123; BSTR bstrClass; pElement-&gt;get_className(&amp;bstrClass); CString strClass = _com_util::ConvertBSTRToString(bstrClass); if (strClass.Compare(&quot;link_title&quot;) == 0) &#123; BSTR bstrText = NULL; pElement-&gt;get_innerText(&amp;bstrText); strText = bstrText; m_list.InsertItem(i, strText); &#125; &#125; &#125;&#125; 法二：利用IHTMLDocument2将字符串形式的HTML转换为DOM对象，利用IHTMLDocument3的getElementByTagName等方法来操作DOM对象。以下已能成功获取标题：1234567891011121314151617181920212223MSHTML::IHTMLDocument3Ptr pDoc3; MSHTML::IHTMLElementCollectionPtr pCollection; MSHTML::IHTMLElementPtr pElement;pDoc3 = pDoc;pCollection = pDoc3-&gt;getElementsByTagName(L&quot;span&quot;);for (long i = 0; i &lt; pCollection-&gt;length; i++)&#123; pElement = pCollection-&gt;item(i, (long)0); if (pElement != NULL) &#123; BSTR bstrClass; pElement-&gt;get_className(&amp;bstrClass); CString strClass = _com_util::ConvertBSTRToString(bstrClass); if (strClass.Compare(&quot;link_title&quot;) == 0) &#123; BSTR bstrText = NULL; pElement-&gt;get_innerText(&amp;bstrText); CString strText = bstrText; m_list.InsertItem(i, strText); &#125; &#125;&#125; 其实两种方法大同小异，相较而言可能数据量大的话，法二效率高些吧。因为法一是直接遍历所有的元素寻找class相同的，而法二是先定位span，然后在span中找寻class。（getElementsByTagName只有IHTMLDocument3Ptr） 使用MSHTML解析HTML页面变体VARIANTMSDN-DOM https://msdn.microsoft.com/en-us/library/ms766487(v=vs.85).aspx使用MSHTML接口获取链接 晚上几个小时做完了一半，抵了之前一两个月。数据库这块没来得及做，没加多线程，很多细节还得调。但比起之前心有余而力不足的感觉还是好多了。 学过msxml后，学习mshtml确实强一点，比一个月前完全不知道怎么下手好很多了。 今晚总算做出来个半成品 半成品 正文解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void CGetWebDlg::ArticleParse(CString strArticle, Blog* blog, int iRow)&#123; IHTMLDocument2* pDoc; MSHTML::IHTMLDocument3Ptr pDoc3; MSHTML::IHTMLElementCollectionPtr pCollection; MSHTML::IHTMLElementPtr pElement; HRESULT hr = CoCreateInstance(CLSID_HTMLDocument, NULL, CLSCTX_INPROC_SERVER, IID_IHTMLDocument2, (void**)&amp;pDoc); //将代码放入安全数组并写入文档 SAFEARRAY* psa = SafeArrayCreateVector(VT_VARIANT, 0, 1); if (psa == NULL || pDoc == NULL) &#123; MessageBox(_T(\"创建Document2对象失败！\")); &#125; VARIANT *param; bstr_t bsData = (LPCTSTR)strArticle; hr = SafeArrayAccessData(psa, (LPVOID*)&amp;param); param-&gt;vt = VT_BSTR; param-&gt;bstrVal = (BSTR)bsData; hr = pDoc-&gt;write(psa); //hr = pDoc-&gt;close(); //SafeArrayDestroy(psa); hr = SafeArrayUnaccessData(psa); _bstr_t href; pDoc3 = pDoc; pCollection = pDoc3-&gt;getElementsByTagName(L\"div\"); for (long k = 0; k &lt; pCollection-&gt;length; k++) &#123; pElement = pCollection-&gt;item(k, (long)0); if (pElement != NULL) &#123; BSTR bstrClass; pElement-&gt;get_id(&amp;bstrClass); CString strClass = _com_util::ConvertBSTRToString(bstrClass); if (strClass.CompareNoCase(\"article_content\") == 0) &#123; BSTR bstrText = NULL; pElement-&gt;get_innerText(&amp;bstrText); CString strText = bstrText; blog-&gt;article = strText; m_list.SetItemData(iRow, (DWORD_PTR)blog); &#125; &#125; &#125;&#125; 建立了一个结构体用来存放每篇文章的标题和正文，方便点击列表控件项时读取对应的结构体。 12345struct Blog &#123; CString title; CString article; &#125;; 列表控件和编辑框交互列表控件初始化1234CRect rectLocal;m_list.GetClientRect(rectLocal); //获得当前客户区信息m_list.InsertColumn(0, \"序号\", LVCFMT_LEFT, rectLocal.Width() / 6, 0);m_list.InsertColumn(1, \"文章列表\", LVCFMT_LEFT, rectLocal.Width() / 6 * 5, 1); 添加多列后，单击只能选中第一列，这时需要修改风格 LVS_EX_FULLROWSELECT 表示整行。1m_list.SetExtendedStyle(LVS_EX_FULLROWSELECT); 添加数据单纯添加一项的话： m_list.InsertItem(项的索引, 数据);但要指定列的话：m_list.InsertItem(项的索引, “”);m_list.SetItemText(行, 列, 数据); OnLvnItemchangedList试了多种方法，只有这一种成功了：12345678910111213141516void CGetWebDlg::OnLvnItemchangedList1(NMHDR *pNMHDR, LRESULT *pResult)&#123; LPNMLISTVIEW pNMLV = reinterpret_cast&lt;LPNMLISTVIEW&gt;(pNMHDR); // TODO: 在此添加控件通知处理程序代码// m_edit.SetWindowText(\"\");// int index = m_list.GetNextItem(-1, LVNI_ALL | LVNI_SELECTED);// Blog *pStructure = (Blog*)m_list.GetItemData(index);// m_edit.SetWindowText(pStructure-&gt;article); if (pNMLV-&gt;uNewState == (LVIS_SELECTED | LVIS_FOCUSED)) &#123; m_edit.SetWindowText(\"\"); Blog *pStructure = (Blog*)m_list.GetItemData(pNMLV-&gt;iItem); m_edit.SetWindowText(pStructure-&gt;article); &#125; *pResult = 0;&#125; 实现列表和编辑框交互后，可以说这已经是一个可以完整运行的程序了，V1.0版本出炉。实测解析时间：1分41秒能够成功获取该博客111篇文章，能够正确显示正文（包括清晰显示代码）。现在的运行图： V1.0 该版本未添加多线程、未和数据库关联。 V2.0实现数据库操作 使用sqlite数据库下载导入官网下载sqliteSource Code sqlite-amalgamation-3200000.zip 有三个东西 shell.c sqlite3.c sqlite3.h根据VS2010下SQLite3生成lib库文件 文章方法生成sqlite3.lib Precompiled Binaries for Windows sqlite-dll-win32-x86-3200000.zip 有一个所需 sqlite3.dll 将lib和dll放入项目工程里，在.cpp开头加上12#include \"sqlite3.h\"#pragma comment(lib,\"sqlite3.lib\") 保存至sqlite数据库12345678910111213141516171819202122232425262728293031323334353637383940int CGetWebDlg::Database(std::vector&lt;Blog*&gt; &amp;vecBlog)&#123; sqlite3 * pDB; char* errMsg; // 连接SQLite数据库 int res = sqlite3_open(\"test.db\", &amp;pDB); if (res != SQLITE_OK) &#123; MessageBox(_T(\"数据库打开失败，请检查后再操作！\"), NULL, MB_ICONSTOP); sqlite3_close(pDB); return -1; &#125; // 创建表 string strSQL = \"create table blog (title text, article text);\"; res = sqlite3_exec(pDB, strSQL.c_str(), 0, 0, &amp;errMsg); if (res != SQLITE_OK) &#123; MessageBox(_T(\"数据库打开失败，请检查后再操作！\"), NULL, MB_ICONSTOP); //return -1; &#125; // 插入数据 vector&lt;Blog*&gt;::iterator iter; for (iter = vecBlog.begin(); iter != vecBlog.end(); iter++) &#123; CString cstrTitle = (*iter)-&gt;title; CString cstrArticle = (*iter)-&gt;article; cstrTitle = ConvertGBKToUtf8(cstrTitle); cstrArticle = ConvertGBKToUtf8(cstrArticle); char *p1 = cstrTitle.GetBuffer(cstrTitle.GetLength() + 1); cstrTitle.ReleaseBuffer(); char *p2 = cstrArticle.GetBuffer(cstrArticle.GetLength() + 1); cstrArticle.ReleaseBuffer(); char *strSQL = sqlite3_mprintf(\"INSERT INTO blog VALUES('%q','%q')\", p1, p2); sqlite3_exec(pDB, strSQL, 0, 0, &amp;errMsg); &#125;&#125; 当然，也可以事先把数据库和表创建好…… 创建数据库和表 因为sqlite数据库是UTF-8格式存储，于是，需要一个转换函数： 123456789101112131415161718CString ConvertUtf8ToGBK(CString &amp;strUtf8)&#123; int len=MultiByteToWideChar(CP_UTF8, 0, (LPCTSTR)strUtf8, -1, NULL,0); unsigned short * wszGBK = new unsigned short[len+1]; memset(wszGBK, 0, len * 2 + 2); MultiByteToWideChar(CP_UTF8, 0, (LPCTSTR)strUtf8, -1, (LPWSTR)wszGBK, len); len = WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)wszGBK, -1, NULL, 0, NULL, NULL); char *szGBK=new char[len + 1]; memset(szGBK, 0, len + 1); WideCharToMultiByte (CP_ACP, 0, (LPCWSTR)wszGBK, -1, szGBK, len, NULL,NULL); strUtf8 = szGBK; delete[] szGBK; delete[] wszGBK; return strUtf8;&#125; 出现的问题 如图，数据少时并不会出现。 Q1 Q2 2.好像是运行了脚本 Q3 据查将“script”修改成别的字符便不会运行脚本，并没尝试成功。 效果下载了一个SQLiteStudio可视化管理工具。可见数据已成功保存至数据库。 sqlite 从sqlite数据库读取数据新建工程。主要用到该函数：123456789int sqlite3_get_table( sqlite3 *db, /* An open database */ const char *zSql, /* SQL to be evaluated */ char ***pazResult, /* Results of the query */ int *pnRow, /* Number of result rows written here */ int *pnColumn, /* Number of result columns written here */ char **pzErrmsg /* Error msg written here */);void sqlite3_free_table(char **result); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void CGetDataFromSqliteDlg::OnBnClickedBtnreaddata()&#123; // TODO: 在此添加控件通知处理程序代码 sqlite3 * pDB; char* errMsg; // 连接SQLite数据库 int res = sqlite3_open(\"test.db\", &amp;pDB); if (res != SQLITE_OK)&#123; MessageBox(_T(\"数据库打开失败，请检查后再操作！\"), NULL, MB_ICONSTOP); sqlite3_close(pDB); &#125; string strSql = \"select * from blog\"; char** pResult; int nRow; int nCol; int nResult; nResult = sqlite3_get_table(pDB, strSql.c_str(), &amp;pResult, &amp;nRow, &amp;nCol, &amp;errMsg); if (nResult != SQLITE_OK) &#123; sqlite3_close(pDB); cout &lt;&lt; errMsg &lt;&lt; endl; sqlite3_free(errMsg); &#125; std::vector&lt;Blog*&gt;vecBlog; string strOut; int nIndex = 2; for (int i = 0; i &lt; nRow; i++) &#123; Blog* blog = new Blog; string tempTitle = pResult[nIndex]; string tempArticle = pResult[nIndex + 1]; CString number; number.Format(\"%d\", i + 1); m_list.InsertItem(nRow, \"\"); CString strTitle(tempTitle.c_str()); CString strArticle(tempArticle.c_str()); ConvertUtf8ToGBK(strTitle); ConvertUtf8ToGBK(strArticle); blog-&gt;title = strTitle; blog-&gt;article = strArticle; vecBlog.push_back(blog); m_list.SetItemText(i, 0, number); m_list.SetItemText(i, 1, strTitle); m_list.SetItemData(i, (DWORD_PTR)blog); nIndex = nIndex + 2; &#125; sqlite3_free_table(pResult); sqlite3_close(pDB);&#125; 同样地，注意格式转码。 成品 V1.5 V1.5成功实现从sqlite数据库读取数据并反映在列表和编辑框中。 To be continued…","raw":null,"content":null,"categories":[{"name":"软件开发","slug":"软件开发","permalink":"https://hubojing.github.io/categories/软件开发/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"},{"name":"MFC","slug":"MFC","permalink":"https://hubojing.github.io/tags/MFC/"},{"name":"爬虫","slug":"爬虫","permalink":"https://hubojing.github.io/tags/爬虫/"}]},{"title":"Socket点对点聊天+文件传输","slug":"Socket点对点聊天-文件传输","date":"2017-05-07T14:58:30.000Z","updated":"2017-05-28T14:29:34.000Z","comments":true,"path":"2017/05/07/Socket点对点聊天-文件传输/","link":"","permalink":"https://hubojing.github.io/2017/05/07/Socket点对点聊天-文件传输/","excerpt":"　Socket编程。　 ","text":"Socket编程。 socket:设计一个点对点聊天小程序。 使用原生socket api实现，即不使用MFC中的socket类，也不使用其他高级socket框架 需要先设计一套协议 有GUI界面 可互相传递文字和文件 即时反应对方的在线还是离线 初级版1.在应用程序类重载的InitInstance函数中调用AfxSocketInit()函数，加载套接字。 12345if(!AfxSocketInit())&#123; AfxMessageBox(\"加载套接字库失败！\"); return FALSE;&#125; 2.在你的对话框类中添加如下函数InitSocket()，初始化套接字 123456789101112131415161718192021222324BOOL CChatDlg::InitSocket()&#123; m_socket=socket(AF_INET,SOCK_DGRAM,0); if(INVALID_SOCKET==m_socket) &#123; MessageBox(\"套接字创建失败！\"); return FALSE; &#125; SOCKADDR_IN addrSock; addrSock.sin_family=AF_INET; addrSock.sin_port=htons(5000); addrSock.sin_addr.S_un.S_addr=htonl(INADDR_ANY); int retval; retval=bind(m_socket,(SOCKADDR*)&amp;addrSock,sizeof(SOCKADDR)); if(SOCKET_ERROR==retval) &#123; closesocket(m_socket); MessageBox(\"绑定失败!\"); return FALSE; &#125; return TRUE; &#125; 3.在对话框类的OnInitDialog()函数中调用上述InitSocket()函数，初始化套接字，同时创建一个线程接收数据： 12345RECVPARAM *pRecvParam=new RECVPARAM;pRecvParam-&gt;sock=m_socket;pRecvParam-&gt;hwnd=m_hWnd;HANDLE hThread=CreateThread(NULL,0,RecvProc,(LPVOID)pRecvParam,0,NULL);CloseHandle(hThread); 其中 12345struct RECVPARAM&#123; SOCKET sock; HWND hwnd;&#125;; 是自定义结构体 4.接收线程函数RecvProc: 1234567891011121314151617DWORD WINAPI CChatDlg::RecvProc(LPVOID lpParameter)&#123; SOCKET sock=((RECVPARAM*)lpParameter)-&gt;sock; HWND hwnd=((RECVPARAM*)lpParameter)-&gt;hwnd; delete lpParameter; SOCKADDR_IN addrFrom; int len=sizeof(SOCKADDR); char recvBuf[200]; int retval; while(TRUE) &#123; retval=recvfrom(sock,recvBuf,200,0,(SOCKADDR*)&amp;addrFrom,&amp;len); if(SOCKET_ERROR==retval) break; &#125; return 0;&#125; recvBuf中就保存了你要的数据。 初级版 中级版界面 原始界面 聊天： TCP 传文件：服务器 传文件 客户端 传文件2 显示文件传输进度： 传输过程 传输成功，可以正常打开文件。 传输成功 下线： 下线 关于： 关于 源程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075// traDlg.cpp : implementation file//#include \"stdafx.h\"#include \"tra.h\"#include \"traDlg.h\"#ifdef _DEBUG#define new DEBUG_NEW#undef THIS_FILEstatic char THIS_FILE[] = __FILE__;#endif#include &lt;dlgs.h&gt;/////////////////////////////////////////////////////////////////////////////// CAboutDlg dialog used for App Aboutclass CAboutDlg : public CDialog&#123;public: CAboutDlg(); // Dialog Data //&#123;&#123;AFX_DATA(CAboutDlg) enum &#123; IDD = IDD_ABOUTBOX &#125;; //&#125;&#125;AFX_DATA // ClassWizard generated virtual function overrides //&#123;&#123;AFX_VIRTUAL(CAboutDlg)protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV support //&#125;&#125;AFX_VIRTUAL // Implementationprotected: //&#123;&#123;AFX_MSG(CAboutDlg) //&#125;&#125;AFX_MSG DECLARE_MESSAGE_MAP()&#125;;CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)&#123; //&#123;&#123;AFX_DATA_INIT(CAboutDlg) //&#125;&#125;AFX_DATA_INIT&#125;void CAboutDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialog::DoDataExchange(pDX); //&#123;&#123;AFX_DATA_MAP(CAboutDlg) //&#125;&#125;AFX_DATA_MAP&#125;BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)//&#123;&#123;AFX_MSG_MAP(CAboutDlg)// No message handlers//&#125;&#125;AFX_MSG_MAPEND_MESSAGE_MAP()/////////////////////////////////////////////////////////////////////////////// CtraDlg dialog#define PORT 34567#define FLAG 2#define SIZEFILE 1024const int SOCK_TCP = 0; //TCP模式const int SOCK_UDP = 1; //UDP模式CWinThread *pThreadSendFile; //发送文件线程--&gt;_SendFileThreadCWinThread *pThreadSendMsg; //发送消息线程CWinThread *pThreadLisen; //监听线程--&gt;_ListenTcpThreadCWinThread *pReceiveThread; //接受线程--&gt;_ReceiveThread//////////////////////////////////////////////////////////////////////////////CtraDlg::CtraDlg(CWnd* pParent /*=NULL*/): CDialog(CtraDlg::IDD, pParent)&#123; //&#123;&#123;AFX_DATA_INIT(CtraDlg) m_MsgSend = _T(\"\"); //&#125;&#125;AFX_DATA_INIT // Note that LoadIcon does not require a subsequent DestroyIcon in Win32 m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME); m_nSockType = 0;//TCP m_WorkType = 2;//两者 m_client = 0; m_server = 0; FileWork = false; FileStop = false; StopServer = false;&#125;void CtraDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialog::DoDataExchange(pDX); //&#123;&#123;AFX_DATA_MAP(CtraDlg) DDX_Control(pDX, IDC_PROGRESS_SEND_FILE, m_Progress); DDX_Control(pDX, IDC_LIST_BOX_ADDMSG, m_AddMsgLIst); DDX_Control(pDX, IDC_IPADDRESS, m_You_IP); DDX_Text(pDX, IDC_EDIT_SENDMSG, m_MsgSend); //&#125;&#125;AFX_DATA_MAP&#125;BEGIN_MESSAGE_MAP(CtraDlg, CDialog)//&#123;&#123;AFX_MSG_MAP(CtraDlg)ON_WM_SYSCOMMAND()ON_WM_PAINT()ON_WM_QUERYDRAGICON()ON_BN_CLICKED(IDC_BUTTON_CONNECT, OnButtonConnect)ON_BN_CLICKED(IDC_BUTTON_DISCONNECT, OnButtonDisconnect)ON_BN_CLICKED(IDC_BUTTON_SEND_MSG, OnButtonSendMsg)ON_BN_CLICKED(IDC_BUTTON_SEND_FILE, OnButtonSendFile)ON_BN_CLICKED(IDC_BUTTON_CLEAR, OnButtonClear)ON_BN_CLICKED(IDC_RADIO_TCP, OnRadioTcp)ON_BN_CLICKED(IDC_RADIO_UDP, OnRadioUdp)ON_BN_CLICKED(IDC_RADIO_SERVER, OnRadioServer)ON_BN_CLICKED(IDC_RADIO_CLIENT, OnRadioClient)ON_BN_CLICKED(IDC_RADIO_BOTH, OnRadioBoth)ON_BN_CLICKED(IDC_BUTTON_STOP_FILE, OnButtonStopFile)ON_MESSAGE(WM_KSEND,OnKSend)//ON_BN_CLICKED(IDC_BUTTON_CAPUTER, OnButtonCaputer)//&#125;&#125;AFX_MSG_MAPEND_MESSAGE_MAP()/////////////////////////////////////////////////////////////////////////////// CtraDlg message handlersBOOL CtraDlg::OnInitDialog()&#123; CDialog::OnInitDialog(); // Add \"About...\" menu item to system menu. // IDM_ABOUTBOX must be in the system command range. ASSERT((IDM_ABOUTBOX &amp; 0xFFF0) == IDM_ABOUTBOX); ASSERT(IDM_ABOUTBOX &lt; 0xF000); CMenu* pSysMenu = GetSystemMenu(FALSE); if (pSysMenu != NULL) &#123; CString strAboutMenu; strAboutMenu.LoadString(IDS_ABOUTBOX); if (!strAboutMenu.IsEmpty()) &#123; pSysMenu-&gt;AppendMenu(MF_SEPARATOR); pSysMenu-&gt;AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu); &#125; &#125; // Set the icon for this dialog. The framework does this automatically // when the application's main window is not a dialog SetIcon(m_hIcon, TRUE); // Set big icon SetIcon(m_hIcon, FALSE); // Set small icon // TODO: Add extra initialization here ///////////////////////////////////////////////////////// CString strLocalName; GetLocalHostName(strLocalName); CString strLocalIP; GetIpAddress(strLocalName,strLocalIP); m_You_IP.SetWindowText(\"127.0.0.1\"); //设置默认IP ///////////////////////////////////////////////////////// ((CButton*)GetDlgItem(IDC_RADIO_BOTH))-&gt;SetCheck(BST_CHECKED);//默认为服务器、客户端一体 SetWindowText(\"博靖牌聊天+文件传输小工具\"); GetDlgItem(IDC_BUTTON_CONNECT)-&gt;SetWindowText(\"启动\"); GetDlgItem(IDC_BUTTON_DISCONNECT)-&gt;SetWindowText(\"关闭\"); //GetDlgItem(IDC_BUTTON_CAPUTER)-&gt;EnableWindow(false);//默认为不可用 ((CButton*)GetDlgItem(IDC_RADIO_TCP))-&gt;SetCheck(BST_CHECKED);//默认为TCP GetDlgItem(IDC_BUTTON_SEND_MSG)-&gt;EnableWindow(false);//发送消息不可用 GetDlgItem(IDC_BUTTON_SEND_FILE)-&gt;EnableWindow(false);//发送文件不可用 GetDlgItem(IDC_BUTTON_CLEAR)-&gt;EnableWindow(false);//清除不可用 GetDlgItem(IDC_BUTTON_DISCONNECT)-&gt;EnableWindow(false);//断开连接不可用 GetDlgItem(IDC_PROGRESS_SEND_FILE)-&gt;ShowWindow(SW_HIDE); return TRUE; // return TRUE unless you set the focus to a control&#125;void CtraDlg::OnSysCommand(UINT nID, LPARAM lParam)&#123; if ((nID &amp; 0xFFF0) == IDM_ABOUTBOX) &#123; CAboutDlg dlgAbout; dlgAbout.DoModal(); &#125; else &#123; CDialog::OnSysCommand(nID, lParam); &#125;&#125;// If you add a minimize button to your dialog, you will need the code below// to draw the icon. For MFC applications using the document/view model,// this is automatically done for you by the framework.void CtraDlg::OnPaint() &#123; if (IsIconic()) &#123; CPaintDC dc(this); // device context for painting SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0); // Center icon in client rectangle int cxIcon = GetSystemMetrics(SM_CXICON); int cyIcon = GetSystemMetrics(SM_CYICON); CRect rect; GetClientRect(&amp;rect); int x = (rect.Width() - cxIcon + 1) / 2; int y = (rect.Height() - cyIcon + 1) / 2; // Draw the icon dc.DrawIcon(x, y, m_hIcon); &#125; else &#123; CDialog::OnPaint(); &#125;&#125;// The system calls this to obtain the cursor to display while the user drags// the minimized window.HCURSOR CtraDlg::OnQueryDragIcon()&#123; return (HCURSOR) m_hIcon;&#125;/**************************************线程************************************************//******************************服务器线程开始***********************************************///TCP监听线程UINT _ListenTcpThread(LPVOID lparam)&#123; CtraDlg *pDlg=(CtraDlg *)lparam; if (pDlg-&gt;StopServer==true) &#123; return -1; &#125; CSocket sockSrvr; pDlg-&gt;m_Potr = PORT+pDlg-&gt;m_server;//保存当前使用端口，用于关闭 int createSucceed=sockSrvr.Create(pDlg-&gt;m_Potr); if (createSucceed == 0) &#123; AfxMessageBox(\"ListenTcpThread Create错误!\"+pDlg-&gt;GetError(GetLastError())); return -1; &#125; int listenSucceed=sockSrvr.Listen(); //开始监听 if(listenSucceed==0) &#123; AfxMessageBox(\"ListenTcpThread Listen错误!\"+pDlg-&gt;GetError(GetLastError())); return -1; &#125; CSocket recSo; SOCKADDR_IN client; int iAddrSize=sizeof(client); int acceptSucceed=sockSrvr.Accept(recSo,(SOCKADDR *)&amp;client,&amp;iAddrSize); //接受连接并取得对方IP if (acceptSucceed==0) &#123; AfxMessageBox(\"ListenTcpThread Accept错误!\"+pDlg-&gt;GetError(GetLastError())); return -1; &#125; sockSrvr.Close(); char flag[FLAG] = &#123;0&#125;; if (recSo.Receive(flag,FLAG) != 2) &#123; return -1; &#125; pDlg-&gt;m_type=flag[0]; if (pDlg-&gt;m_type=='D') &#123; return 0; &#125; pThreadLisen=::AfxBeginThread(_ListenTcpThread,pDlg); pDlg-&gt;ReceiveFileMsg(recSo,client); return 0;&#125;UINT _UDPThread(LPVOID lparam) //UDP接受信息线程开始&#123; CtraDlg *pDlg=(CtraDlg *)lparam; if (pDlg-&gt;StopServer == true) &#123; return -1; &#125; CSocket sockSrvrUdp; sockSrvrUdp.Create(PORT+pDlg-&gt;m_client,SOCK_DGRAM); char buff[100] = &#123;0&#125;; int ret=0; CString ipStr; CString msg; UINT port; for(;;) &#123; ret=sockSrvrUdp.ReceiveFrom(buff,100,ipStr,port);//IP和port均为返回值 if (buff[0]=='D') &#123; return 0; &#125; if (ret==SOCKET_ERROR) &#123; break; &#125; msg.Format(buff); pDlg-&gt;AddMsgList(ipStr,msg); &#125; sockSrvrUdp.Close(); return 0;&#125;//服务器线程结束/*********************************************客户端线程开始*****************************************************///发送文件线程UINT _SendFileThread(LPVOID lparam)&#123; CtraDlg *pDlg = (CtraDlg *)lparam; if (pDlg-&gt;StopServer == true) &#123; return -1; &#125; CSocket sockClient; sockClient.Create(); CString ip; pDlg-&gt;m_You_IP.GetWindowText(ip); sockClient.Connect(ip, PORT+pDlg-&gt;m_client); //首先发送标记F为文件,2 int end = 0; end = sockClient.Send(\"F\", FLAG); //发送标志是否成功 if (end == SOCKET_ERROR) &#123; AfxMessageBox(\"_SendFileThread Send错误!\"+pDlg-&gt;GetError(GetLastError())); return -1; &#125; else if (end != 2) &#123; AfxMessageBox(\"文件头错误！\"); return -1; &#125; /////////////////////////////////////////////////////////////////// CFile myFile; FILEINFO myFileInfo; if (!myFile.Open(pDlg-&gt;m_fileName, CFile::modeRead | CFile::typeBinary)) &#123; return -1; &#125; myFileInfo.fileLength=myFile.GetLength(); //得到文件大小 strcpy(myFileInfo.fileName,myFile.GetFileName());//得到文件名称 sockClient.Send(&amp;myFileInfo,sizeof(myFileInfo)); //发送文件信息 pDlg-&gt;m_Progress.SetRange32(0, myFileInfo.fileLength); myFile.Seek(0, CFile::begin); char m_buf[SIZEFILE] = &#123;0&#125;; CString strError; int num = 0; end = 0; int temp = 0; pDlg-&gt;GetDlgItem(IDC_BUTTON_STOP_FILE)-&gt;EnableWindow(true); for (;;) &#123; if (pDlg-&gt;FileWork == false) &#123; pDlg-&gt;FileWork = true; pDlg-&gt;GetDlgItem(IDCANCEL)-&gt;EnableWindow(false); pDlg-&gt;GetDlgItem(IDC_BUTTON_DISCONNECT)-&gt;EnableWindow(false); &#125; num = myFile.Read(m_buf, SIZEFILE); if (num == 0) &#123; break; &#125; end = sockClient.Send(m_buf, num); temp += end; pDlg-&gt;m_Progress.SetPos(temp); if (pDlg-&gt;FileStop == true) &#123; pDlg-&gt;FileStop = false; pDlg-&gt;FileWork = false; break; &#125; if (end == SOCKET_ERROR) &#123; AfxMessageBox(\"_SendFileThread Send错误!\"+pDlg-&gt;GetError(GetLastError())); break; &#125; &#125; pDlg-&gt;m_Progress.SetPos(0); CString strLocalName; pDlg-&gt;GetLocalHostName(strLocalName); CString strLocalIP; pDlg-&gt;GetIpAddress(strLocalName,strLocalIP); if(temp == myFileInfo.fileLength) &#123; pDlg-&gt;AddMsgList(strLocalName, \"文件发送成功！\"); &#125; else &#123; pDlg-&gt;AddMsgList(strLocalName, \"文件发送失败！\"); &#125; myFile.Close(); sockClient.Close(); pDlg-&gt;FileWork = false; pDlg-&gt;GetDlgItem(IDC_PROGRESS_SEND_FILE)-&gt;ShowWindow(SW_HIDE); pDlg-&gt;GetDlgItem(IDC_BUTTON_STOP_FILE)-&gt;EnableWindow(false); pDlg-&gt;GetDlgItem(IDCANCEL)-&gt;EnableWindow(true); pDlg-&gt;GetDlgItem(IDC_BUTTON_DISCONNECT)-&gt;EnableWindow(true); return 0;&#125;UINT _SendMsgThread(LPVOID lparam) //TCP发送信息线程&#123; CtraDlg *pDlg=(CtraDlg *)lparam; if (pDlg-&gt;StopServer == true) &#123; return -1; &#125; CSocket sockClient; sockClient.Create(); CString ip,strError; pDlg-&gt;m_You_IP.GetWindowText(ip); int conn = sockClient.Connect(ip, PORT+pDlg-&gt;m_client); if (conn == 0) &#123; AfxMessageBox(\"_SendMsgThread Connect错误!\"+pDlg-&gt;GetError(GetLastError())); sockClient.ShutDown(2); sockClient.Close(); AfxEndThread(1L); return 0; &#125; //首先发送标记M为信息,2 int end = 0; end = sockClient.Send(\"M\",FLAG); if(end == SOCKET_ERROR) &#123; AfxMessageBox(\"_SendMsgThread Send错误!\"+pDlg-&gt;GetError(GetLastError())); return -1; &#125; else if(end != 2) &#123; AfxMessageBox(\"消息头错误！\"); return -1; &#125; CString strMsg = pDlg-&gt;m_MsgSend; end = sockClient.Send(strMsg,strMsg.GetLength()); if (end == SOCKET_ERROR) &#123; AfxMessageBox(\"_SendMsgThread Send错误!\"+pDlg-&gt;GetError(GetLastError())); return -1; &#125; CString strLocalName; pDlg-&gt;GetLocalHostName(strLocalName); CString strLocalIP; pDlg-&gt;GetIpAddress(strLocalName,strLocalIP); pDlg-&gt;AddMsgList(strLocalName,strMsg); int i=0; sockClient.Close(); return 0;&#125;///////////////////////////////////////////////////////////////////UINT _SendMsgUdpThread(LPVOID lparam) //UDP发送信息&#123; CtraDlg *pDlg = (CtraDlg *)lparam; if (pDlg-&gt;StopServer == true) &#123; return -1; &#125; CSocket sockClientUdp; pDlg-&gt;m_type = PORT+pDlg-&gt;m_client+10; sockClientUdp.Create(pDlg-&gt;m_type, SOCK_DGRAM); CString strMsg = pDlg-&gt;m_MsgSend; int ret = 0; CString ipStr; pDlg-&gt;m_You_IP.GetWindowText(ipStr); UINT port = PORT+pDlg-&gt;m_server; ret=sockClientUdp.SendTo(strMsg, strMsg.GetLength(), port, ipStr); if (ret == SOCKET_ERROR) &#123; DWORD error = GetLastError(); &#125; CString strLocalName; pDlg-&gt;GetLocalHostName(strLocalName); CString strLocalIP; pDlg-&gt;GetIpAddress(strLocalName, strLocalIP); pDlg-&gt;AddMsgList(strLocalName, strMsg); sockClientUdp.Close(); return 0; &#125;/************************************客户端线程结束**********************************//*************************************函数****************************************/int CtraDlg::ReceiveFileMsg(CSocket &amp;recSo,SOCKADDR_IN &amp;client)//接受函数&#123; if (m_type == 'F') //文件 &#123; SaveYouFile(recSo, client); &#125; else if (m_type == 'M') //信息 &#123; char buff[100] = &#123;0&#125;; CString msg; int ret = 0; for (;;) &#123; ret = recSo.Receive(buff,100); if (ret == 0) &#123; break; &#125; msg += buff; &#125; CString strOut,strIn; m_You_IP.GetWindowText(strIn); GetNamebyAddress(strIn,strOut); CString youName; // youName.Format(inet_ntoa(client.sin_addr)); // CString str = youName+\"&lt;-\"+strOut; CString str = strOut; AddMsgList(str, msg); &#125; recSo.Close(); return 0;&#125;int CtraDlg::SaveYouFile(CSocket &amp;recSo, SOCKADDR_IN &amp;client)//接受文件&#123; CString fname; CFileDialog dlg(false); //另存文件 FILEINFO myFileInfo; recSo.Receive(&amp;myFileInfo, sizeof(FILEINFO)); int fileLength=myFileInfo.fileLength; CString strfileIp,strfileName,strfileLength; strfileIp.Format(inet_ntoa(client.sin_addr)); strfileName.Format(myFileInfo.fileName); strfileLength.Format(\"%f\", myFileInfo.fileLength/1024.0); CString title = \"文件\"+strfileName + \" 大小\" + strfileLength + \"KB \" + \"来自\" + strfileIp + \" 是否接受？\"; dlg.m_ofn.lpstrTitle = title;//标题条 char fileme[500] = &#123;0&#125;;//必须足够大小 strcpy(fileme, strfileName); dlg.m_ofn.lpstrFile = fileme; //文件名称 if (dlg.DoModal() == IDOK) &#123; fname = dlg.GetPathName(); //得到文件名名称、路径 GetDlgItem(IDC_PROGRESS_SEND_FILE)-&gt;ShowWindow(SW_SHOW); &#125; else &#123; GetDlgItem(IDC_PROGRESS_SEND_FILE)-&gt;ShowWindow(SW_HIDE); GetDlgItem(IDC_BUTTON_STOP_FILE)-&gt;EnableWindow(false); GetDlgItem(IDC_BUTTON_DISCONNECT)-&gt;EnableWindow(true); GetDlgItem(IDCANCEL)-&gt;EnableWindow(true); recSo.Close(); return 0; &#125; char buf[SIZEFILE] = &#123;0&#125;; CFile f(fname, CFile::modeCreate|CFile::modeWrite); //存文件 m_Progress.SetRange32(0,fileLength); int n = 0; //接受的字节数 0表示结束 int temp = 0; GetDlgItem(IDC_BUTTON_STOP_FILE)-&gt;EnableWindow(true); GetDlgItem(IDCANCEL)-&gt;EnableWindow(false); GetDlgItem(IDC_BUTTON_DISCONNECT)-&gt;EnableWindow(false); for (;;) &#123; n = recSo.Receive(buf,SIZEFILE); //接受 if (n == 0) //0表示结束 &#123; break;//接受完毕 &#125; f.Write(buf,n); temp += n; m_Progress.SetPos(temp); if (FileWork == false) &#123; FileWork = true; &#125; if (FileStop == true) &#123; FileStop = false; FileWork = false; break; &#125; &#125; f.Close(); m_Progress.SetPos(0); if (temp == fileLength) &#123; AddMsgList(inet_ntoa(client.sin_addr),\"文件接收成功！\"); &#125; else &#123; AddMsgList(inet_ntoa(client.sin_addr),\"文件接收失败！\"); &#125; FileWork = false; GetDlgItem(IDC_PROGRESS_SEND_FILE)-&gt;ShowWindow(SW_HIDE); GetDlgItem(IDC_BUTTON_STOP_FILE)-&gt;EnableWindow(false); GetDlgItem(IDCANCEL)-&gt;EnableWindow(true); GetDlgItem(IDC_BUTTON_DISCONNECT)-&gt;EnableWindow(true); return 0;&#125;/*********************************************按钮*****************************************/void CtraDlg::OnButtonConnect() //开始连接&#123; // TODO: Add your control notification handler code here CString str; m_You_IP.GetWindowText(str); CString strOut,strIn; m_You_IP.GetWindowText(strIn); if(GetNamebyAddress(strIn,strOut) == -1) &#123; GetDlgItem(IDC_BUTTON_CONNECT)-&gt;EnableWindow(true);//连接不可用 return; &#125; //m_MsgSend = \"你好\" + strOut + \"!\"; m_MsgSend =\" \"; UpdateData(false); if (m_nSockType == SOCK_TCP) &#123; pThreadLisen=::AfxBeginThread(_ListenTcpThread,this); //开始TCP线程 GetDlgItem(IDC_BUTTON_SEND_MSG)-&gt;EnableWindow(true);//发送消息可用 GetDlgItem(IDC_BUTTON_SEND_FILE)-&gt;EnableWindow(true);//文件可用 //显示上线 CString strLocalName; GetLocalHostName(strLocalName); AddMsgList(strLocalName, \"上线！\"); &#125; else &#123; pThreadLisen=::AfxBeginThread(_UDPThread,this); //开始UDP线程 GetDlgItem(IDC_BUTTON_SEND_MSG)-&gt;EnableWindow(true);//发送可用 GetDlgItem(IDC_BUTTON_SEND_FILE)-&gt;EnableWindow(false);//文件不可用 //显示上线 CString strLocalName; GetLocalHostName(strLocalName); AddMsgList(strLocalName, \"上线！\"); &#125; GetDlgItem(IDC_RADIO_TCP)-&gt;EnableWindow(false);//单选不可用 GetDlgItem(IDC_RADIO_UDP)-&gt;EnableWindow(false);//单选不可用 GetDlgItem(IDC_BUTTON_DISCONNECT)-&gt;EnableWindow(true);//断开可用 GetDlgItem(IDC_BUTTON_CONNECT)-&gt;EnableWindow(false);//连接不可用 GetDlgItem(IDC_RADIO_SERVER)-&gt;EnableWindow(false); GetDlgItem(IDC_RADIO_CLIENT)-&gt;EnableWindow(false); GetDlgItem(IDC_RADIO_BOTH)-&gt;EnableWindow(false); GetDlgItem(IDC_IPADDRESS)-&gt;EnableWindow(false); &#125;void CtraDlg::OnButtonDisconnect() //关闭&#123; // TODO: Add your control notification handler code here GetDlgItem(IDC_BUTTON_CONNECT)-&gt;EnableWindow(true); GetDlgItem(IDC_RADIO_TCP)-&gt;EnableWindow(true); ((CButton*)GetDlgItem(IDC_RADIO_UDP))-&gt;EnableWindow(true); GetDlgItem(IDC_BUTTON_DISCONNECT)-&gt;EnableWindow(false); GetDlgItem(IDC_BUTTON_SEND_MSG)-&gt;EnableWindow(false); GetDlgItem(IDC_BUTTON_SEND_FILE)-&gt;EnableWindow(false); m_AddMsgLIst.ResetContent(); GetDlgItem(IDC_BUTTON_CLEAR)-&gt;EnableWindow(false); ((CButton*)GetDlgItem(IDC_RADIO_SERVER))-&gt;EnableWindow(true); ((CButton*)GetDlgItem(IDC_RADIO_CLIENT))-&gt;EnableWindow(true); ((CButton*)GetDlgItem(IDC_RADIO_BOTH))-&gt;EnableWindow(true); GetDlgItem(IDC_IPADDRESS)-&gt;EnableWindow(true); m_AddMsgLIst.SendMessage(LB_SETHORIZONTALEXTENT,0,0);/**********************************************发送结束***********************************************/ if(m_nSockType == SOCK_TCP) &#123; DWORD dwStatus; if (pThreadLisen != NULL) &#123; if(::GetExitCodeThread(pThreadLisen-&gt;m_hThread, &amp;dwStatus)==0) &#123; int errror = GetLastError(); return; &#125; if (dwStatus == STILL_ACTIVE) &#123; CSocket sockClient; sockClient.Create(); CString ip,strError; ip=\"127.0.0.1\"; int conn = sockClient.Connect(ip, m_Potr); if (conn == 0) &#123; AfxMessageBox(\"关闭错误!\"+GetError(GetLastError())); sockClient.ShutDown(2); sockClient.Close(); return; &#125; sockClient.Send(\"D\",FLAG); //结束 &#125; else &#123; delete pThreadLisen; pThreadLisen = NULL; &#125; &#125; &#125; else &#123; CSocket sockClientUdp; int succeedCreate = sockClientUdp.Create(m_type, SOCK_DGRAM); CString strMsg = \"D\"; int ret = 0; CString ipStr; m_You_IP.GetWindowText(ipStr); UINT port = PORT+m_server; ret = sockClientUdp.SendTo(strMsg, 1, port, ipStr); &#125; //显示下线 CString strLocalName; GetLocalHostName(strLocalName); AddMsgList(strLocalName, \"下线！\");&#125;void CtraDlg::OnButtonSendMsg() //发送消息&#123; // TODO: Add your control notification handler code here UpdateData(true); if (m_MsgSend.GetLength() == 0) &#123; return; &#125; if (m_nSockType == SOCK_TCP) &#123; ::AfxBeginThread(_SendMsgThread, this); &#125; else &#123; ::AfxBeginThread(_SendMsgUdpThread, this); &#125; SetDlgItemText(IDC_EDIT_SENDMSG, \"\");&#125;void CtraDlg::OnButtonSendFile() //发送文件&#123; // TODO: Add your control notification handler code here CFileDialog dlg(true); CString ip; m_You_IP.GetWindowText(ip); CString title = \"文件发往\" + ip + \"请选择\"; dlg.m_ofn.lpstrTitle = title;//标题条 if (dlg.DoModal() == IDOK) &#123; m_fileName = dlg.GetPathName(); GetDlgItem(IDC_PROGRESS_SEND_FILE)-&gt;ShowWindow(SW_SHOW); pThreadSendFile=::AfxBeginThread(_SendFileThread, this); //开始传送文件线程 &#125; &#125;void CtraDlg::AddMsgList(CString IP,CString str) //添加信息于LISTBOX 控件中&#123; SYSTEMTIME tm; GetLocalTime(&amp;tm); CString time; time.Format(_T(\" %d:%02.2d \"), tm.wHour, tm.wMinute); m_AddMsgLIst.AddString(IP+\"(\"+time+\")\"+str); int numList = m_AddMsgLIst.GetCount()-1; GetDlgItem(IDC_BUTTON_CLEAR)-&gt;EnableWindow(true); m_AddMsgLIst.SetTopIndex(numList); m_AddMsgLIst.SetCurSel(numList); //水平滚动 int max_width = 0; CSize sz; CClientDC dc(this); for (int i = 0; i&lt;m_AddMsgLIst.GetCount(); i++) &#123; m_AddMsgLIst.GetText(i,str); sz = dc.GetTextExtent(str); if (max_width &lt; sz.cx) &#123; max_width = sz.cx; &#125; &#125; m_AddMsgLIst.SendMessage(LB_SETHORIZONTALEXTENT,max_width,0);&#125;void CtraDlg::OnButtonClear() //清除聊天内容&#123; // TODO: Add your control notification handler code here m_AddMsgLIst.ResetContent(); GetDlgItem(IDC_BUTTON_CLEAR)-&gt;EnableWindow(false); m_AddMsgLIst.SendMessage(LB_SETHORIZONTALEXTENT,0,0);&#125;void CtraDlg::OnRadioTcp() //选择TCP模式&#123; // TODO: Add your control notification handler code here m_nSockType = SOCK_TCP; CString text; if (m_WorkType== 0) &#123; text = \"服务器\"; &#125; else if (m_WorkType == 1) &#123; text = \"客户端\"; &#125; else &#123; text = \"小工具\"; &#125; SetWindowText(text + \"TCP方式\");&#125;void CtraDlg::OnRadioUdp() //选择UDP模式&#123; // TODO: Add your control notification handler code here m_nSockType = SOCK_UDP; CString text; if (m_WorkType == 0) &#123; text = \"服务器\"; &#125; else if (m_WorkType == 1) &#123; text = \"客户端\"; &#125; else &#123; text = \"小工具\"; &#125; SetWindowText(text + \"UDP方式\"); &#125;CString CtraDlg::GetError(DWORD error) //返回错误信息&#123; CString strError; switch(error) &#123; case WSANOTINITIALISED: strError = \"初始化错误\"; break; case WSAENOTCONN: strError = \"对方没有启动\"; break; case WSAEWOULDBLOCK : strError = \"对方已经关闭\"; break; case WSAECONNREFUSED: strError = \"连接的尝试被拒绝\"; break; case WSAENOTSOCK: strError = \"在一个非套接字上尝试了一个操作\"; break; case WSAEADDRINUSE: strError = \"特定的地址已在使用中\"; break; case WSAECONNRESET: strError = \"与主机的连接被关闭\"; break; default: strError = \"一般错误\"; &#125; return strError; &#125;int CtraDlg::GetLocalHostName(CString &amp;sHostName) //获得本地计算机名称&#123; char szHostName[256]; int nRetCode; nRetCode = gethostname(szHostName,sizeof(szHostName)); if(nRetCode!=0) &#123; //产生错误 sHostName = _T(\"获取不到主机名！\"); return GetLastError(); &#125; sHostName = szHostName; return 0;&#125;int CtraDlg::GetIpAddress(const CString &amp;sHostName, CString &amp;sIpAddress)//获得本地IP&#123; struct hostent FAR * lpHostEnt=gethostbyname(sHostName); if(lpHostEnt==NULL) &#123; //产生错误 sIpAddress = _T(\"\"); return GetLastError(); &#125; //获取IP LPSTR lpAddr = lpHostEnt-&gt;h_addr_list[0]; if(lpAddr) &#123; struct in_addr inAddr; memmove(&amp;inAddr, lpAddr, 4); //转换为标准格式 sIpAddress = inet_ntoa(inAddr); if (sIpAddress.IsEmpty()) &#123; sIpAddress = _T(\"获取不到IP！\"); &#125; &#125; return 0;&#125;int CtraDlg::GetNamebyAddress(const CString &amp;IpAddress,CString &amp;sYouName)//获得对方计算机名称&#123; unsigned long addr; addr = inet_addr(IpAddress); struct hostent FAR * lpHostEnt = gethostbyaddr((char *)&amp;addr, 4, AF_INET); if (lpHostEnt == NULL) &#123; //产生错误 sYouName = _T(\"\"); AfxMessageBox(\"无法连接！\");//应该取得其错误 return -1; &#125; CString name = lpHostEnt-&gt;h_name; sYouName = name; return 0;&#125;void CtraDlg::OnRadioServer() &#123; // TODO: Add your control notification handler code here CString text; if (m_nSockType == SOCK_TCP) &#123; text = \"TCP方式\"; &#125; else &#123; text = \"UDP方式\"; &#125; m_server = 1; m_client = 2; m_WorkType = 0; SetWindowText(\"服务器 \" + text); GetDlgItem(IDC_BUTTON_CONNECT)-&gt;SetWindowText(\"启动服务\"); GetDlgItem(IDC_BUTTON_DISCONNECT)-&gt;SetWindowText(\"关闭服务\"); &#125;void CtraDlg::OnRadioClient() &#123; // TODO: Add your control notification handler code here CString text; if (m_nSockType == SOCK_TCP) &#123; text = \"TCP方式\"; &#125; else &#123; text = \"UDP方式\"; &#125; m_server = 2; m_client = 1; m_WorkType = 1; SetWindowText(\"客户端 \" + text); GetDlgItem(IDC_BUTTON_CONNECT)-&gt;SetWindowText(\"连接\"); GetDlgItem(IDC_BUTTON_DISCONNECT)-&gt;SetWindowText(\"断开连接\"); &#125;void CtraDlg::OnRadioBoth() &#123; // TODO: Add your control notification handler code here CString text; if (m_nSockType == SOCK_TCP) &#123; text = \"TCP方式\"; &#125; else &#123; text = \"UDP方式\"; &#125; m_server = m_client = 0; m_WorkType = 2; SetWindowText(text); GetDlgItem(IDC_BUTTON_CONNECT)-&gt;SetWindowText(\"启动\"); GetDlgItem(IDC_BUTTON_DISCONNECT)-&gt;SetWindowText(\"关闭\");&#125;void CtraDlg::OnButtonStopFile() &#123; // TODO: Add your control notification handler code here FileStop = true; FileWork = false; GetDlgItem(IDCANCEL)-&gt;EnableWindow(true); GetDlgItem(IDC_BUTTON_DISCONNECT)-&gt;EnableWindow(true);&#125;LRESULT CtraDlg::OnKSend(WPARAM wParam,LPARAM lParam)&#123; OnButtonSendMsg(); return 0;&#125;BOOL CtraDlg::PreTranslateMessage(MSG* pMsg) &#123; // TODO: Add your specialized code here and/or call the base class if (pMsg-&gt;message == WM_KEYDOWN &amp;&amp; pMsg-&gt;wParam == VK_RETURN) &#123; if (GetFocus()-&gt;GetDlgCtrlID()==IDC_EDIT_SENDMSG || GetFocus()-&gt;GetDlgCtrlID()==IDC_BUTTON_SEND_MSG) &#123; AfxGetMainWnd()-&gt;SendMessage(WM_KSEND); return TRUE; &#125; return CDialog::PreTranslateMessage(pMsg); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// traDlg.h : header file//#if !defined(AFX_traDLG_H__F42FE5AC_E2CC_44AB_9D0A_748191BC989F__INCLUDED_)#define AFX_traDLG_H__F42FE5AC_E2CC_44AB_9D0A_748191BC989F__INCLUDED_#if _MSC_VER &gt; 1000#pragma once#endif // _MSC_VER &gt; 1000//#include \"ColorListBox.h\"/////////////////////////////////////////////////////////////////////////////// CtraDlg dialogclass CtraDlg : public CDialog&#123;// Constructionpublic: CtraDlg(CWnd* pParent = NULL); // standard constructor// Dialog Data //&#123;&#123;AFX_DATA(CtraDlg) enum &#123; IDD = IDD_tra_DIALOG &#125;; CProgressCtrl m_Progress; CListBox m_AddMsgLIst; CIPAddressCtrl m_You_IP; CString m_MsgSend; //&#125;&#125;AFX_DATA // ClassWizard generated virtual function overrides //&#123;&#123;AFX_VIRTUAL(CtraDlg) public: virtual BOOL PreTranslateMessage(MSG* pMsg); protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV support //&#125;&#125;AFX_VIRTUAL// Implementationprotected: HICON m_hIcon; // Generated message map functions //&#123;&#123;AFX_MSG(CtraDlg) virtual BOOL OnInitDialog(); afx_msg void OnSysCommand(UINT nID, LPARAM lParam); afx_msg void OnPaint(); afx_msg HCURSOR OnQueryDragIcon(); afx_msg void OnButtonConnect(); afx_msg void OnButtonDisconnect(); afx_msg void OnButtonSendMsg(); afx_msg void OnButtonSendFile(); afx_msg void OnButtonClear(); afx_msg void OnRadioTcp(); afx_msg void OnRadioUdp(); afx_msg void OnRadioServer(); afx_msg void OnRadioClient(); afx_msg void OnRadioBoth(); afx_msg void OnButtonStopFile(); afx_msg LRESULT OnKSend(WPARAM wParam,LPARAM lParam);//发送消息 //afx_msg void OnButtonCaputer(); //&#125;&#125;AFX_MSG DECLARE_MESSAGE_MAP()public: int SaveYouFile(CSocket &amp;recSo,SOCKADDR_IN &amp;client); int ReceiveFileMsg(CSocket &amp; socket,SOCKADDR_IN &amp;client); int GetIpAddress(const CString &amp; sHostName,CString &amp; sIpAddress); int GetLocalHostName(CString &amp;sHostName); CString GetError(DWORD error); int m_nSockType; //连接类型 int m_WorkType; //工作方式 server0,client1,both2 void AddMsgList(CString IP, CString str); //LISTBOX控件添加信息 int m_client, m_server; CString m_fileName; bool FileWork, FileStop, StopServer; char m_type;//接受类型/F-文件，C-抓平，D-关闭,M-消息 int m_Potr;//当前使用端口 int GetNamebyAddress(const CString &amp;IpAddress,CString &amp;sYouName);//获得对方计算机名称&#125;;struct FILEINFO&#123; int fileLength; char fileName[100];&#125;;//&#123;&#123;AFX_INSERT_LOCATION&#125;&#125;// Microsoft Visual C++ will insert additional declarations immediately before the previous line.#endif // !defined(AFX_traDLG_H__F42FE5AC_E2CC_44AB_9D0A_748191BC989F__INCLUDED_) 参考资料网上的资料，查到的大部分都是用的MFC的socket类做的…… 高级版→→→→1.基于MFC仿QQ聊天程序设计完整实例教程2.CRichEditCtrlEx支持静态表情聊天类的使用","raw":null,"content":null,"categories":[{"name":"软件开发","slug":"软件开发","permalink":"https://hubojing.github.io/categories/软件开发/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"},{"name":"MFC","slug":"MFC","permalink":"https://hubojing.github.io/tags/MFC/"}]},{"title":"四大组件之ContentProvider记录","slug":"ContentProvider记录","date":"2017-05-05T14:00:42.000Z","updated":"2017-05-05T15:05:43.000Z","comments":true,"path":"2017/05/05/ContentProvider记录/","link":"","permalink":"https://hubojing.github.io/2017/05/05/ContentProvider记录/","excerpt":"ContentProvider记录。 ","text":"ContentProvider记录。 数据存储方式： Shared Preferences 文件存储 SQLite 其他还有网络存储等 上述不可完成的任务：都只是在单独的一个应用程序之中达到一个数据的共享 ContentProvider Uri UriMatcher类 ContentProvider 使用 ContentResolver 操作 ContentProvider 中的数据：当外部应用需要对 ContentProvider 中的数据进行增删改查的时候，可以使用 ContentResolver 类来完成。 使用 Activity 提供的 getContentResolver() 方法获取 ContentResolver 对象。 ContentResolver 类提供了与 ContentProvider 类相同签名的四个方法： public Uri insert(Uri uri,ContentValues values)该方法用于往ContentProvider里面添加数据 public int delete(Uri uri,String selection,String[] selectionArgs)该方法从ContentProvider中删除数据 public int update(Uri uri,ContentValues values,String selection,String[] selectionArgs)该方法用于更新ContentProvider里面的数据 public Cursor query(Uri uri,String[] projection,String selection,String[] selectionArgs,String sortOrder)该方法用于从ContentProvider中获取数据 使用系统提供的ContentProvider查询联系人MyContentProvider.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.abc.contentproviderdemo1;import android.content.ContentProvider;import android.content.ContentValues;import android.database.Cursor;import android.net.Uri;public class MyContentProvider extends ContentProvider &#123; @Override // 在ContentProvider创建后被调用 public boolean onCreate() &#123; // TODO Auto-generated method stub return false; &#125; @Override // 根据uri查询出selection指定的条件所匹配的全部记录，并且可以指定查询哪些列 以什么方式（order）排序 public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; // TODO Auto-generated method stub return null; &#125; @Override // 返回当前uri的MIME类型，如果该URI对应的数据可能包括多条记录 // 如果该URI对应的数据只有一条记录 该MIME类型字符串 就是以vnd.android.cursor.item/开头 public String getType(Uri uri) &#123; // TODO Auto-generated method stub return null; &#125; @Override // 根据uri插入Values对应的数据 public Uri insert(Uri uri, ContentValues values) &#123; // TODO Auto-generated method stub return null; &#125; @Override // 根据Uri删除selection指定的条件所匹配的全部记录 public int delete(Uri uri, String selection, String[] selectionArgs) &#123; // TODO Auto-generated method stub return 0; &#125; @Override // 根据uri修改selection指定的条件所匹配的全部记录 public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; // TODO Auto-generated method stub return 0; &#125;&#125; MainActivity.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.abc.contentproviderdemo1;import android.app.Activity;import android.content.ContentResolver;import android.database.Cursor;import android.os.Bundle;import android.provider.ContactsContract.CommonDataKinds.Email;import android.provider.ContactsContract.CommonDataKinds.Phone;import android.provider.ContactsContract.Contacts;import android.util.Log;public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ContentResolver cr = getContentResolver(); Cursor c = cr.query(Contacts.CONTENT_URI, new String[] &#123; Contacts._ID, Contacts.DISPLAY_NAME &#125;, null, null, null); if (c != null) &#123; while (c.moveToNext()) &#123; int id = c.getInt(c.getColumnIndex(&quot;_id&quot;)); Log.i(&quot;info&quot;, &quot;_id&quot; + id); Log.i(&quot;info&quot;, &quot;name:&quot; + c.getString(c.getColumnIndex(&quot;display_name&quot;))); Cursor c1 = cr.query(Phone.CONTENT_URI, new String[] &#123; Phone.NUMBER, Phone.TYPE &#125;, Phone.CONTACT_ID + &quot;=&quot; + id, null, null); // 根据联系人ID查询出联系人的电话号码 if (c1 != null) &#123; while (c1.moveToNext()) &#123; int type = c1.getInt(c1.getColumnIndex(Phone.TYPE)); if (type == Phone.TYPE_HOME) &#123; Log.i(&quot;info&quot;, &quot;家庭电话：&quot; + c1.getString(c1.getColumnIndex(Phone.NUMBER))); &#125; else if (type == Phone.TYPE_MOBILE) &#123; Log.i(&quot;info&quot;, &quot;手机&quot; + c1.getString(c1.getColumnIndex(Phone.NUMBER))); &#125; &#125; c1.close(); &#125; // 根据联系人的ID去查询出联系人的邮箱地址 Cursor c2 = cr.query(Email.CONTENT_URI, new String[] &#123; Email.DATA, Email.TYPE &#125;, Email.CONTACT_ID + &quot;=&quot; + id, null, null); if (c2 != null) &#123; while (c2.moveToNext()) &#123; int type = c2.getInt(c2.getColumnIndex(Email.TYPE)); if (type == Email.TYPE_WORK) &#123; Log.i(&quot;info&quot;, &quot;工作邮箱：&quot; + c2.getString(c2.getColumnIndex(Email.DATA))); &#125; &#125; c2.close(); &#125; &#125; c.close(); &#125; &#125;&#125; AndroidManifest.xml注册 1&lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot;/&gt; 增加联系人MainActivity.java 1234567891011121314151617181920212223242526272829303132333435363738package com.abc.contentproviderdemo2;import android.app.Activity;import android.content.ContentResolver;import android.content.ContentUris;import android.content.ContentValues;import android.net.Uri;import android.os.Bundle;import android.provider.ContactsContract.CommonDataKinds.Phone;import android.provider.ContactsContract.CommonDataKinds.StructuredName;import android.provider.ContactsContract.Data;import android.provider.ContactsContract.RawContacts;public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ContentResolver cr = getContentResolver(); // 向联系人中插入一行数据 ContentValues values = new ContentValues(); Uri uri = cr.insert(RawContacts.CONTENT_URI, values); Long raw_contact_id = ContentUris.parseId(uri); values.clear(); values.put(StructuredName.RAW_CONTACT_ID, raw_contact_id); values.put(StructuredName.DISPLAY_NAME, &quot;胡博靖&quot;); values.put(StructuredName.MIMETYPE, StructuredName.CONTENT_ITEM_TYPE); uri = cr.insert(Data.CONTENT_URI, values); // 插入电话信息 values.clear(); values.put(Phone.RAW_CONTACT_ID, raw_contact_id); values.put(Phone.NUMBER, &quot;12345678910&quot;); values.put(Phone.MIMETYPE, Phone.CONTENT_ITEM_TYPE); uri = cr.insert(Data.CONTENT_URI, values); &#125;&#125; 在AndroidManifest.xml中注册 1&lt;uses-permission android:name=&quot;android.permission.WRITE_CONTACTS&quot;/&gt;","raw":null,"content":null,"categories":[{"name":"软件开发","slug":"软件开发","permalink":"https://hubojing.github.io/categories/软件开发/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://hubojing.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"https://hubojing.github.io/tags/Java/"}]},{"title":"四大组件之Service记录","slug":"Service记录","date":"2017-05-01T08:14:00.000Z","updated":"2017-05-03T13:44:34.000Z","comments":true,"path":"2017/05/01/Service记录/","link":"","permalink":"https://hubojing.github.io/2017/05/01/Service记录/","excerpt":"　　根据广大程序员经验，初学者请告别Eclipse，拥抱Android Studio！　　原因：　　1. 未来是Android Studio的天下（Google自己出品）。　　2. Eclipse的配置和相关安装可以磨灭初学者一半的耐心，简直是拦路虎。（比如和我一样做类似题目毕设的同学已经哭晕在厕所）　　3. 促使你换一台高配电脑。（心累，Android Studio在垃圾本上跑，几分钟编译一次，卡到怀疑人生，其实垃圾本四年前还是一条能跑lol的好本本，岁月催laptop老） ","text":"根据广大程序员经验，初学者请告别Eclipse，拥抱Android Studio！ 原因： 1. 未来是Android Studio的天下（Google自己出品）。 2. Eclipse的配置和相关安装可以磨灭初学者一半的耐心，简直是拦路虎。（比如和我一样做类似题目毕设的同学已经哭晕在厕所） 3. 促使你换一台高配电脑。（心累，Android Studio在垃圾本上跑，几分钟编译一次，卡到怀疑人生，其实垃圾本四年前还是一条能跑lol的好本本，岁月催laptop老） Android sdk文件夹到了80几G…撑爆了我的硬盘……电脑里装的软件过于多了…趁着五一大好春光（下雨）都给卸载了！包括毕设用的eclipse和各种版本的VS，以及以前用过现在用的少的各种专业软件（每一个都是10G大户）。不过我还是毅然留下了常年没有玩耍的游戏们（加起来也才80多G！相比之下，sdk里都放了些什么！）。 但毕设是要做的。 所以Android套装们需要重新下载下来，当年安装的时候，对JDK、SDK、ADT这种东西一点儿不了解，现在重新来一遍。这几天写了一些文字，但不能发上来，因为放入我的毕业论文里了。 －－－－－－－－－－－－－－－－－－－－－－－－废话终结线－－－－－－－－－－－－－－－－－－－－－－－－ Service生命周期 Service生命周期 注意 运行在主线程，不能用它做耗时的请求或动作 可在服务中开一个线程，在线程中做耗时动作 两种方式（本地服务）Start方式： 服务跟启动页没有任何联系 无法得到服务对象 Bind方式（支持数据回传）： 通过Ibinder接口实例，返回一个ServiceConnection对象给启动源。 通过ServiceConnection对象的相关方法可以得到Service对象 Start启动activity_main.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot; android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot; android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; tools:context=&quot;com.abc.service.MainActivity&quot; &gt; &lt;TextView android:id=&quot;@+id/textView1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;start:&quot; /&gt; &lt;Button android:id=&quot;@+id/start&quot; android:onClick=&quot;doClick&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;StartService&quot; /&gt; &lt;Button android:id=&quot;@+id/stop&quot; android:onClick=&quot;doClick&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;StopService&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Bind:&quot; /&gt; &lt;Button android:id=&quot;@+id/bind&quot; android:onClick=&quot;doClick&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;BindService&quot; /&gt; &lt;Button android:id=&quot;@+id/play&quot; android:onClick=&quot;doClick&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;播放&quot; /&gt; &lt;Button android:id=&quot;@+id/pause&quot; android:onClick=&quot;doClick&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;暂停&quot; /&gt; &lt;Button android:id=&quot;@+id/next&quot; android:onClick=&quot;doClick&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;下一首&quot; /&gt; &lt;Button android:id=&quot;@+id/pervious&quot; android:onClick=&quot;doClick&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;上一首&quot; /&gt; &lt;Button android:id=&quot;@+id/unbind&quot; android:onClick=&quot;doClick&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;UnBindService&quot; /&gt;&lt;/LinearLayout&gt; 如图。 样式 MainActivity.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.abc.service;import android.app.Activity;import android.content.Intent;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.view.View;public class MainActivity extends Activity &#123; Intent intent1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void doClick(View v) &#123; switch (v.getId()) &#123; case R.id.start: intent1 = new Intent(MainActivity.this, MyStartService.class); startService(intent1); break; case R.id.stop: stopService(intent1); break; &#125; &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.main, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item.getItemId(); if (id == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(item); &#125;&#125; MyStartService.java 12345678910111213141516171819202122232425262728293031323334353637package com.abc.service;import android.app.Service;import android.content.Intent;import android.os.IBinder;import android.util.Log;public class MyStartService extends Service &#123; @Override public void onCreate() &#123; // TODO Auto-generated method stub Log.i(&quot;info&quot;, &quot;Service--onCreate()&quot;); super.onCreate(); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; // TODO Auto-generated method stub Log.i(&quot;info&quot;, &quot;Service--onStartCommand()&quot;); return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; // TODO Auto-generated method stub Log.i(&quot;info&quot;, &quot;Service--onDestroy()&quot;); super.onDestroy(); &#125; @Override public IBinder onBind(Intent intent) &#123; // TODO Auto-generated method stub Log.i(&quot;info&quot;, &quot;Service--onBind()&quot;); return null; &#125;&#125; 注册 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.abc.service&quot; android:versionCode=&quot;1&quot; android:versionName=&quot;1.0&quot; &gt; &lt;uses-sdk android:minSdkVersion=&quot;14&quot; android:targetSdkVersion=&quot;25&quot; /&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@drawable/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:theme=&quot;@style/AppTheme&quot; &gt; &lt;activity android:name=&quot;.MainActivity&quot; android:label=&quot;@string/app_name&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;service android:name=&quot;com.abc.service.MyStartService&quot;&gt;&lt;/service&gt; &lt;/application&gt;&lt;/manifest&gt; 可在LogCat中看到执行情况。 Bind启动注册新类 1&lt;service android:name=&quot;com.abc.service.MyBindService&quot;&gt;&lt;/service&gt; MyBindService.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.abc.service;import android.app.Service;import android.content.Intent;import android.content.ServiceConnection;import android.os.Binder;import android.os.IBinder;import android.util.Log;public class MyBindService extends Service &#123; @Override public void onCreate() &#123; // TODO Auto-generated method stub super.onCreate(); &#125; public class MyBinder extends Binder &#123; public MyBindService getService() &#123; return MyBindService.this; &#125; &#125; @Override public IBinder onBind(Intent intent) &#123; // TODO Auto-generated method stub Log.i(&quot;info&quot;, &quot;onBind--onCreate()&quot;); return new MyBinder(); &#125; @Override public void unbindService(ServiceConnection conn) &#123; // TODO Auto-generated method stub Log.i(&quot;info&quot;, &quot;BindService--unbindService()&quot;); super.unbindService(conn); &#125; @Override public void onDestroy() &#123; // TODO Auto-generated method stub Log.i(&quot;info&quot;, &quot;BindService--onDestroy()&quot;); super.onDestroy(); &#125; public void Play() &#123; Log.i(&quot;info&quot;, &quot;播放&quot;); &#125; public void Pause() &#123; Log.i(&quot;info&quot;, &quot;暂停&quot;); &#125; public void Pervious() &#123; Log.i(&quot;info&quot;, &quot;上一首&quot;); &#125; public void next() &#123; Log.i(&quot;info&quot;, &quot;下一首&quot;); &#125;&#125; MainActivity.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.abc.service;import com.abc.service.MyBindService.MyBinder;import android.app.Activity;import android.app.Service;import android.content.ComponentName;import android.content.Intent;import android.content.ServiceConnection;import android.os.Bundle;import android.os.IBinder;import android.view.Menu;import android.view.MenuItem;import android.view.View;public class MainActivity extends Activity &#123; Intent intent1; Intent intent2; MyBindService service; ServiceConnection conn = new ServiceConnection() &#123; @Override // 当启动源跟Service的连接意外丢失的时候会调用这个方法 // 比如当Service崩溃了或者被强行杀死了 public void onServiceDisconnected(ComponentName name) &#123; // TODO Auto-generated method stub &#125; @Override // 当启动页跟Service成功连接之后将会在自动调用这个方法 public void onServiceConnected(ComponentName name, IBinder binder) &#123; // TODO Auto-generated method stub service = ((MyBinder) binder).getService(); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void doClick(View v) &#123; switch (v.getId()) &#123; case R.id.start: intent1 = new Intent(MainActivity.this, MyStartService.class); startService(intent1); break; case R.id.stop: stopService(intent1); break; case R.id.play: service.Play(); break; case R.id.pause: service.Pause(); break; case R.id.pervious: service.Pervious(); break; case R.id.next: service.next(); break; case R.id.bind: intent2 = new Intent(MainActivity.this, MyBindService.class); bindService(intent2, conn, Service.BIND_AUTO_CREATE); break; case R.id.unbind: unbindService(conn); break; &#125; &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.main, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item.getItemId(); if (id == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(item); &#125;&#125; UnBindService只能点击一次，否则会报错。 两种方法混用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.abc.service;import com.abc.service.MyBindService.MyBinder;import android.app.Activity;import android.app.Service;import android.content.ComponentName;import android.content.Intent;import android.content.ServiceConnection;import android.os.Bundle;import android.os.IBinder;import android.view.Menu;import android.view.MenuItem;import android.view.View;public class MainActivity extends Activity &#123; Intent intent1; Intent intent2; MyBindService service; ServiceConnection conn = new ServiceConnection() &#123; @Override // 当启动源跟Service的连接意外丢失的时候会调用这个方法 // 比如当Service崩溃了或者被强行杀死了 public void onServiceDisconnected(ComponentName name) &#123; // TODO Auto-generated method stub &#125; @Override // 当启动页跟Service成功连接之后将会在自动调用这个方法 public void onServiceConnected(ComponentName name, IBinder binder) &#123; // TODO Auto-generated method stub service = ((MyBinder) binder).getService(); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void doClick(View v) &#123; switch (v.getId()) &#123; case R.id.start: intent1 = new Intent(MainActivity.this, MyStartService.class); startService(intent1); break; case R.id.stop: stopService(intent1); break; case R.id.play: service.Play(); break; case R.id.pause: service.Pause(); break; case R.id.pervious: service.Pervious(); break; case R.id.next: service.next(); break; case R.id.bind: intent2 = new Intent(MainActivity.this, MyBindService.class); startService(intent2); bindService(intent2, conn, Service.BIND_AUTO_CREATE); break; case R.id.unbind: unbindService(conn); break; &#125; &#125; @Override protected void onDestroy() &#123; // TODO Auto-generated method stub stopService(intent2); unbindService(conn); super.onDestroy(); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.main, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item.getItemId(); if (id == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(item); &#125;&#125;","raw":null,"content":null,"categories":[{"name":"软件开发","slug":"软件开发","permalink":"https://hubojing.github.io/categories/软件开发/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://hubojing.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"https://hubojing.github.io/tags/Java/"}]},{"title":"MFC绘制时钟","slug":"MFC绘制时钟","date":"2017-04-23T08:14:07.000Z","updated":"2017-04-27T12:31:16.000Z","comments":true,"path":"2017/04/23/MFC绘制时钟/","link":"","permalink":"https://hubojing.github.io/2017/04/23/MFC绘制时钟/","excerpt":" 　　使用GDI接口在视图上绘制一个时钟。　　 ","text":"使用GDI接口在视图上绘制一个时钟。 GDI是Graphics Device Interface的缩写，含义是图形设备接口，它的主要任务是负责系统与绘图程序之间的信息交换，处理所有Windows程序的图形输出。 在Windows操作系统下，绝大多数具备图形界面的应用程序都离不开GDI，我们利用GDI所提供的众多函数就可以方便的在屏幕、打印机及其它输出设备上输出图形，文本等操作。GDI函数大致可分类为： 设备上下文函数(如GetDC、CreateDC、DeleteDC)、 画线函数(如LineTo、Polyline、Arc)、填充画图函数(如Ellipse、FillRect、Pie)、画图属性函数(如SetBkColor、SetBkMode、SetTextColor)、文本、字体函数(如TextOut、GetFontData)、位图函数(如SetPixel、BitBlt、StretchBlt)、坐标函数(如DPtoLP、LPtoDP、ScreenToClient、ClientToScreen)、映射函数(如SetMapMode、SetWindowExtEx、SetViewportExtEx)、元文件函数(如PlayMetaFile、SetWinMetaFileBits)、区域函数(如FillRgn、FrameRgn、InvertRgn)、路径函数(如BeginPath、EndPath、StrokeAndFillPath)、裁剪函数(如SelectClipRgn、SelectClipPath)等。 ——百度百科 最初想法：建立一个单文档工程，在OnDraw利用12CClientDC dc(this);dc.Ellipse(CRect(100,100,500,500)); 画圆，但是打开的窗口太大了。于是，想初始化窗口，在CMainFrame里的PreCreateWindow设置窗口大小：1234567891011BOOL CMainFrame::PreCreateWindow(CREATESTRUCT&amp; cs)&#123; if( !CFrameWnd::PreCreateWindow(cs) ) return FALSE; // TODO: Modify the Window class or styles here by modifying // the CREATESTRUCT cs cs.cx = 630; cs.cy = 680; return TRUE;&#125; 接下来画钟面上的格子。用MoveTo和LineTo确定线段起始点和终点。我用了一个比较蠢的方法：手算坐标！于是，产生了这样的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445void CClockView::OnDraw(CDC* pDC)&#123; CClockDoc* pDoc = GetDocument(); ASSERT_VALID(pDoc); // TODO: add draw code for native data here CClientDC dc(this); dc.Ellipse(CRect(100,100,500,500)); //上 dc.MoveTo(300,140); dc.LineTo(300,100); //下 dc.MoveTo(300,460); dc.LineTo(300,500); //左 dc.MoveTo(140,300); dc.LineTo(100,300); //右 dc.MoveTo(460,300); dc.LineTo(500,300); //第一区间第二点 dc.MoveTo(380,300-80*1.73); dc.LineTo(400,300-100*1.73); //第一区间第三点 dc.MoveTo(300+80*1.73,220); dc.LineTo(300+100*1.73,200); //第二区间第二点 dc.MoveTo(300+80*1.73,380); dc.LineTo(300+100*1.73,400); //第二区间第三点 dc.MoveTo(380,300+80*1.73); dc.LineTo(400,300+100*1.73); //第三区间第二点 dc.MoveTo(220,300+80*1.73); dc.LineTo(200,300+100*1.73); //第三区间第三点 dc.MoveTo(300-80*1.73,380); dc.LineTo(300-100*1.73,400); //第四区间第二点 dc.MoveTo(300-80*1.73,220); dc.LineTo(300-100*1.73,200); //第四区间第三点 dc.MoveTo(220,300-80*1.73); dc.LineTo(200,300-100*1.73);&#125; [连三角函数都近似等于的我……等会儿会谈优化问题] 效果是这样： 这里写图片描述 在视类添加ＷＭ_CREATE响应函数，设置一个定时器，1秒发送一次消息。12345678910int CClockView::OnCreate(LPCREATESTRUCT lpCreateStruct) &#123; if (CView::OnCreate(lpCreateStruct) == -1) return -1; // TODO: Add your specialized creation code here SetTimer(1, 1000, NULL); return 0;&#125; 因为指针是在动的，所以要及时刷新页面，在视类添加WM_TIMER响应函数：12345678void CClockView::OnTimer(UINT nIDEvent) &#123; // TODO: Add your message handler code here and/or call default InvalidateRect(NULL, TRUE); UpdateWindow(); CView::OnTimer(nIDEvent);&#125; 为了和系统时间一致，就要获取时间，在OnDraw中加入：1CTime Time = CTime::GetCurrentTime(); 接下来就是创建三个指针：12345678910111213141516171819double Radians;//时针Radians = Time.GetHour() + Time.GetMinute()/60.0 + Time.GetSecond()/3600.0;Radians *= 2 * 3.14 / 12.0;dc.MoveTo(300, 300);dc.LineTo(300 + (int)((double)100 * sin(Radians)), 300 - (int)((double)100 * cos(Radians))); //取半径的1/2//分针Radians = Time.GetMinute() + Time.GetSecond()/60;Radians *= 2 * 3.14 / 60.0;dc.MoveTo(300, 300);dc.LineTo(300 + (int)((double)150 * sin(Radians)), 300 - (int)((double)150 * cos(Radians))); //取半径的3/4//秒针Radians = Time.GetSecond();Radians *= 2 * 3.14 / 60.0;dc.MoveTo(300, 300);dc.LineTo(300 + (int)((double)190 * sin(Radians)), 300 - (int)((double)190 * cos(Radians))); //取半径的19/20 为了三角函数能用，在函数头部添加#include &quot;math.h&quot;。 这里写图片描述 美化界面：1234567BOOL CClockApp::InitInstance()&#123;… m_pMainWnd-&gt;SetWindowText(\"博靖牌时钟 V1.0\"); return TRUE;&#125; 隐藏菜单、状态栏、工具条：12345678910int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)&#123; … SetMenu(NULL); //隐藏菜单 ShowControlBar(&amp;m_wndToolBar,FALSE,FALSE); //隐藏工具条 ShowControlBar(&amp;m_wndStatusBar,FALSE,FALSE); //隐藏状态栏 return 0;&#125; 效果： 这里写图片描述 详解：InvalidateRect是一个函数，该函数向指定的窗体更新区域添加一个矩形，然后窗口客户区域的这一部分将被重新绘制。 ShowControlBar：void ShowControlBar(CControlBar* pBar,BOOL bShow,Bool bDelay);参数：pBar 指向要显示或隐含的控件条bShow 如果为TRUE ,指定控件条将显示；如果为FALSE，则隐藏。bDelay 如果为TRUE，延迟显示控件条；如果为FALSE,则立即显示说明：调用该函数显示或隐藏一个控件条。 缺点：1.不能修改指针和线条样式（例如颜色、粗细等）。2.窗口拉伸后，钟面不能随窗口拉伸。 改进版：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081void CClock2View::OnDraw(CDC* pDC)&#123; CClock2Doc* pDoc = GetDocument(); ASSERT_VALID(pDoc); // TODO: add draw code for native data here CRect r1; GetClientRect(&amp;r1); CTime Time = CTime::GetCurrentTime(); //创建画笔 CPen pen(PS_SOLID, 10, RGB(139, 115, 8)); CPen *pOldPen = pDC-&gt;SelectObject(&amp;pen); //创建钟面 pDC-&gt;Ellipse(CRect(30, 30, r1.right-30, r1.bottom-30)); CPoint pt = r1.CenterPoint(); pDC-&gt;SetTextColor(RGB(255,0,0)); CString strNumber; CSize size; double Radians; //设置钟面数字 for (int i = 1; i &lt;= 12; i++) &#123; strNumber.Format(\"%d\",i); Radians = (double)i*2*3.14/12.0; size = pDC-&gt;GetTextExtent(strNumber,strNumber.GetLength()); //计算钟点放置位置 //x = CenterX - (size.cx/2) + (int)((double)(CenterX - 20) * sin(Radians)); //y = CenterY - (size.cy/2) - (int)((double)(CenterY - 20) * cos(Radians)); double x = pt.x - (size.cx/2) + (int)((double)(pt.x - 70) * sin(Radians)); double y = pt.y - (size.cy/2) - (int)((double)(pt.y - 70) * cos(Radians)); //double x = pt.x + (double)(r1.right - 50 - pt.x) * sin(Radians); //double y = pt.y - (double)(r1.bottom - 60 - pt.y) * cos(Radians); pDC-&gt;TextOut(x, y, strNumber); &#125; //设置钟面上的格子 for (int j = 1; j &lt;= 12; j++) &#123; Radians = (double)j*2*3.14/12.0; int x = pt.x + (int)((double)(pt.x - 30) * sin(Radians)); int y = pt.y - (int)((double)(pt.y - 30) * cos(Radians)); int m = pt.x + (int)((double)(pt.x - 50) * sin(Radians)); int n = pt.y - (int)((double)(pt.y - 50) * cos(Radians)); pDC-&gt;MoveTo(m, n); pDC-&gt;LineTo(x, y); &#125; //时针 CPen HourPen(PS_SOLID, 6, RGB(255, 20, 147)); pDC-&gt;SelectObject(&amp;HourPen); Radians = Time.GetHour() + Time.GetMinute()/60.0 + Time.GetSecond()/3600.0; Radians *= 2 * 3.14 / 12.0; pDC-&gt;MoveTo(pt.x, pt.y); pDC-&gt;LineTo(pt.x + (int)((double)(pt.x/3) * sin(Radians)), pt.y - (int)((double)(pt.y/3) * cos(Radians))); //分针 CPen MinPen(PS_SOLID, 4, RGB(78, 238, 148)); pDC-&gt;SelectObject(&amp;MinPen); Radians = Time.GetMinute() + Time.GetSecond()/60; Radians *= 2 * 3.14 / 60.0; pDC-&gt;MoveTo(pt.x, pt.y); pDC-&gt;LineTo(pt.x + (int)((double)(pt.y*1/2) * sin(Radians)), pt.y - (int)((double)(pt.y*1/2) * cos(Radians))); //秒针 CPen SecPen(PS_SOLID, 2, RGB(0, 0, 205)); pDC-&gt;SelectObject(&amp;SecPen); Radians = Time.GetSecond(); Radians *= 2 * 3.14 / 60.0; pDC-&gt;MoveTo(pt.x, pt.y); pDC-&gt;LineTo(pt.x + (int)((double)(pt.x*2/3) * sin(Radians)), pt.y - (int)((double)(pt.y*2/3) * cos(Radians))); &#125; 详解：弧长公式：时针：α=l/r=(2πr/12)/r=2π/12 分针、秒针同理。GetTextExtent函数功能：使用该函数获得所选字体中指定字符串的高度和宽度函数原型一：CSize GetTextExtent(LPCTSTR lpszString, int nCount) const；参数：lpszString是字符串的指针，也可以用CString 对象nCount是指字符串的长度函数原型二： CSize GetTextExtent( const CString&amp; str) const;参数：str是一个字符串对象，包含指定的字符。返回值：以逻辑单位返回字符串的尺寸，保存在一个CSize对象中。 TextOut，函数名。该函数用当前选择的字体、背景颜色和正文颜色将一个字符串写到指定位置。 效果： 这里写图片描述 值得改进处：1.每秒刷新时整个频幕闪动较大。2.可以突出12、3、6、9的格子长度。3.调整数字的大小和字体。4.指针做的更美观，考虑用位图或图片替代。","raw":null,"content":null,"categories":[{"name":"软件开发","slug":"软件开发","permalink":"https://hubojing.github.io/categories/软件开发/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"},{"name":"MFC","slug":"MFC","permalink":"https://hubojing.github.io/tags/MFC/"}]},{"title":"折腾才是人生","slug":"折腾才是人生","date":"2017-04-20T16:02:54.000Z","updated":"2017-04-20T16:02:54.000Z","comments":true,"path":"2017/04/21/折腾才是人生/","link":"","permalink":"https://hubojing.github.io/2017/04/21/折腾才是人生/","excerpt":" 　　其实是一篇吐槽贴和一个标准的Flag。　　 ","text":"其实是一篇吐槽贴和一个标准的Flag。 虽然现在天色已深，哦，应该说是凌晨了，明天还要早起。但！我真的还是想吐槽…… 一篇文章怎么可以没有目录？ 啊？啊？啊？ 要我一篇上万字的文章怎么翻…… （于是抛弃了yilia,hueman）（认真脸：我试过给hueman加目录的，一个toc函数，明明很简单的样子……然后就把主题玩崩了，其实要还原还是可以的，只是我对没目录的怨念很深呐） 为什么每一种主题评论的格式都不能统一一下……我终于找到每换一次主题就丢评论的解决方法了……（虽然数据量有点庞大，周末看有没有时间搞定） 为什么换个主题，不蒜子计数就从头开始！（尤其是近期更换频繁）现在都打算不显示点击数（网站点击和每篇文章浏览量）了（几千的点击噢，好气）……（百度统计什么的用过，然而还是直接显示出来方便（主要是显得网站有人气哈哈哈）其实到底有几个人看，无所谓啦~） 快五月了，好愁，多说到底用什么替换？？ 另外，真的，图床贴图还没有CSDN博客上图来得方便。（比如刚才上传三十几张图，要是图床的话自己要不停复制外链，那效率可想而知。） 综上所述， 这都是自己不会写主题的后果！！！ Flag: 现在不敢说完全独立写一个主题出来（主要是时间、精力、学习工作、学习方向的问题），毕竟博客以文章质量为主，但我希望今年能修改出自己满意的样子来……","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/tags/杂谈/"}]},{"title":"MFC傻瓜式教程","slug":"MFC傻瓜式教程","date":"2017-04-13T14:26:01.000Z","updated":"2017-08-13T11:45:34.000Z","comments":true,"path":"2017/04/13/MFC傻瓜式教程/","link":"","permalink":"https://hubojing.github.io/2017/04/13/MFC傻瓜式教程/","excerpt":" \n\n\n\n　　　　本教程重操作，轻理论，为操作减负。需了解详细原理的朋友可以自行看各种书籍。　　直接上菜。","text":"本教程重操作，轻理论，为操作减负。需了解详细原理的朋友可以自行看各种书籍。 直接上菜。 MFC：Microsoft Foundation Class ，微软基础类库。 对话框对话框的创建和显示 新建MFC AppWizard(exe)工程，单文档类型。工程名：Mybole。编译运行。 新建 点击帮助-关于Mybole。这是MFC自动创建的。 关于 创建自己的对话框。点击Insert-Resource。选择Dialog，点击New。VC++自动将其标识设置为IDD_DIALOG1，并自动添加到ResourceView-Dialog项中。Dialog项下还有一个对话框资源标识：IDD_ABOUTBOX，即上一步中的“关于”对话框。 Insert Resource对话框 选中对话框本身，右键点击属性。将Caption设置为“测试”。 选择View-ClassWizard，点击create a new class，OK。出现下图，并输入下图选项。 New Class 在随后出现的MFC ClassWizard对话框上点击OK。 列表 注意：看看左侧类列表中是否添加好了CTestDlg，否则会影响后续操作。 接下来，我们希望在程序中显示这个对话窗口。 点击右侧菜单Menu，选中IDR_MAINFRAME。点击帮助旁边的虚线框。 Menu 对虚线框右键属性，修改为下图。 属性 关闭属性。点击View-ClassWizard（中文是建立类向导），选择CMyboleView，用COMMAND命令消息响应函数。如图。 COMMAND 模态对话框的创建 需要调用CDialog类的成员函数：DoModal，它能创建并显示一个模态对话框，其返回值将作为CDialog类的另一个成员函数：EndDialog的参数，后者功能是关闭模态对话框。 在FileView中选择MyboleView.cpp，编写程序。 记得在开头添加头文件 #include “testdlg.h” （头文件大小写问题，linux区分，windows不区分） 编程 显示模态对话框的具体实现代码：123456void CMyboleView::OnDialog() &#123; // TODO: Add your command handler code here CTestDlg dlg; dlg.DoModal();&#125; 编译运行，点击对话框。会发现若不确认该窗口，将无法点击其他窗口。 模态对话框1 模态对话框2 非模态对话框的创建将上面的模态对话框代码注释掉。 改为：12345678910void CMyboleView::OnDialog() &#123; // TODO: Add your command handler code here //CTestDlg dlg; //dlg.DoModal(); CTestDlg *pDlg = new CTestDlg; pDlg-&gt;Create(IDD_DIALOG1,this); pDlg-&gt;ShowWindow(SW_SHOW);&#125; 注意：需要把之前运行的对话框关掉才能编译成功。 然而，当它生命周期结束时，所保存的内存地址就丢失了，那么程序中也就无法再引用到它所指向的那块内存。于是，我们这样解决该问题。 MFC ClassWizard 注意：Message里双击添加函数或者点击add Class… void CTestDlg::PostNcDestroy(){ // TODO: Add your specialized code here and/or call the base class delete this; CDialog::PostNcDestroy();} 区别：点击确定，对话框都会消失。但是，模态对话框窗口对象被销毁了。对非模态对话框来说，只是隐藏起来了，并未被销毁。因此，若要销毁对话框，若有一个ID为IDOK的按钮，就必须重写基类的OnOK这个虚函数，并在重写的函数中调用DestroyWindow函数，完成销毁。并不要再调用基类的OnOK函数。同样地，若有一个ID为IDCANCEL的按钮，也必须重写基类的OnCancel虚函数，并在重写的函数中调用DestroyWindow函数，完成销毁。并不要再调用基类的OnCancel函数。 动态创建按钮注释掉非模态对话框代码，还原模态对话框代码。 点击ResourceView-IDD_DIALOG1，打开资源，用鼠标拖出控件面板上的Button按钮控件，对按钮右键，选择属性，设置如下。 按钮 接下来，我们实现当单击Add按钮时，在对话框中动态创建一个按钮这一功能。 为CTestDlg类添加一个私有的CButton成员变量。 点击ClassView标签页右键，如图点击。 ClassView 填入信息。 添加成员变量 添加Add按钮单击消息的响应函数。 按钮点右键，选ClassWizard（建立类向导），如图。 建立类向导 单击Edit Code，即可定位到该函数定义处。 添加一下代码：123456void CTestDlg::OnBtnAdd() &#123; // TODO: Add your control notification handler code here m_btn.Create(\"New\",BS_DEFPUSHBUTTON | WS_VISIBLE | WS_CHILD, CRect(0,0,100,100),this,123);&#125; 为避免多次点击Add出现非法操作，我们需要进行如下步骤。 为CTestDlg类增加一个私有的BOOL类型成员变量。变量类型：BOOL变量名称：m_bIsCreatedAccess: private 在TestDlg.cpp中找到构造函数，将m_bIsCreated初始为FALSE。如图所示。 这里写图片描述 或者改为如下亦可。Static BOOL bIsCreated = FALSE; 回到Add，双击它，进入代码部分，改之。12345678910111213141516void CTestDlg::OnBtnAdd() &#123; // TODO: Add your control notification handler code here if(m_bIsCreated==FALSE) &#123; m_btn.Create(\"New\",BS_DEFPUSHBUTTON | WS_VISIBLE | WS_CHILD, CRect(0,0,100,100),this,123); m_bIsCreated = TRUE; &#125; else &#123; m_btn.DestroyWindow(); m_bIsCreated = FALSE; &#125;&#125; 或者以下亦能实现。1234567891011121314void CTestDlg::OnBtnAdd() &#123; // TODO: Add your control notification handler code here if(!m_btn.m_hWnd) &#123; m_btn.Create(\"New\",BS_DEFPUSHBUTTON | WS_VISIBLE | WS_CHILD, CRect(0,0,100,100),this,123); &#125; else &#123; m_btn.DestroyWindow(); &#125;&#125; 效果： 点击Add出现New窗口，再点击就销毁。 控件的访问控件的调整用Layout-Align，Layout-Make Same Size，Layout-Space Evenly里的选项进行调整。 这里写图片描述 静态文本控件 查看三个静态文本框，它们ID相同。我们可以更改第一个静态文本框ID为IDC_NUMBER1，再打开ClassWizard，可以在ObjectIDs看到新ID。 这里写图片描述 对BN_CLICKED进行Add Function，并Edit Code: 此时运行程序点击第一个静态文本框并没有反应。这是因为：静态文本控件在默认状态下是不发送通告消息的。 为了该控件能向父窗口发送鼠标事件，我们对该文本框右键-属性，切换到styles选项卡，勾上Notify。 这里写图片描述 现在可以显示了： 点击就改变。 这里写图片描述 总结：为了使一个静态文本控件能够响应鼠标单击消息，那么需要进行两个特殊的步骤：第一步，改变它的ID；第二步，在它的属性对话框中选中Notify选项。 编辑框控件利用上面的对话框实现这样的功能：在前两个编辑框中分别输入一个数字，然后单击Add按钮，对前两个编辑框中的数字求和，并将结果显示在第三个编辑框中。 第一种方式1234567891011121314void CTestDlg::OnBtnAdd() &#123; int num1, num2, num3; char ch1[10], ch2[10], ch3[10]; GetDlgItem(IDC_EDIT1)-&gt;GetWindowText(ch1,10); GetDlgItem(IDC_EDIT2)-&gt;GetWindowText(ch2,10); num1 = atoi(ch1); num2 = atoi(ch2); num3 = num1 + num2; itoa(num3,ch3,10); GetDlgItem(IDC_EDIT3)-&gt;SetWindowText(ch3);&#125; C语言转换函数：atoi 将一个由数字组成的字符串转换为相应的数值itoa 数值转换为文本itoa函数的第三个参数表示转换的进制，数字10表示十进制。 效果： 这里写图片描述 第二种方式 代码如下：123456789101112131415161718void CTestDlg::OnBtnAdd() &#123; int num1, num2, num3; char ch1[10], ch2[10], ch3[10]; //GetDlgItem(IDC_EDIT1)-&gt;GetWindowText(ch1,10); //GetDlgItem(IDC_EDIT2)-&gt;GetWindowText(ch2,10); GetDlgItemText(IDC_EDIT1,ch1,10); GetDlgItemText(IDC_EDIT2,ch2,10); num1 = atoi(ch1); num2 = atoi(ch2); num3 = num1 + num2; itoa(num3,ch3,10); //GetDlgItem(IDC_EDIT3)-&gt;SetWindowText(ch3); SetDlgItemText(IDC_EDIT3,ch3);&#125; GetDlgItemText 将返回对话框中指定ID的控件上的文本，相当于将上面的GetDlgItem和GetWindowText这两个函数功能组合起来了。与之对应的是SetDlgItemText，用来设置对话框中指定ID的控件上的文本。 第三种方式12345678910111213141516171819202122void CTestDlg::OnBtnAdd() &#123; int num1, num2, num3; //char ch1[10], ch2[10], ch3[10]; //GetDlgItem(IDC_EDIT1)-&gt;GetWindowText(ch1,10); //GetDlgItem(IDC_EDIT2)-&gt;GetWindowText(ch2,10); //GetDlgItemText(IDC_EDIT1,ch1,10); //GetDlgItemText(IDC_EDIT2,ch2,10); num1 = GetDlgItemInt(IDC_EDIT1); num2 = GetDlgItemInt(IDC_EDIT2); //num1 = atoi(ch1); //num2 = atoi(ch2); num3 = num1 + num2; //itoa(num3,ch3,10); //GetDlgItem(IDC_EDIT3)-&gt;SetWindowText(ch3); //SetDlgItemText(IDC_EDIT3,ch3); SetDlgItemInt(IDC_EDIT3,num3);&#125; 第四种方式 将这三个编辑框分别与对话框类的三个成员变量相关联，然后通过这些成员变量来检索和设置编辑框的文本，这是最简单的访问控件的方式。打开ClassWizard对话框，切换到Member Variables选项卡，如图。 这里写图片描述 首先为IDC_EDIT1编辑框添加一个关联的成员变量，方法是在Control IDs列表中选中IDC_EDIT1，再单击Add Variable按钮，如图。 这里写图片描述 这里写图片描述 同样地，为IDC_EDIT2和IDC_EDIT3分别添加好成员变量。 接着修改代码： 123456void CTestDlg::OnBtnAdd() &#123; UpdateData(); m_num3 = m_num1 + m_num2; UpdateData(FALSE);&#125; 对编辑框控件中输入的数值设定一个范围： 打开ClassWizard-Member Variable，选中IDC_EDIT1，下方输入0和100。同样为IDC_EDIT2也设置好。 这里写图片描述 第五种方式 将编辑框控件再与一个变量相关联，代表控件本身。为IDC_EDIT1增加一个控件类型的变量：m_edit1，类别为Control。同样地，也为IDC_EDIT2和IDC_EDIT3添加。 这里写图片描述 修改代码：123456789101112131415161718void CTestDlg::OnBtnAdd() &#123; int num1, num2, num3; char ch1[10], ch2[10], ch3[10]; m_edit1.GetWindowText(ch1,10); m_edit2.GetWindowText(ch2,10); //num1 = GetDlgItemInt(IDC_EDIT1); //num2 = GetDlgItemInt(IDC_EDIT2); num1 = atoi(ch1); num2 = atoi(ch2); num3 = num1 + num2; itoa(num3,ch3,10); m_edit3.SetWindowText(ch3);&#125; 第六种方式 修改代码：123456789101112131415void CTestDlg::OnBtnAdd() &#123; int num1, num2, num3; char ch1[10], ch2[10], ch3[10]; ::SendMessage(GetDlgItem(IDC_EDIT1)-&gt;m_hWnd, WM_GETTEXT, 10, (LPARAM)ch1); ::SendMessage(m_edit2.m_hWnd, WM_GETTEXT, 10, (LPARAM)ch2); num1 = atoi(ch1); num2 = atoi(ch2); num3 = num1 + num2; itoa(num3,ch3,10); m_edit3.SendMessage(WM_SETTEXT, 0, (LPARAM)ch3);&#125; 第七种方式 修改代码：123456789101112131415void CTestDlg::OnBtnAdd() &#123; int num1, num2, num3; char ch1[10], ch2[10], ch3[10]; SendDlgItemMessage(IDC_EDIT1, WM_GETTEXT, 10, (LPARAM)ch1); SendDlgItemMessage(IDC_EDIT2, WM_GETTEXT, 10, (LPARAM)ch2); num1 = atoi(ch1); num2 = atoi(ch2); num3 = num1 + num2; itoa(num3,ch3,10); SendDlgItemMessage(IDC_EDIT3, WM_SETTEXT, 0, (LPARAM)ch3);&#125; 获得编辑框复选的内容： 在上述代码最后添加： SendDlgItemMessage(IDC_EDIT3, EM_SETSEL, 0, -1); //0,-1表示全选若1,3表示选中1-3位复选 m_edit3.SetFocus(); 效果： 这里写图片描述 总结1 GetDlgItem()-&gt;Get(Set)WindowTest()2 GetDlgItemText()/SetDlgItemText()3 GetDlgItemInt()/SetDlgItemInt()4 将控件和整型变量相关联5 将控件和控件变量相关联6 SendMessage()7 SendDlgItemMessage() 最常用是1、4、5。在利用MFC编程时，6、7用得少。 对话框伸缩功能的实现 对话框上再添加一个按钮，Caption设置为“收缩&lt;&lt;”点击ClassWizard，添加一个命令相应函数（BN_CLICKED）。具体实现代码为：123456789101112void CTestDlg::OnButton1() &#123; CString str; if(GetDlgItemText(IDC_BUTTON1,str), str == \"收缩&lt;&lt;\") &#123; SetDlgItemText(IDC_BUTTON1, \"拓展&gt;&gt;\"); &#125; else &#123; SetDlgItemText(IDC_BUTTON1, \"收缩&lt;&lt;\"); &#125;&#125; 拖动一个图像控件来划分对话框中要动态切除的部分。 这里写图片描述 修改该控件ID为IDC_SEPATATOR，styles选项卡勾上Sunken选项。 修改代码：12345678910111213141516171819202122232425262728293031323334353637void CTestDlg::OnButton1() &#123; CString str; if(GetDlgItemText(IDC_BUTTON1,str), str == \"收缩&lt;&lt;\") &#123; SetDlgItemText(IDC_BUTTON1, \"拓展&gt;&gt;\"); &#125; else &#123; SetDlgItemText(IDC_BUTTON1, \"收缩&lt;&lt;\"); &#125; static CRect rectLarge; static CRect rectSmall; CRect rect1(10,10,10,10); CRect rect2(0,0,0,0); if(rectLarge.IsRectNull()) &#123; CRect rectSeparator; GetWindowRect(&amp;rectLarge); GetDlgItem(IDC_SEPARATOR)-&gt;GetWindowRect(&amp;rectSeparator); rectSmall.left=rectLarge.left; rectSmall.top=rectLarge.top; rectSmall.right=rectLarge.right; rectSmall.bottom=rectSeparator.bottom; &#125; if(str == \"收缩&lt;&lt;\") &#123; SetWindowPos(NULL, 0, 0, rectSmall.Width(), rectSmall.Height(), SWP_NOMOVE | SWP_NOZORDER); &#125; else &#123; SetWindowPos(NULL, 0, 0, rectLarge.Width(), rectLarge.Height(), SWP_NOMOVE | SWP_NOZORDER); &#125;&#125; 效果： 这里写图片描述 点击“收缩&lt;&lt;”： 这里写图片描述 若希望隐藏分隔条，则设置属性去掉“Visible”前的勾。 输入焦点的传递 为了屏蔽掉默认的回车键关闭对话框这一功能，应该在对话框子类（此处是CTestDlg类）中重写OK按钮的消息响应函数。 首先点击OK按钮，添加鼠标单击消息响应函数。注释掉原有函数。 法一 在ClassView选项卡的CTestDlg类添加WM_INITDIALOG消息的响应函数。对类右键，选择Add Windows Message Handler，在弹出的框左侧选择WM_INITDIALOG，直接单击Add and Edit，跳转。 修改代码为：12345678910111213141516171819202122232425262728293031323334void CTestDlg::OnOK() &#123; // TODO: Add extra validation here //CDialog::OnOK();&#125;WNDPROC prevProc; LRESULT CALLBACK NewEditProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam ) &#123; if(uMsg == WM_CHAR &amp;&amp; wParam == 0x0d) &#123; ::SetFocus(GetNextWindow(hwnd,GW_HWNDNEXT)); return 1; &#125; else &#123; return prevProc(hwnd,uMsg,wParam,lParam); &#125; &#125;BOOL CTestDlg::OnInitDialog() &#123; CDialog::OnInitDialog(); prevProc=(WNDPROC)SetWindowLong(GetDlgItem(IDC_EDIT1)-&gt;m_hWnd, GWL_WNDPROC, (LONG)NewEditProc); return TRUE;&#125; 查看第一个编辑框的属性，打开styles选项卡，勾上MultiLine（多行）。即可实现焦点的传递。 法二 只需要改变一行代码：12345678910111213141516171819WNDPROC prevProc; LRESULT CALLBACK NewEditProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam ) &#123; if(uMsg == WM_CHAR &amp;&amp; wParam == 0x0d) &#123; //::SetFocus(GetNextWindow(hwnd,GW_HWNDNEXT)); SetFocus(::GetWindow(hwnd,GW_HWNDNEXT)); return 1; &#125; else &#123; return prevProc(hwnd,uMsg,wParam,lParam); &#125; &#125; 法三 编辑框属性有一个WS_TABSTOP，如果勾选了，则在对话框中按下Tab键后，输入焦点可以转移到此控件上。 修改一行代码：1234567891011121314151617181920WNDPROC prevProc; LRESULT CALLBACK NewEditProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam ) &#123; if(uMsg == WM_CHAR &amp;&amp; wParam == 0x0d) &#123; SetFocus(::GetNextDlgTabItem(::GetParent(hwnd),hwnd,FALSE)); //::SetFocus(GetNextWindow(hwnd,GW_HWNDNEXT)); //SetFocus(::GetWindow(hwnd,GW_HWNDNEXT)); return 1; &#125; else &#123; return prevProc(hwnd,uMsg,wParam,lParam); &#125; &#125; 三种方法的缺点：只修改了第一个编辑框的窗口过程，因此从第二到第三个编辑框的焦点转移无法实现，除非继续修改第二个编辑窗口。 再介绍一种方法解决这个问题。 法四 在MFC中，默认情况下，当在对话框窗口中按下回车键时，会调用对话框的默认按钮的响应函数，我们可以在此默认按钮的响应函数中把焦点依次向下传递。 首先取消第一个编辑框的MultiLine。 接着修改OnOK函数为：123456789void CTestDlg::OnOK() &#123; // TODO: Add extra validation here //GetDlgItem(IDC_EDIT1)-&gt;GetNextWindow()-&gt;SetFocus(); //GetFocus()-&gt;GetNextWindow()-&gt;SetFocus(); //GetFocus()-&gt;GetWindow(GW_HWNDNEXT)-&gt;SetFocus(); GetNextDlgTabItem(GetFocus())-&gt;SetFocus(); //CDialog::OnOK();&#125; 注释掉的部分是各种失败的尝试，各有各的bug。现在程序是正常的。 **注意：然而该屏蔽回车键的方法并非是常规做法，应该在PreTranslateMessage中进行拦截。（return TRUE即拦截）** 具体做法： 现在Testdlg.h中添加：123456789class CTestDlg : public CDialog&#123;protected: virtual BOOL PreTranslateMessage(MSG* pMsg);public: virtual void OnOK();…… 接着：1234567891011121314151617181920212223242526CTestDlg::PreTranslateMessage(MSG* pMsg)&#123; //屏蔽ESC关闭窗体 if (pMsg-&gt;message == WM_KEYDOWN &amp;&amp; pMsg-&gt;wParam == VK_ESCAPE) &#123; return TRUE; &#125; //屏蔽回车关闭窗体，但会导致回车在窗体上失效. /* if (pMsg-&gt;message == WM_KEYDOWN &amp;&amp; pMsg-&gt;wParam == VK_RETURN &amp;&amp; pMsg-&gt;wParam) &#123; return TRUE; &#125; */ else &#123; return CDialog::PreTranslateMessage(pMsg); &#125;&#125;void CTestDlg::OnOK() &#123; // TODO: Add extra validation here //CDialog::OnOK();&#125; 点击Layout-Tab order，这些序号就是各控件的Tab顺序。顺序可改变，依次点击希望的顺序控件即可。 调用顺序：当用户按下回车键时，Windows将查看对话框中是否存在指定的默认按钮，如果有，就调用该默认按钮单击消息的响应函数。如果没有，就会调用虚拟的OnOK函数，即使对话框没有包含默认的OK按钮（这个默认OK按钮的ID是IDOK）。 文件和注册表操作C语言对文件操作的支持 新建单文档类型的MFC应用程序，工程名为File，并为主菜单添加一个子菜单，名称为“文件操作”，然后为其添加两个菜单项，并分别为它们添加相应的命令响应函数（通过COMMAND），让CFileView类接收这些菜单项的命令响应。 这里写图片描述 这里写图片描述 文件的打开和写入 代码：12345void CFileView::OnFileWrite() &#123; FILE *pFile = fopen(\"1.txt\",\"w\"); fwrite(\"http://www.sunxin.org\", 1, strlen(\"http://www.sunxin.org\"), pFile); &#125; 编译后可看到文件夹中生成了1.txt，打开有一行网址。 文件的关闭 增加一行代码：123456void CFileView::OnFileWrite() &#123; FILE *pFile = fopen(\"1.txt\",\"w\"); fwrite(\"http://www.sunxin.org\", 1, strlen(\"http://www.sunxin.org\"), pFile); fclose(pFile);&#125; 文件指针定位 代码：1234567void CFileView::OnFileWrite() &#123; FILE *pFile = fopen(\"1.txt\",\"w\"); fwrite(\"http://www.sunxin.org\", 1, strlen(\"http://www.sunxin.org\"), pFile); fwrite(\"欢迎访问\", 1, strlen(\"欢迎访问\"), pFile); fclose(pFile);&#125; 显示：http://www.sunxin.org欢迎访问 将文件指针移动到文件的开始位置处： 代码：123456789void CFileView::OnFileWrite() &#123; FILE *pFile = fopen(\"1.txt\",\"w\"); fwrite(\"http://www.sunxin.org\", 1, strlen(\"http://www.sunxin.org\"), pFile); fseek(pFile, 0, SEEK_SET); fwrite(\"ftp:\", 1, strlen(\"ftp:\"),pFile); //fwrite(\"欢迎访问\", 1, strlen(\"欢迎访问\"), pFile); fclose(pFile);&#125; 显示：ftp:://www.sunxin.org 文件的读取 在OnFileRead函数中写入代码：123456789void CFileView::OnFileRead() &#123; FILE *pFile = fopen(\"1.txt\",\"r\"); char ch[100]; fread(ch, 1, 100, pFile); fclose(pFile); MessageBox(ch); &#125; 编译运行： 原因：C语言以“\\0”结束。 解决方法： 法一： 修改代码：12345678void CFileView::OnFileWrite() &#123; FILE *pFile = fopen(\"1.txt\",\"w\"); char buf[22] = \"http://www.sunxin.org\"; buf[21] = '\\0'; fwrite(buf, 1, 22, pFile); fclose(pFile);&#125; 先点击写入文件，再点击读取文件，就可以看到正确的内容。 缺点：增加了文件大小。 法二：12345678910void CFileView::OnFileRead() &#123; FILE *pFile = fopen(\"1.txt\",\"r\"); char ch[100]; memset(ch, 0, 100); fread(ch, 1, 100, pFile); fclose(pFile); MessageBox(ch); &#125; 法三： 读取文件时，不知道文件大小时的做法。12345678910111213void CFileView::OnFileRead() &#123; FILE *pFile = fopen(\"1.txt\",\"r\"); char *pBuf; fseek(pFile, 0, SEEK_END); int len=ftell(pFile); pBuf = new char[len+1]; rewind(pFile); fread(pBuf, 1, len, pFile); pBuf[len] = 0; fclose(pFile); MessageBox(pBuf);&#125; 二进制文件和文本文件 代码：1234567891011121314151617181920void CFileView::OnFileWrite() &#123; FILE *pFile = fopen(\"2.txt\", \"w\"); char ch[3]; ch[0] = 'a'; ch[1] = 10; ch[2] = 'b'; fwrite(ch, 1, 3, pFile); fclose(pFile);&#125;void CFileView::OnFileRead() &#123; FILE *pFile = fopen(\"2.txt\",\"r\"); char ch[100]; fread(ch, 1, 3, pFile); ch[3] = 0; fclose(pFile); MessageBox(ch);&#125; 效果： 文本方式：10实际上是换行符的ASCII码。 以文本方式和二进制方式读取文件是有明显的区别的。 文本方式和二进制方式 二进制方式：换行是由两个字符组成的，即ASCII码10（回车符）和13（换行符）。 写入和读取文件时要保持一致。如果采用文本方式写入，应采用文本方式读取；如果采用二进制方式写入数据，在读取时也应采用二进制方式。 面试题：给你一个整数，如：98341，将这个整数保存到文件中，要求在以记事本程序打开该文件时，显示的是：98341。 法一：1234567891011121314void CFileView::OnFileWrite() &#123; FILE *pFile = fopen(\"3.txt\", \"w\"); char ch[5]; ch[0] = 9 + 48; ch[1] = 8 + 48; ch[2] = 3 + 48; ch[3] = 4 + 48; ch[4] = 1 + 48; fwrite(ch, 1, 5, pFile); fclose(pFile);&#125; 或 1234567891011void CFileView::OnFileWrite() &#123; FILE *pFile = fopen(\"3.txt\", \"w\"); int i = 98341; char ch[5]; itoa(i, ch, 10); fwrite(ch, 1, 5, pFile); fclose(pFile);&#125; 面试题：给定一个字符串，其中既有数字字符，又有26个英文字母中的几个字符，让你判断一下哪些是数字字符。 对这种问题，实际上就是判断各字符的ASCII码，对于数字字符来说，它们的ASCII码大于等于48，小于等于57。 C++对文件操作的支持1234567891011121314151617void CFileView::OnFileWrite() &#123; ofstream ofs(\"4.txt\"); ofs.write(\"http://www.sunxin.org\",strlen(\"http://www.sunxin.org\")); ofs.close;&#125;void CFileView::OnFileRead() &#123; ifstream ifs(\"4.txt\"); char ch[100]; memset(ch, 0, 100); ifs.read(ch,100); ifs.close(); MessageBox(ch);&#125; Win32 API 对文件操作的支持文件的创建、打开和写入123456789101112131415void CFileView::OnFileWrite() &#123; //定义一个句柄变量 HANDLE hFile; //创建文件 hFile = CreateFile(\"5.txt\", GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL); //接收实际写入的字节数 DWORD dwWrites; //写入数据 WriteFile(hFile,\"http://www.sunxin.org\",strlen(\"http://www.sunxin.org\"), &amp;dwWrites, NULL); //关闭文件句柄 CloseHandle(hFile);&#125; 文件的读取123456789101112131415161718void CFileView::OnFileRead() &#123; HANDLE hFile; //打开文件 hFile = CreateFile(\"5.txt\", GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); //接收实际收到的数据 char ch[100]; //接收实际读取到的字节数 DWORD dwReads; //读取数据 ReadFile(hFile, ch, 100, &amp;dwReads, NULL); //设置字符串结束字符 ch[dwReads] = 0; //关闭打开的文件对象的句柄 CloseHandle(hFile); //显示读取到的数据 MessageBox(ch);&#125; 菜单菜单命令响应函数 新建一个单文档的MFC AppWizard(exe)工程，工程名为Menu。Build运行。 左上角点击按钮，可以让属性框始终显示，不会因为点击对话框以外的地方就消失。 去掉Pop-up弹出前的勾，将ID改为ID_TEST。给Test添加响应函数在CMainFrame中，在函数中加入 MessageBox(“MainFrame Clicked”); 效果： 这里写图片描述 菜单命令的路由程序类对菜单命令的响应顺序 响应Test 菜单项命令的顺序依次是：视类、文档类、框架类，最后才是应用程序类。 Windows消息的分类 凡是从CWnd派生的类，它们既可以接收标准消息，也可以接收命令消息和通告消息。而对于那些从CCmdTarget派生的类，则只能接收命令消息和通告消息，不能接收标准消息。本例中的文档类（CMenuDoc）和应用程序类（CWinApp），因为它们都派生于CCmdTarget类，所以它们可以接收菜单命令消息。但它们不是从CWnd类派生的，所以不能接收标准消息。 菜单命令的路由 菜单命令消息路由的具体过程：当点击某个菜单项时，最先接收到这个菜单命令消息的是框架类。框架类将把接收到的这个消息交给它的子窗口，即视类，由视类首先进行处理。视类首先根据命令消息映射机制查找自身是否对此消息进行了响应，如果响应了，就调用相应响应函数对这个消息进行处理，消息路由过程结束；如果视类没有对此命令消息做出响应，就交由文档类，文档类同样查找自身是否对这个菜单命令进行了响应，如果响应了，就由文档类的命令消息响应函数进行处理，路由过程结束。如果文档类也未做出响应，就把这个命令消息交还给视类，后者又把该消息交还给框架类。框架类查看自己是否对这个命令消息进行了响应，如果它也没有做出响应，就把这个菜单命令消息交给应用程序类，由后者来进行处理。 基本菜单操作标记菜单 运行刚才创建的Menu程序，点击查看，前面都有一个对号，这种类型就是标记菜单。在CMainFrame类的OnCreate的return语句之前添加这句代码 GetMenu()-&gt;GetSubMenu(0)-&gt;CheckMenuItem(0, MF_BYPOSITION | MF_CHECKED); 或者GetMenu()-&gt;GetSubMenu(0)-&gt;CheckMenuItem(ID_FILE_NEW, MF_BYCOMMAND | MF_CHECKED); Build并运行，可发现新建左边已添加一个复选标记。 默认菜单项 在刚才的代码下，添加 GetMenu()-&gt;GetSubMenu(0)-&gt;SetDefaultItem(1, TRUE); 或者GetMenu()-&gt;GetSubMenu(0)-&gt;SetDefaultItem(ID_FILE_OPEN, FALSE); 编译运行，会发现“打开”变成了粗体。 注意：“打印”的索引是5，不是4。计算菜单项索引时，一定要把分割栏菜单项计算在内。并且，一个子菜单只能有一个默认菜单项。 图形标记菜单 Insert-Resource-Bitmap，创建一个位图资源。如图。 这里写图片描述 为CMainFrame类添加一个CBitmap类型的成员变量：m_bitmap。 接着添加代码： CString str; str.Format(“x=%d”,y=%d”, GetSystemMetrics(SM_CXMENUCHECK),GetSystemMetrics(SM_CYMENUCHECK)); MessageBox(str); m_bitmap.LoadBitmap(IDB_BITMAP1); GetMenu()-&gt;GetSubMenu(0)-&gt;SetMenuItemBitmaps(0, MF_BYPOSITION, &amp;m_bitmap, &amp;m_bitmap); 禁用菜单项 通常把MF_GRAYED和MF_DISABLED这两个标志放在一起使用。不过这么做并不是必需的。 删除之前的代码，写入 GetMenu()-&gt;GetSubMenu(0)-&gt;EnableMenuItem(1, MF_BYPOSITION | MF_DISABLED | MF_GRAYED); 打开“文件”子菜单，发现“打开”菜单栏变灰，点击不起作用。 移除和装载菜单 再添加一行代码： SetMenu(NULL); 此时菜单栏被移除了。 再添加几行代码：CMenu menu; menu.LoadMenu(IDR_MAINFRAME); SetMenu(&amp;menu); menu.Detach(); 此时菜单栏又装载了。1234567891011121314151617181920CMenu menu;menu.CreateMenu();GetMenu()-&gt;AppendMenu(MF_POPUP, (UINT)menu.m_hMenu, \"Test1\");menu.AppendMenu(MF_STRING, 111, \"Hello\");menu.AppendMenu(MF_STRING, 112, \"Bye\");menu.AppendMenu(MF_STRING, 113, \"Mybole\");menu.Detach();CMenu menu1;menu1.CreateMenu();GetMenu()-&gt;InsertMenu(2, MF_POPUP | MF_BYPOSITION, (UINT)menu1. m_hMenu,\"Test\");menu1.Detach();GetMenu()-&gt;GetSubMenu(2)-&gt;AppendMenu(MF_STRING, 118, \"Welcome\");GetMenu()-&gt;GetSubMenu(0)-&gt;AppendMenu(MF_STRING, 114, \"Welcome\");GetMenu()-&gt;GetSubMenu(0)-&gt;InsertMenu(ID_FILE_OPEN, MF_BYCOMMAND | MF_STRING, 115, \"VC编程\"); MFC菜单命令更新机制 MFC命令更新机制：当要显示菜单时，操作系统发出WM_INITMENUPOPOP消息，然后由程序窗口的基类如CFrameWnd接管，它会创建一个CCmdUI对象，并与程序的第一个菜单项相关联，调用该对象的一个成员函数DoUpdate()。这个函数发出CN_UPDATE_COMMAND_UI消息，这条消息带有一个指向CCmdUI对象的指针。这时，系统会判断是否存在一个ON_UPDATE_COMMAND_UI宏去捕获这个菜单项消息。如果找到这样一个宏，就调用相应的消息响应函数进行处理，在这个函数中，可以利用传递过来的CCmdUI对象去调用相应的函数，使该菜单项可以使用，或禁用该菜单项。当更新完第一个菜单项后，同一个CCmdUI对象就设置为与第二个菜单项相关联，依此顺序进行，直到完成所有菜单项的处理。 添加代码：12345void CMainFrame::OnUpdateEditCut(CCmdUI* pCmdUI) &#123; // TODO: Add your command update UI handler code here pCmdUI-&gt;Enable();&#125; 编辑-剪切 可用了。 如果要把工具栏上的一个工具按钮与菜单栏中的某个菜单项相关联，只要将它们的ID设置为同一个标识就可以了。 如果希望禁用文件-新建，为ID_FILE_NEW添加UPDATE_COMMAND_UI消息响应函数。 代码如下：123456void CMainFrame::OnUpdateFileNew(CCmdUI* pCmdUI) &#123; // TODO: Add your command update UI handler code here pCmdUI-&gt;Enable(FALSE);&#125; 或者12345void CMainFrame::OnUpdateFileNew(CCmdUI* pCmdUI) &#123; if (2 == pCmdUI-&gt;m_nIndex) pCmdUI-&gt;Enable();&#125; 快捷菜单 1. 新增一个新的菜单资源。点开，顶级菜单设置任意的文本，如abc。添加两个菜单项： 显示 IDM_SHOW 退出 IDM_EXIT 2. 给CMenuView类添加WM_RBUTTONDOWN消息响应函数。12345678910void CMenu2View::OnRButtonDown(UINT nFlags, CPoint point) &#123; CMenu menu; menu.LoadMenu(IDR_MENU1); CMenu* pPopup = menu.GetSubMenu(0); ClientToScreen(&amp;point); pPopup-&gt;TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this); CView::OnRButtonDown(nFlags, point);&#125; 效果： 3.对“显示”右键ClassWizard，可以取消创建新类的询问。分别为CMainFrame类和CMenuView类添加一个响应。 代码：1234void CMenu2View::OnShow() &#123; MessageBox(\"View show\"); &#125; 1234void CMainFrame::OnShow() &#123; MessageBox(\"Main show\");&#125; 结果是显示“View show”。说明只有视类才能对快捷菜单项命令做出响应。若想让CMainView类对此快捷菜单项进行响应的话，修改代码：1234567891011void CMenu2View::OnRButtonDown(UINT nFlags, CPoint point) &#123; CMenu menu; menu.LoadMenu(IDR_MENU1); CMenu* pPopup = menu.GetSubMenu(0); ClientToScreen(&amp;point); //pPopup-&gt;TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this); pPopup-&gt;TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, GetParent()); CView::OnRButtonDown(nFlags, point);&#125; 同时删去视类的显示。 动态菜单操作添加菜单项目 在CMainFrame类的OnCreate函数中添加代码：1234CMenu menu;menu.CreateMenu();GetMenu()-&gt;AppendMenu(MF_POPUP, (UINT)menu.m_hMenu, \"Test\");menu.Detach(); 插入菜单项目123456CMenu menu;menu.CreateMenu();/*GetMenu()-&gt;AppendMenu(MF_POPUP, (UINT)menu.m_hMenu, \"Test\");menu.Detach();*/GetMenu()-&gt;InsertMenu(2, MF_POPUP | MF_BYPOSITION, (UINT)menu. m_hMenu,\"Test\");menu.Detach(); 如果要在新插入的子菜单中添加菜单项的话，同样可以使用AppendMenu函数来实现。12345678910CMenu menu; menu.CreateMenu(); /*GetMenu()-&gt;AppendMenu(MF_POPUP, (UINT)menu.m_hMenu, \"Test\"); menu.Detach();*/ GetMenu()-&gt;InsertMenu(2, MF_POPUP | MF_BYPOSITION, (UINT)menu. m_hMenu,\"Test\"); menu.AppendMenu(MF_STRING, 111, \"Hello\"); menu.AppendMenu(MF_STRING, 112, \"Bye\"); menu.AppendMenu(MF_STRING, 113, \"Mybole\"); menu.Detach(); 111、112、113是随便赋予的ID号。 若要在“文件”子菜单下添加一个菜单项Welcome，再添加一行代码： GetMenu()-&gt;GetSubMenu(0)-&gt;AppendMenu(MF_STRING, 114, “Welcome”); 若要在“文件”中的“新建”和“打开”插入一个菜单项VC编程，再添加一行代码： GetMenu()-&gt;GetSubMenu(0)-&gt;InsertMenu(ID_FILE_OPEN, MF_BYCOMMAND | MF_STRING, 115， “VC编程”); 删除菜单 删除“编辑”：在CMainFrame类的OnCreate函数最后（return之前）添加： GetMenu()-&gt;DeleteMenu(1, MF_BYPOSITION); 删除“文件”下的“打开”： GetMenu()-&gt;GetSubMenu(0)-&gt;DeleteMenu(2, MF_BYPOSITION); 动态添加的菜单项的命令响应 Resource.h中添加新ID1#define IDM_HELLO 111 将menu.AppendMenu(MF_STRING, 111, “Hello”); 改为 menu.AppendMenu(MF_STRING, IDM_HELLO, “Hello”); 三部曲： 1. 点开MainFrm.h，增加为123456//&#123;&#123;AFX_MSG(CMainFrame) afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct); afx_msg void OnShow(); //&#125;&#125;AFX_MSG afx_msg void OnHello(); DECLARE_MESSAGE_MAP() 2. 点开MainFrm.cpp，增加为1234567BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd) //&#123;&#123;AFX_MSG_MAP(CMainFrame) ON_WM_CREATE() ON_COMMAND(IDM_SHOW, OnShow) ON_COMMAND(IDM_HELLO, OnHello) //&#125;&#125;AFX_MSG_MAPEND_MESSAGE_MAP() 3. CMainFrame类中添加1234void CMainFrame::OnHello()&#123; MessageBox(\"Hello\");&#125; 电话本示例程序 删除之前写入CMainFrame类的OnCreate函数，留下原始函数。 动态添加子菜单的实现 利用ClassWizard添加WM_CHAR消息。在Menu2View.h中添加：123private: int m_nIndex; CMenu m_menu; 在Menu2View.cpp里，添加：12345CMenu2View::CMenu2View()&#123; // TODO: add construction code here m_nIndex = -1;&#125; 显示输入的字符添加菜单项及其命令响应函数 在资源编辑器中打开程序的菜单，在“帮助”后添加一个新菜单abc，添加4个菜单项。名称为1，ID为IDM_PHONE1，以此类推。用ClassWizard为CMenu2View类分别加上这四个菜单项的命令响应函数。 修改CMenu2View类的头文件，如下：12345678910protected: //&#123;&#123;AFX_MSG(CMenu2View) afx_msg void OnRButtonDown(UINT nFlags, CPoint point); afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags); afx_msg void OnPhone1(); afx_msg void OnPhone2(); afx_msg void OnPhone3(); afx_msg void OnPhone4(); //&#125;&#125;AFX_MSG DECLARE_MESSAGE_MAP() CMenu2View.cpp中，123456789101112 //&#123;&#123;AFX_MSG_MAP(CMenu2View) ON_WM_CHAR() //&#125;&#125;AFX_MSG_MAP ON_COMMAND(IDM_PHONE1, OnPhone1) ON_COMMAND(IDM_PHONE2, OnPhone2) ON_COMMAND(IDM_PHONE3, OnPhone3) ON_COMMAND(IDM_PHONE4, OnPhone4) // Standard printing commands ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint) ON_COMMAND(ID_FILE_PRINT_DIRECT, CView::OnFilePrint) ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)END_MESSAGE_MAP() 123456789101112131415161718192021222324252627void CMenu2View::OnPhone1() &#123; CClientDC dc(this); dc.TextOut(0, 0, m_strArray.GetAt(0)); &#125;void CMenu2View::OnPhone2() &#123; CClientDC dc(this); dc.TextOut(0, 0, m_strArray.GetAt(1)); &#125;void CMenu2View::OnPhone3() &#123; CClientDC dc(this); dc.TextOut(0, 0, m_strArray.GetAt(2)); &#125;void CMenu2View::OnPhone4() &#123; CClientDC dc(this); dc.TextOut(0, 0, m_strArray.GetAt(3)); &#125; 框架类窗口截获菜单命令消息 右键单击CMainFrame，选择Add Virtual Functions-OnCommand，单击Add Handler，再点击Edit Existing。 这里写图片描述 代码：12345678910111213BOOL CMainFrame::OnCommand(WPARAM wParam, LPARAM lParam) &#123; int MenuCmdID = LOWORD(wParam); CMenu2View *pView = (CMenu2View *)GetActiveView(); if (MenuCmdID &gt;= IDM_PHONE1 &amp;&amp; MenuCmdID &lt; IDM_PHONE1 + pView-&gt;m_strArray.GetSize()) &#123; //MessageBox(\"Test\"); CClientDC dc(pView); dc.TextOut(0, 0, pView-&gt;m_strArray.GetAt(MenuCmdID - IDM_PHONE1)); return TRUE; &#125; return CFrameWnd::OnCommand(wParam, lParam);&#125; 将MainFrm.cpp里添加#include “Menu2View.h” 。 将Menu2View.cpp中的#include “Menu2Doc.h”剪切到Menu2View.h文件的前部（#endif // _MSC_VER &gt; 1000下面）。 最终代码：123456789101112131415161718192021222324void CMenu2View::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) &#123; CClientDC dc(this); if (0x0d == nChar) &#123; if (0 == ++m_nIndex) &#123; m_menu.CreatePopupMenu(); GetParent()-&gt;GetMenu()-&gt;AppendMenu(MF_POPUP, (UINT)m_menu.m_hMenu, \"PhoneBook\"); GetParent()-&gt;DrawMenuBar(); &#125; m_menu.AppendMenu(MF_STRING, IDM_PHONE1 + m_nIndex, m_strLine.Left(m_strLine.Find(' '))); m_strArray.Add(m_strLine); m_strLine.Empty(); Invalidate(); &#125; else &#123; m_strLine += nChar; dc.TextOut(0, 0, m_strLine); &#125; CView::OnChar(nChar, nRepCnt, nFlags);&#125; 效果： 这里写图片描述 简单绘图MFC消息映射机制 与消息有关的三处信息：1.头文件XXXX.h中 2.源文件XXXX.cpp中 3.源文件XXXX.cpp的响应函数中 绘制线条 对CDrawView右键点击Add Member Variable，变量名称：m_ptOrigin，类型：CPoint，访问权限设置：Private。 代码：12345void CDrawView::OnLButtonDown(UINT nFlags, CPoint point) &#123; m_ptOrigin = point; CView::OnLButtonDown(nFlags, point);&#125; 1234567891011121314void CDrawView::OnLButtonUp(UINT nFlags, CPoint point) &#123; //首先获得窗口的设备描述表 HDC hdc; hdc = ::GetDC(m_hWnd); //移动到线条的起点 MoveToEx(hdc, m_ptOrigin.x, m_ptOrigin.y, NULL); //画线 LineTo(hdc, point.x, point.y); //释放设备描述表 ::ReleaseDC(m_hWnd, hdc); CView::OnLButtonUp(nFlags, point);&#125; 这里写图片描述 利用MFC的CDC类实现画线功能12345678910111213141516171819void CDrawView::OnLButtonUp(UINT nFlags, CPoint point) &#123; /*//首先获得窗口的设备描述表 HDC hdc; hdc = ::GetDC(m_hWnd); //移动到线条的起点 MoveToEx(hdc, m_ptOrigin.x, m_ptOrigin.y, NULL); //画线 LineTo(hdc, point.x, point.y); //释放设备描述表 ::ReleaseDC(m_hWnd, hdc);*/ CDC* pDC = GetDC(); pDC-&gt;MoveTo(m_ptOrigin); pDC-&gt;LineTo(point); ReleaseDC(pDC); CView::OnLButtonUp(nFlags, point);&#125; 利用MFC的CWindowDC类实现画线功能12345678void CDrawView::OnLButtonUp(UINT nFlags, CPoint point) &#123; CWindowDC dc(GetParent()); dc.MoveTo(m_ptOrigin); dc.LineTo(point); CView::OnLButtonUp(nFlags, point);&#125; 在桌面窗口中画线12345678void CDrawView::OnLButtonUp(UINT nFlags, CPoint point) &#123; CWindowDC dc(GetDesktopWindow()); dc.MoveTo(m_ptOrigin); dc.LineTo(point); CView::OnLButtonUp(nFlags, point);&#125; 注意：在桌面上画图需要权限（一般写代码时需要避免软件以外的操作）。 绘制彩色线条 在程序中，当构造一个GDI对象后，该对象并不会立即生效，必须选入设备描述表，它才会在以后的绘制操作中生效。一般情况下，在完成绘图操作之后，都要利用SelectObject函数把之前的GDI对象选入设备描述表，以便使其恢复到先前的状态。1234567891011void CDrawView::OnLButtonUp(UINT nFlags, CPoint point) &#123; CPen pen(PS_SOLID, 1, RGB(255, 0, 0)); CClientDC dc(this); CPen* pOldPen = dc.SelectObject(&amp;pen); dc.MoveTo(m_ptOrigin); dc.LineTo(point); dc.SelectObject(pOldPen); CView::OnLButtonUp(nFlags, point);&#125; 运行的效果是红色线条。 改为 CPen pen(PS_DASH, 1, RGB(255, 0, 0)); 是虚线。（其中第二个参数需小于等于10） CPen pen(PS_DOT, 1, RGB(255, 0, 0)); 是点线。 使用画刷绘图简单画刷1234567891011void CDrawView::OnLButtonUp(UINT nFlags, CPoint point) &#123; //创建一个红色画刷 CBrush brush(RGB(255, 0, 0)); //创建并获得设备描述表 CClientDC dc(this); //利用红色画刷填充鼠标拖拽过程中形成的矩形区域 dc.FillRect(CRect(m_ptOrigin, point),&amp;brush); CView::OnLButtonUp(nFlags, point);&#125; 位图画刷 Insert-Resource-Bitmap-New，在这里发挥灵魂画手的天赋吧！ 代码：123456789101112131415void CDrawView::OnLButtonUp(UINT nFlags, CPoint point) &#123; //创建位图对象 CBitmap bitmap; //加载位图资源 bitmap.LoadBitmap(IDB_BITMAP1); //创建位图画刷 CBrush brush(&amp;bitmap); //创建并获得设备描述表 CClientDC dc(this); //利用位图画刷填充鼠标拖拽过程中形成的矩形区域 dc.FillRect(CRect(m_ptOrigin, point),&amp;brush); CView::OnLButtonUp(nFlags, point);&#125; 我画的是不是很滑稽（手动滑稽） 透明画刷 先进行一种尝试：123456789void CDrawView::OnLButtonUp(UINT nFlags, CPoint point) &#123; //创建并获得设备描述表 CClientDC dc(this); //绘制一个矩形 dc.Rectangle(CRect(m_ptOrigin,point)); CView::OnLButtonUp(nFlags, point);&#125; 如果希望矩形内部是透明的，能够看到被遮挡的图形，就要创建一个透明画刷。123456789101112131415void CDrawView::OnLButtonUp(UINT nFlags, CPoint point) &#123; //创建并获得设备描述表 CClientDC dc(this); //创建一个空画刷 CBrush *pBrush = CBrush::FromHandle((HBRUSH)GetStockObject(NULL_BRUSH)); //将空画刷选入设备描述表 CBrush *pOldBrush = dc.SelectObject(pBrush); //绘制一个矩形 dc.Rectangle(CRect(m_ptOrigin, point)); //恢复先前的画刷 dc.SelectObject(pOldBrush); CView::OnLButtonUp(nFlags, point);&#125; 这里写图片描述 绘制连续线条 首先为视类增加鼠标移动消息（WM_MOUSEMOVE）的响应函数（默认OnMouseMove），并为视类添加一个BOOL型的私有成员变量m_bDraw。在视类头文件定义：12 Private: BOOL m_bDraw; 在视类的构造函数中：1m_bDraw = FALSE; 在OnLButtonDown中：1m_bDraw = TRUE; 在OnLButtonUp中：1m_bDraw = FALSE; 12345678910111213void CDrawView::OnMouseMove(UINT nFlags, CPoint point) &#123; CClientDC dc(this); if(m_bDraw == TRUE) &#123; dc.MoveTo(m_ptOrigin); dc.LineTo(point); //修改线段的起点 m_ptOrigin = point; &#125; CView::OnMouseMove(nFlags, point);&#125; 这里写图片描述 给线条换色：12345678910111213141516171819void CDrawView::OnMouseMove(UINT nFlags, CPoint point) &#123; CClientDC dc(this); //创建一个红色的、宽度为1的实线画笔 CPen pen(PS_SOLID, 1, RGB(255, 0, 0)); //把创建的画笔选入设备描述表 CPen *pOldPen = dc.SelectObject(&amp;pen); if (m_bDraw == TRUE) &#123; dc.MoveTo(m_ptOrigin); dc.LineTo(point); //修改线段的起点 m_ptOrigin = point; &#125; //恢复设备描述表 dc.SelectObject(pOldPen); CView::OnMouseMove(nFlags, point);&#125; 绘制扇形效果的线条 去掉上述代码中的 m_ptOrigin = point; 效果： 绘制一个带边线的扇形： 为CDrawView类增加一个CPoint类型的私有成员变量m_ptOld，用来保存鼠标上一个移动点。 在OnLButton中：1m_ptOld = point; 在OnMouseMove中：123456789101112131415161718192021void CDrawView::OnMouseMove(UINT nFlags, CPoint point) &#123; CClientDC dc(this); //创建一个红色的、宽度为1的实线画笔 CPen pen(PS_SOLID, 1, RGB(255, 0, 0)); //把创建的画笔选入设备描述表 CPen *pOldPen = dc.SelectObject(&amp;pen); if (m_bDraw == TRUE) &#123; dc.MoveTo(m_ptOrigin); dc.LineTo(point); dc.LineTo(m_ptOld); //修改线段的起点 //m_ptOrigin = point; m_ptOld = point; &#125; //恢复设备描述表 dc.SelectObject(pOldPen); CView::OnMouseMove(nFlags, point);&#125; 最好将OnLButtonUp里原来写的代码删除或注释之。 效果： 这里写图片描述 MFC提供一个设置绘图模式的函数SetROP2，带有一个参数R2_BLACK、R2_WHITE、R2_MERGENOTPEN等。 例如，在CClientDC dc(this); 下方添加代码： dc.SetROP2(R2_MERGENOTPEN); 编译运行后看不到绘制的线条，这就是设置了R2_MERGENOTPEN这种绘图模式。使用R2_BLACK，将会发现绘制的线条颜色始终都是黑色的。 文本编程插入符创建文本插入符 创建一个单文档类型的MFC AppWizard(exe)工程，取名为Text。为CTextView类添加WM_CREATE消息的响应函数OnCreate，在此函数中创建一个宽度为20、高度为100的插入符。代码如下。123456789int CTextView::OnCreate(LPCREATESTRUCT lpCreateStruct) &#123; if (CView::OnCreate(lpCreateStruct) == -1) return -1; CreateSolidCaret(20,100); ShowCaret(); return 0;&#125; 这里写图片描述 让插入符适应于当前字体的大小：123456789101112131415161718int CTextView::OnCreate(LPCREATESTRUCT lpCreateStruct) &#123; if (CView::OnCreate(lpCreateStruct) == -1) return -1; //创建设备描述表 CClientDC dc(this); //定义文本信息结构体变量 TEXTMETRIC tm; //获得设备描述表中的文本信息 dc.GetTextMetrics(&amp;tm); //根据字体大小，创建何时的插入符（除以8是经验值） CreateSolidCaret(tm.tmAveCharWidth/8, tm.tmHeight); //显示插入符 ShowCaret(); return 0;&#125; 运行结果就比较符合常规了。 创建图形插入符 新建一个位图资源，画一个图形。在TextView.h中添加12private: CBitmap bitmap; 代码：123456789101112int CTextView::OnCreate(LPCREATESTRUCT lpCreateStruct) &#123; if (CView::OnCreate(lpCreateStruct) == -1) return -1; bitmap.LoadBitmap(IDB_BITMAP1); CreateCaret(&amp;bitmap); ShowCaret(); return 0;&#125; 这里写图片描述 窗口重绘OnDraw函数 实现在程序窗口中输出一串文字的功能。12345678void CTextView::OnDraw(CDC* pDC)&#123; CTextDoc* pDoc = GetDocument(); ASSERT_VALID(pDoc); CString str(\"VC++ 深入编程\"); pDC-&gt;TextOut(50, 50, str);&#125; 添加字符串资源 点击Resource View-String Table选项，在此字符串表最底部的空行上双击，即可弹出添加新字符串资源的对话框。ID：IDS_STRINGVC，Caption：“VC++编程 文本编程”。代码如下。12345678910111213void CTextView::OnDraw(CDC* pDC)&#123; CTextDoc* pDoc = GetDocument(); ASSERT_VALID(pDoc); //CString str(\"VC++ 深入编程\"); CString str; str = \"VC++ 深入编程\"; pDC-&gt;TextOut(50, 50, str); str.LoadString(IDS_STRINGVC); pDC-&gt;TextOut(0, 200, str);&#125; 这里写图片描述 路径123456789101112131415161718192021222324252627void CTextView::OnDraw(CDC* pDC)&#123; CTextDoc* pDoc = GetDocument(); ASSERT_VALID(pDoc); //CString str(\"VC++ 深入编程\"); CString str; str = \"VC++ 深入编程\"; pDC-&gt;TextOut(50, 50, str); CSize sz = pDC-&gt;GetTextExtent(str); str.LoadString(IDS_STRINGVC); pDC-&gt;TextOut(0, 200, str); pDC-&gt;BeginPath(); pDC-&gt;Rectangle(50, 50, 50+sz.cx, 50+sz.cy); pDC-&gt;EndPath(); for(int i=0; i&lt;300; i+=10) &#123; pDC-&gt;MoveTo(0, i); pDC-&gt;LineTo(300, i); pDC-&gt;MoveTo(i,0); pDC-&gt;LineTo(i,300); &#125; 1234567891011121314151617181920212223242526272829void CTextView::OnDraw(CDC* pDC)&#123; CTextDoc* pDoc = GetDocument(); ASSERT_VALID(pDoc); //CString str(\"VC++ 深入编程\"); CString str; str = \"VC++ 深入编程\"; pDC-&gt;TextOut(50, 50, str); CSize sz = pDC-&gt;GetTextExtent(str); str.LoadString(IDS_STRINGVC); pDC-&gt;TextOut(0, 200, str); pDC-&gt;BeginPath(); pDC-&gt;Rectangle(50, 50, 50+sz.cx, 50+sz.cy); pDC-&gt;EndPath(); pDC-&gt;SelectClipPath(RGN_DIFF); for(int i=0; i&lt;300; i+=10) &#123; pDC-&gt;MoveTo(0, i); pDC-&gt;LineTo(300, i); pDC-&gt;MoveTo(i,0); pDC-&gt;LineTo(i,300); &#125;&#125; 这正是RGN_DIFF模式的效果。 如果是RGN_AND，效果是新的裁剪区域是当前裁剪区域和当前路径层的交集。 路径层的作用：实现特殊效果。如，希望整幅图形中某一部分与其他部分有所区别，就可以把这部分的图形设置到一个路径层中，然后利用SelectClipPath函数设置一种模式，让路径层和裁剪区域进行互操作以达到一种特殊效果。 字符输入 当用户在键盘上按下某个字符按键后，要把该字符输出到程序窗口上。首先让CTextView捕获WM_CHAR消息，接着为该类定义一个CString类型的成员变量：m_strLine，并在CTextView类的构造函数中将这个变量初始化：m_strLine = “”;123456void CTextView::OnLButtonDown(UINT nFlags, CPoint point) &#123; SetCaretPos(point); CView::OnLButtonDown(nFlags, point);&#125; 为CTextView类再增加一个CPoint类型的成员变量，取名m_ptOrigin，权限为私有。在CTextView类的构造函数中设置其初值为0。12345678void CTextView::OnLButtonDown(UINT nFlags, CPoint point) &#123; SetCaretPos(point); m_strLine.Empty(); m_ptOrigin = point; CView::OnLButtonDown(nFlags, point);&#125; 注意：回车字符的ASCII码十六进制是0x0d，退格键的ASCII码十六进制值是0x08。 最终代码：1234567891011121314151617181920212223242526272829303132void CTextView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) &#123; CClientDC dc(this); TEXTMETRIC tm; dc.GetTextMetrics(&amp;tm); if (0x0d == nChar) &#123; m_strLine.Empty(); m_ptOrigin.y += tm.tmHeight; &#125; else if(0x08 == nChar) &#123; COLORREF clr = dc.SetTextColor(dc.GetBkColor()); dc.TextOut(m_ptOrigin.x, m_ptOrigin.y, m_strLine); m_strLine = m_strLine.Left(m_strLine.GetLength() - 1); dc.SetTextColor(clr); &#125; else &#123; m_strLine += nChar; &#125; CSize sz = dc.GetTextExtent(m_strLine); CPoint pt; pt.x = m_ptOrigin.x + sz.cx; pt.y = m_ptOrigin.y; SetCaretPos(pt); dc.TextOut(m_ptOrigin.x, m_ptOrigin.y, m_strLine); CView::OnChar(nChar, nRepCnt, nFlags);&#125; 设置字体1234567891011void CTextView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) &#123; CClientDC dc(this); CFont font; font.CreatePointFont(300, \"华文行楷\", NULL); CFont *pOldFont = dc.SelectObject(&amp;font);…… dc.SelectObject(pOldFont); CView::OnChar(nChar, nRepCnt, nFlags);&#125; 字幕变色功能的实现 在这个Text例子中，我们在视类的OnCreate 函数中设置定时器，设置一个时间间隔为100ms，标识为1的定时器。12345678int CTextView::OnCreate(LPCREATESTRUCT lpCreateStruct) &#123; …… SetTimer(1, 100, NULL); return 0;&#125; 给CTextView类添加WM_TIMER消息的响应函数。1234567891011121314151617181920212223242526272829303132void CTextView::OnTimer(UINT nIDEvent) &#123; m_nWidth += 5; CClientDC dc(this); TEXTMETRIC tm; dc.GetTextMetrics(&amp;tm); CRect rect; rect.left =0; rect.top = 200; rect.right = m_nWidth; rect.bottom = rect.top + tm.tmHeight; dc.SetTextColor(RGB(255, 0, 0)); CString str; str.LoadString(IDS_STRINGVC); dc.DrawText(str, rect, DT_LEFT); rect.top = 150; rect.bottom = rect.top + tm.tmHeight; dc.DrawText(str, rect, DT_RIGHT); CSize sz = dc.GetTextExtent(str); if (m_nWidth &gt; sz.cx) &#123; m_nWidth = 0; dc.SetTextColor(RGB(0, 255, 0)); dc.TextOut(0, 200, str); &#125; CView::OnTimer(nIDEvent);&#125; 红色渐变效果可看到。 这里写图片描述 绘图控制简单绘图 新建一个单文档类型的MFC AppWizard(exe)工程，取名：Graphic。 添加的菜单项： 这里写图片描述 给CGraphicView类中添加一个私有变量：1UINT m_nDrawType; 在视类构造函数中将此变量初始化为0。 1234567891011121314151617181920void CGraphicView::OnDot() &#123; m_nDrawType = 1; &#125;void CGraphicView::OnLine() &#123; m_nDrawType = 2; &#125;void CGraphicView::OnRectangle() &#123; m_nDrawType = 3; &#125;void CGraphicView::OnEllipse() &#123; m_nDrawType = 4; &#125; CGraphicView类再增加一个CPoint类型的私有成员变量：m_ptOrigin。在CGraphicView类构造函数中，将该变量的值设置为0。1234567891011121314151617181920212223242526272829303132333435void CGraphicView::OnLButtonDown(UINT nFlags, CPoint point) &#123; m_ptOrigin = point; CView::OnLButtonDown(nFlags, point);&#125;void CGraphicView::OnLButtonUp(UINT nFlags, CPoint point) &#123; CClientDC dc(this); //为边框设定颜色 CPen pen(PS_SOLID, 1, RGB(255, 0, 0)); dc.SelectObject(&amp;pen); //能看到图形内部内容(透明) CBrush *pBrush = CBrush::FromHandle((HBRUSH)GetStockObject(NULL_BRUSH)); dc.SelectObject(pBrush); switch(m_nDrawType) &#123; case 1: dc.SetPixel(point,RGB(255, 0, 0)); break; case 2: dc.MoveTo(m_ptOrigin); dc.LineTo(point); break; case 3: dc.Rectangle(CRect(m_ptOrigin,point)); break; case 4: dc.Ellipse(CRect(m_ptOrigin, point)); break; &#125; CView::OnLButtonUp(nFlags, point);&#125; 设置对话框 再增加一个对话框资源，ID为IDD_DLG_SETTING，Caption为Setting，Font为宋体。 设置线宽 添加一个静态文本框，并将Caption设为“线宽”。再添加一个编辑框，ID：IDC_LINE_WIDTH。为此对话框资源创建一个响应的对话框类，类名为CSettingDlg。对编辑框右键，ClassWizard，为它添加一个成员变量：m_nLineWidth，类型为UINT。为绘图菜单下再增加一个菜单项为“设置”，ID为IDM_SETTING。为此菜单项添加一个命令响应，选择视类做出响应。为CGraphicView类添加一个私有成员变量：m_nLineWidth，类型：UINT，并在CGraphicView类的构造函数初始化为0。123456789void CGraphicView::OnSetting() &#123; CSettingDlg dlg; dlg.m_nLineWidth = m_nLineWidth; //将保存的用户先前设置的线宽再传回给该设置对话框 if(IDOK == dlg.DoModal())//点击OK才保持线宽值 &#123; m_nLineWidth = dlg.m_nLineWidth; &#125;&#125; 在源文件前部添加：1Include “SettingDlg.h” 修改OnLButtonUp函数：1234567void CGraphicView::OnLButtonUp(UINT nFlags, CPoint point) &#123; CClientDC dc(this); //为边框设定颜色(m_nLineWidth定义线宽) CPen pen(PS_SOLID, m_nLineWidth, RGB(255, 0, 0));……&#125; 设置线型 为对话框资源添加一个组框，Caption设为线型。ID为IDC_LINE_STYLE。在组框内放三个单选按钮，ID不变，名称分别为：实线、虚线、点线（不要改变顺序）。在第一个单选按钮上右键，属性勾上Group，使三个按钮成为一组。再为CGraphicView类添加一个Int类型的私有成员变量m_nLineStyle，在构造函数中初始化为0。 由于WINGDI.h定义了一些符号常量，（可以在PS_SOLID右键，Go To Definition Of PS_SOLID），刚好PS_SOLID（实线）值本身就是0；PS_DASH（虚线）是1；PS_DOT（点线）是2。所以此处的排列是故意为之。 这里写图片描述 这里写图片描述 注意：若要画出虚线和点线，线宽只能为0或1。 颜色对话框 在绘图下增加一个子菜单，ID为IDM_COLOR，Caption为颜色。为其在视类增加一个命令响应，代码：1234567891011void CGraphicView::OnColor() &#123; CColorDialog dlg; dlg.m_cc.Flags |= CC_RGBINIT; dlg.m_cc.rgbResult = m_clr; if (IDOK == dlg.DoModal()) &#123; m_clr = dlg.m_cc.rgbResult; //dlg.m_cc.Flags |= CC_RGBINIT | CC_FULLOPEN;//让颜色对话框完全展开 &#125;&#125; 为CGraphicView类再增加一个COLORREF类型的私有成员变量：m_clr，并在构造函数中初始化为红色：1m_clr = RGB(255, 0, 0); 修改该函数两处位置：12345678910111213141516171819202122232425262728void CGraphicView::OnLButtonUp(UINT nFlags, CPoint point) &#123; CClientDC dc(this); //为边框设定颜色(m_nLineStyle定义线型，m_nLineWidth定义线宽，m_clr定义颜色) CPen pen(m_nLineStyle, m_nLineWidth, m_clr); dc.SelectObject(&amp;pen); //能看到图形内部内容(透明) CBrush *pBrush = CBrush::FromHandle((HBRUSH)GetStockObject(NULL_BRUSH)); dc.SelectObject(pBrush); switch(m_nDrawType) &#123; case 1: dc.SetPixel(point,m_clr); break; case 2: dc.MoveTo(m_ptOrigin); dc.LineTo(point); break; case 3: dc.Rectangle(CRect(m_ptOrigin,point)); break; case 4: dc.Ellipse(CRect(m_ptOrigin, point)); break; &#125; CView::OnLButtonUp(nFlags, point);&#125; 注意：//dlg.m_cc.Flags |= CC_RGBINIT | CC_FULLOPEN;//让颜色对话框完全展开这句我没能实现展开效果。 字体对话框 增加一个菜单，ID为IDM_FONT，Caption为字体。在视类增加命令响应，代码：123456789101112void CGraphicView::OnFont() &#123; CFontDialog dlg; if (IDOK == dlg.DoModal()) &#123; if (m_font.m_hObject) //m_font对象是否已经与某字体资源相关联 m_font.DeleteObject(); m_font.CreateFontIndirect(dlg.m_cf.lpLogFont); m_strFontName = dlg.m_cf.lpLogFont-&gt;lfFaceName; &#125; &#125; 12345678910void CGraphicView::OnDraw(CDC* pDC)&#123; CGraphicDoc* pDoc = GetDocument(); ASSERT_VALID(pDoc); // TODO: add draw code for native data here CFont *pOldFont = pDC-&gt;SelectObject(&amp;m_font); pDC-&gt;TextOut(0, 0, m_strFontName); pDC-&gt;SelectObject(pOldFont);&#125; 示例对话框 在对话框中增加一个组框，Caption:示例，ID：IDC_SAMPLE。为CSettingDlg类添加编辑框控件的EN_CHANCE响应函数，对三个单选按钮都选择BN_CLICKED消息。1234567891011121314151617void CSettingDlg::OnRadio1() &#123; // TODO: Add your control notification handler code here Invalidate(); &#125;void CSettingDlg::OnRadio2() &#123; // TODO: Add your control notification handler code here Invalidate(); &#125;void CSettingDlg::OnRadio3() &#123; // TODO: Add your control notification handler code here Invalidate(); &#125; 1234567891011121314151617void CSettingDlg::OnPaint() &#123; CPaintDC dc(this); // device context for painting // TODO: Add your message handler code here UpdateData(); CPen pen(m_nLineStyle, m_nLineWidth, m_clr); dc.SelectObject(&amp;pen); CRect rect; GetDlgItem(IDC_SAMPLE)-&gt;GetWindowRect(&amp;rect); ScreenToClient(&amp;rect); dc.MoveTo(rect.left+20, rect.top+rect.Height()/2); dc.LineTo(rect.right-20, rect.top+rect.Height()/2); // Do not call CDialog::OnPaint() for painting messages&#125; 这里写图片描述 现在可以实时修改了。 10.6 改变对话框和控件的背景及文本颜色改变整个对话框及其子控件的背景色 为CSettingDlg类添加WM_CTLCOLOR消息，并定义一个CBrush类型的私有成员变量：m_brush，并在构造函数中初始化一个蓝色画刷：1m_brush.CreateSolidBrush (RGB(0, 0, 255)); 12345678910HBRUSH CSettingDlg::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) &#123; HBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor); // TODO: Change any attributes of the DC here // TODO: Return a different brush if the default is not desired //return hbr; return m_brush;&#125; 仅改变某个子控件的背景及文本颜色图形的保存和重绘坐标空间和转换坐标空间 Win32应用程序编程接口（API）使用四种坐标空间：世界坐标系空间、页面空间、设备空间和物理设备空间。Win32 API把世界坐标系空间和页面空间称为逻辑空间。 转换 转换是把对象从一个坐标空间复制到另一个坐标空间时改变（或转变）这一对象的大小、方位和形态。 图形的保存和重绘123456789101112131415HBRUSH CSettingDlg::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) &#123; HBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor); // TODO: Change any attributes of the DC here // TODO: Return a different brush if the default is not desired //return hbr; if (pWnd -&gt; GetDlgCtrlID() == IDC_LINE_STYLE) &#123; pDC-&gt;SetTextColor(RGB(255, 0, 0)); return m_brush; &#125; return hbr;&#125; 上述程序再加一行：1pDC-&gt;SetBkMode(TRANSPARENT); 1234567891011121314151617181920212223HBRUSH CSettingDlg::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) &#123; HBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor); // TODO: Change any attributes of the DC here // TODO: Return a different brush if the default is not desired //return hbr; if (pWnd -&gt; GetDlgCtrlID() == IDC_LINE_STYLE) &#123; pDC-&gt;SetTextColor(RGB(255, 0, 0)); pDC-&gt;SetBkMode(TRANSPARENT); return m_brush; &#125; if (pWnd-&gt;GetDlgCtrlID() == IDC_LINE_WIDTH) &#123; pDC-&gt;SetTextColor(RGB(255, 0, 0)); //pDC-&gt;SetBkMode(TRANSPARENT); pDC-&gt;SetBkColor(RGB(0, 0, 255)); return m_brush; &#125; return hbr;&#125; 改变控件上的文本字体 为对话框增加一个静态文本控件，ID:IDC_TEXT，Caption:程序员，为CSettingDlg类增加一个CFont类型的私有成员变量：m_font，在构造函数中添加1m_font.CreatePointFont(200, \"华文行楷\"); 在OnCtlColor函数中添加：1234if (pWnd-&gt;GetDlgCtrlID() == IDC_TEXT)&#123; pDC-&gt;SelectObject(&amp;m_font);&#125; 改变按钮控件的背景色及文本颜色 在CSettingDlg类OnCtlColor函数中添加：1234567 if (pWnd-&gt;GetDlgCtrlID() == IDOK) &#123; pDC-&gt;SetTextColor(RGB(255, 0, 0)); return m_brush; &#125; return hbr;&#125; 点Insert-New Class，选择MFC Class，新增类名：CTestBtn，基类CButton。 为此类添加DrawItem虚函数重写。123456789101112131415161718192021void CTestBtn::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct) &#123; // TODO: Add your code to draw the specified item UINT uStyle = DFCS_BUTTONPUSH; ASSERT(lpDrawItemStruct-&gt;CtlType == ODT_BUTTON); if (lpDrawItemStruct-&gt;itemState &amp; ODS_SELECTED) uStyle |= DFCS_PUSHED; ::DrawFrameControl(lpDrawItemStruct-&gt;hDC, &amp;lpDrawItemStruct-&gt;rcItem, DFC_BUTTON, uStyle); CString strText; GetWindowText(strText); COLORREF crOldColor = ::SetTextColor(lpDrawItemStruct-&gt;hDC, RGB(255, 0, 0)); ::DrawText(lpDrawItemStruct-&gt;hDC, strText, strText.GetLength(), &amp;lpDrawItemStruct-&gt;rcItem, DT_SINGLELINE | DT_VCENTER | DT_CENTER); ::SetTextColor(lpDrawItemStruct-&gt;hDC, crOldColor); &#125; 然而，此时我返回双击OK键显示“Cannot add new member”…… 按理，接下来应该是： 利用ClassWizard打开Add Member Variable对话框，为OK按钮关联一个成员变量，名称为m_btnTest，类型CTestBtn。在SettingDlg.h文件前部添加#include “TestBtn.h”。对OK右键属性，打开Styles，选中Owner draw选项。此时OK文字变红色。 位图的显示定制应用程序外观修改应用程序窗口的外观在窗口创建之前修改 创建前，打开CMainFrame类的PreCreateWindow成员函数，修改CREATETRUCT结构体中的cx和cy成员。12345678910BOOL CMainFrame::PreCreateWindow(CREATESTRUCT&amp; cs)&#123; if( !CFrameWnd::PreCreateWindow(cs) ) return FALSE; // TODO: Modify the Window class or styles here by modifying // the CREATESTRUCT cs cs.cx = 300; cs.cy = 200; return TRUE;&#125; 创建运行，可看到初始大小为300x200的应用程序窗口。 修改窗口标题：在上述 return TRUE; 前添加：12cs.style &amp;= ~FWS_ADDTOTITLE;cs.lpszName = \"http://www.sunxin.org\"; 在窗口创建之后修改 注释掉之前添加的代码。在OnCreate函数中添加：123456789101112131415int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)&#123; … // TODO: Delete these three lines if you don't want the toolbar to // be dockable m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY); EnableDocking(CBRS_ALIGN_ANY); DockControlBar(&amp;m_wndToolBar); SetWindowLong(m_hWnd, GWL_STYLE, WS_OVERLAPPEDWINDOW); return 0;&#125; 创建运行后可看到文档标题去掉了。 去掉窗口最大化框类型： 将上述SetWindowLong函数替换为1SetWindowLong(m_hWnd, GWL_STYLE, GetWindowLong(m_hWnd, GWL_STYLE) &amp; ~WS_MAXIMIZEBOX); 创建运行发现最大化框变灰，不能放大窗口了。 修改窗口的光标、图标和背景在窗口创建之前修改网络编程计算机网络基本知识ISO/OSI七层参考模型应用层——处理网络应用Telnet、FTP、HTTP、DNS、SMTP、POP3 表示层——数据表示TCP、UDP 会话层——主机间通信传输层——端到端的连接网络层——寻址和最短路径IP、ICMP、IGMP 数据链路层——介质访问（接入）物理层——二进制传输 基于TCP的网络应用程序的编写服务器端程序 关闭先前的工作区，新建一个工程，选择Win32 Console Application类型，名为TCPSrv。选择An empty project选项，创建一个空工程。再新建一个C++源文件：TcpSrv.cpp。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;Winsock2.h&gt;#include &lt;stdio.h&gt;void main()&#123; //加载套接字库 WORD wVersionRequested; WSADATA wsaData; int err; wVersionRequested = MAKEWORD(1, 1); err = WSAStartup(wVersionRequested, &amp;wsaData); if (err != 0)&#123; return; &#125; if (LOBYTE(wsaData.wVersion) != 1 || HIBYTE(wsaData.wVersion) != 1)&#123; WSACleanup(); return; &#125; //创建用于监听的套接字 SOCKET sockSrv = socket(AF_INET, SOCK_STREAM, 0); SOCKADDR_IN addrSrv; addrSrv.sin_addr.S_un.S_addr = htonl(INADDR_ANY); addrSrv.sin_family = AF_INET; addrSrv.sin_port = htons(7000); //绑定套接字 bind(sockSrv, (SOCKADDR*)&amp;addrSrv, sizeof(SOCKADDR)); //将套接字设为监听模式，准备接收客户请求 listen(sockSrv, 5); SOCKADDR_IN addrClient; int len = sizeof(SOCKADDR); while (1) &#123; //等待客户请求到来 SOCKET sockConn = accept(sockSrv, (SOCKADDR*)&amp;addrClient, &amp;len); char sendBuf[100]; sprintf(sendBuf, \"Welcome %s to http://www.sunxin.org\", inet_ntoa(addrClient.sin_addr)); //发送数据 send(sockConn, sendBuf, strlen(sendBuf)+1, 0); char recvBuf[100]; //接收数据 recv(sockConn, recvBuf, 100, 0); //打印接收的数据 printf(\"%s\\n\", recvBuf); //关闭套接字 closesocket(sockConn); &#125;&#125; Project-Setting-Link，在Object/library modules编辑框中添加ws2_32.lib文件，注意输入的库文件与前面的库文件之间一定 要有一个空格。 这里写图片描述 客户端程序 在工作区名称上单击鼠标右键，选择Add New Project to Workspace，再创建一个Win32 Console Application类型的应用程序，创建一个空工程。为此增加一个C++源文件：TcpClient.cpp。12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;Winsock2.h&gt;#include &lt;stdio.h&gt;void main()&#123; //加载套接字库 WORD wVersionRequested; WSADATA wsaData; int err; wVersionRequested = MAKEWORD(1, 1); err = WSAStartup(wVersionRequested, &amp;wsaData); if (err != 0)&#123; return; &#125; if (LOBYTE(wsaData.wVersion) != 1 || HIBYTE(wsaData.wVersion) != 1)&#123; WSACleanup(); return; &#125; //创建套接字 SOCKET sockClient = socket(AF_INET, SOCK_STREAM, 0); SOCKADDR_IN addrSrv; addrSrv.sin_addr.S_un.S_addr = inet_addr(\"127.0.0.1\"); addrSrv.sin_family = AF_INET; addrSrv.sin_port = htons(7000); //向服务器发出连接请求 connect(sockClient, (SOCKADDR*)&amp;addrSrv, sizeof(SOCKADDR)); //接收数据 char recvBuf[100]; recv(sockClient, recvBuf, 100, 0); printf(\"%s\\n\",recvBuf); //发送数据 send(sockClient, \"This is lisi\", strlen(\"This is lisi\")+1, 0); //关闭套接字 closesocket(sockClient); WSACleanup();&#125; 链接库文件：ws2_32.lib。 创建运行，首先运行服务器程序，然后再运行客户端程序。 这里写图片描述 注意：当没有报错，服务器端运行结果为“烫烫……烫”（N个烫）时，尝试换一个端口号，有可能你设置的端口号被其它的应用程序占用了。 基于UDP的网络应用程序的编写服务器端程序 关闭先前的工作区，新建一个工程，选择Win32 Console Application类型，名为UdpSrv。选择An empty project选项，创建一个空工程。再新建一个C++源文件：UdpSrv.cpp。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;Winsock2.h&gt;#include &lt;stdio.h&gt;void main()&#123; //加载套接字库 WORD wVersionRequired; WSADATA wsaData; int err; wVersionRequired = MAKEWORD(1, 1); err = WSAStartup(wVersionRequired, &amp;wsaData); if (err != 0) &#123; return; &#125; if (LOBYTE(wsaData.wVersion) != 1 || HIBYTE(wsaData.wVersion) !=1) &#123; WSACleanup(); return; &#125; //创建套接字 SOCKET sockSrv = socket(AF_INET, SOCK_DGRAM, 0); SOCKADDR_IN addrSrv; addrSrv.sin_addr.S_un.S_addr = htonl(INADDR_ANY); addrSrv.sin_family = AF_INET; addrSrv.sin_port = htons(7000); //绑定套接字 bind(sockSrv, (SOCKADDR*)&amp;addrSrv, sizeof(SOCKADDR)); //等待并接收数据 SOCKADDR_IN addrClient; int len = sizeof(SOCKADDR); char recvBuf[100]; recvfrom(sockSrv, recvBuf, 100, 0, (SOCKADDR*)&amp;addrClient, &amp;len); printf(\"%s\\n\",recvBuf); //关闭套接字 closesocket(sockSrv); WSACleanup();&#125; 在工程设置对话框的链接选项卡下添加库文件：Ws2_32.lib的链接。 客户端程序 在同一个UdpSrv工作区中创建客户端应用程序。创建一个空的Win32 Console Application类型的工程，名为：UdpClient。为该工程添加一个C++源文件：UdpClient.cpp。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;Winsock2.h&gt;#include &lt;stdio.h&gt;void main()&#123; //加载套接字库 WORD wVersionRequired; WSADATA wsaData; int err; wVersionRequired = MAKEWORD(1, 1); err = WSAStartup(wVersionRequired, &amp;wsaData); if (err != 0) &#123; return; &#125; if (LOBYTE(wsaData.wVersion) != 1 || HIBYTE(wsaData.wVersion) !=1) &#123; WSACleanup(); return; &#125; //创建套接字 SOCKET sockClient = socket(AF_INET, SOCK_DGRAM, 0); SOCKADDR_IN addrSrv; addrSrv.sin_addr.S_un.S_addr = inet_addr(\"127.0.0.1\"); addrSrv.sin_family = AF_INET; addrSrv.sin_port = htons(7000); //发送数据 sendto(sockClient, \"Hello\", strlen(\"Hello\")+1, 0, (SOCKADDR*)&amp;addrSrv, sizeof(SOCKADDR)); //关闭套接字 closesocket(sockClient); WSACleanup();&#125; 链接库文件：ws2_32.lib。 创建运行。服务器端程序应先启动，然后启动客户端程序。 这里写图片描述 基于TCP和基于UDP的网络应用程序在发送和接收数据时使用的函数是不一样的：前者使用send和recv，后者使用sendto和recvfrom。 基于UDP的简单聊天程序 在新工作区新建一个空的Win32 Console Application类型的应用程序，名为NetSrv。为该工程添加一个C++源文件：NetSrv.cpp。接着为该工程添加对WinSock库的链接，即在工程设置对话框的Link选项卡上添加ws2_32.lib文件的链接。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;Winsock2.h&gt;#include &lt;stdio.h&gt; void main() &#123; //加载套接字库 WORD wVersionRequested; WSADATA wsaData; int err; wVersionRequested = MAKEWORD(1, 1); err = WSAStartup(wVersionRequested, &amp;wsaData); if (err != 0) &#123; return; &#125; if (LOBYTE(wsaData.wVersion) != 1 || HIBYTE(wsaData.wVersion) !=1) &#123; WSACleanup(); return; &#125; //创建套接字 SOCKET sockSrv = socket(AF_INET, SOCK_DGRAM, 0); SOCKADDR_IN addrSrv; addrSrv.sin_addr.S_un.S_addr = htonl(INADDR_ANY); addrSrv.sin_family = AF_INET; addrSrv.sin_port = htons(7000); //绑定套接字 bind(sockSrv, (SOCKADDR*)&amp;addrSrv, sizeof(SOCKADDR)); char recvBuf[100]; char sendBuf[100]; char tempBuf[200]; SOCKADDR_IN addrClient; int len = sizeof(SOCKADDR); while(1) &#123; //等待并接收数据 recvfrom(sockSrv, recvBuf, 100, 0, (SOCKADDR*)&amp;addrClient, &amp;len); if ('q' == recvBuf[0]) &#123; sendto(sockSrv, \"q\", strlen(\"q\")+1, 0, (SOCKADDR*)&amp;addrClient, len); printf(\"Chat end!\\n\"); break; &#125; sprintf(tempBuf, \"%s say : %s\", inet_ntoa(addrClient.sin_addr), recvBuf); printf(\"%s\\n\", tempBuf); //发送数据 printf(\"Please input data:\\n\"); gets(sendBuf); sendto(sockSrv, sendBuf, strlen(sendBuf)+1, 0, (SOCKADDR*)&amp;addrClient, len); &#125; //关闭套接字 closesocket(sockSrv); WSACleanup(); &#125; 客户端程序 向已有工作区增加一个空的Win32 Console Application类型的工程：NetClient。为此添加一个C++源文件：NetClient.cpp。为该工程添加ws2_32.lib文件的链接。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;Winsock2.h&gt;#include &lt;stdio.h&gt; void main() &#123; //加载套接字库 WORD wVersionRequested; WSADATA wsaData; int err; wVersionRequested = MAKEWORD(1, 1); err = WSAStartup(wVersionRequested, &amp;wsaData); if (err != 0) &#123; return; &#125; if (LOBYTE(wsaData.wVersion) != 1 || HIBYTE(wsaData.wVersion) !=1) &#123; WSACleanup(); return; &#125; //创建套接字 SOCKET sockClient = socket(AF_INET, SOCK_DGRAM, 0); SOCKADDR_IN addrSrv; addrSrv.sin_addr.S_un.S_addr = inet_addr(\"127.0.0.1\"); addrSrv.sin_family = AF_INET; addrSrv.sin_port = htons(7000); char recvBuf[100]; char sendBuf[100]; char tempBuf[200]; int len = sizeof(SOCKADDR); while(1) &#123; //发送数据 printf(\"Please input data:\\n\"); gets(sendBuf); sendto(sockClient, sendBuf, strlen(sendBuf)+1, 0, (SOCKADDR*)&amp;addrSrv, len); //等待并接收数据 recvfrom(sockClient, recvBuf, 100, 0, (SOCKADDR*)&amp;addrSrv, &amp;len); if('q' == recvBuf[0]) &#123; sendto(sockClient, \"q\", strlen(\"q\")+1, 0, (SOCKADDR*)&amp;addrSrv, len); printf(\"Chat end!\\n\"); break; &#125; sprintf(tempBuf, \"%s say : %s\", inet_ntoa(addrSrv.sin_addr), recvBuf); printf(\"%s\\n\", tempBuf); &#125; //关闭套接字 closesocket(sockClient); WSACleanup(); &#125; 这里写图片描述 多线程进程程序和进程简单多线程示例1234567891011121314151617181920212223#include &lt;windows.h&gt;#include &lt;iostream.h&gt; DWORD WINAPI Fun1Proc( LPVOID lpParameter //thread data ); void main() &#123; HANDLE hThread1; hThread1 = CreateThread(NULL, 0, Fun1Proc, NULL, 0, NULL); CloseHandle(hThread1); cout&lt;&lt;\"main thread is running\"&lt;&lt;endl; Sleep(10);//让主线程暂停运行，进入分线程 &#125; //线程1的入口函数 DWORD WINAPI Fun1Proc( LPVOID lpParameter //thread data ) &#123; cout&lt;&lt;\"thread1 is running\"&lt;&lt;endl; return 0; &#125; 交替运行：12345678910111213141516171819202122232425262728293031323334#include &lt;windows.h&gt;#include &lt;iostream.h&gt; DWORD WINAPI Fun1Proc( LPVOID lpParameter //thread data ); int index = 0; void main() &#123; HANDLE hThread1; hThread1 = CreateThread(NULL, 0, Fun1Proc, NULL, 0, NULL); CloseHandle(hThread1); while (index ++&lt; 100) &#123; cout&lt;&lt;\"main thread is running\"&lt;&lt;endl; &#125; //Sleep(10);//让主线程暂停运行，进入分线程 &#125; //线程1的入口函数 DWORD WINAPI Fun1Proc( LPVOID lpParameter //thread data ) &#123; while (index++&lt; 100) cout&lt;&lt;\"thread1 is running\"&lt;&lt;endl; return 0; &#125; 线程同步火车站售票系统模拟程序 由主线程创建的两个线程（1和2）负责销售火车票。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;windows.h&gt;#include &lt;iostream.h&gt; DWORD WINAPI Fun1Proc( LPVOID lpParameter //thread data ); DWORD WINAPI Fun2Proc( LPVOID lpParameter //thread data ); int index = 0; int tickets = 100; HANDLE hMutex; void main() &#123; HANDLE hThread1; HANDLE hThread2; //创建互斥对象 hMutex = CreateMutex(NULL, FALSE, NULL); //创建线程 hThread1 = CreateThread(NULL, 0, Fun1Proc, NULL, 0, NULL); hThread2 = CreateThread(NULL, 0, Fun2Proc, NULL, 0, NULL); CloseHandle(hThread1); CloseHandle(hThread2); Sleep(4000); &#125; //线程1的入口函数 DWORD WINAPI Fun1Proc( LPVOID lpParameter //thread data ) &#123; while (TRUE) &#123; WaitForSingleObject(hMutex, INFINITE);//实现线程同步 if (tickets &gt; 0) &#123; Sleep(1); cout&lt;&lt;\"thread1 sell ticket:\"&lt;&lt;tickets--&lt;&lt;endl; &#125; else break; ReleaseMutex(hMutex);//释放当前线程对互斥对象的所有权 &#125; return 0; &#125; //线程2的入口函数 DWORD WINAPI Fun2Proc( LPVOID lpParameter //thread data ) &#123; while (TRUE) &#123; WaitForSingleObject(hMutex,INFINITE); if (tickets &gt; 0) &#123; Sleep(1); cout&lt;&lt;\"thread2 sell ticket:\"&lt;&lt;tickets--&lt;&lt;endl; &#125; else break; ReleaseMutex(hMutex); &#125; return 0;&#125; 这时所销售的票号正常，没有看到销售了号码为0的票。 对互斥对象来说，谁拥有谁释放。 保证应用程序只有一个实例运行12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;windows.h&gt;#include &lt;iostream.h&gt; DWORD WINAPI Fun1Proc( LPVOID lpParameter //thread data ); DWORD WINAPI Fun2Proc( LPVOID lpParameter //thread data ); int index = 0; int tickets = 100; HANDLE hMutex; void main() &#123; HANDLE hThread1; HANDLE hThread2; //创建互斥对象(注意命名) hMutex = CreateMutex(NULL, FALSE, \"1\"); if (hMutex) &#123; if (ERROR_ALREADY_EXISTS == GetLastError()) &#123; cout&lt;&lt;\"only one instance can run!\"&lt;&lt;endl; return; &#125; &#125; //创建线程 hThread1 = CreateThread(NULL, 0, Fun1Proc, NULL, 0, NULL); hThread2 = CreateThread(NULL, 0, Fun2Proc, NULL, 0, NULL); CloseHandle(hThread1); CloseHandle(hThread2); WaitForSingleObject(hMutex, INFINITE); ReleaseMutex(hMutex); ReleaseMutex(hMutex); Sleep(4000); &#125; //线程1的入口函数 DWORD WINAPI Fun1Proc( LPVOID lpParameter //thread data ) &#123; while (TRUE) &#123; WaitForSingleObject(hMutex, INFINITE);//实现线程同步 if (tickets &gt; 0) &#123; Sleep(1); cout&lt;&lt;\"thread1 sell ticket:\"&lt;&lt;tickets--&lt;&lt;endl; &#125; else break; ReleaseMutex(hMutex);//释放当前线程对互斥对象的所有权 &#125; return 0; &#125; //线程2的入口函数 DWORD WINAPI Fun2Proc( LPVOID lpParameter //thread data ) &#123; while (TRUE) &#123; WaitForSingleObject(hMutex,INFINITE); if (tickets &gt; 0) &#123; Sleep(1); cout&lt;&lt;\"thread2 sell ticket:\"&lt;&lt;tickets--&lt;&lt;endl; &#125; else break; ReleaseMutex(hMutex); &#125; return 0;&#125; 网络聊天室程序的实现 新建一个基于对话框的工程，名为：Chat。 这里写图片描述 这里写图片描述 加载套接字库 在CChatApp类的InitInstance函数开始位置123456789BOOL CChatApp::InitInstance()&#123; if (!AfxSocketInit()) &#123; AfxMessageBox(\"加载套接字库失败！\"); return FALSE; &#125;……&#125; 在stdafx.h中，添加头文件#include &lt;Afxsock.h&gt;。 创建并初始化套接字1234567891011121314151617181920212223242526BOOL CChatDlg::InitSocket()&#123; //创建套接字 m_socket = socket(AF_INET, SOCK_DGRAM, 0); if (INVALID_SOCKET == m_socket) &#123; MessageBox(\"套接字创建失败！\"); return FALSE; &#125; SOCKADDR_IN addrSock; addrSock.sin_family = AF_INET; addrSock.sin_port = htons(7000); addrSock.sin_addr.S_un.S_addr = htonl(INADDR_ANY); int retval; //绑定套接字 retval = bind(m_socket, (SOCKADDR*)&amp;addrSock, sizeof(SOCKADDR)); if (SOCKET_ERROR == retval) &#123; closesocket(m_socket); MessageBox(\"绑定失败！\"); return TRUE; &#125; return TRUE;&#125; 123456789BOOL CChatDlg::OnInitDialog()&#123;…… // TODO: Add extra initialization here InitSocket(); return TRUE; // return TRUE unless you set the focus to a control&#125; 实现接收端功能 在CChatDlg类中定义：12345678/////////////////////////////////////////////////////////////////////////////// CChatDlg dialogstruct RECVPARAM&#123; SOCKET sock; //已创建的套接字 HWND hwnd; //对话框句柄&#125;; 在Chatdlg.h中添加：static DWORD WINAPI RecvProc(LPVOID lpParameter);在OnInitDialog()中添加：123456789101112131415161718BOOL CChatDlg::OnInitDialog()&#123;……// TODO: Add extra initialization here InitSocket(); RECVPARAM *pRecvParam = new RECVPARAM; pRecvParam-&gt;sock = m_socket; pRecvParam-&gt;hwnd = m_hWnd; //创建接收线程 HANDLE hThread = CreateThread(NULL, 0, RecvProc, (LPVOID)pRecvParam, 0, NULL); //关闭该接收程句柄，释放其引用计数 CloseHandle(hThread); return TRUE; // return TRUE unless you set the focus to a control&#125; 在CChatDlg类中添加：1234DWORD WINAPI CChatDlg::RecvProc(LPVOID lpParameter)&#123; return 0;&#125; 若要求采用完全面向对象的思想来编程，不能使用全局函数和全局变量了，可以采用静态成员函数和静态成员变量的方法来解决。 123456789101112131415161718192021222324DWORD WINAPI CChatDlg::RecvProc(LPVOID lpParameter)&#123; //获取主线程传递的套接字和窗口句柄 SOCKET sock = ((RECVPARAM*)lpParameter)-&gt;sock; HWND hwnd = ((RECVPARAM*)lpParameter)-&gt;hwnd; delete lpParameter; SOCKADDR_IN addrFrom; int len = sizeof(SOCKADDR); char recvBuf[200]; char tempBuf[300]; int retval; while(TRUE) &#123; //接收数据 retval = recvfrom(sock, recvBuf, 200, 0, (SOCKADDR*)&amp;addrFrom, &amp;len); if (SOCKET_ERROR == retval) break; sprintf(tempBuf, \"%s 说： %s\", inet_ntoa(addrFrom.sin_addr), recvBuf); ::PostMessage(hwnd, WM_RECVDATA, 0, (LPARAM)tempBuf); &#125; return 0;&#125; 在该类添加头文件 #define WM_RECVDATA WM_USER+1 在CChatDlg类头文件中编写该消息响应函数原型的声明：123456789// Generated message map functions//&#123;&#123;AFX_MSG(CChatDlg)virtual BOOL OnInitDialog();afx_msg void OnSysCommand(UINT nID, LPARAM lParam);afx_msg void OnPaint();afx_msg HCURSOR OnQueryDragIcon();//&#125;&#125;AFX_MSGafx_msg void OnRecvData(WPARAM wParam, LPARAM lParam);DECLARE_MESSAGE_MAP() 在CChatDlg类的源文件中添加WM_RECVDATA消息映射。12345678BEGIN_MESSAGE_MAP(CChatDlg, CDialog) //&#123;&#123;AFX_MSG_MAP(CChatDlg) ON_WM_SYSCOMMAND() ON_WM_PAINT() ON_WM_QUERYDRAGICON() //&#125;&#125;AFX_MSG_MAP ON_MESSAGE(WM_RECVDATA, OnRecvData)END_MESSAGE_MAP() 在构造函数中123456789101112void CChatDlg::OnRecvData(WPARAM wParam, LPARAM lParam)&#123; //取出接收到的数据 CString str = (char*)lParam; CString strTemp; //获得已有数据 GetDlgItemText(IDC_EDIT_RECV, strTemp); str += \"\\r\\n\"; str += strTemp; //显示所有接收到的数据 SetDlgItemText(IDC_EDIT_RECV, str);&#125; 实现发送端功能双击发送，添加响应函数。123456789101112131415161718192021void CChatDlg::OnBtnSend() &#123; //获取对方IP// TODO: Add your control notification handler code here DWORD dwIP; ((CIPAddressCtrl*)GetDlgItem(IDC_IPADDRESS1))-&gt;GetAddress(dwIP); SOCKADDR_IN addrTo; addrTo.sin_family = AF_INET; addrTo.sin_port = htons(7000); addrTo.sin_addr.S_un.S_addr = htonl(dwIP); CString strSend; //获得待发送数据 GetDlgItemText(IDC_EDIT_SEND, strSend); //发送数据 sendto(m_socket, strSend, strSend.GetLength()+1, 0, (SOCKADDR*)&amp;addrTo, sizeof(SOCKADDR)); //清空发送编辑框中的内容 SetDlgItemText(IDC_EDIT_SEND, \"\");&#125; 为了让编辑框控件接受换行符，必须设置该控件支持多行数据这一属性。 这里写图片描述 将“发送”设置为Default button，还可以选择取消Visible选项。 本例在一个程序中同时实现了接收端和发送端的功能，所以只需在聊天双方各自的机器上安装本程序，在聊天时，通过输入对方主机的IP地址，就可以与对方进行通信了。 ActiveX控件ActiveX控件OCX是ActiveX控件的一种后缀名。但ActiveX控件对应的文件也可以是其他后缀名，例如DLL。作为一个典型的ActiveX控件，它具有方法、属性、事件这三种特性。在一个文件中可以包含多个ActiveX控件。 MFC ActiveX ControlWizard动态链接库 动态链接库有两种加载方式：隐式链接和显式加载 Win32 DLL的创建和使用 新建一个Win32 Dynamic-Link Library类型的工程，取名为Dll1。并在AppWizard的第一步选择“An empty Dll project”，即创建一个空的动态链接库工程。然后添加一个C++源文件：Dll1.cpp。添加代码：123456789int add(int a, int b)&#123; return a + b;&#125;int subtract(int a, int b)&#123; return a - b;&#125; Build生成Dll1程序。在该工程的Debug目录下，可看到一个Dll1.dll文件，这就是生成的动态链接库文件。 Dumpbin命令 应用程序如果想要访问某个DLL中的函数，那么该函数必须是已经被导出的函数。为了查看有哪些导出函数，可以用VS提供的命令行工具：Dumpbin实现。 从DLL中导出函数 为导出函数，需在每一个将被导出的函数前添加标识符：_declspec(dllexport)。修改上述代码：123456789_declspec(dllexport) int add(int a, int b)&#123; return a + b;&#125;_declspec(dllexport) int subtract(int a, int b)&#123; return a - b;&#125; 编译后可看到又生成了两个新文件，Dll1.lib，它保存Dll1.dll中导出的函数和变量的符号名。以及DALL1.EXP文件。 隐式链接方式加载DLL 编写一个测试程序测试这个动态链接库。新建一个基于对话框的MFC应用程序，取名DllTest，放置两个按钮，ID和Caption分别为：IDC_BTN_ADD，Add，IDC_BTN_SUBTRACT，Subtract。 利用extern声明外部函数 为让编译器知道这两个函数，需作出声明，注意放在OnBtnAdd函数和OnBtnSubtract函数前面。123456789101112131415161718extern int add(int a, int b);extern int subtract(int a, int b);void CDllTestDlg::OnBtnAdd() &#123; // TODO: Add your control notification handler code here CString str; str.Format(\"5 + 3 = %d\", add(5, 3)); MessageBox(str);&#125;void CDllTestDlg::OnBtnSubtract() &#123; // TODO: Add your control notification handler code here CString str; str.Format(\"5 - 3 = %d\", subtract(5, 3)); MessageBox(str);&#125; Build后报错：123456789101112131415--------------------Configuration: DllTest - Win32 Debug--------------------Compiling resources...Compiling...StdAfx.cppCompiling...DllTest.cppDllTestDlg.cppGenerating Code...Linking...DllTestDlg.obj : error LNK2001: unresolved external symbol \"int __cdecl add(int,int)\" (?add@@YAHHH@Z)DllTestDlg.obj : error LNK2001: unresolved external symbol \"int __cdecl subtract(int,int)\" (?subtract@@YAHHH@Z)Debug/DllTest.exe : fatal error LNK1120: 2 unresolved externals执行 link.exe 时出错.DllTest.exe - 1 error(s), 0 warning(s) 可看到编译成功，错误发生在链接时。为解决该问题，需利用动态链接库的引入库文件。 在Dll1.dll文件所在目录下，复制Dll1.lib文件，并将其复制到DllTest程序所在目录下，这个文件中就包含了Dll1.dll中导出函数的符号名。 然后在DllTest中，选择Porject\\Settings\\link，在Object/library modules中输入dll1.lib。 再次编译，成功生成DllTest.exe文件。 （可利用dumpbin -imports dlltest.exe查看输入信息） 运行程序，弹出报错对话框： 报错 将Dll1.dll放置在DllTest工程所在目录下，就好了。 效果如图。 效果 Depends工具 在Microsoft Visual Studio\\Common\\Tools中有一个DEPENDS.EXE，该工具可以查看可执行程序，还可以查看动态链接库，主要是看它们依赖于哪些动态链接库。 打开该工具，单击File\\Open，选择DllText.exe，将会看到： DEPENDS DllTest程序需访问Dll1.dll这一动态链接库，但该文件名前有一个问号，说明没有找到Dll1.dll这个动态链接库。这是因为前面将动态链接库文件放在了\\DllTest\\Debug目录的上一级目录下了。这里，可将Dll1.dll文件再复制到\\DllTest\\Debug目录下，然后重启Depends工具。这时问号就没有了。（因为Dll1.dll与DllTest.exe位于同一目录，在打开DllTest.exe时，就可找到该动态链接库。） 成功 利用_declspec(dllimport)声明外部函数 除了使用extern关键字表明函数是外部定义的之外，还可以使用标识符：_declspec(dllimport)来表明函数是从动态链接库中引入的。将之前的extern声明注释起来。添加：12_declspec(dllimport) int add(int a, int b);_declspec(dllimport) int subtract(int a, int b); 若调用的函数来自于动态链接库，应采用这种方式声明外部函数，编译器可以生成运行效率更高的代码。 完善Win32 DLL例子 为知道DLL有哪些导出函数，通常在编写动态链接库时，会提供一个头文件，在此提供DLL导出函数原型的声明，以及函数有关注释文档。 为DLL1工程添加一个头文件：Dll1.h，并添加代码12_declspec(dllimport) int add(int a, int b);_declspec(dllimport) int subtract(int a, int b); 然后将DllTestDlg.cpp先前添加的声明语句注释起来，并在前部添加下面的语句：1#include \"dll1.h\" Build并运行，结果和之前一样。 所以在发布Dll1.dll动态链接库时，可将Dll1.h头文件一起提供给使用者。 下面对Dll.h进行改造，使其不仅能为调用动态链接库的客户端程序服务，也能由动态链接库程序自身来使用。修改头文件：1234567#ifdef DLL1_API#else#define DLL1_API _declspec(dllimport)#endif_declspec(dllimport) int add(int a, int b);_declspec(dllimport) int subtract(int a, int b); 修改Dll1.cpp123456789101112#define DLL1_API _declspec(dllexport)#include \"Dll1.h\"int add(int a, int b)&#123; return a + b;&#125;int subtract(int a, int b)&#123; return a - b;&#125; 将重新生成的文件复制，运行，结果也是正确的。 从DLL中导出C++类 在一个动态链接库中还可以导出一个C++类。 在Dll1.h中添加如下代码： 12345class DLL1_API Point&#123;public: void output(int x, int y);&#125;; 在Dll1.cpp中改为：1234567891011121314151617181920212223242526272829#define DLL1_API _declspec(dllexport)#include \"Dll1.h\"#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;int add(int a, int b)&#123; return a + b;&#125;int subtract(int a, int b)&#123; return a - b;&#125;void Point::output(int x, int y)&#123; //返回调用者进程当前正在使用的那个窗口的句柄 HWND hwnd = GetForegroundWindow(); //获取DC HDC hdc = GetDC(hwnd); char buf[20]; memset(buf, 0, 20); sprintf(buf, \"x = %d, y = %d\", x, y); //输出坐标 TextOut(hdc, 0, 0, buf, strlen(buf)); //释放DC ReleaseDC(hwnd, hdc);&#125; 将Dll1.dll和Dll1.lib复制到测试工程DllTest所在目录下（本例将对应Dll1.h也放在了DllTest项目工程下，所以Dll1.h也应相应复制过来）。为避免麻烦，也可以把动态链接库文件所在目录添加到系统的环境变量Path中。这样就无需复制。 为测试这个新生成的DLL，打开DllTest工程，在对话框中增加一个按钮，属性为IDC_BTN_OUTPUT，Capition为Output。双击按钮添加响应函数OnBtnOutput。 123456void CDllTestDlg::OnBtnOutput() &#123; // TODO: Add your control notification handler code here Point pt; pt.output(5, 3);&#125; 记得删除Debug下的旧Dll1.dll，放入新的，否则会报错。 Output 可利用Dumpbin命令的exports选项查看Dll1.dll这一动态链接库的导出情况，利用imports选项查看测试程序的导入情况。 另外，在实现动态链接库时，可以不导出整个类，而只导出该类中的某些函数。打开Dll1工程，在Dll1.h中将声明Point类时使用的DLL1_API宏注释起来，然后在output函数的声明前放置DLL1_API宏。这样就表示只导出Point类中的成员函数output。为证实这一点，为Point类再添加一个成员函数test，123456class /*DLL1_API*/ Point&#123;public: void DLL1_API output(int x, int y); void test();&#125;; 接着在Dll1.cpp中添加test函数的实现：123void Point::test()&#123;&#125; Build后，利用dumpbin命令的exports可查看Dll1.dll的导出信息。可将所需文件再次复制到DllTest工程中，运行结果和之前相同。在导出类的成员函数时，该函数必须具有public类型的访问权限，否则即使能被导出也不能被其他程序访问。 解决名字改编问题C++编译器在生产厂DLL时，会对导出的函数进行名字改编，由于不同编译器改编规则不同，所以改编后名字不同。若利用不同编译器分别生成DLL和访问该DLL的客户端程序时，后者在访问该DLL的导出函数时就会出现问题。因此希望动态链接库在编译时，导出函数的名称不要发生改变。为此，在定义导出函数时，需加上限定符：extern “C”。C一定要大写。打开Dll1工程，找到Dll1.cpp和Dll1.h中定义DLL1_API宏的代码，添加限定符。此时，Dll1.h为1234567891011121314#ifdef DLL1_API#else#define DLL1_API extern \"C\" _declspec(dllimport)#endifDLL1_API int add(int a, int b);DLL1_API int subtract(int a, int b);/*class Point&#123;public: void DLL1_API output(int x, int y); void test();&#125;;*/ Dll1.cpp为1234567891011121314151617181920212223242526272829303132333435#define DLL1_API extern \"C\" _declspec(dllexport)#include \"Dll1.h\"#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;int add(int a, int b)&#123; return a + b;&#125;int subtract(int a, int b)&#123; return a - b;&#125;/*void Point::output(int x, int y)&#123; //返回调用者进程当前正在使用的那个窗口的句柄 HWND hwnd = GetForegroundWindow(); //获取DC HDC hdc = GetDC(hwnd); char buf[20]; memset(buf, 0, 20); sprintf(buf, \"x = %d, y = %d\", x, y); //输出坐标 TextOut(hdc, 0, 0, buf, strlen(buf)); //释放DC ReleaseDC(hwnd, hdc);&#125;void Point::test()&#123;&#125;*/ Build后生成Dll1.dll，用dumpbin命令的exports选项查看该动态链接库的导出信息，发现add和subtract函数名没有被改编。然后利用DllTest工程测试，将Point类的代码注释起来，将发现客户端可访问Dll1中的导出函数。 缺陷：extern “C”只能导出全局函数，不能导出一个类的成员函数。另外，如果导出函数的调用约定发生了改变，即使使用了extern “C”，函数名仍会发生改编。例如，在Dll1.h中add和subtract函数添加_stdcall关键字标准调用约定。1234567#ifdef DLL1_API#else#define DLL1_API extern \"C\" _declspec(dllimport)#endifDLL1_API _stdcall int add(int a, int b);DLL1_API _stdcall int subtract(int a, int b); 在Dll1.cpp中1234567891011121314#define DLL1_API extern \"C\" _declspec(dllexport)#include \"Dll1.h\"#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;int _stdcall add(int a, int b)&#123; return a + b;&#125;int _stdcall subtract(int a, int b)&#123; return a - b;&#125; 没有_stdcall关键字，函数的调用约定就是C调用约定，标准调用约定是WINAPI调用约定，与C调用约定不同。Build后生成最新Dll1.dll，利用Dumpbin的exports选项查看该动态链接库的导出情况，可看到名字变为_add@8。 这种情况下，可通过模型定义文件（DEF）的方式来解决名字改编问题。新建一个Win32 Dynamic-Link Library类型的工程，取名为Dll2，在AppWizard第一步选择“An empty Dll project”选项。添加Dll2.cpp，12345678int add(int a, int b)&#123; return a + b;&#125;int subtract(int a, int b)&#123; return a - b;&#125; 在Dll2工程目录下新建一个空文本文件，改后缀为.def，添加到工程Source文件并打开：12345LIBRARY Dll2EXPORTSaddsubtract Bulid后利用Dumpbin的exports查看证明没有发生名字改编。 显示加载方式加载DLL将最新的Dll2.dll复制到DllTest工程目录下。将DllTestDlg.cpp包含Dll1.h的那行代码注释起来，在link选项卡上删除对Dll1.lib的链接。需用到LoadLibrary函数。 To be continued… 听听那冷雨","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hubojing.github.io/categories/编程语言/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://hubojing.github.io/tags/CPP/"},{"name":"MFC","slug":"MFC","permalink":"https://hubojing.github.io/tags/MFC/"}]},{"title":"多说关闭引发的麻烦","slug":"多说关闭引发的麻烦","date":"2017-04-05T08:44:21.000Z","updated":"2018-03-29T12:51:07.000Z","comments":true,"path":"2017/04/05/多说关闭引发的麻烦/","link":"","permalink":"https://hubojing.github.io/2017/04/05/多说关闭引发的麻烦/","excerpt":" 　　　　　关于评论系统的折腾经。　　　　","text":"关于评论系统的折腾经。 2018.3.29 更新最新，已更换到valine评论系统。 我以为短期内我不可能再更新这篇文章了。没想到…… 2017.7.9 网页云跟帖停止服务 跟帖关闭 此刻我只想说：哈哈哈哈哈哈哈哈！ 跟帖服务跟不上，最终还是被畅言玩死了。幸好早早换了disqus。 同时，为这个商业社会默哀一秒钟。 2017.7.3 disqus不用翻墙即可评论 不审核，直接显示。并且，可以回访！ 这次折腾好后短期内应该不会再弄评论框了 专注工作专注工作 墙内换成网易云跟帖后，评论量就跳水式下降，仿佛被打入冷宫？加上跟帖各种缺陷，还是用disqus吧，刚好听说了可以不翻墙就能用的方法，遂试之。 之前的600条评论又只能暂以json的形式躺在电脑里了。为什么大家的格式都不一样呢？这真的很不和谐，很不！和！谐！！ 登录服务器我用的xshell，ssh连接服务器。我的服务器是DigitalOcean买的 512M的……(它已经被闲置了三个月了，心疼money)详见DigitalOcean购买服务器教程 安装面板在服务器上安装宝塔Linux面板1yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install.sh &amp;&amp; sh install.sh 然后在浏览器中打开面板。 新建站点在网站中添加站点，输入一个域名。（可勾选FTP） 配置API利用 PHP cURL 转发 Disqus API 请求 ，将文件clone到本地。在config中按要求配置。 将API打包上传到面板，解压。再将dist文件夹下的两个文件上传上去。 域名解析接着打开解析博客的地址，我用的腾讯云。DNSPOD 添加域名。主机记录填对应的新建的站点名（不带网站一级域名），记录类型A，记录值为服务器地址。 disqus配置disqus后台中勾选允许匿名评论。 修改主题中评论文件完工。 部署时，12345678fatal: Unable to create &apos;E:/hexo/.deploy_git/.git/index.lock&apos;: File exists.Another git process seems to be running in this repository, e.g.an editor opened by &apos;git commit&apos;. Please make sure all processesare terminated then try again. If it still fails, a git processmay have crashed in this repository earlier:remove the file manually to continue.FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html 解决：删除对应的index.lock。 2017.5.27 已更换为Disqus 由于Disqus被墙，可能需要科学上网后才能看到评论。若墙内的朋友们需要评论，可以直接点击QQ图标（PC端在左边栏，移动端在页面上方），和我进行在线对话。 2017.5.30 已导入历史评论 虽然比不上多说，比网易云跟帖还是好很多了。目前发现有一篇文章的评论导入失败，Disqus的显示如下：Missing or invalid message 或 Unable to find parent post我再看看怎么解决，是否需要手工导入。参考：多说评论迁移至Disqus 多说八百年不发邮件通知我有评论，在我换为网易云跟帖后，竟然邮件通知我有评论了！ 多说关闭带来的评论区何去何从让我颇为困扰。现在能用的大概只有这些：畅言（需备案）、网易云跟帖（github.io不支持）、友言（也有倒闭趋势）、来必力（韩国）。 没有一个像多说这样好用的！ 虽然多说也有很多问题，但它至少解决了核心问题：1.评论显示正确的网友名称。来看看我换上网易云跟帖后的效果： 网易云跟帖 都是有态度网友…… 我压根分不清谁是谁！ 2.点击头像可以回访人家的独立博客。这一点真的很重要，这往往是我们小众的独立博客人交朋友的主要途径啊！ 3.可以自定义。头像旋转、评论框自定义，真的可以很好看。这些跟帖做不到。 4.盖楼模式多样。而跟帖只能一种，我不太喜欢，重复率太高，我还是喜欢多说的嵌套。 多说名字没起好啊！多说无益必自毙→_→先换回多说吧，再等一个月看看。","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/tags/杂谈/"}]},{"title":"DigitalOcean购买服务器教程","slug":"DigitalOcean购买服务器教程","date":"2017-03-28T13:50:20.000Z","updated":"2017-03-28T13:50:20.000Z","comments":true,"path":"2017/03/28/DigitalOcean购买服务器教程/","link":"","permalink":"https://hubojing.github.io/2017/03/28/DigitalOcean购买服务器教程/","excerpt":"GitHub教育礼包有50美金优惠券，加上朋友的链接送的10美金，自己充值的5美金，正好可以买一个服务器用一年了。　　 ","text":"GitHub教育礼包有50美金优惠券，加上朋友的链接送的10美金，自己充值的5美金，正好可以买一个服务器用一年了。 步骤注册、优惠码1.点击https://m.do.co/c/9d7b9b7b94ba/ 进入DigitalOcean注册。（通过以上链接，你可以多获得10美金！同时，我也将得到10美金。） 注册时，需要支付5美金完成支付，最好用paypal支付（可以去注册一个账号），最好不要用信用卡（土豪可以用……）。 2.点击头像下的Setting，再点击右侧的Billing Billing 3.输入教育礼包优惠码 Promo code 注意：很有可能显示“ Account not eligible to use this promo code.”可能滥用优惠码却不是学生的人太多，DO加强了监管，审查比较严格。反正我的是没有通过。于是，需要向客服反映情况。点击Support， Support 点击Create ticket，把你的情况写清楚，最好说明你是学生，并附带你的优惠码。之后官方会帮你搞定。（在三小时后就处理好了我的） 购买服务器点击创建Droplet， Create Droplet 服务器价格 学生……穷啊……只能买最便宜的……这样刚好可以用一年。 选择服务器系统 选择centos6.8x64 选择地址 旧金山比较快。 可选项 这个的第一个和第三个可以选，最好不选第三个。 改名 改名 点击create，服务器购买成功。DO会给你发送一封带有初始密码的邮件。 使用下载puTTY或xshell。puTTY puTTY 我以shell为例， 初始页 新建会话。 属性 IP地址填你的服务器IP，接受并保存你的主机密钥。输入用户名。输入初始密码。再修改密码。（密码最好复杂一点） 完成。可以愉快地使用你的服务器啦！ 致谢感谢小忆的耐心指导和大力帮助！","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"https://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"备忘","slug":"备忘","permalink":"https://hubojing.github.io/tags/备忘/"}]},{"title":"更换为.me域名教程","slug":"更换为.me域名教程","date":"2017-03-26T13:01:21.000Z","updated":"2017-03-26T13:01:21.000Z","comments":true,"path":"2017/03/26/更换为.me域名教程/","link":"","permalink":"https://hubojing.github.io/2017/03/26/更换为.me域名教程/","excerpt":"既然申请得到Github教育礼包，就应开始使用。我的博客是基于Hexo搭建于Github的博客，原域名：http://hubojing.github.io/ ，现在的新域名是 http://www.hubojing.me/ 。　　　 ","text":"既然申请得到Github教育礼包，就应开始使用。我的博客是基于Hexo搭建于Github的博客，原域名：http://hubojing.github.io/ ，现在的新域名是 http://www.hubojing.me/ 。 注册.me域名1.打开教育礼包中的namecheap优惠页面https://nc.me/，使用你的github账号登录。 登录 登陆后，显示已成功。 成功 搜索你想要的域名。 查询页面 2.如果该域名未被注册，那么你可以注册该域名。 注册页面 点击ADD。 付款 点击Complete Order。 详情 点击下方的Finish Up完成注册，这样该域名就属于你了。 紧接着，会要求你登录你的namecheap账号，如果之前没有用过该网站，就点register注册一个账号。 注册 注册完成后，是以下的页面显示。 注册完成 在和你的Github账户绑定在一起： 绑定成功 这样.me域名注册就算是全部完成了。 域名管理打开网址http://www.namecheap.com/，登录自己的账户。点击Domain List， 点击 你将看到域名列表。 域名列表 由于国外的DNS可能很慢，于是最好托管到国内的服务商来。我选择的是腾讯云。 转移到腾讯云进入https://www.dnspod.cn/，注册新账号（可以用QQ、微信等直接登录免注册）。 点击添加域名，将刚才的.me域名输入。保存。 添加域名 控制台全局外观： 控制台 再回到namecheap控制台，修改NAMESERVERS，选择Custom DNS，如图。 修改DNS 需要等待一会儿才能成功。（最晚48h，我就等了几分钟就好了。） 成功提示 回到腾讯云，域名是红的。 红色 点击进去看看，再返回，等待一下，再刷新。变成蓝色，说明已经更新成功了。 点击进入，点击添加记录， 添加记录 保存。 GitHub博客项目设置进入项目页（是博客项目页，非个人资料页），点击Setting， GitHub Pages 将Custom domain改为你刚才解析的域名，比如我的 www.hubojing.me ，点击Save保存。 保存成功 大功告成！你的新域名已能正常使用，并且也能通过旧域名自动跳转到新域名！（记得重启浏览器，或者使用IE或Edge浏览器打开查看效果！） 大功告成 致谢感谢 小忆 在我更换域名时提供的大力帮助！","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"https://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"域名","slug":"域名","permalink":"https://hubojing.github.io/tags/域名/"}]},{"title":"Github教育礼包","slug":"Github教育礼包","date":"2017-03-25T03:21:23.000Z","updated":"2017-03-25T03:21:23.000Z","comments":true,"path":"2017/03/25/Github教育礼包/","link":"","permalink":"https://hubojing.github.io/2017/03/25/Github教育礼包/","excerpt":"　感谢小伙伴让我知道github教育礼包，并告诉我如何申请。 ","text":"感谢小伙伴让我知道github教育礼包，并告诉我如何申请。 到教育优惠页面申请：https://education.github.com/ 填写学校信息及申请理由，如果有edu邮箱一般很快就通过了；如果没有，需要提供证件来证明。 一般来说一小时到几天就申请成功了。（我当天晚上收到了邮件）有用的主要三个东西： me域名免费一年 DO的免费VPS代金券50美金（有效期1年），可以使用最低配置11个月 免费SSL证书 收到的邮件（截取片段）：If you need help getting started with Git and GitHub, check out: https://help.github.com/articles/good-resources-for-learning-git-and-github We’ve also given you access to the Student Developer Pack, available at: https://education.github.com/pack If you have any questions, contact us: https://education.github.com/contact Spread the word: we love giving educational discounts to students, teachers, administrators, and researchers! Please send them to: https://education.github.com Have an Octotastic day!（这个 Octotastic 我不造是什么意思……词典也没这个词 望大神解答） My Pack: ATOM A hackable text editor for the 21st Century来自21世纪的可定制文本编辑器免费使用 aws educate Access to the AWS cloud, free training, and collaboration resourcesAWS云，免费教程和资源。 bitnami Install cloud applications in a single click轻松安装云应用 CARTO An open and powerful platform for spatial data analysis, visualization, and application creation.一个开放有力的空间、视觉、应用创建数据分析平台。 CrowdFlower Crowdsourcing and data enrichment platform众包与数据富集平台 DATADOG Cloud-based infrastructure monitoring云基础设施监控 DigitalOcean Simple cloud hosting, built for developers简单云托管，为开发者而生 dnsimple Simple DNS management with one-click services and a robust API简单的DNS管理，包括一键服务和强大的API FLATIRON SCHOOL Learn Web Development from the premier coding bootcamp for launching developers.从最开始的代码集训营开始学习Web开发成为开发者。 Github Powerful collaboration, code review, and code management强大的协作、代码审查和代码管理 GitKraken The downright luxurious Git client for Windows, Mac and LinuxWindows，Mac和Linux上的超级豪华Git客户端 HACKHANDS Live programming help available 24/7编程帮助 Microsoft Imagine A suite of Microsoft Azure cloud services and developer tools, including the Visual Studio IDE一套微软Azure的云服务和开发工具，包括Visual Studio IDE namecheap Affordable registration, hosting, and domain management便宜的注册，托管和域管理 SendGrid Email infrastructure as a service电子邮件基础设施服务 stripe Web and mobile payments, built for developers网络和移动支付，为开发者而生 TAPLYTICS Dynamic A/B testing, smart push notifications and custom analytics for native mobile apps动态A / B测试，智能推送通知和自定义分析本地移动应用程序 transifex Localization platform that easily integrates with your code base易于与代码库集成的本地化平台 Travis CI Continuous integration platform for open source and private projects开源和私有项目的连续集成平台 UDACITY Enroll in a Nanodegree program, and launch your career in Web and Mobile Development, Machine Learning, Data Science, and more. Enroll in a Nanodegree program, and launch your career in Web and Mobile Development, Machine Learning, Data Science, and more.报名参加一个nanodegree项目，在Web、移动开发、机器学习、数据科学以及等多方面，开启你的职业生涯。 UNREAL A complete suite of game development tools for PC, console, mobile, web and VR一套完整的游戏开发工具，用于PC，控制台，移动，网络和虚拟现实 正在学习其中一些工具的使用中……未完待续。","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"https://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://hubojing.github.io/tags/Github/"}]},{"title":"简易计算器（Android）","slug":"制作简易计算器APP（线性结构）","date":"2017-03-21T16:19:25.000Z","updated":"2017-03-30T15:54:22.000Z","comments":true,"path":"2017/03/22/制作简易计算器APP（线性结构）/","link":"","permalink":"https://hubojing.github.io/2017/03/22/制作简易计算器APP（线性结构）/","excerpt":"安卓端简易计算器APP实现。","text":"安卓端简易计算器APP实现。 目标制作简易计算器（Android）。 思路第一步：页面布局第二步：事件监听以及实现运算 成品 简易计算器 代码MainActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206package com.example.calculator;import android.app.Activity;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;public class MainActivity extends Activity implements OnClickListener&#123; Button btn_0;//0按钮 Button btn_1;//1按钮 Button btn_2;//2按钮 Button btn_3;//3按钮 Button btn_4;//4按钮 Button btn_5;//5按钮 Button btn_6;//6按钮 Button btn_7;//7按钮 Button btn_8;//8按钮 Button btn_9;//9按钮 Button btn_point;//小数点按钮 Button btn_clear;//清除按钮 Button btn_del;//删除按钮 Button btn_plus;//加按钮 Button btn_minus;//减按钮 Button btn_multiply;//乘按钮 Button btn_divide;//除按钮 Button btn_equal;//等号按钮 EditText et_input;//显示输入内容的显示屏 boolean clear_flag;//清空标识 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); btn_0 = (Button) findViewById(R.id.btn_0); btn_1 = (Button) findViewById(R.id.btn_1); btn_2 = (Button) findViewById(R.id.btn_2); btn_3 = (Button) findViewById(R.id.btn_3); btn_4 = (Button) findViewById(R.id.btn_4); btn_5 = (Button) findViewById(R.id.btn_5); btn_6 = (Button) findViewById(R.id.btn_6); btn_7 = (Button) findViewById(R.id.btn_7); btn_8 = (Button) findViewById(R.id.btn_8); btn_9 = (Button) findViewById(R.id.btn_9); btn_point = (Button) findViewById(R.id.btn_point); btn_clear = (Button) findViewById(R.id.btn_clear); btn_del = (Button) findViewById(R.id.btn_del); btn_plus = (Button) findViewById(R.id.btn_plus); btn_minus = (Button) findViewById(R.id.btn_minus); btn_multiply = (Button) findViewById(R.id.btn_multiply); btn_divide = (Button) findViewById(R.id.btn_divide); btn_equal = (Button) findViewById(R.id.btn_equal); //以上是实例化按钮 et_input=(EditText)findViewById(R.id.et_input);//实例化显示屏 btn_0.setOnClickListener(this); btn_1.setOnClickListener(this); btn_2.setOnClickListener(this); btn_3.setOnClickListener(this); btn_4.setOnClickListener(this); btn_5.setOnClickListener(this); btn_6.setOnClickListener(this); btn_7.setOnClickListener(this); btn_8.setOnClickListener(this); btn_9.setOnClickListener(this); btn_point.setOnClickListener(this); btn_clear.setOnClickListener(this); btn_del.setOnClickListener(this); btn_plus.setOnClickListener(this); btn_minus.setOnClickListener(this); btn_multiply.setOnClickListener(this); btn_divide.setOnClickListener(this); btn_equal.setOnClickListener(this); //以上设置按钮的点击事件 &#125; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub String str =et_input.getText().toString(); switch (v.getId()) &#123; case R.id.btn_0: case R.id.btn_1: case R.id.btn_2: case R.id.btn_3: case R.id.btn_4: case R.id.btn_5: case R.id.btn_6: case R.id.btn_7: case R.id.btn_8: case R.id.btn_9: case R.id.btn_point: if(clear_flag)&#123; clear_flag=false; str=\"\"; et_input.setText(\"\"); &#125; et_input.setText(str+((Button)v).getText()); break; case R.id.btn_plus: case R.id.btn_minus: case R.id.btn_multiply: case R.id.btn_divide: if(clear_flag)&#123; clear_flag=false; str=\"\"; et_input.setText(\"\"); &#125; et_input.setText(str+\" \"+((Button)v).getText()+\" \"); break; case R.id.btn_clear: clear_flag=false; str=\"\"; et_input.setText(\"\"); break; case R.id.btn_del: if(clear_flag)&#123; clear_flag=false; str=\"\"; et_input.setText(\"\"); &#125;else if(str!=null&amp;&amp;!str.equals(\"\"))&#123; et_input.setText(str.substring(0, str.length()-1)); &#125; break; case R.id.btn_equal: getResult(); break; &#125; &#125; /** * 运算结果 */ private void getResult()&#123; String exp=et_input.getText().toString(); if(exp==null||exp.equals(\"\"))&#123; return; &#125; if(!exp.contains(\" \"))&#123; return; &#125; if(clear_flag)&#123; clear_flag=false; return; &#125; clear_flag=true; double result=0; String s1=exp.substring(0, exp.indexOf(\" \"));//运算符前面的字符串 String op=exp.substring(exp.indexOf(\" \")+1, exp.indexOf(\" \")+2);//运算符 String s2=exp.substring(exp.indexOf(\" \")+3);//运算符后面的字符串 if(!s1.equals(\"\")&amp;&amp;!s2.equals(\"\"))&#123; double d1=Double.parseDouble(s1); double d2=Double.parseDouble(s2); if(op.equals(\"+\"))&#123; result=d1+d2; &#125;else if(op.equals(\"-\"))&#123; result=d1-d2; &#125;else if(op.equals(\"×\"))&#123; result=d1*d2; &#125;else if(op.equals(\"÷\"))&#123; if(d2==0)&#123; result=0; &#125;else&#123; result=d1/d2; &#125; &#125; if(!s1.contains(\".\")&amp;&amp;!s2.contains(\".\")&amp;&amp;!op.equals(\"÷\"))&#123; int r=(int)result; et_input.setText(r+\"\"); &#125;else&#123; et_input.setText(result+\"\"); &#125; &#125;else if(!s1.equals(\"\")&amp;&amp;s2.equals(\"\"))&#123; et_input.setText(exp); &#125;else if(s1.equals(\"\")&amp;&amp;!s2.equals(\"\"))&#123; double d2=Double.parseDouble(s2); if(op.equals(\"+\"))&#123; result=0+d2; &#125;else if(op.equals(\"-\"))&#123; result=0-d2; &#125;else if(op.equals(\"×\"))&#123; result=0; &#125;else if(op.equals(\"÷\"))&#123; result=0; &#125; if(!s2.contains(\".\"))&#123; int r=(int)result; et_input.setText(r+\"\"); &#125;else&#123; et_input.setText(result+\"\"); &#125; &#125;else&#123; et_input.setText(\"\"); &#125; &#125;&#125; activity_main.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" tools:context=\"com.example.calculator.MainActivity\" &gt; &lt;EditText android:layout_width=\"fill_parent\" android:layout_height=\"60dip\" android:id=\"@+id/et_input\" android:editable=\"false\" android:gravity=\"right|bottom\" android:background=\"@drawable/white_bg\" /&gt; &lt;LinearLayout android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"20dp\" android:orientation=\"horizontal\" android:gravity=\"center_horizontal\" &gt; &lt;Button android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:text=\"C\" android:paddingRight=\"10dp\" android:paddingBottom=\"10dp\" android:background=\"@drawable/white_selector\" android:textSize=\"20sp\" android:gravity=\"right|bottom\" android:id=\"@+id/btn_clear\" /&gt; &lt;Button android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:text=\"DEL\" android:paddingRight=\"10dp\" android:paddingBottom=\"10dp\" android:background=\"@drawable/white_selector\" android:layout_marginLeft=\"10dp\" android:textSize=\"20sp\" android:gravity=\"right|bottom\" android:id=\"@+id/btn_del\" /&gt; &lt;Button android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:text=\"÷\" android:paddingRight=\"10dp\" android:paddingBottom=\"10dp\" android:background=\"@drawable/white_selector\" android:layout_marginLeft=\"10dp\" android:textSize=\"20sp\" android:gravity=\"right|bottom\" android:id=\"@+id/btn_divide\" /&gt; &lt;Button android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:text=\"×\" android:paddingRight=\"10dp\" android:paddingBottom=\"10dp\" android:background=\"@drawable/white_selector\" android:layout_marginLeft=\"10dp\" android:textSize=\"20sp\" android:gravity=\"right|bottom\" android:id=\"@+id/btn_multiply\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"10dp\" android:orientation=\"horizontal\" android:gravity=\"center_horizontal\" &gt; &lt;Button android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:text=\"7\" android:paddingRight=\"10dp\" android:paddingBottom=\"10dp\" android:background=\"@drawable/white_selector\" android:textSize=\"20sp\" android:gravity=\"right|bottom\" android:id=\"@+id/btn_7\" /&gt; &lt;Button android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:text=\"8\" android:paddingRight=\"10dp\" android:paddingBottom=\"10dp\" android:background=\"@drawable/white_selector\" android:layout_marginLeft=\"10dp\" android:textSize=\"20sp\" android:gravity=\"right|bottom\" android:id=\"@+id/btn_8\" /&gt; &lt;Button android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:text=\"9\" android:paddingRight=\"10dp\" android:paddingBottom=\"10dp\" android:background=\"@drawable/white_selector\" android:layout_marginLeft=\"10dp\" android:textSize=\"20sp\" android:gravity=\"right|bottom\" android:id=\"@+id/btn_9\" /&gt; &lt;Button android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:text=\"-\" android:paddingRight=\"10dp\" android:paddingBottom=\"10dp\" android:background=\"@drawable/white_selector\" android:layout_marginLeft=\"10dp\" android:textSize=\"20sp\" android:gravity=\"right|bottom\" android:id=\"@+id/btn_minus\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"10dp\" android:orientation=\"horizontal\" android:gravity=\"center_horizontal\" &gt; &lt;Button android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:text=\"4\" android:paddingRight=\"10dp\" android:paddingBottom=\"10dp\" android:background=\"@drawable/white_selector\" android:textSize=\"20sp\" android:gravity=\"right|bottom\" android:id=\"@+id/btn_4\" /&gt; &lt;Button android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:text=\"5\" android:paddingRight=\"10dp\" android:paddingBottom=\"10dp\" android:background=\"@drawable/white_selector\" android:layout_marginLeft=\"10dp\" android:textSize=\"20sp\" android:gravity=\"right|bottom\" android:id=\"@+id/btn_5\" /&gt; &lt;Button android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:text=\"6\" android:paddingRight=\"10dp\" android:paddingBottom=\"10dp\" android:background=\"@drawable/white_selector\" android:layout_marginLeft=\"10dp\" android:textSize=\"20sp\" android:gravity=\"right|bottom\" android:id=\"@+id/btn_6\" /&gt; &lt;Button android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:text=\"+\" android:paddingRight=\"10dp\" android:paddingBottom=\"10dp\" android:background=\"@drawable/white_selector\" android:layout_marginLeft=\"10dp\" android:textSize=\"20sp\" android:gravity=\"right|bottom\" android:id=\"@+id/btn_plus\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" android:layout_marginTop=\"10dp\" android:gravity=\"center_horizontal\" &gt; &lt;LinearLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" &gt; &lt;LinearLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" &gt; &lt;Button android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:text=\"1\" android:paddingRight=\"10dp\" android:paddingBottom=\"10dp\" android:background=\"@drawable/white_selector\" android:textSize=\"20sp\" android:gravity=\"right|bottom\" android:id=\"@+id/btn_1\" /&gt; &lt;Button android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:text=\"2\" android:paddingRight=\"10dp\" android:paddingBottom=\"10dp\" android:background=\"@drawable/white_selector\" android:textSize=\"20sp\" android:gravity=\"right|bottom\" android:layout_marginLeft=\"10dp\" android:id=\"@+id/btn_2\" /&gt; &lt;Button android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:text=\"3\" android:paddingRight=\"10dp\" android:paddingBottom=\"10dp\" android:background=\"@drawable/white_selector\" android:textSize=\"20sp\" android:gravity=\"right|bottom\" android:layout_marginLeft=\"10dp\" android:id=\"@+id/btn_3\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"10dp\" android:orientation=\"horizontal\" &gt; &lt;Button android:layout_width=\"130dp\" android:layout_height=\"60dp\" android:text=\"0\" android:paddingRight=\"10dp\" android:paddingBottom=\"10dp\" android:background=\"@drawable/white_selector\" android:textSize=\"20sp\" android:gravity=\"right|bottom\" android:id=\"@+id/btn_0\" /&gt; &lt;Button android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:text=\".\" android:paddingRight=\"10dp\" android:paddingBottom=\"10dp\" android:background=\"@drawable/white_selector\" android:textSize=\"20sp\" android:gravity=\"right|bottom\" android:layout_marginLeft=\"10dp\" android:id=\"@+id/btn_point\" /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;Button android:layout_width=\"60dp\" android:layout_height=\"130dp\" android:text=\"=\" android:paddingRight=\"10dp\" android:paddingBottom=\"10dp\" android:background=\"@drawable/orange_selector\" android:layout_marginLeft=\"10dp\" android:textSize=\"20sp\" android:gravity=\"right|bottom\" android:id=\"@+id/btn_equal\" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; color.xmlres/values下新建一个xml.123456789&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;color name=\"white\"&gt;#FFFFFF&lt;/color&gt; &lt;color name=\"red\"&gt;#FF0000&lt;/color&gt; &lt;color name=\"black\"&gt;#000000&lt;/color&gt; &lt;color name=\"gray\"&gt;#808080&lt;/color&gt; &lt;color name=\"orange\"&gt;#FFA500&lt;/color&gt; &lt;color name=\"ashen\"&gt;#CD853F&lt;/color&gt;&lt;/resources&gt; white_bg.xml12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" &gt; &lt;corners android:radius=\"5dp\"/&gt; &lt;solid android:color=\"@color/white\" /&gt; &lt;!-- &lt;gradient android:startColor=\"@color/white\" android:endColor=\"@color/red\" /&gt; &lt;stroke android:width=\"1dp\" android:color=\"@color/black\" /&gt; --&gt;&lt;/shape&gt; white_selector.xml12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\" &gt; &lt;item android:drawable=\"@drawable/gray_bg\" android:state_pressed=\"true\"/&gt; &lt;item android:drawable=\"@drawable/white_bg\"/&gt;&lt;/selector&gt; 出现的问题及解决方法 新建工程时，出现报错：123\\res\\values\\styles.xml:7: error: Error retrieving parent for item: No resource found that matches the given name 'Theme.AppCompat.Light'.\\res\\values-v11\\styles.xml:7: error: Error retrieving parent for item: No resource found that matches the given name 'Theme.AppCompat.Light'.\\res\\values-v14\\styles.xml:8: error: Error retrieving parent for item: No resource found that matches the given name 'Theme.AppCompat.Light.DarkActionBar'. 解决方法：顺着改为：123style name=\"AppBaseTheme\" parent=\"android:Theme.Light\"style name=\"AppBaseTheme\" parent=\"android:Theme.Holo.Light\"style name=\"AppBaseTheme\"parent=\"android:Theme.Holo.Light.DarkActionBar\" 然后menu会报错，改为：1android:showAsAction=\"never\" 导入工程时报错The import android cannot be resolved 解决：在新建Android项目的时候，eclipes新更新的ADT，在创建的Android版本最低版本低于4.0的时候，会新建一个v7的项目，把里面的包导入就可以。如果不想有警告的话，直接在创建项目的时候把最低版本设置为4.0以上就可以。并且不会出现第一个问题。 定义按钮时错误提示：Button cannot be resolved to a type 解决：没导包，快捷键ctrl+shift+o搞定。 笔记去掉标题栏在res/values/string.xml中和AndroidManifest.xml去掉相应代码即可。 颜色需新建xml存放在res/values/colors中，RGB颜色表示。 drawble下文件结构 颜色和选择器 注意Main_Activity.java中，首先命名控件，给一个id，其次，按钮要设置点击事件，监听到该控件动作。activity_main.xml中，线性结构可以嵌套使用。 思考：线性结构代码显臃肿，换成TableLayout也许更佳。并且计算器需要进一步优化，目前存在小的问题，例如，加减乘除符号可以在没有数字输入时顺序打印在屏幕上。总之，基本实现了计算器的功能。 APP下载https://github.com/hubojing/Calculator","raw":null,"content":null,"categories":[{"name":"软件开发","slug":"软件开发","permalink":"https://hubojing.github.io/categories/软件开发/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://hubojing.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"https://hubojing.github.io/tags/Java/"}]},{"title":"模拟借书系统（Java异常机制实现）","slug":"模拟借书系统（java异常机制实现）","date":"2017-03-19T09:09:12.000Z","updated":"2017-03-30T15:56:22.000Z","comments":true,"path":"2017/03/19/模拟借书系统（java异常机制实现）/","link":"","permalink":"https://hubojing.github.io/2017/03/19/模拟借书系统（java异常机制实现）/","excerpt":"java语言实现一个控制台版的模拟借书系统。","text":"java语言实现一个控制台版的模拟借书系统。 目标用java语言实现一个控制台版的模拟借书系统，旨在练习java异常机制。 要求 要求 成品 最终效果 参考代码及注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.jinger;import java.util.Scanner;//导入Scanner包public class BookManagerEasy &#123; private static Scanner console = new Scanner(System.in);//接收系统输入 public static void main(String[] args) &#123; //定义”图书“数组 String[] books = &#123; \"C语言\", \"数据结构\", \"汇编语言\", \"高数\", \"大学语文\", \"毛概\" &#125;; while (true) &#123; System.out.println(\"输入命令：1-按照名称查找图书；2-按照序号查找图书\"); String book; try &#123; //取得整型命令 int command = inputCommand(); //根据不同命令值，进行不同操作 switch (command) &#123; case 1://按照图书名称选择图书 book = getBookByName(books); System.out.println(\"book:\" + book); break; case 2://按照图书序号（数组下标）选择图书 book = getBookByNumber(books); System.out.println(\"book:\" + book); break; case -1://返回值为-1，说明输入有误 System.out.println(\"命令输入错误！请根据提示输入数字命令！\"); continue; default://其他值的命令均认为是错误命令 System.out.println(\"命令输入错误！\"); continue; &#125; break;//退出程序 &#125; catch (Exception bne) &#123; //捕获“图书不存在异常”时，要求重新输入命令 System.out.println(bne.getMessage()); continue; &#125; &#125; &#125; //按照图书名称查询图书 private static String getBookByName(String[] books) throws Exception &#123; System.out.println(\"输入图书名称：\"); //获取输入的图书名称 String name = console.next(); for (int i = 0; i &lt; books.length; i++) &#123; if (name.equals(books[i])) //输入的名称与某一图书名称匹配，返回该图书 return books[i]; &#125; //若无匹配，抛出”图书不存在异常“ throw new Exception(\"图书不存在！\"); &#125; //根据图书序号（数组下标）查询图书 private static String getBookByNumber(String[] books) throws Exception &#123; while (true) &#123; System.out.println(\"输入图书序号：\"); try &#123; //获取输入的图书序号（数组下标） int index = inputCommand(); //若返回值为-1 if(index == -1)&#123; System.out.println(\"命令输入错误！请根据提示输入数字命令！\"); continue; &#125; //若不出现“数组下标越界异常”，则返回相应位置的图书 String book = books[index]; return book; &#125; catch (ArrayIndexOutOfBoundsException e) &#123; //输入的序号不存在（引发“数组下标越界异常”），则抛出“图书不存在异常” Exception bookNotExists = new Exception(\"图书不存在！\"); bookNotExists.initCause(e); throw bookNotExists; &#125; &#125; &#125; //从控制台输入命令，用于输入命令和输入图书序号 private static int inputCommand()&#123; int command; try &#123; command = console.nextInt(); return command; &#125; catch (Exception e) &#123; //若输入字符型或者字符串，则抛出异常，捕获该异常，抛出“错误命令异常” console = new Scanner(System.in); //返回-1 return -1; &#125; &#125;&#125;","raw":null,"content":null,"categories":[{"name":"软件开发","slug":"软件开发","permalink":"https://hubojing.github.io/categories/软件开发/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hubojing.github.io/tags/Java/"}]},{"title":"达达租车系统（Java实现）","slug":"达达租车系统（Java实现）","date":"2017-03-18T10:52:48.000Z","updated":"2017-03-18T11:07:14.000Z","comments":true,"path":"2017/03/18/达达租车系统（Java实现）/","link":"","permalink":"https://hubojing.github.io/2017/03/18/达达租车系统（Java实现）/","excerpt":"　　　　java编写一个控制台版的“达达租车系统”。　　　　","text":"java编写一个控制台版的“达达租车系统”。 目标java编写一个控制台版的“达达租车系统” 功能1.展示所有可租车辆2.选择车型、租车量3.展示租车清单，包含：总金额、总载货量及其车型、总载人量及其车型 三大分析数据模型分析 数据模型分析 业务模型分析 业务模型分析 显示和流程分析 显示和流程分析 成品 租车页面 租车账单 思路 首先定义一个Car类，它包含基本功能：车名、载客数、载货量、日租金。接着创建三个小类，分别是客车类、货车类和皮卡类（既能载客又能载货），它们都继承Car类。最后需要一个主类，用于开启整个系统，调用每个小类。 代码12345678910111213141516171819202122232425262728293031323334package com.jinger;public abstract class Car &#123; public int rent;//日租金 public int people;//载客人数 public int loads;//载货量 public String name;//车名public int getRent()&#123; return rent;&#125;public void setRent(int rent)&#123; this.rent=rent;&#125;public int getPeople()&#123; return people;&#125;public void setPeople(int people)&#123; this.people=people;&#125;public int getLoads()&#123; return loads;&#125;public void setLoads(int loads)&#123; this.loads=loads;&#125;public String getName()&#123; return name;&#125;public void setName(String name)&#123; this.name=name;&#125;&#125; 客车类123456789101112131415package com.jinger;public class PassageCar extends Car&#123; public PassageCar(String name,int people,int rent)&#123; this.setName(name); this.setPeople(people); this.setRent(rent); &#125; public String toString()&#123; return this.getName()+\"\\t\"+this.getPeople()+\"\\t\\t\\t\\t\"+this.getRent(); &#125; &#125; 卡车类12345678910111213package com.jinger;public class Truck extends Car &#123; public Truck(String name,int loads,int rent)&#123; this.setName(name); this.setLoads(loads); this.setRent(rent); &#125; public String toString()&#123; return this.getName()+\"\\t\\t\\t\"+this.getLoads()+\"\\t\\t\"+this.getRent(); &#125; &#125; 皮卡类1234567891011121314package com.jinger;public class Pickup extends Car &#123; public Pickup(String name,int people,int loads,int rent)&#123; this.setName(name); this.setPeople(people); this.setLoads(loads); this.setRent(rent); &#125; public String toString()&#123; return this.getName()+\"\\t\"+this.getPeople()+\"\\t\\t\"+this.getLoads()+\"\\t\\t\"+this.getRent(); &#125; &#125; 主类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.jinger;import java.util.*;public class Initial &#123; public static void main(String[] args) &#123; //对各类车实例化并保存到cars数组 Car[] cars=&#123; new PassageCar(\"奥迪A4\",4,500), new PassageCar(\"马自达6\",4,400), new Pickup(\"皮卡雪6\",4,2,450), new PassageCar(\"金龙\",20,800), new Truck(\"松花江\",4,400), new Truck(\"依维柯\",20,1000)&#125;; System.out.println(\"****欢迎使用达达租车系统！****\"); System.out.println(\"****您确认租车吗？****\"+\"\\n\"+\"是（请输入1） \\t 否（请输入2）\"); Scanner in1=new Scanner(System.in); int is=in1.nextInt(); if(is!=1)&#123; System.out.println(\"****欢迎下次光临！****\"); System.exit(0); &#125; if(is==1)&#123; System.out.println(\"****您可租车的类型及价目表****\"); System.out.println(\"序号\"+\"\\t车名\"+\"\\t载客数（人）\"+\"\\t载货量（吨）\"+\"\\t日租金（元/天）\"); //使用循环方式将各类车输出 for(int i=0;i&lt;cars.length;i++)&#123; System.out.println((i+1)+\"\\t\"+cars[i]); &#125; System.out.println(\"****请输入您的租车数量：****\"); int num1=in1.nextInt(); Car[] rentcar=new Car[num1]; int price=0;//总价格 int totalpeople=0;//总人数 int totalloads=0;//总载货量 for(int i=0;i&lt;num1;i++)&#123; System.out.println(\"****请输入第\"+(i+1)+\"辆车的序号：****\"); int numx=in1.nextInt(); rentcar[i]=cars[numx-1]; &#125; System.out.println(\"****请输入天数：****\"); int day=in1.nextInt(); for(int i=0;i&lt;num1;i++)&#123; price=price+rentcar[i].rent *day; &#125; System.out.println(\"****您的账单：****\"); System.out.println(\"已选载人车：\"); for(int i=0;i&lt;num1;i++)&#123; if(rentcar[i].people!=0)&#123; System.out.println(rentcar[i].name+\"\\t\"); &#125; totalpeople=totalpeople+rentcar[i].people; &#125; System.out.println('\\n'); System.out.println(\"已选载货车：\"); for(int i=0;i&lt;num1;i++)&#123; if(rentcar[i].loads!=0)&#123; System.out.println(rentcar[i].name+\"\\t\"); &#125; totalloads=totalloads+rentcar[i].loads; &#125; System.out.println('\\n'); System.out.println(\"共载客：\"+totalpeople+\"人\"); System.out.println(\"共载货：\"+totalloads+\"吨\"); System.out.println(\"租车总价格：\"+price+\"元\"); System.out.println('\\n'); System.out.println(\"****感谢您的惠顾，欢迎再次光临！****\"); &#125; &#125; &#125; 收获思路决定编码。编程要注重自顶而下、逐步求精的设计方法。 源程序下载https://github.com/hubojing/Car-rental-system","raw":null,"content":null,"categories":[{"name":"软件开发","slug":"软件开发","permalink":"https://hubojing.github.io/categories/软件开发/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hubojing.github.io/tags/Java/"}]},{"title":"别做井底之蛙","slug":"反省","date":"2017-03-05T16:11:48.000Z","updated":"2017-03-30T15:55:52.000Z","comments":true,"path":"2017/03/06/反省/","link":"","permalink":"https://hubojing.github.io/2017/03/06/反省/","excerpt":"即将毕业了，谈谈最近我关于技术的思考。","text":"即将毕业了，谈谈最近我关于技术的思考。 最近总想给自己的四年打个分。给个70分吧。四年来，我一直认为，自己没有辜负这四年。这四年里，自己很多方面得到了成长。但直到最近，我发现了些什么。 这四年来，我一直是大家眼中的优秀学生，绩点高，学生工作也做得好。我时刻提醒自己，千万不要被眼前的赞誉迷了眼。我之所以显得优秀，是因为我所处的环境还不够好。这是我的技术博客，关于其他方面就不提了。尤谈技术。 大一大二沉浸在繁忙的学生工作中，忽略了自己是个十足的工科生，只注重课堂学习，忽视了动手实践。大二在实验室的半年，收获有，却不是很大。一方面是学校实验室的建设不完善，最重要的是实验室方向不是我所感兴趣的，再加上我当时过于急于求成，收效甚微就心烦意乱。大三卸任部分学生工作，时间多了出来。突然就意识到了自己的专业被自己落下了。于是就诞生了这个技术博客，记录我所学的知识。算是对自己学技术的一点弥补。后来表示不服，自己报名了计算机比赛，最后竟意外抱得国奖回，让自己开心了一阵。我就算没在实验室了，我还是能自己干出事情来！我是有些倔。再后来考研。过程不说了，和所有考研人一样平常。考完后让自己彻底放松了二个月，所有和学习的事情都放下了，包括这里。这也是为什么这段时间我的github绿的很少，以及博客长久未更的原因。 简历看似让人羡慕，可我近来愈发觉得，自己就是一只井底之蛙。没有实验室的帮助，没有老师的指导，没有志同道合的伙伴，全靠自己一个人，自己的学习时常走入歧途。不过这都不重要，重要的是我只要愿意不断学习，总会越懂越多。最近我看了大神和牛人甚至是认识的同学们的学习过程，自己的努力与之相比不值一提。之前即使我总是警告自己不要感动自己，可最终还是让自己浮在了表面。 我是通信工程专业的学生，却常“不务正业”地倒弄计算机专业的东西（不过这是我的兴趣所在，我也从不觉得是错误，通信和计算机本是一家），有时候我在想，我的本家知识还没学通学透呢？ 寒假放松的两个月，有个网友隔几天就问我有没有敲代码。我都说没有。他当时批评我说，女生果然不适合干技术。我回复他，你可以指责我，但我不能代表整个女性群体。后来想想，他的批评是有理的，像我那样三天打鱼、两天晒网的学习，怎么会有效果？ 最近我常常在想，我口口声声说爱技术，还有一个做学术做科研的愿望，到底是不是发自心底的？我在还没深入了解它的时候，有什么资格说爱它？ 感觉自己被越甩越远，但自己不想在做井底之蛙了。虽然醒悟地有些晚，但好歹是想过来了。 即将毕业的我，让自己重新做回一个普通的学生，耐心的学习，安心做毕设，回归一个工科学生对技术所抱有的憧憬之心。 先给自己定一个小目标：让github重新绿起来。欢迎各位监督。 写于2017年3月6日凌晨1点","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/tags/杂谈/"}]},{"title":"虚拟实验平台比赛项目记录","slug":"虚拟实验平台","date":"2017-02-10T10:27:55.000Z","updated":"2017-02-25T13:29:36.000Z","comments":true,"path":"2017/02/10/虚拟实验平台/","link":"","permalink":"https://hubojing.github.io/2017/02/10/虚拟实验平台/","excerpt":"　　说话算数，许诺的上海决赛详细情况记录。 ","text":"说话算数，许诺的上海决赛详细情况记录。 项目名称数字图像处理教学辅助虚拟实验平台 项目平台matlab GUI 项目简述利用matlabGUI可视化，设计一个方便数字图像处理教学的虚拟实验平台，加深学生兴趣，让学生直观了解。 项目框架虚拟实验平台分为实验主窗口和手写数字识别案例。 原理相关数字图像处理是通过计算机对图像进行去除噪声、增强、复原、分割、提取特征等处理的方法和技术，它是指将图像信号转换成数字信号并利用计算机对其进行处理的过程。可以用来提高图像的视感质量，提取图像中所包含的某些特征或特殊信息，对图像数据进行变换、编码和压缩，以便于图像的存储和传输。最近邻插值法最近邻插值法nearest_neighbor是最简单的灰度值插值。也称作零阶插值，就是令变换后像素的灰度值等于距它最近的输入像素的灰度值。双三次插值法双三次插值是一种更加复杂的插值方式，它能创造出比双线性插值更平滑的图像边缘。又叫双立方插值，用于在图像中“插值”（Interpolating）或增加“像素”（Pixel）数量/密度的一种方法。通常利用插值技术增加图形数据，以便在它打印或其他形式输出的时候，能够增大打印面积以及（或者）分辨率。属性：通过双三次插值可以得到一个连续的插值函数，它的一阶偏导数连续，并且交叉导数处处连续。公式：计算系数 的过程依赖于插值数据的特性。如果已知插值函数的导数，常用的方法就是使用四个顶点的高度以及每个顶点的三个导数。一阶导数 与 表示 x 与 y 方向的表面斜率，二阶相互导数 表示同时在 x 与 y 方向的斜率。这些值可以通过分别连续对 x 与 y 向量取微分得到。对于网格单元的每个顶点，将局部坐标（0,0, 1,0, 0,1 和 1,1) 带入这些方程，再解这 16 个方程。 图像增强1.直方图作用直方图的观看规则就是“左黑右白”，左边代表暗部，右边代表亮部，而中间则代表中间调。纵向上的高度代表像素密集程度，越高，代表的就是分布在这个亮度上的像素很多。 2.分为空间域和频域空域分为点运算和领域去噪直方图修正属于点运算，平滑和锐化属于领域去噪。平滑是在添加噪声之后进行的处理滤波的本义是指信号有各种频率的成分,滤掉不想要的成分,即为滤掉常说的噪声,留下想要的成分.这即是滤波的过程,也是目的。图像锐化是补偿图像的轮廓，增强图像的边缘及灰度跳变的部分，使图像变得清晰，分为空域处理和频域处理两类。图像平滑往往使图像中的边界、轮廓变得模糊，为了减少这类不利效果的影响，这就需要利用图像锐化技术，使图像的边缘变的清晰直方图修正法分为直方图均衡化和直方图规定化（直方图匹配） 目的：采用直方图修整后可使图像的灰度间距拉开或使灰度分布均匀，从而增大反差，使图像细节清晰，从而增强图像。直方图均衡化：通过对原图像进行某种变换使原图像的灰度直方图修正为均匀的直方图的一种方法。直方图规定化：使原图像灰度直方图变成规定形状的直方图而对图像作修正的增强方法。 频域增强频谱图图像从圆心到外是由低频到高频的一个过程 同心圆表示在不同方向上的同一频率 而频谱有明暗表示分解成的多个正弦波由于相位的不同叠加后就形成了有大小的分别 而相位不同的正弦波又是由在不同位置的原图像的圆（也是不同位置的频率变化组成的）图像分割方法：阈值分割、区域分割、边缘分割、基于特定理论的分割图像分割方法依照分割时所依据的图像特性不同，大致可以分为四大类。第一类是阈值方法，这种方法是根据图像灰度值得分布特性确定某个阈值来进行图像分割的。第二类为边缘检测方法，这类方法是通过检测出封闭某个区域的边界来进行图像分割的。通俗地讲，这类方法实际上是沿着闭合的边缘线将其包围的区域剪切出来。第三类方法是区域提取方法，这类方法的特点是根据特定区域与其他背景区域特性上的不同来进行图像分割的。另外，还有一种基于形态学的分水岭算法。阈值分割：基本原理是：通过设定不同的特征阈值，把图像象素点分为若干类。常用的特征包括：直接来自原始图像的灰度或彩色特征；由原始灰度或彩色值变换得到的特征。设原始图像为f(x，y)，按照一定的准则f(x，y)中找到特征值T，将图像分割为两个部分，分割后的图像为：若取：b0=0(黑)，b1=1(白)，即为我们通常所说的图像二值化。直方图阈值双峰法：双峰法是一种简单的阈值分割方法，即如果灰度级直方图呈现明显的双峰状，则选双峰之间的谷底所对应的灰度级作为阈值分割。均匀性度量法：均匀性度量法的设计思想是，假设当图像被分为目标物和背景两个类别时，属于同一类别内的像素值分布应该具有均匀性。在这里采用方差来度量像素间的均匀性。设原图像为f(x,y)，结果图像为g(x,y)。类间最大方差法（Otsu法）：Otsu是一种使类间方差最大的自动确定阈值的方法，该方法具有简单、处理速度快的特点，是一种常用的阈值选取方法。MATLAB中的graythresh函数求取阈值采用的就是Otsu法。局部阈值法：局部阈值图像分割的原理与全局阈值分割相似，只是在使用之前的程序前，将图像分割成若干子图像进行处理，在处理后，在将各自的结果拼接起来。边缘检测：最简单的边缘检测方法是边缘检测算子，它利用相邻区域的像素值不连续的性质，采用一阶或二阶导数来检测边缘点。边缘检测是图像处理和计算机视觉中的基本问题，边缘检测的目的是标识数字图像中亮度变化明显的点。图像属性中的显著变化通常反映了属性的重要事件和变化。 这些包括（i）深度上的不连续、（ii）表面方向不连续、（iii）物质属性变化和（iv）场景照明变化。 边缘检测是图像处理和计算机视觉中，尤其是特征提取中的一个研究领域。图像分割的意义图像分割是图像分析的第一步，图像分割接下来的任务，如特征提取、目标识别等的好坏，都取决于图像分割的质量如何。图像变换Fourier变换有两个好处，即：可以获得信号的频域特性；可以将卷积运算转换为乘积运算。因此二维Fourier变换的应用也是根据这两个特点来进行的。在图像滤波中的应用首先，我们来看Fourier变换后的图像，中间部分为低频部分，越靠外边频率越高。因此，我们可以在Fourier变换图中，选择所需要的高频或是低频滤波。离散余弦变换，尤其是它的第二种类型，经常被信号处理和图像处理使用，用于对信号和图像(包括静止图像和运动图像)进行有损数据压缩。这是由于离散余弦变换具有很强的”能量集中”特性:大多数的自然信号(包括声音和图像)的能量都集中在离散余弦变换后的低频部分，而且当信号具有接近马尔科夫过程(Markov processes)的统计特性时，离散余弦变换的去相关性接近于K-L变换(Karhunen-Loève 变换–它具有最优的去相关性)的性能。图像的形态学数字图像处理中的形态学处理是指将数字形态学作为工具从图像中提取对于表达和描绘区域形状有用处的图像分量，比如边界、骨架以及凸壳，还包括用于预处理或后处理的形态学过滤、细化和修剪等。图像形态学处理中我们感兴趣的主要是二值图像。在二值图像中，所有黑色像素的集合是图像完整的形态学描述，二值图像的各个分量是Z2的元素。假定二值图像A和形态学处理的结构元素B是定义在笛卡儿网格上的集合，网格中值为1的点是集合的元素，当结构元素的原点移到点(x,y)时，记为Sxy，为简单起见，结构元素为3x3，且全都为1，在这种限制下，决定输出结果的是逻辑运算。膨胀和腐蚀这两种操作是形态学处理的基础，许多形态学算法都是以这两种运算为基础的。开操作是先腐蚀、后膨胀处理。闭操作是先膨胀、后腐蚀处理。腐蚀和膨胀，看上去好像是一对互逆的操作，实际上，这两种操作不具有互逆的关系。开运算和闭运算正是依据腐蚀和膨胀的不可逆性，演变而来的。先腐蚀后膨胀的过程就称为开运算。闭运算是通过对腐蚀和膨胀的另一种不同次序的执行而得到的，闭运算是先膨胀后腐蚀的过程，其功能是用来填充物体内细小空洞、连接邻近物体、平滑其边界，同时不明显改变不明显改变其面积。 #相关函数有关函数的意义inputdlg 输入对话框创建一个输入对话框，prompt为提示字符串，title为对话框名称，num_line为显示的行数，defans为默认的数值 imresize 缩放‘nearest’：改变图像尺寸时采用最近邻插值算法；‘bilinear’：采用双线性插值算法；‘bicubic’： 采用双三次插值算法 msgbox 创建对话框imshow 显示图像ndims 求一个数组维数 numel 计算数组中满足指定条件的元素个数若是一幅图像，则numel(A)将给出它的像素数。 I(:,:,1):在矩阵引用里，表示所有元素。比如一个二维矩阵A，A(:,1)就表示A的第一列元素。 flipl中提供了许多对矩阵操作的函数，可以实现矩阵的三角矩阵的提取（triu、tril）、矩阵的翻转（flipud、fliplr、Flipdim）和旋转（rot90）等各种操作。 sizesize(X,1),返回矩阵X的行数；size(X,2),返回矩阵X的列数；N=size(X,2)，就是把矩阵X的列数赋值给Nsize（）：获取矩阵的行数和列数（1）s=size(A),当只有一个输出参数时，返回一个行向量，该行向量的第一个元素时矩阵的行数，第二个元素是矩阵的列数。（2）[r,c]=size(A),当有两个输出参数时，size函数将矩阵的行数返回到第一个输出变量r，将矩阵的列数返回到第二个输出变量c。（3）size(A,n)如果在size函数的输入参数中再添加一项n，并用1或2为n赋值，则 size将返回矩阵的行数或列数。其中r=size(A,1)该语句返回的时矩阵A的行数， c=size(A,2) 该语句返回的时矩阵A的列数。 imrotate 旋转B = imrotate(A,angle,method,bbox)将图像A（图像的数据矩阵）绕图像的中心点旋转angle度， 正数表示逆时针旋转， 负数表示顺时针旋转。返回旋转后的图像矩阵。使用method参数可以改变插值算法，method参数可以为下面这三个值：‘nearest’：最邻近线性插值（Nearest-neighbor interpolation）‘bilinear’： 双线性插值（Bilinear interpolation）‘bicubic’： 双三次插值（或叫做双立方插值）（Bicubic interpolation）bbox参数用于指定输出图像属性：‘crop’： 通过对旋转后的图像B进行裁剪， 保持旋转后输出图像B的尺寸和输入图像A的尺寸一样。‘loose’： 使输出图像足够大， 以保证源图像旋转后超出图像尺寸范围的像素值没有丢失。 一般这种格式产生的图像的尺寸都要大于源图像的尺寸。 imadd 两个图像相加，或者一个图像加上一个常量imsubstract 两个图像相减，或者一个图像减掉一个常量immultiply 两个图像相乘，或者一个图像乘上一个常量imdivide 两个图像相除，或者一个图像除以一个常量imabsdiff 两个图像的差的绝对值imcomplement 求一个图像的反色图inlincomb 求一组图像的线性组合imadjust 调节灰度图像的亮度或彩色图像的颜色矩阵 histeq 直方图均衡bar(x,y) 其中x必须是严格递增的且一维向量x和一维向量y长度相同。以一维向量x的值为x坐标，对应的y为y坐标画直方图。 var函数实际上求的并不是方差，而是误差理论中“有限次测量数据的标准偏差的估计值”。 graythresh函数用法：使用最大类间方差法找到图片的一个合适的阈值（threshold）。在使用im2bw函数将灰度图像转换为二值图像时，需要设定一个阈值，这个函数可以帮助我们获得一个合适的阈值。利用这个阈值通常比人为设定的阈值能更好地把一张灰度图像转换为二值图像。 手写归纳手写数字模块小结handwrite1.exit函数，存在即返回非0值，不存在即返回02.load template pattern; %将template文件中的pattern加载到工作环境中3.pattern(1,1).num=0; %pattern是一个数组，这里.num表示样本数量4.pattern(1,1).feature=[]; %.feature表示特征值（样本）5.save template pattern; %将pattern保存在template.mat文件中6.pos0=get(handles.WritingAxes,’currentpoint’);%获取最近一次点击的位置，返回一个2x3的矩阵，矩阵的每行代表一个点的坐标这两个点的具体含义，和坐标系的投影类型以及鼠标点击位置是否位于坐标系内有关。对于典型情况（正交投影，鼠标点击位于坐标系范围内），可以通过鼠标点击的位置，作一条垂直于屏幕的直线，则该线与坐标系的六个面必然会有两个交点（想象一下，2D坐标系的外框是一个矩形，3D坐标系外框是一个长方体），这两个交点的坐标就是上面所说的pos0，其第一行是靠近观察者的那个面上的点，而第二行是离观察者稍远的那个面上的点。7.x0=pos0(1,1); %靠近观察者那个面上点的第一个坐标（即x） y0=pos0(1,2); %靠近观察者那个面上点的第一个坐标（即y）8.line(x,y, ‘marker’, ‘.’,’markerSize’,18, ‘LineStyle’,’-‘,’LineWidth’,2,’Color’,’black’);%默认选择黑笔画线，设定点的模型大小，线的模型宽度颜色9.X=x0:stepX:x; %设定坐标参数，0.1单位 Y=(y-y0)(X-x0)/(x-x0)+y0; %两点直线方程11.Img=getframe(handles.WritingAxes); %获取坐标轴内图像%getframe获得的是一个架构struct类型的数据，其中cdata子域的内容才可以用imwrite内容保存，用Img.cdata表示，是截取区域的数据12.imwrite(I,’当前手写数字.bmp’,’bmp’); %将图像数据写入图像文件13.data=GetFeature(I); %对手写数字进行处理，获取特征向量14.pattern(1,1).num=pattern(1,1).num+1; %样本容量加一15.pattern(1,1).feature(:,pattern(1,1).num)=data;%新增样本（保存的是特征向量）放在最后16.pattern(1,1).num=pattern(1,1).num-1; %样本容量减一17.pattern(1,1).feature(:,pattern(1,1).num)=[]; %删除倒数第二个18.set(handles.RecognitionResult,’String’,Result); %显示识别结果feature1.[row,col]=find(I==0); %返回数字的上下左右的边界2.I=I(min(row):max(row),min(col):max(col));%截取手写数字图像，使其紧包含数字边界，不包含多余的空白3.[row,col]=size(I); %求截取后图像的宽和高，数组的行和列4.r=fix(row/5); %fix朝0方向取整5.data=data’; %将当前手写数字的特征向量由行向量变为列向量BayesTwoValue1.sum = sum+pattern(1,i).num; %样本总数求和2.pw(i) = pattern(1,i).num/sum; %每个数字的样本概率,先验概率3.[maxval,maxpos] = max(pwx); %取后验概率中最大的%第一个参数是序列中的最大值 第二个参数是最大值在序列中位置4.Result= maxpos-1; %最大值即为最匹配的数字，其数值为它所处位置序号减一BayesLeastError1.[pc_template,pc_data]=pcapro(data); %主成分分析2.mean_data(i).data=mean(pattern(1,i).feature’)’; %求各个类型样品的平均值%mean(x)表示对列向量x求平均值3.h(i)=(pc_data-mean_data(i).data)’s_inv(i).data(pc_data-mean_data(i).data)… (-0.5)+log(pw(i))+log(abs(s_det(i)))*(-0.5); %判别函数BayesLeastRisk1.[minval minpos]=min(risk); %取损失最小的 答辩我们准备的答辩稿（部分）：思路： 为更好的协助老师的教学，充实课堂内容，从而设计的辅助教学实验软件，并拓展手写数字识别系统，用来丰富课堂知识。首先我们选择matlab软件来设计虚拟实验平台，因为大部分工科院校都或多或少 接触过matlab，上手容易。然后由于MatlabGUI强大的可视化界面，让我们决定实现它。一开始我们只设计了手写数字识别，但感觉过于单一，且只涉及到数字图像处理中数字识别模式识别这一块，不够全面，而且学生初学时是从最基本的操作学起，因此，我们根据学习顺序，补充了每一章节的基本实验，使我们的平台更加完善。 遇到的困难： 主要就是程序的问题，这是一个很需要耐心细心的模块，经常会遇到各种奇怪的问题，比如某个功能失效，界面无响应这些，其次就是生成的可执行文件不能很好的适应所有电脑，拓展模块里的手写也可能因为样本的不足出现错误，所以样本的填充也很复杂很需要时间。 作品的优点和缺点： 优点：操作相对简单，界面比较整洁，知识覆盖面广 缺点：可执行文件适应性不够强，部分功能有延迟，没有更详细的解释相关操作的意义，可能还需要一个使用说明的嵌入模块，手写数字模块样本容量不够大。运用技术： 软件的设计基本上全部由matlab/GUI 完成，并使用其特定的命令生成可执行文件，编程时运用了各种简单或复杂的算法，如缩小放大的最近邻插值法，双三次插值法，图像增强里的直方图均衡化、阈值分割的直方图双峰法、均匀性度量法、otsu法、局部阈值法等等。这对于我们两个没有系统学习过这门课的人来说，还是很具有挑战性。贝叶斯决策的原理。 贝叶斯决策理论方法是统计模型决策中的一个基本方法，其基本思想是： 已知类条件概率密度参数表达式和先验概率。 利用贝叶斯公式转换成后验概率。 根据后验概率大小进行决策分类。这个手写识别案例的用处： 是对这门课程的一个拓展，通过对写入的图像灰度化，裁剪，提取特征参数，与贝叶斯决策结合，进行概率分析，匹配，显示最符合的数字，算是部分操作的小应用，同时也涉及到数字图像处理较难的部分：模式识别一块；同时可以用来延伸出车牌识别或人脸识别等更高级的应用系统。 现场老师问了几个问题，回忆了下，有问和PS的区别和项目的意义。 项目获奖第九届中国计算机设计大赛国家三等奖、中南赛区二等奖 P.S.配图为我设计的作品海报。","raw":null,"content":null,"categories":[{"name":"通信工程","slug":"通信工程","permalink":"https://hubojing.github.io/categories/通信工程/"}],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"https://hubojing.github.io/tags/Matlab/"}]},{"title":"yelee --> hueman主题更换","slug":"hueman主题更换","date":"2017-01-03T09:45:10.000Z","updated":"2017-04-05T09:52:36.000Z","comments":true,"path":"2017/01/03/hueman主题更换/","link":"","permalink":"https://hubojing.github.io/2017/01/03/hueman主题更换/","excerpt":"\n我又双叒叕把博客玩崩了……淡定——\n　\n　\n　\n ","text":"我又双叒叕把博客玩崩了……淡定—— 前两天调双语博客页面失败，顺带着把yelee主题玩垮了。[拆毁天才girl NO.1] MoXFIVE也很久没有更新yelee的文档了，索性我就换了个主题。现在的主题是hueman。 换个主题就仿佛整个人都整容了一样→_→什么都要变！ 改config，调样式，换logo，整个人都不好了！ hueman很漂亮，优点突出，但对比yelee，也有一些缺点，例如：没有网站计数，没有文章目录等。 把折腾几个小时的成果记录一下，方便以后接着折腾[手动滑稽]。 主题文档https://github.com/ppoffice/hexo-theme-hueman/wiki 更改背景hueman\\source\\css_partial\\header.styl12-background: color-header-background+ background-image: url(\"地址\") 记得把footer里的背景也给改了，对称美！ 更换logohueman\\source\\css\\images把logo-header.png更换为自己的logo。我在网上随便在线生成了个艺术字就贴上来了…… #加入网站计数\\themes\\hueman\\layout\\common\\footer.ejs和yelee一样，交给不蒜子[http://ibruce.info/2015/04/04/busuanzi/] 。 安装脚本12&lt;script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; 安装标签1.显示站点总访问量要显示站点总访问量，复制以下代码添加到你需要显示的位置。有两种算法可选：算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。123&lt;span id=\"busuanzi_container_site_pv\"&gt; 本站总访问量&lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt;次&lt;/span&gt; 算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。123&lt;span id=\"busuanzi_container_site_uv\"&gt; 本站访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人次&lt;/span&gt; 2.显示单页面访问量要显示每篇文章的访问量，复制以下代码添加到你需要显示的位置。算法：pv的方式，单个用户点击1篇文章，本篇文章记录1次阅读量。123&lt;span id=\"busuanzi_container_page_pv\"&gt; 本文总阅读量&lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt;次&lt;/span&gt; 后续待解决（欢迎各位大神们给建议）： 1.文章目录问题（不知道在哪里改，toc怎么调用，&lt;%- toc(str, [options]) %&gt;需点拨） 2.博客内搜索问题（insight插件总是安装失败，估计是node版本问题，可是有点不敢动node，害怕博客又崩了(瑟瑟发抖.jpg)） 3.分类顺序问题（应该是互联网、通信工程、杂谈，不知道为什么成了互联网、杂谈、通信工程） 4.文章浏览量丢失（蓝瘦香菇…） 5.双语页面问题（就是不！死！心！） 6.微言板块（类似空间的说说，每条下面可以评论，未来会把自己的问题放在这里，等待高手解答） ……","raw":null,"content":null,"categories":[{"name":"博客","slug":"博客","permalink":"https://hubojing.github.io/categories/博客/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hubojing.github.io/tags/Hexo/"}]},{"title":"一天一点linux","slug":"linux整理笔记","date":"2016-12-26T15:31:29.000Z","updated":"2018-11-20T14:28:10.000Z","comments":true,"path":"2016/12/26/linux整理笔记/","link":"","permalink":"https://hubojing.github.io/2016/12/26/linux整理笔记/","excerpt":"\n笔记整理。\n　　 ","text":"笔记整理。 基本概念及操作Linux 桌面环境介绍相对于现在的 Windows 系统，UNIX/Linux 本身是没有图形界面的，我们通常在 Unix/Linux 发行版上看到的图形界面实际都只是运行在 Linux 系统之上的一套软件，类似 Windows95 之前的Windows 的图形界面实则也只是运行在 DOS 环境的一套软件。而 Linux 上的这套软件以前是XFree86，现在则是 xorg（X.Org），而这套软件又是通过 X 窗口系统（X Window System，也常被称为X11或X）实现的，X 本身只是工具包及架构协议，而 xorg 便是 X 架构规范的一个实现体，也就是说它是实现了 X 协议规范的一个提供图形用户界面服务的服务器，就像实现了 http 协议提供 web 服务的 Apache。如果只有服务器也是不能实现一个完整的桌面环境的，当然还需要一个客户端，我们称为 X Client，像如下几个大家熟知也最流行的实现了客户端功能的桌面环境KDE，GNOME，XFCE，LXDE。这也意味着在 Linux 上你可以自己选择安装不同的桌面环境，甚至可以定制自己的专属桌面。 Linux终端Terminal（终端）通常在我们使用 Linux 时，我们并不是直接与系统打交道，而是通过一个叫做 Shell 的中间程序来完成的，在图形界面下为了实现让我们在一个窗口中完成接受用户输入和显示输出，Linux 系统还提供了一个叫做终端模拟器的程序（Terminal），下面几个比较常见的终端模拟器，例如 gnome-terminal，kconsole，xterm，rxvt，kvt，nxterm 和 eterm。终端本质上是对应着 Linux 上的 /dev/tty 设备，Linux 的多用户登陆就是通过不同的 /dev/tty 设备完成的，Linux 默认提供了 6 个纯命令行界面的 “terminal”（准确的说这里应该是 6 个 virtual consoles）来让用户登录，在物理机系统上你可以通过使用[Ctrl]+[Alt]+[F1]～[F6]进行切换，不过在我们的在线实验环境中可能无法切换，因为特殊功能按键会被你主机系统劫持。当你切换到其中一个终端后想要切换回图形界面，你可以按下[Ctrl]+[Alt]+[F7]来完成。 Shell通常在图形界面中对实际体验带来差异的不是上述的不同发行版的各种终端模拟器，而大都是这个 Shell（壳），有壳就有核，这里的核就是指的 UNIX/Linux 内核，Shell 是指“提供给使用者使用界面”的软件（命令解析器），类似于 DOS 下的 command（命令行）和后来的 cmd.exe。普通意义上的 Shell 就是可以接受用户输入命令的程序。它之所以被称作 Shell 是因为它隐藏了操作系统底层的细节。同样的 Unix/Linux 下的图形用户界面 GNOME 和 KDE，有时也被叫做“虚拟 shell”或“图形 shell”。 Unix/Linux 操作系统下的 Shell 既是用户交互的界面，也是控制系统的脚本语言。当然在这点也有别于 Windows 下的命令行，虽然也提供了很简单的控制语句。在Windows 操作系统下，可能有些用户从来都不会直接的使用 Shell，然而在 UNIX 系列操作系统下，Shell 仍然是控制系统启动、X11 启动和很多其他实用工具的脚本解释程序。 在 UNIX/Linux 中比较流行的常见的 Shell 有 bash，zsh，ksh，csh 等等，Ubuntu 终端默认使用的是 bash，默认的桌面环境是 GNOME 或者 Unity（基于 GNOME）。 命令行操作重要快捷键Tab 补全命令、目录、参数Ctrl+c 强行终止当前程序（不会使终端退出）Ctrl+d 键盘输入结束或退出终端Ctrl+s 暂停当前程序，暂停后按下任意键恢复运行Ctrl+z 将当前程序放到后台运行，恢复到前台为命令fgCtrl+a 将光标移至输入行头，相当于Home键Ctrl+e 将光标移至输入行末，相当于End键Ctrl+k 删除从光标所在位置到行末Alt+Backspace 向前删除一个单词Shift+PgUp 将终端显示向上滚动Shift+PgDn 将终端显示向下滚动 历史输入命令： 方向键 上通配符：星号（*）和问号（?），用来对对字符串进行模糊匹配（比如文件名，参数名）。当查找文件夹时，可以使用它来代替一个或多个真正字符；当不知道真正字符或者懒得输入完整名字时，常常使用通配符代替一个或多个真正的字符。 一次性创建多个文件在创建文件的时候，如果需要一次性创建多个文件，比如：“love_1_linux.txt，love_2_linux.txt，… love_10_linux.txt”。在 Linux 中十分方便：1$ touch love_&#123;1..10&#125;_linux.txt Shell 常用通配符字符 含义 匹配 0 或多个字符? 匹配任意一个字符[list] 匹配 list 中的任意单一字符[!list] 匹配 除list 中的任意单一字符以外的字符[c1-c2] 匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z]{string1,string2,…} 匹配 sring1 或 string2 (或更多)其一字符串{c1..c2} 匹配 c1-c2 中全部字符 如{1..10} 在命令行中获取帮助man 命令Manual pages 是在 UNIX 或类 UNIX 操作系统在线软件文档的一种普遍的形式。 内容包括计算机程序（包括库和系统调用），正式的标准和惯例，甚至是抽象的概念。用户可以通过执行 man 命令调用手册页。 你可以使用如下方式来获得某个命令的说明和使用方式的详细介绍： $ man &lt;command_name&gt; 比如你想查看 man 命令本身的使用方式，你可以输入： man man 通常情况下，man 手册里面的内容都是英文的，这就要求你有一定的英文基础。man 手册的内容很多，涉及了 Linux 使用过程中的方方面面，为了便于查找，是做了分册（分区段）处理的，在Research UNIX、BSD、OS X 和 Linux 中，手册通常被分为8个区段，安排如下：区段 说明1 一般命令2 系统调用3 库函数，涵盖了C标准函数库4 特殊文件（通常是/dev中的设备）和驱动程序5 文件格式和约定6 游戏和屏保7 杂项8 系统管理命令和守护进程 要查看相应区段的内容，就在 man 后面加上相应区段的数字即可，如：1$ man 1 ls 会显示第一区段中的ls命令man页面。 所有的手册页遵循一个常见的布局，其为通过简单的 ASCII 文本展示而优化，而这种情况下可能没有任何形式的高亮或字体控制。一般包括以下部分内容： NAME（名称） 该命令或函数的名称，接着是一行简介。 SYNOPSIS（概要） 对于命令，正式的描述它如何运行，以及需要什么样的命令行参数。对于函数，介绍函数所需的参数，以及哪个头文件包含该函数的定义。 DESCRIPTION（说明） 命令或函数功能的文本描述。 EXAMPLES（示例） 常用的一些示例。 SEE ALSO（参见） 相关命令或函数的列表。 也可能存在其他部分内容，但这些部分没有得到跨手册页的标准化。常见的例子包括：OPTIONS（选项），EXIT STATUS（退出状态），ENVIRONMENT（环境），BUGS（程序漏洞），FILES（文件），AUTHOR（作者），REPORTING BUGS（已知漏洞），HISTORY（历史）和COPYRIGHT（版权）。 通常 man 手册中的内容很多，不容易找到想要的结果，可以在 man 中使用搜索，/&lt;要搜索的关键字&gt;，查找到后使用n键切换到下一个关键字所在处，shift+n为上一个关键字所在处。使用Space(空格键)翻页，Enter(回车键)向下滚动一行，或者使用j,k（vim编辑器的移动键）进行向前向后滚动一行。按下h键为显示使用帮助(因为man使用less作为阅读器，实为less工具的帮助)，按下q退出。 想要获得更详细的帮助，使用info命令，不过通常使用man足够。如果知道某个命令的作用，只是想快速查看一些它的某个具体参数的作用，使用–help参数，大部分命令都会带有这个参数，如：1$ ls --help 用户及文件权限管理Linux 用户管理Linux 是一个可以实现多用户登陆的操作系统。 查看用户12345$ who am i或者$ who mom likes who 命令其它常用参数参数 说明-a 打印能打印的全部-d 打印死掉的进程-m 同am i,mom likes-q 打印当前登录用户数及用户名-u 打印当前登录用户登录信息-r 打印运行等级 创建用户在 Linux 系统里， root 账户拥有整个系统至高无上的权利，比如 新建/添加 用户。su，su- 与 sudo su 可以切换到用户user，执行时需要输入目标用户的密码，sudo 可以以特权级别运行cmd命令，需要当前用户属于sudo组，且需要输入当前用户密码。su - 命令也是切换用户，同时环境变量也会跟着改变成目标用户的环境变量。 新建一个叫 lilei 的用户：1$ sudo adduser lilei 这个命令不但可以添加用户到系统，同时也会默认为新用户创建 home 目录： $ ls /home 现在你已经创建好一个用户，并且你可以使用你创建的用户登录了，使用如下命令切换登录用户： $ su -l lilei 输入刚刚设置的 lilei 的密码。退出当前用户跟退出终端一样可以使用 exit 命令或者使用快捷键 Ctrl+d。 用户组每个用户都有一个归属（用户组），用户组简单地理解就是一组用户的集合，它们共享一些资源和权限，同时拥有私有资源，就跟家的形式差不多，你的兄弟姐妹（不同的用户）属于同一个家（用户组），你们可以共同拥有这个家（共享资源），爸妈对待你们都一样（共享权限），你偶尔写写日记，其他人未经允许不能查看（私有资源和权限）。当然一个用户是可以属于多个用户组的，正如你既属于家庭，又属于学校或公司。 知道自己属于哪些用户组的方法方法一：使用groups命令1$ groups nancy 每次新建用户如果不指定用户组的话，默认会自动创建一个与用户名相同的用户组（差不多就相当于家长的意思，或者说是老总）。默认情况下在sudo用户组里的可以使用sudo命令获得root权限。 方法二：查看/etc/group文件1$ cat /etc/group | sort cat 命令用于读取指定文件的内容并打印到终端输出。| sort 表示将读取的文本进行一个字典排序再输出。使用命令过滤掉一些你不想看到的结果：1$ cat /etc/group | grep -E \"nancy\" etc/group 文件格式说明 /etc/group 的内容包括用户组（Group）、用户组口令、GID 及该用户组所包含的用户（User），每个用户组一条记录。格式如下： group_name:password:GID:user_list 你看到上面的 password 字段为一个 ‘x’ 并不是说密码就是它，只是表示密码不可见而已。 将其它用户加入 sudo 用户组 默认情况下新创建的用户是不具有 root 权限的，也不在 sudo 用户组，可以让其加入sudo用户组从而获取 root 权限。12$ su -l lilei$ sudo ls 使用 usermod 命令可以为用户添加用户组，同样使用该命令你必需有 root 权限，你可以直接使用 root 用户为其它用户添加用户组，或者用其它已经在 sudo 用户组的用户使用 sudo 命令获取权限来执行该命令。 用 nancy 用户执行 sudo 命令将 lilei 添加到 sudo 用户组，让它也可以使用 sudo 命令获得 root 权限 $ su nancy # 此处需要输入nancy用户密码，可以点击右侧工具栏中的“SSH直连”查看$ groups lilei$ sudo usermod -G sudo lilei$ groups lilei 然后你再切换回 lilei 用户，现在就可以使用 sudo 获取 root 权限了。 删除用户1$ sudo deluser lilei --remove-home Linux 文件权限查看文件权限使用较长格式列出文件：1$ ls -l Linux 里面一切皆文件。 ls 命令的一些其它常用的用法： 显示除了 &apos;.&apos;(当前目录)，&apos;..&apos; 上一级目录之外的所有包含隐藏文件（Linux 下以 &apos;.&apos; 开头的文件为隐藏文件） 1$ ls -A 可以同时使用 ‘-A’ 和 ‘-l’ 参数：1$ ls -Al 查看某一个目录的完整属性，而不是显示目录里面的文件属性：1$ ls -dl &lt;目录名&gt; 显示所有文件大小，并以普通人类能看懂的方式呈现： 1$ ls -AsSh 其中小 s 为显示文件大小，大 S 为按文件大小排序，若需要知道如何按其它方式排序，使用“man”命令查询。 变更文件所有者假设目前是 lilei 用户登录，新建一个文件，命名为 “iphone6”： $ touch iphone6 可见文件所有者是 lilei 。现在，换回到nancy用户身份，使用以下命令变更文件所有者为 nancy ： $ cd /home/lilei$ ls iphone6$ sudo chown nancy iphone6$ cp iphone6 /home/nancy 现在查看，发现 文件所有者成功修改为 nancy 。 修改文件权限方式一：二进制数字表示每个文件的三组权限（拥有者，所属用户组，其他用户,记住这个顺序是一定的）就对应这一个 “rwx”，也就是一个 ‘7’。1$ echo \"echo \\\"hello nancy\\\"\" &gt; iphone6 然后修改权限：1$ chmod 700 iphone6 现在，其他用户已经不能读这个“iphone6”文件了 方式二：加减赋值操作完成上述相同的效果：1$ chmod go-rw iphone6 ‘g’’o’还有’u’，分别表示group，others，user，’+’，’-‘ 就分别表示增加和去掉相应的权限。 Linux 目录结构及文件基本操作Linux 目录结构 Linux 是以树形目录结构的形式来构建整个系统的，可以理解为一个用户可操作系统的骨架。虽然本质上无论是目录结构还是操作系统内核都是存储在磁盘上的，但从逻辑上来说 Linux 的磁盘是“挂在”（挂载在）目录上的，每一个目录不仅能使用本地磁盘分区的文件系统，也可以使用网络上的文件系统。举例来说，可以利用网络文件系统（Network File System，NFS）服务器载入某特定目录等。 FHS 标准FHS 定义了两层规范，第一层是， / 下面的各个目录应该要放什么文件数据，例如 /etc 应该要放置设置文件，/bin 与 /sbin 则应该要放置可执行文件等等。 第二层则是针对 /usr 及 /var 这两个目录的子目录来定义。例如 /var/log 放置系统登录文件、/usr/share 放置共享数据等等。 目录路径cd 切换目录， . 表示当前目录，.. 表示上一级目录（以 . 开头的文件都是隐藏文件，所以这两个目录必然也是隐藏的， ls -a 命令查看隐藏文件）, - 表示上一次所在目录，～ 通常表示当前用户的”home”目录。使用 pwd 命令可以获取当前所在路径（绝对路径）。 进入上一级目录：1$ cd .. 进入你的“home”目录：12$ cd ~ # 或者 cd /home/&lt;你的用户名&gt; 使用 pwd 获取当前路径：1$ pwd 绝对路径以根”/“目录为起点的完整路径，以你所要到的目录为终点，表现形式如： /usr/local/bin，表示根目录下的 usr 目录中的 local 目录中的 bin 目录。 相对路径相对于当前的目录的路径，相对路径是以当前目录 . 为起点，以所要到的目录为终点，表现形式如： usr/local/bin （这里假设当前目录为根目录）。表示相对路径实际并没有加上表示当前目录的那个 . ，而是直接以目录名开头，因为这个 usr 目录为 / 目录下的子目录，是可以省略 . 的（也有类似不能省略的情况）；如果是当前目录的上一级目录，则需要使用 .. ，比如当前目录为“home”目录，根目录就应该表示为 ../../ ,表示上一级目录（”home”目录）的上一级目录（”/“目录）。 以”home”目录为起点，分别以绝对路径和相对路径的方式进入 /usr/local/bin 目录：1234# 绝对路径$ cd /usr/local/bin# 相对路径$ cd ../../usr/local/bin 在进行目录切换的过程中请多使用 Tab 键自动补全，可避免输入错误，连续按两次Tab可以显示全部候选结果。 Linux 文件的基本操作新建新建空白文件使用 touch 命令创建空白文件，关于 touch 命令，其主要是来更改已有文件的时间戳的（比如，最近访问时间，最近修改时间），但其在不加任何参数的情况下，只指定一个文件名，则可以创建一个为指定文件名的空白文件（不会覆盖已有同名文件），当然你也可以同时指定该文件的时间戳。创建名为 test 的空白文件，因为在其他目录没有权限，所以需要先 cd ~ 切换回用户的 /home/nancy 目录：12$ cd ~$ touch test 新建目录使用 mkdir（make directories）命令可以创建一个空目录,也可同时指定创建目录的权限属性 创建名为”mydir”的空目录：1$ mkdir mydir 使用 -p 参数，同时创建父目录（如果不存在该父目录），如下同时创建一个多级目录（这在有时候安装软件，配置安装路径时非常有用）：1$ mkdir -p father/son/grandson 后面的目录路径，以绝对路径的方式表示也是可以的。 复制使用cp（copy）命令复制一个文件或目录到指定目录。将之前创建的”test”文件复制到”/home/nancy/father/son/grandson”目录中：1$ cp test father/son/grandson 复制目录要成功复制目录需要加上-r或者-R参数，表示递归复制，就是说有点“株连九族”的意思：1$ cp -r father family 删除删除文件使用rm（remove files or directories）命令，删除一个文件或目录：1$ rm test 有时候你会遇到想要删除一些为只读权限的文件，直接使用rm删除会显示一个提示,你如果想忽略这提示，直接删除文件，可以使用-f参数强制删除：1$ rm -f test 删除目录跟复制目录一样，要删除一个目录，也需要加上-r或-R参数：1$ rm -r family 移动文件与文件重命名移动文件使用mv(move or rename files)命令，移动文件（剪切）。将文件”file1”移动到”Documents”目录mv 源目录文件 目的目录：12$ mkdir Documents$ mv file1 Documents 重命名文件将文件”file1”重命名为”myfile” mv 旧的文件名 新的文件名：1$ mv file1 myfile 批量重命名12345678# 使用通配符批量创建 5 个文件$ touch file&#123;1..5&#125;.txt# 批量将这 5 个后缀为 .txt 的文本文件重命名为以 .c 为后缀的文件$ rename 's/\\.txt/\\.c/' *.txt# 批量将这 5 个文件，文件名改为大写$ rename 'y/a-z/A-Z/' *.c 简单解释下上面的命令，rename是先使用第二个参数的通配符匹配所有后缀为.txt的文件，然后使用第一个参数提供的正则表达式将匹配的这些文件的.txt后缀替换为.c 。 查看文件使用cat,tac和nl命令查看文件打印文件内容到标准输出（终端）,其中cat为正序显示，tac倒序显示。查看之前从”/etc”目录下拷贝来的passwd文件：1$ cat passwd 可以加上-n参数显示行号：1$ cat -n passwd nl命令，添加行号并打印，这是个比cat -n更专业的行号打印命令。 它的常用的几个参数：12345678-b : 指定添加行号的方式，主要有两种： -b a:表示无论是否为空行，同样列出行号(\"cat -n\"就是这种方式) -b t:只列出非空行的编号并列出（默认为这种方式）-n : 设置行号的样式，主要有三种： -n ln:在行号字段最左端显示 -n rn:在行号字段最右边显示，且不加 0 -n rz:在行号字段最右边显示，且加 0-w : 行号字段占用的位数(默认为 6 位) 使用more和less命令分页查看文件其中more命令比较简单，只能向一个方向滚动，而”less”为基于”more”和”vi”(编辑器)开发，功能更强大。less 的使用基本和 more 一致。使用more工具打开passwd文件：1$ more passwd 打开后默认只显示一屏内容，终端底部显示当前阅读的进度(百分比)。可以使用Enter键向下滚动一行，使用Space键向下滚动一屏，按下h显示帮助，q退出。使用head和tail命令查看文件head是只查看的头几行（默认为10行，不足10行则显示全部），tail是查看尾几行。1$ tail /etc/passwd 甚至更直接的只看一行， 加上-n参数，后面紧跟行数：1$ tail -n 1 /etc/passwd 参数-f，这个参数可以实现不停地读取某个文件的内容并显示。这可让我们动态查看日志起到实时监视的作用。 查看文件类型在 Linux 下面文件的类型不是根据文件后缀来判断的，我们通常使用file命令可以查看文件的类型：1$ file /bin/ls 编辑文件Linux 内部的 vim 学习教程，输入如下命令即可开始：1$ vimtutor 环境变量与文件查找环境变量变量准确的说应该是 Shell 变量，所谓变量就是计算机中用于记录一个值（不一定是数值，也可以是字符或字符串）的符号，而这些符号将用于不同的运算处理中。在 Shell 中如何创建一个变量，如何给变量赋值和如何读取变量的值呢？使用declare命令创建一个变量名为 tmp 的变量：1$ declare tmp 使用=号赋值运算符为变量 tmp 赋值为 nancy：1$ tmp=nancy 读取变量的值，使用echo命令和$符号（$符号用于表示引用一个变量的值，初学易忘）：1$ echo $tmp 注意:关于变量名，并不是任何形式的变量名都是可用的，变量名只能是英文字母,数字或者下划线，且不能以数字作为开头。 环境变量环境变量就是作用域比自定义变量要大，如Shell 的环境变量作用于自身和它的子进程。在所有的 UNIX 和类 UNIX 系统中，每个进程都有其各自的环境变量设置，且默认情况下，当一个进程被创建时，处理创建过程中明确指定的话，它将继承其父进程的绝大部分环境设置。Shell 程序也作为一个进程运行在操作系统之上，而在 Shell中运行的大部分命令都将以 Shell 的子进程的方式运行。 通常会涉及到的环境变量有三种： 当前 Shell 进程私有用户自定义变量，如上面我们创建的 temp 变量，只在当前 Shell 中有效。 Shell 本身内建的变量。 从自定义变量导出的环境变量。 也有三个与上述三种环境变量相关的命令，set，env，export。这三个命令都可用于打印相关环境变量,区别在于涉及的是不同范围的环境变量，详见下表：命令 说明set 显示当前 Shell 所有环境变量，包括其内建环境变量（与 Shell 外观等相关），用户自定义变量及导出的环境变量env 显示与当前用户相关的环境变量，还可以让命令在指定环境中运行export 显示从 Shell 中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量 关于环境变量，可以简单的理解成在当前进程的子进程是否有效，有效则为环境变量，否则不是（有人也将所有变量统称为环境变量，只是以全局环境变量和局部环境变量进行区分，只要理解它们的实质区别即可）。 注意：为了与普通变量区分，通常我们习惯将环境变量名设为大写。 命令的查找路径与顺序Shell 中输入一个命令，Shell 是通过环境变量PATH来进行搜索去找到这个命令然后执行的。Windows 中的也是有这么一个 PATH 环境变量。这个PATH里面就保存了Shell中执行的命令的搜索路径。查看PATH环境变量的内容：1$ echo $PATH 默认情况下有输出：1/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games 通常这一类目录下放的都是可执行文件，当我们在 Shell 中执行一个命令时，系统就会按照 PATH 中设定的路径按照顺序依次到目录中去查找，如果存在同名的命令，则执行先找到的那个。 练习创建一个最简单的可执行 Shell 脚本和一个使用 C 语言创建的”hello world”程序。创建一个 Shell 脚本文件：1$ vim hello_shell.sh 在脚本中添加如下内容，保存并退出（注意不要省掉第一行）：1234567#!/bin/zshfor ((i=0; i&lt;10; i++));do echo \"hello shell\"doneexit 0 为文件添加可执行权限：1$ chmod 755 hello_shell.sh 执行脚本1$ ./hello_shell.sh 创建一个 C 语言”hello world”程序：1$ vim hello_world.c 1234567#include &lt;stdio.h&gt;int main(void)&#123; printf(\"hello world!\\n\"); return 0;&#125; 使用 gcc 生成可执行文件：1$ gcc -o hello_world hello_world.c gcc 生成二进制文件默认具有可执行权限，不需要修改 在 nancy 家目录创建一个mybin目录，并将上述 hello_shell.sh 和 hello_world 文件移动到其中：12$ mkdir mybin$ mv hello_shell.sh hello_world mybin/ 在mybin目录中分别运行刚刚创建的两个程序：123$ cd mybin$ ./hello_shell.sh$ ./hello_world 回到上一级目录，也就是nancy家目录，当再想运行那两个程序时，会发现提示命令找不到，除非加上命令的完整路径，但那样很不方便，要做到想使用系统命令一样执行自己创建的脚本文件或者程序，那就要将命令所在路径添加到PATH环境变量了。 添加自定义路径到“PATH”环境变量PATH里面的路径是以：作为分割符，可这样添加自定义路径：1$ PATH=$PATH:/home/shiyanlou/mybin 注意这里一定要使用绝对路径。 可以在其他任意目录执行那两个命令了（注意需要去掉前面的./）。这给 PATH 环境变量追加了一个路径，它也只是在当前 Shell 有效，一旦退出终端，再打开就会发现又失效了。让添加的环境变量全局有效或者每次启动 Shell 时自动执行上面添加自定义路径到 PATH 的命令——后一种方式——让它自动执行。 在每个用户的 home 目录中有一个 Shell 每次启动时会默认执行一个配置脚本，以初始化环境，包括添加一些用户自定义环境变量等等。zsh 的配置文件是.zshrc，相应 Bash 的配置文件为.bashrc。它们在etc下还都有一个或多个全局的配置文件，不过一般只修改用户目录下的配置文件。 简单的使用下面命令直接添加内容到.zshrc中：1$ echo \"PATH=$PATH:/home/shiyanlou/mybin\" &gt;&gt; .zshrc 上述命令中&gt;&gt;表示将标准输出以追加的方式重定向到一个文件中，注意前面用到的&gt;是以覆盖的方式重定向到一个文件中，使用的时候一定要注意分辨。在指定文件不存在的情况下都会创建新的文件。 修改和删除已有变量变量修改 变量的修改有以下几种方式：变量设置方式 说明${变量名#匹配字串} 从头向后开始匹配，删除符合匹配字串的最短数据${变量名##匹配字串} 从头向后开始匹配，删除符合匹配字串的最长数据${变量名%匹配字串} 从尾向前开始匹配，删除符合匹配字串的最短数据${变量名%%匹配字串} 从尾向前开始匹配，删除符合匹配字串的最长数据${变量名/旧的字串/新的字串} 将符合旧字串的第一个字串替换为新的字串${变量名//旧的字串/新的字串} 将符合旧字串的全部字串替换为新的字串 比如要修改前面添加到 PATH 的环境变量。为了避免操作失误导致命令找不到，先将 PATH 赋值给一个新的自定义变量 path：12345$ path=$PATH$ echo $path$ path=$&#123;path%/home/shiyanlou/mybin&#125;# 或使用通配符,*表示任意多个任意字符$ path=$&#123;path%*/mybin&#125; 变量删除可以使用unset命令删除一个环境变量：1$ unset temp 如何让环境变量立即生效上面在Shell 中修改了一个配置脚本文件之后（比如 zsh 的配置文件 home 目录下的.zshrc），每次都要退出终端重新打开甚至重启主机之后其才能生效，很麻烦，使用source命令来让其立即生效，如：1$ source .zshrc source命令还有一个别名就是.，注意与表示当前路径的那个点区分开，虽然形式一样，但作用和使用方式一样，上面的命令如果替换成.的方式就该是1$ . ./.zshrc 注意第一个点后面有一个空格，而且后面的文件必须指定完整的绝对或相对路径名，source 则不需要。 搜索文件与搜索相关的命令常用的有如下几个whereis,which,find,locate。 whereis简单快速1$whereis who whereis只能搜索二进制文件(-b)，man帮助文件(-m)和源代码文件(-s)。如果想要获得更全面的搜索结果可用locate命令。 locate快而全通过”/var/lib/mlocate/mlocate.db”数据库查找，不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行updatedb命令更新一次，所以有时刚添加的文件，它可能会找不到，需要手动执行一次updatedb命令（在我们的环境中必须先执行一次该命令）。它可以用来查找指定目录下的不同文件类型，如查找 /etc 下所有以 sh 开头的文件：1$ locate /etc/sh 注意,它不只是在 etc 目录下查找并会自动递归子目录进行查找。查找 /usr/share/ 下所有 jpg 文件：1$ locate /usr/share/\\*.jpg 注意要添加*号前面的反斜杠转义，否则会无法找到。 如果想只统计数目可以加上-c参数，-i参数可以忽略大小写进行查找，whereis 的-b,-m，-s同样可以是使用。 which小而精 which本身是 Shell 内建的一个命令，通常使用which来确定是否安装了某个指定的软件，因为它只从PATH环境变量指定的路径中去搜索命令：1$ which man find精而细 find应该是这几个命令中最强大的了，它不但可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索。在指定目录下搜索指定文件名的文件：1$ find /etc/ -name interfaces 注意 find 命令的路径是作为第一个参数的， 基本命令格式为 find [path] [option] [action] 与时间相关的命令参数：参数 说明-atime 最后访问时间-ctime 创建时间-mtime 最后修改时间 下面以-mtime参数举例： -mtime n: n 为数字，表示为在n天之前的”一天之内“修改过的文件 -mtime +n: 列出在n天之前（不包含n天本身）被修改过的文件 -mtime -n: 列出在n天之内（包含n天本身）被修改过的文件 newer file: file为一个已存在的文件，列出比file还要新的文件名 列出 home 目录中，当天（24 小时之内）有改动的文件：1$ find ~ -mtime 0 列出用户家目录下比Code文件夹新的文件：1$ find ~ -newer /home/shiyanlou/Code 《黑客帝国》电影里满屏幕代码的“数字雨”，在 Linux 里面也可以轻松实现这样的效果，只需要一个命令cmatrix。需要先安装，因为 Ubuntu 没有预装：1$ sudo apt-get update;sudo apt-get install cmatrix 文件打包与解压缩文件打包和解压缩在 Windows 上最常见的不外乎这三种.zip,.rar,.7z后缀的压缩文件，而在 Linux 上面常见常用的除了以上这三种外，还有.gz,.xz,.bz2,.tar,.tar.gz,.tar.xz,tar.bz2，简单介绍如下：文件后缀名 说明.zip zip程序打包压缩的文件 .rar rar程序压缩的文件.7z 7zip程序压缩的文件 .tar tar程序打包，未压缩的文件.gz gzip程序(GNU zip)压缩的文件 .xz xz程序压缩的文件.bz2 bzip2程序压缩的文件 .tar.gz tar打包，gzip程序压缩的文件.tar.xz tar打包，xz程序压缩的文件 tar.bz2 tar打包，bzip2程序压缩的文件*.tar.7z tar打包，7z程序压缩的文件 zip压缩打包程序使用zip打包文件夹： 123$ zip -r -q -o nancy.zip /home/nancy$ du -h nancy.zip$ file nancy.zip 上面命令将 nancy 的 home 目录打包成一个文件，并查看了打包后文件的大小和类型。-r参数表示递归打包包含子目录的全部内容，-q参数表示为安静模式，即不向屏幕输出信息，-o，表示输出文件，需在其后紧跟打包输出文件名。后面使用du命令查看打包后文件的大小。 设置压缩级别为9和1（9最大,1最小），重新打包： 12$ zip -r -9 -q -o nancy_9.zip /home/nancy -x ~/*.zip$ zip -r -1 -q -o nancy_1.zip /home/nancy -x ~/*.zip 这里添加了一个参数用于设置压缩级别-[1-9]，1表示最快压缩但体积大，9表示体积最小但耗时最久。最后那个-x是为了排除我们上一次创建的 zip 文件，否则又会被打包进这一次的压缩文件中，注意:这里只能使用绝对路径，否则不起作用。 我们再用du命令分别查看默认压缩级别、最低、最高压缩级别及未压缩的文件的大小：1$ du -h -d 0 *.zip ~ | sort 通过man 手册可知： h, --human-readable（顾名思义，你可以试试不加的情况） d, --max-depth（所查看文件的深度） 在环境中操作之后看到的大小可能跟图上的有些不同，因为在使用过程中，会随时还生成一些缓存文件在当前用户的家目录中，这对于学习命令使用来说，是无关紧要的，可以忽略这些不同。 创建加密zip包 使用-e参数可以创建加密压缩包：1$ zip -r -e -o nancy_encryption.zip /home/nancy 注意: 关于zip命令，因为 Windows 系统与 Linux/Unix 在文本文件格式上的一些兼容问题，比如换行符（为不可见字符），在 Windows 为 CR+LF（Carriage-Return+Line-Feed：回车加换行），而在 Linux/Unix 上为 LF（换行），所以如果在不加处理的情况下，在 Linux 上编辑的文本，在 Windows 系统上打开可能看起来是没有换行的。如果你想让你在 Linux 创建的 zip 压缩文件在 Windows 上解压后没有任何问题，那么你还需要对命令做一些修改：1$ zip -r -l -o nancy.zip /home/nancy 需要加上-l参数将LF转换为CR+LF来达到以上目的。 使用unzip命令解压缩zip文件将shiyanlou.zip解压到当前目录：1$ unzip shiyanlou.zip 使用安静模式，将文件解压到指定目录：1$ unzip -q shiyanlou.zip -d ziptest 上述指定目录不存在，将会自动创建。如果不想解压只想查看压缩包的内容可以使用-l参数：1$ unzip -l shiyanlou.zip 注意： 使用unzip解压文件时我们同样应该注意兼容问题，不过这里我们关心的不再是上面的问题，而是中文编码的问题，通常 Windows 系统上面创建的压缩文件，如果有有包含中文的文档或以中文作为文件名的文件时默认会采用 GBK 或其它编码，而 Linux 上面默认使用的是 UTF-8 编码，如果不加任何处理，直接解压的话可能会出现中文乱码的问题（有时候它会自动帮你处理），为了解决这个问题，我们可以在解压时指定编码类型。 使用-O（英文字母，大写o）参数指定编码类型：1unzip -O GBK 中文压缩文件.zip rar打包压缩命令rar也是 Windows 上常用的一种压缩文件格式，在 Linux 上可以使用rar和unrar工具分别创建和解压 rar 压缩包。 安装rar和unrar工具： 12$ sudo apt-get update$ sudo apt-get install rar unrar 从指定文件或目录创建压缩包或添加文件到压缩包： 12$ rm *.zip$ rar a nancy.rar . 上面的命令使用a参数添加一个目录～到一个归档文件中，如果该文件不存在就会自动创建。注意：rar 的命令参数没有-，如果加上会报错。 从指定压缩包文件中删除某个文件： 1$ rar d nancy.rar .zshrc 查看不解压文件： 1$ rar l nancy.rar 使用unrar解压rar文件 全路径解压：1$ unrar x nancy.rar 去掉路径解压：12$ mkdir tmp$ unrar e nancy.rar tmp/ rar命令参数非常多，上面只涉及了一些基本操作。 tar打包工具创建一个 tar 包： 1$ tar -cf nancy.tar ~ -c表示创建一个 tar 包文件，-f用于指定创建的文件名，注意文件名必须紧跟在-f参数之后，比如不能写成tar -fc nancy.tar，可以写成tar -f nancy.tar -c ~。你还可以加上-v参数以可视的的方式输出打包的文件。上面会自动去掉表示绝对路径的/，你也可以使用-P保留绝对路径符。 解包一个文件(-x参数)到指定路径的已存在目录(-C参数)： 12$ mkdir tardir$ tar -xf nancy.tar -C tardir 只查看不解包文件-t参数： 1$ tar -tf nancy.tar 保留文件属性和跟随链接（符号链接或软链接），有时候我们使用tar备份文件当你在其他主机还原时希望保留文件的属性(-p参数)和备份链接指向的源文件而不是链接本身(-h参数)： 1$ tar -cphf etc.tar /etc 对于创建不同的压缩格式的文件，对于tar来说是相当简单的，需要的只是换一个参数，这里我们就以使用gzip工具创建*.tar.gz文件为例来说明。 我们只需要在创建 tar 文件的基础上添加-z参数，使用gzip来压缩文件： 1$ tar -czf nancy.tar.gz ~ 解压*.tar.gz文件： 1$ tar -xzf nancy.tar.gz 要使用其他的压缩工具创建或解压相应文件只需要更改一个参数即可：压缩文件格式 参数.tar.gz -z .tar.xz -J*tar.bz2 -j 趣味程序（火炉）：12$ sudo apt-get install libaa-bin $ aafire 文件系统操作与磁盘管理简单文件系统操作使用 df 命令查看磁盘的容量1$ df 物理主机上的 /dev/sda2 是对应着主机硬盘的分区，后面的数字表示分区号，数字前面的字母 a 表示第几块硬盘（也可能是可移动磁盘），如果主机上有多块硬盘则可能还会出现 /dev/sdb，/dev/sdc 这些磁盘设备都会在 /dev 目录下以文件的存在形式。 还会看到”1k-blocks”，它表示以磁盘块大小的方式显示容量，后面为相应的以块大小表示的已用和可用容量。使用 du 命令查看目录的容量1234# 默认同样以 blocks 的大小展示$ du # 加上`-h`参数，以更易读的方式展示$ du -h -d参数指定查看目录的深度1234# 只查看1级目录的信息$ du -h -d 0 ~# 查看2级$ du -h -d 1 ~ 简单的磁盘管理下面涉及的命令具有一定的危险性，操作不当可能会丢失你的个人数据，初学者建议在虚拟环境中进行操作 创建虚拟磁盘dd 命令简介dd命令用于转换和复制文件，不过它的复制不同于cp。之前提到过关于 Linux 的很重要的一点，一切即文件，在 Linux 上，硬件的设备驱动（如硬盘）和特殊设备文件（如/dev/zero和/dev/random）都像普通文件一样，只要在各自的驱动程序中实现了对应的功能，dd 也可以读取自和/或写入到这些文件。这样，dd也可以用在备份硬件的引导扇区、获取一定数量的随机数据或者空数据等任务中。dd程序也可以在复制时处理数据，例如转换字节序、或在 ASCII 与 EBCDIC 编码间互换。 dd的命令行语句与其他的 Linux 程序不同，因为它的命令行选项格式为选项=值，而不是更标准的–选项 值或-选项=值。dd默认从标准输入中读取，并写入到标准输出中，但可以用选项if（input file，输入文件）和of（output file，输出文件）改变。 我们先来试试用dd命令从标准输入读入用户输入到标准输出或者一个文件：12345678# 输出到文件$ dd of=test bs=10 count=1 # 或者 dd if=/dev/stdin of=test bs=10 count=1hello$ cat test# 输出到标准输出$ dd if=/dev/stdin of=/dev/stdout bs=10 count=1world$ cat test 上述命令从标准输入设备读入用户输入（缺省值，所以可省略）然后输出到 test 文件，bs（block size）用于指定块大小（缺省单位为 Byte，也可为其指定如’K’，’M’，’G’等单位），count用于指定块数量。 dd在拷贝的同时还可以实现数据转换。例，将输出的英文字符转换为大写再写入文件：123$ dd if=/dev/stdin of=test bs=10 count=1 conv=ucasehello$ cat test 结果将是HELLO。可在man文档查看其它所以转换参数。 使用dd命令创建寻镜像文件从/dev/zero设备创建一个容量为 256M 的空文件：12$ dd if=/dev/zero of=virtual.img bs=1M count=256$ du -h virtual.img 使用 mkfs 命令格式化磁盘（这里是自己创建的虚拟磁盘镜像）在命令行输入 sudo mkfs 然后按下Tab键，有多个以 mkfs 为前缀的命令，这些不同的后缀是表示不同的文件系统，可以用 mkfs 格式化成的文件系统。例，将虚拟磁盘镜像格式化为ext4文件系统：1$ sudo mkfs.ext4 virtual.img 实际 mkfs.ext4 是使用 mke2fs 来完成格式化工作的。想知道 Linux 支持哪些文件系统可输入ls -l /lib/modules/$(uname -r)/kernel/fs查看。 使用mount命令挂载磁盘到目录树该指令通常是使用在 USB 或其他可移除存储设备上，而根目录则需要始终保持挂载的状态。使用mount查看主机已挂载的文件系统：1$ sudo mount mount命令的一般格式如下：1mount [options] [source] [directory] 一些常用操作：1mount [-o [操作选项]] [-t 文件系统类型] [-w|--rw|--ro] [文件系统源] [挂载点] 例，挂载创建的虚拟磁盘镜像到/mnt目录：12345$mount -o loop -t ext4 virtual.img /mnt# 挂载类型可省，会自动识别#以只读方式挂载$ mount -o loop --ro virtual.img /mnt#或者mount -o loop,ro virtual.img /mnt 使用umount命令卸载已挂载磁盘12# 命令格式 sudo umount 已挂载设备或挂载点$ sudo umount /mnt 使用fdisk为磁盘分区12345# 查看银盘分区表信息$ sudo fdisk -l# 进入磁盘分区模式$ sudo fdisk virtual.img 然后分区。 使用loseup命令建立镜像与回环设备的关联12345$ sudo losetup /dev/loop0 virtual.img# 若提示设备忙可使用其它回环设备，&quot;ls /dev/loop*&quot;查看所有回环设备# 解除设备关联$ sudo losetup -d /dev/loop0 然后再使用mkfs格式化各分区，格式化之前需为各分区建立虚拟设备的映射，用到kpartx工具，需安装：12345$ sudo apt-get install kpartx$ sudo kpartx -av /dev/loop0#取消映射$ sudo kpartx -dv /dev/loop0 接着是格式化：123$ sudo mkfs.ext4 -q /dev/mapper/loop0p1$ sudo mkfs.ext4 -q /dev/mapper/loop0p5$ sudo mkfs.ext4 -q /dev/mapper/loop0p6 格式化完成后在/media目录下新建四个空目录用于挂载虚拟磁盘：12345678910111213$ mkdir -p /media/virtualdisk_&#123;1..3&#125;# 挂载磁盘分区$ sudo mount /dev/mapper/loop0p1 /media/virtualdisk_1$ sudo mount /dev/mapper/loop0p5 /media/virtualdisk_2$ sudo mount /dev/mapper/loop0p6 /media/virtualdisk_3# 卸载磁盘分区$ sudo umount /dev/mapper/loop0p1$ sudo umount /dev/mapper/loop0p5$ sudo umount /dev/mapper/loop0p6$ df -h 趣味程序cowsay命令，可在终端里以动物说话的形式打印一段话。1234567891011121314# 安装$ sudo apt-get install cowsay# 默认是一只牛$ cowsay hello shiyanlou# 加上&apos;-l&apos;参数打印所有支持的动物种类$ cowsay -l# 使用&apos;-f&apos;参数选择动物种类$ cowsay -f elephant hello shiyanlou# 此外它还可以结合fortune命令一起使用$ fortune | cowsay -f daemon Linux下的帮助命令内建命令与外部命令内建命令：shell程序的一部分，通常在系统加载时shell就被加载并驻留在系统内存中。如history、cd、exit等。外部命令：系统加载时不随系统一起被加载到内存中，需要时再调用内存。是在Bash之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin等等。如lsvi等。可使用type区分是内建命令还是外部命令。12type exittype service 123456# 内建命令，内建命令都是在 bash 源码中的 builtins 的.def中xxx is a shell builtin# 外部命令，外部命令在/usr/bin or /usr/sbin等等中xxx is /usr/sbin/xxx#若是得到alias的结果，说明该指令为命令别名所设定的名称；xxx is an alias for xx --xxx 帮助命令的使用help命令进入bash，bash中内置该命令：1bash 1help ls 会出错。因为help命令只能用于显示内建命令的帮助信息。 若是外部命令，需：1ls --help man命令1man ls 得到的内容比help更详细，且无内建命令与外部命令的区别。 man手册：章节数 说明1 Standard commands （标准命令）2 System calls （系统调用）3 Library functions （库函数）4 Special devices （设备说明）5 File formats （文件格式）6 Games and toys （游戏和娱乐）7 Miscellaneous （杂项）8 Administrative Commands （管理员命令）9 其他（Linux特定的）， 用来存放内核例行程序的文档。 可通过pgup与pgdn或上下键翻看，按q退出。 info命令1info ls 比man更详细。 Linux任务计划crontabcrontab的使用crontab简介crontab命令用于设置周期性被执行的指令。该命令从输入设备读取指令，并将其存放在crond文件中，以供之后读取和执行。通常，crontab 储存的指令被守护进程激活，crond 为其守护进程，crond 常常在后台运行，每一分钟会检查一次是否有预定的作业需要执行。通过 crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script 脚本。时间间隔的单位可以是分钟、小时、日、月、周的任意组合。crontab格式：12345678# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed crontab准备Ubuntu默认启动。 crontab使用添加一个计划任务：1crontab -e 出现选择编辑工具，这里选第一个基本的vim。1man crontab 查看详细格式。 添加任务：在文档的最后一排加上一排命令,该任务是每分钟我们会在/home/test目录下创建一个以当前的年月日时分秒为名字的空白文件1*/1 * * * * touch /home/test/$(date +\\%Y\\%m\\%d\\%H\\%M\\%S) 添加成功后我们会得到最后一排 installing new crontab 的一个提示。也可以通过这样的一个指令来查看我们添加了哪些任务1crontab -l 虽然添加了任务，但是如果 cron 的守护进程没有启动，它不会监测到有任务，也就不会执行，通过以下2种方式来确定cron是否成功的在后台启动。123ps aux|grep cronorpgrep cron 查看执行任务命令之后在日志中的信息反馈1sudo tail -f /var/log/syslog 删除任务：1crontab -r crontab的深入每个用户使用 crontab -e 添加计划任务，都会在 /var/spool/cron/crontabs 中添加一个该用户自己的任务文档，这样目的是为了隔离。如果是系统级别的定时任务，只需要以 sudo 权限编辑 /etc/crontab 文件就可以。 cron 服务监测时间最小单位是分钟，所以 cron 会每分钟去读取一次 /etc/crontab 与 /var/spool/cron/crontabs 里面的內容。 在 /etc 目录下，cron 相关的目录有下面几个：每个目录的作用：/etc/cron.daily，目录下的脚本会每天执行一次，在每天的6点25分时运行；/etc/cron.hourly，目录下的脚本会每个小时执行一次，在每小时的17分钟时运行；/etc/cron.monthly，目录下的脚本会每月执行一次，在每月1号的6点52分时运行；/etc/cron.weekly，目录下的脚本会每周执行一次，在每周第七天的6点47分时运行；系统默认执行时间可以根据需求进行修改。 进一步学习参考http://linux.vbird.org/linux_basic/0430cron.php 命令执行顺序控制与管道命令执行顺序的控制顺序执行多条命令一般终端一次输入一条命令，按下回车执行。若需一次执行多条命令，可用；完成。1$ sudo apt-get update;sudo apt-get install some-tool;some-tool 有选择的执行命令若需上一条命令执行成功才执行下一条，或不成功执行其它什么处理，可使用which来查找是否安装某个命令。例：1$ which cowsay&gt;/dev/null &amp;&amp; cowsay -f head-in ohch~ 使用$?环境变量获取上一次命令的返回结果：1234567$ which cowsaycowsay not found$ echo $?$ which cat/bin/cat$ echo $?0 ||与&amp;&amp;结果相反，当上一条命令执行结果为≠0($?≠0)时则执行它后面的命令。 1$ which cowsay&gt;/dev/null || echo &quot;cowsay has not been install, please run &apos;sudo apt-get install cowsay&apos; to install&quot; 1$ which cowsay&gt;/dev/null &amp;&amp; echo &quot;exist&quot; || echo &quot;not exist&quot; 管道管道是一种通信机制，通常用于进程间的通信（也可通过socket进行网络通信）。它表现出来的形式是将前面每一个进程的输出（stdout）直接作为一个进程的输入（stdin）。管道分为匿名管道和具名管道。在使用一些过滤程序时经常用到匿名管道，在命令行中由|分隔符表示。具名管道，简单来说是有名字的管道，通常只在源程序中用到具名管道。 试用例：查看/etc目录下有哪些文件和目录，使用ls命令来查看：1$ ls -al /etc 有太多内容屏幕不能完全显示，此时可用滚动条或快捷键滚动窗口来查看。也可以使用管道：1$ ls -al /etc | less 通过管道将前一个命令（ls）的输出作为下一个命令（less）的输入，就可以一行行看了。 cut命令cut命令，打印每一行的某一字段。例：打印/etc/passwd文件中以:为分隔符的第1个字段和第6个字段分别表示用户名和其家目录：1cut /etc/passwd -d &apos;:&apos; -f 1,6 打印/etc/passewd文件中每一行的前N个字符：12345678# 前五个（包含第五个）$ cut /etc/passwd -c -5# 前五个之后的（包含第五个）$ cut /etc/passwd -c 5-# 第五个$ cut /etc/passwd -c 5# 2到5之间的（包含第五个）$ cut /etc/passwd -c 2-5 grep命令grep命令，在文本中或stdin中查找匹配字符串。它结合正则表达式可以实现很复杂却很高效的匹配和查找。grep命令的一般形式为：1grep [命令选项]... 用于匹配的表达式 [文件]... 搜索/home目录下所有包含”helloworld”的所有文本文件，并显示在文本中的行号：1$ grep -rnI &quot;helloworld&quot; ~ -r参数表示递归搜索子目录中的文件，-n表示打印匹配项行号，-I表示忽略二进制文件。 也可在匹配字段中使用正则表达式：12# 查看环境变量中以&quot;helloworld&quot;结尾的字符串$ export | grep &quot;.*helloworld$&quot; $表示一行的末尾。 wc命令wc命令，简单小巧的计数工具。wc命令用于统计并输出一个文件中行、单词和字节的数目，例：输出/etc/passwd文件的统计信息：1$ wc /etc/passwd 分别只输出行数、单词数、字节数、字符数和输入文本中最长一行的字节数：12345678910# 行数$ wc -l /etc/passwd# 单词数$ wc -w /etc/passwd# 字节数$ wc -c /etc/passwd# 字符数$ wc -m /etc/passwd# 最长行字节数$ wc -L /etc/passwd 注意：对于西文字符来说，一个字符就是一个字节，但对于中文字符一个汉字是大于2个字节的，具体数目是由字符编码决定的。 结合管道统计/etc下面所有目录数：1$ ls -dl /etc/*/ | wc -l sort排序命令将输入按照一定方式排序，然后再输出,它支持的排序有按字典排序,数字排序，按月份排序，随机排序，反转排序，指定特定字段进行排序等等。默认为字典排序：1$ cat /etc/passswd | sort 反转排序：1$ cat /etc/passwd | sort -r 按特定字段排序：1$ cat /etc/passwd | sort -t&apos;:&apos; -k 3 -t参数用于指定字段的分隔符，-k字段号用于指定对哪一个字段进行排序。若/etc/passwd文件的第三个字段为数字，默认情况下是以字典序排序的，若要按照数字排序则要加上-n参数：1$ cat /etc/passwd | sort -t&apos;:&apos; -k 3 -n uniq去重命令uniq命令可用于过滤或输出重复行。 过滤重复行可使用history命令查看最近执行过的命令，若只想查看使用了哪个命令而无需知道具体干了什么，可去掉命令后的参数并去掉重复的命令：1$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | uniq uniq命令只能去除连续重复的行，不是全文去重。 要达到预期效果，先排序：12$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort | uniq# 或 $ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort -u 输出重复行1234# 输出重复过的行（重复的只输出一个）及重复次数$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort | uniq -dc# 输出所有重复的行$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort | uniq -D 简单的文本处理文本处理命令tr命令tr命令可用来删除一段文本信息中的某些文字，或将其进行转换。 使用方式：1tr [option]...SET1 [SET2] 常用的选项有：选项 说明-d 删除和set1匹配的字符，注意不是全词匹配也不是按字符顺序匹配-s 去除set1指定的在输入文本中连续并重复的字符例:1234567# 删除“hello world”中所有的&apos;o&apos;,&apos;l&apos;,&apos;h&apos;$ echo &apos;hello world&apos; | tr -d &apos;olh&apos;# 将‘hello’中的ll，去重为一个l$ echo &apos;hello&apos; | tr -s &apos;l&apos;# 将输入文本，全部转换为大写或小写输出$ echo &apos;input some text here&apos; | tr &apos;[:lower:]&apos;&apos;[:upper:]&apos;# 上面的&apos;[:lower:]&apos;&apos;[:upper:]&apos;也可简写为&apos;[a-z]&apos;&apos;[A-Z]&apos;，反过来将大写变小写也是可以的 col命令col命令可将Tab换成对等数量的空格，或反转该操作。使用方式：1col [option] 常用的选项有：选项 说明-x 将Tab转换为空格-h 将空格转换为Tab（默认选项）例：1234# 查看/etc/protocols中的不可见字符，可看到很多^I，这其实是Tab转移成可见字符的符号$ cat -A /etc/protocols# 使用col -x将/etc/protocols中的Tab转换为空格，然后再使用cat查看，会发现^I不见了$ cat /etc/protocols | col -x | cat -A join命令join命令用于将两个文件中包含相同内容的那一行合并在一起。使用方式：1join [option]... file1 file2 常用的选项有：选项 说明-t 指定分隔符，默认为空格-i 忽略大小写的差异-1 指明第一个文件要用哪个字段来对比，默认对比第一个字段-2 指明第二个文件要用哪个字段来对比，默认对比第一个字段 例：12345678# 创建两个文件$ echo &apos;1 hello&apos; &gt; file1$ echo &apos;1 world&apos; &gt; file2$ join file1 file2# 将/etc/passwd与/etc/shadow两个文件合并，指定以&apos;:&apos;作为分隔符$ sudo join -t &apos;:&apos; /etc/passwd /etc/shadow# 将/etc/passwd与/etc/group两个文件合并，指定以&apos;:&apos;作为分隔符，分别比对第4和第3个字段$ sudo join -t &apos;:&apos; -1 4 /etc/passwd -2 3 /etc/group paste命令与join命令类似，它是在不对比数据的情况下，简单地将多个文件合并在一起，以Tab隔开。使用方式：1paste [option] file... 常用的选项有：选项 说明-d 指定合并的分隔符，默认为Tab-s 不合并到一行，每个文件为一行 例：12345$ echo hello &gt; file1$ echo world &gt; file2$ echo www.hubojing.me &gt; file3$ paste -d &apos;:&apos; file1 file2 file3$ paste -s file1 file2 file3 输出结果为：1234hello:world:www.hubojing.mehelloworldwww.hubojing.me 数据流重定向重定向，将输出到标准输出的数据重定向到一个文件中。如&gt;或&gt;&gt;操作。 数据流重定向123$ echo &apos;hello world&apos; &gt; redirect$ echo &apos;www.hubojing.me&apos; &gt;&gt; redirect$ cat redirect &gt;表示从左到右，&lt;从右到左。 简单的重定向Linux默认提供三个特殊设备，用于终端显示和输出，分别为stdin（标准输入），stdout（标准输出），stderr（标准错误输出）。文件描述符 设备文件 说明0 /dev/stdin 标准输入1 /dev/stdout 标准输出2 /dev/stderr 标准错误 文件描述符是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。 默认使用终端的标准输入作为命令的输入和标准输出作为命令的输出：12$ cat(按Ctrl+C退出) 将cat的连续输出（heredoc方式）重定向到一个文件1234567891011$ mkdir Documents$ cat &gt; Documents/test.c &lt;&lt;EOF#include &lt;stdio.h&gt;int main()&#123; printf(&quot;hello world\\n&quot;); return 0;&#125;EOF 将一个命令作为命令的输入，标准输出作为命令的输出1$ cat Documents/test.c 将echo命令通过管道传过来的数据作为cat命令的输入，将标准输出作为命令的输出1$ echo &apos;hi&apos; | cat 将echo命令的输出从默认的标准输出重定向到一个普通文件12$ echo &apos;hello world&apos; &gt; redirect$ cat redirect 输出结果：1hello world 管道和重定向的区别：管道默认是连接前一个命令的输出到下一个命令的输入，重定向是需要一个文件来建立两个命令的连接。 标准错误重定向12# 使用cat命令同时读取两个文件，其中一个存在，另一个不存在$ cat Documents/test.c hello.c 结果：12345678#include &lt;stdio.h&gt;int main()&#123; printf(&quot;hello world\\n&quot;); return 0;&#125;cat: hello.c:没有那个文件或目录 按理，继续将输出重定向到一个文件，将看不到任何输出1$ cat Documents/test.c hello.c &gt; somefile 然而依然出现了同样的错误信息。标准输出和标准错误虽然都指向终端屏幕，实际它们并不一样。若要隐藏某些错误或者警告，就需要用到文件描述符。1234# 将标准错误重定向到标准输出，再将标准输出重定向到文件，注意要将重定向到文件写到前面$ cat Documents/test.c hello.c &gt;somefile 2&gt;&amp;1# 或者只用bash提供的特殊的重定向符号&quot;&amp;&quot;将标准错误和标准输出同时重定向到文件$ cat Documents/test.c hello.c &amp;&gt;somefilehell 注意应该在输出重定向文件描述符前加上&amp;,否则shell会当做重定向到一个文件名为1的文件中。 使用tee命令同时重定向到多个文件除了西药将输出重定向到文件，也需要将信息打印在终端的话，1234$ echo &apos;hello world&apos; | tee hellohello world$ cat hellohello world 永久重定向之前的操作都是临时性的，若要实现永久有效，例如在一个脚本中，需要在某一部分的命令的输出全部进行重定向，并不需要在每个命令上加上临时重定向的操作，使用exec命令即可。exec命令是使用指定的命令替换当前的Shell，及使用一个进程替换当前进程，或指定新的重定向：12345678# 先开启一个子 Shell$ zsh# 使用exec替换当前进程的重定向，将标准输出重定向到一个文件$ exec 1&gt;somefile# 后面执行的命令的输出都将被重定向到文件中,直到退出当前子shell，或取消exec的重定向$ ls$ exit$ cat somefile 创建输出文件描述符在Shell中有9个文件描述符。上面使用了它默认提供的0,1,2号文件描述符。查看当前Shell进程中打开的文件描述符：1$ cd /dev/fd/;ls -Al 使用exec命令创建新的文件描述符：12345678$ zsh$ exec 3&gt;somefile# 先进入目录再查看，否则可能不能得到正确的结果，然后再回到上一次的目录$ cd /dev/fd/;ls -Al;cd -# 注意下面的命令&gt;与&amp;之间不应该有空格，如果有空格则会出错$ echo &quot;this is test&quot; &gt;&amp;3$ cat somefile$ exit 关闭文件描述符例：上面打开的3号文件描述符，使用如下操作关闭它：12$ exec 3&gt;&amp;-$ cd /dev/fd;ls -Al;cd - 完全屏蔽命令的输出Linux中有一个被称为“黑洞”的设备文件，所有导入它的数据都将被“吞噬”。在类UNIX系统中，/dev/null，或称空设备，是一个特殊的设备文件，通常用于丢弃不需要的输出流，或作为用于输入流的空文件，这些操作通常由重定向完成。读取它则会立即得到一个EOF。设个/dev/null屏蔽命令的输出：1$ cat Documents/test.c nefile 1&gt;/dev/null 2&gt;&amp;1 上述操作将得不到任何输出结果。 使用xargs分割参数列表xargs是一条UNIX和类UNIX操作系统的常用命令。作用是将参数列表转换成小块分段传递给其它命令，以避免参数列表过长。当处理产生大量输出结果的命令，如find，locate和grep的结果。1$ cat -d: -f1 &lt; /etc/passwd | sort | xargs echo 该命令用于将/etc/passwd文件按:分割取第一个字段排序后，使用echo命令生成一个列表。 轻松一下：将图片转换为 ascii 字符查看的工具 aview/asciiview，彩色的。1234$ sudo apt-get install caca-utils$ cacaview &lt;pic_file&gt;$ cacademo$ cacafire 正则表达式基础正则表达式正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。 和通配符的区别：例：1shi* 正则表达式：*表示匹配前面的子表达式（这里就是它前面一个字符）零次或多次，比如它可以匹配”sh”,”shii”,”shish”,”shiishi”等等。通配符：匹配通配符后面任意多个任意字符，所以它可以匹配”shiyanlou”，和”shiyanxiang”两个字符。 基本语法一个正则表达式通常被称为一个模式（pattern），用来描述或匹配一系列符合某个句法规则的字符串。 选择|竖直分隔符表示选择，如”boy|girl”匹配”boy”或”girl” 数量限定除了*，还有+，?，如果在一个模式中不加数量限定符则表示出现一次且仅出现一次： +表示前面的字符必须出现至少一次（一次或多次），如，”goo+gle”可匹配”gooogle””goooogle”等； ?表示前面的字符最多出现一次（0次或1次），如，”clou?r”可匹配”color”或”colour”; *表示前面的字符可以不出现，也可以出现一次或多次（0次或1次或多次），如”0*42”可匹配42、042、0042、00042等。 范围和优先级()可以用来定义模式字符串的范围和优先级。如，”gr(a|e)y”等价于”gray|grey”，”(grand)?father”匹配father和grandfather(?将圆括号内容作为一个整体匹配)。 语法（部分）正则表达式有多种不同的风格，下面列举一些常用的作为 PCRE 子集的适用于perl和python编程语言及grep或egrep的正则表达式匹配规则：(由于markdown表格解析的问题，下面的竖直分隔符用全角字符代替，实际使用时请换回半角字符) 语法 优先级优先级为从上到下从左到右依次降低： 优先级 关于正则表达式的资料：正则表达式wiki几种正则表达式引擎的语法差异各语言各平台对正则表达式的支持 regex思维导图：regex思维导图 grep模式匹配命令基本操作grep命令用于打印输出文本中匹配的模式串，它使用正则表达式作为模式匹配的条件。它支持三种正则表达式引擎，分别用三个参数指定：参数 说明-E POSIX扩展正则表达式，ERE-G POSIX基本正则表达式，BRE-P Perl正则表达式，PCRE 常用参数：参数 说明-b 将二进制文件作为文本来进行匹配-c 统计以模式匹配的数目-i 忽略大小写-n 显示匹配文本所在行的行号-v 反选，输出不匹配行的内容-r 递归匹配查找-A n n为正整数，表示after的意思，除了列出匹配行之外，还列出后面的n行-B n n为正整数，表示before的意思，除了列出匹配行之外，还列出前面的n行–color=auto 将输出中的匹配项设置为自动颜色显示 注：大多数发行版中是默认了grep的颜色的，可通过参数指定或修改GREP_COLOR环境变量。 使用正则表达式基本正则表达式，BRE 位置查找/etc/group文件中以”helloworld”为开头的行 12$ grep &apos;helloworld&apos; /etc/group$ grep &apos;helloworld&apos; /etc/group 数量 123456# 将匹配以&apos;z&apos;开头以&apos;o&apos;结尾的所有字符串$ echo &apos;zero\\nzo\\nzoo&apos; | grep &apos;z.*o&apos;# 将匹配以&apos;z&apos;开头以&apos;o&apos;结尾，中间包含一个任意字符的字符串$ echo &apos;zero\\nzo\\nzoo&apos; | grep &apos;z.o&apos;# 将匹配以&apos;z&apos;开头,以任意多个&apos;o&apos;结尾的字符串$ echo &apos;zero\\nzo\\nzoo&apos; | grep &apos;zo*&apos; \\n为换行符。 选择1234567891011121314# grep默认是区分大小写的，这里将匹配所有的小写字母$ echo &apos;1234\\nabcd&apos; | grep &apos;[a-z]&apos;# 将匹配所有的数字$ echo &apos;1234\\nabcd&apos; | grep &apos;[0-9]&apos;# 将匹配所有的数字$ echo &apos;1234\\nabcd&apos; | grep &apos;[[:digit:]]&apos;# 将匹配所有的小写字母$ echo &apos;1234\\nabcd&apos; | grep &apos;[[:lower:]]&apos;# 将匹配所有的大写字母$ echo &apos;1234\\nabcd&apos; | grep &apos;[[:upper:]]&apos;# 将匹配所有的字母和数字，包括0-9,a-z,A-Z$ echo &apos;1234\\nabcd&apos; | grep &apos;[[:alnum:]]&apos;# 将匹配所有的字母$ echo &apos;1234\\nabcd&apos; | grep &apos;[[:alpha:]]&apos; 下面包含完整的特殊符号及说明：特殊符号 说明[:alnum:] 代表英文大小写字母及数字，亦即 0-9, A-Z, a-z[:alpha:] 代表任何英文大小写字母，亦即 A-Z, a-z[:blank:] 代表空白键与 [Tab] 按键两者[:cntrl:] 代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等[:digit:] 代表数字而已，亦即 0-9[:graph:] 除了空白字节 (空白键与 [Tab] 按键) 外的其他所有按键[:lower:] 代表小写字母，亦即 a-z[:print:] 代表任何可以被列印出来的字符[:punct:] 代表标点符号 (punctuation symbol)，亦即：” ‘ ? ! ; : # $…[:upper:] 代表大写字母，亦即 A-Z[:space:] 任何会产生空白的字符，包括空白键, [Tab], CR 等等[:xdigit:] 代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字节注意：之所以要使用特殊符号，是因为上面的[a-z]不是在所有情况下都管用，这还与主机当前的语系有关，即设置在LANG环境变量的值，zh_CN.UTF-8的话[a-z]，即为所有小写字母，其它语系可能是大小写交替的如，”a A b B…z Z”，[a-z]中就可能包含大写字母。所以在使用[a-z]时请确保当前语系的影响，使用[:lower:]则不会有这个问题。12# 排除字符$ $ echo &apos;geek\\ngood&apos; | grep &apos;[^o]&apos; 注意:当^放到中括号内为排除字符，否则表示行首。 扩展正则表达式，ERE通过grep使用扩展正则表达式需加上-E参数，或使用egrep。 数量 1234# 只匹配&quot;zo&quot;$ echo &apos;zero\\nzo\\nzoo&apos; | grep -E &apos;zo&#123;1&#125;&apos;# 匹配以&quot;zo&quot;开头的所有单词$ echo &apos;zero\\nzo\\nzoo&apos; | grep -E &apos;zo&#123;1,&#125;&apos; 选择 1234# 匹配&quot;www.shiyanlou.com&quot;和&quot;www.google.com&quot;$ echo &apos;www.shiyanlou.com\\nwww.baidu.com\\nwww.google.com&apos; | grep -E &apos;www\\.(shiyanlou|google)\\.com&apos;# 或者匹配不包含&quot;baidu&quot;的内容$ echo &apos;www.shiyanlou.com\\nwww.baidu.com\\nwww.google.com&apos; | grep -Ev &apos;www\\.baidu\\.com&apos; .有特殊含义，需转义。 sed流编辑器sed工具在 man 手册里面的全名为”sed - stream editor for filtering and transforming text”，意即，用于过滤和转换文本的流编辑器。 前面的”vi/vim(编辑器之神)”,”emacs(神的编辑器)”,”gedit”编辑器，sed与上述的最大不同之处在于它是一个非交互式的编辑器。 sed常用参数介绍sed 命令基本格式：123sed [参数]... [执行命令] [输入文件]...# 形如：$ sed -i &apos;1s/sad/happy/&apos; test # 表示将test文件中第一行的&quot;sad&quot;替换为&quot;happy&quot; 参数 说明-n 安静模式，只打印受影响的行，默认打印输入数据的全部内容-e 用于在脚本中添加多个执行命令一次执行，在命令行中执行多个命令通常不需要加该参数-f filename 指定执行filename文件中的命令-r 使用扩展正则表达式，默认为标准正则表达式-i 将直接修改输入文件内容，而不是打印到标准输出设备 sed编辑器的执行命令sed执行命令格式：12345[n1][,n2]command[n1][~step]command# 其中一些命令可以在后面加上作用范围，形如：$ sed -i &apos;s/sad/happy/g&apos; test # g表示全局范围$ sed -i &apos;s/sad/happy/4&apos; test # 4表示指定行中的第四个匹配字符串 其中n1,n2表示输入内容的行号，它们之间为,逗号则表示从n1到n2行，如果为～波浪号则表示从n1开始以step为步进的所有行；command为执行动作，下面为一些常用动作指令： 命令 说明s 行内替换c 整行替换a 插入到指定行的后面i 插入到指定行的前面p 打印指定行，通常与-n参数配合使用d 删除指定行 例：先找一个文本文件：1$ cp /etc/passwd ~ 打印指定行1234# 打印2-5行$ nl passwd | sed -n &apos;2,5p&apos;# 打印奇数行$ nl passwd | sed -n &apos;1~2p&apos; 行内替换12# 将输入文本中&quot;helloworld&quot; 全局替换为&quot;hehe&quot;,并只打印替换的那一行，注意这里不能省略最后的&quot;p&quot;命令$ sed -n &apos;s/helloworld/hehe/gp&apos; passwd 行间替换1234$ nl passwd | grep &quot;hubojing&quot;# 删除第21行$ sed -n &apos;21c\\www.hubojing.me&apos; passwd（这里只把要删的行打印出来了，并没有真正的删除，若要删除，需使用-i参数） 关于sed资料：sed简明教程sed单行脚本快速参考sed完全手册 awk文本处理语言awk介绍简单地说，AWK是一种用于处理文本的编程语言工具。在大多数linux发行版上面，实际使用的是gawk（GNU awk，awk的GNU版本）。nawk,gawk,mawk。 基本概念awk所有的操作都是基于pattern(模式)—action(动作)对来完成的，如下面的形式：1$ pattern &#123;action&#125; 它将所有的动作操作用一对{}花括号包围起来。其中pattern通常是表示用于匹配输入的文本的“关系式”或“正则表达式”，action则是表示匹配后将执行的动作。在一个完整awk操作中，这两者可以只有其中一个，如果没有pattern则默认匹配输入的全部文本，如果没有action则默认为打印匹配内容到屏幕。 awk处理文本的方式，是将文本分割成一些“字段”，然后再对这些字段进行处理，默认情况下，awk以空格作为一个字段的分割符，不过这不是固定了，可以任意指定分隔符。 awk命令基本格式12awk [-F fs] [-v var=value] [-f prog-file | &apos;program text&apos;] [file...]其中-F参数用于预先指定前面提到的字段分隔符（还有其他指定字段的方式） ，-v用于预先为awk程序指定变量，-f参数用于指定awk命令要执行的程序文件，或者在不加-f参数的情况下直接将程序语句放在这里，最后为awk需要处理的文本输入，且可以同时输入多个文本文件。 例：先用vim新建一个文本文档1$ vim test 包含如下内容12I like linuxwww.hubojing.me 使用awk将本文内容打印到终端123456# &quot;quote&gt;&quot; 不用输入$ awk &apos;&#123;&gt; print&gt; &#125;&apos; test# 或者写到一行$ awk &apos;&#123;print&#125;&apos; test 说明:该操作省略了pattern，所以awk会默认匹配输入文本的全部内容，然后在”{}”花括号中执行动作，即print打印所有匹配项，这里是全部文本内容。 将test的第一行的每个字段单独显示为一行123456789101112131415$ awk &apos;&#123;&gt; if(NR==1)&#123;&gt; print $1 &quot;\\n&quot; $2 &quot;\\n&quot; $3&gt; &#125; else &#123;&gt; print&#125;&gt; &#125;&apos; test# 或者$ awk &apos;&#123;&gt; if(NR==1)&#123;&gt; OFS=&quot;\\n&quot;&gt; print $1, $2, $3&gt; &#125; else &#123;&gt; print&#125;&gt; &#125;&apos; test NR与OFS，这两个是awk内建的变量，NR表示当前读入的记录数，可简单的理解为当前处理的行数，OFS表示输出时的字段分隔符，默认为” “空格。将字段分隔符设置为\\n换行符，所以第一行原本以空格为字段分隔的内容就分别输出到单独一行了。然后是$N其中N为相应的字段号，这也是awk的内建变量，它表示引用相应的字段，因为这里第一行只有三个字段，所以只引用到了$3。除此之外另一个这里没有出现的$0，它表示引用当前记录（当前行）的全部内容。 将test的第二行的以点为分段的字段换成以空格为分隔1234567891011121314$ awk -F&apos;.&apos; &apos;&#123;&gt; if(NR==2)&#123;&gt; print $1 &quot;\\t&quot; $2 &quot;\\t&quot; $3&gt; &#125;&#125;&apos; test# 或者$ awk &apos;&gt; BEGIN&#123;&gt; FS=&quot;.&quot;&gt; OFS=&quot;\\t&quot; # 如果写为一行，两个动作语句之间应该以&quot;;&quot;号分开 &gt; &#125;&#123;&gt; if(NR==2)&#123;&gt; print $1, $2, $3&gt; &#125;&#125;&apos; test -F参数，它是用来预先指定待处理记录的字段分隔符。需注意除了指定OFS我们还可以在print 语句中直接打印特殊符号如这里的\\t，print打印的非变量内容都需要用””一对引号包围起来。上面另一个版本，展示了实现预先指定变量分隔符的另一种方式，即使用BEGIN，就这个表达式指示了，其后的动作将在所有动作之前执行，这里是FS赋值了新的”.”点号代替默认的” “空格。 awk常用的内置变量变量名 说明FILENAME 当前输入文件名，若有多个文件，则只表示第一个。如果输入是来自标准输入，则为空字符串$0 当前记录的内容$N N表示字段号，最大值为NF变量的值FS 字段分隔符，由正则表达式表示，默认为” “空格RS 输入记录分隔符，默认为”\\n”，即一行为一个记录NF 当前记录字段数NR 已经读入的记录数FNR 当前输入文件的记录数，请注意它与NR的区别OFS 输出字段分隔符，默认为” “空格ORS 输出记录分隔符，默认为”\\n” awk相关资料：awk程序设计语言awk简明教程awk用户指南 一个学习vim的游戏vim大冒险 Linux下软件安装在不同的linux发行版上面在线安装方式会有一些差异包括使用的命令及它们的包管理工具，本文基于ubuntu的，所以涉及的在线安装方式将只适用于ubuntu发行版，或其它基于ubuntu的发行版如国内的ubuntukylin(优麒麟)，ubuntu又是基于debian的发行版，它使用的是debian的包管理工具dpkg，所以一些操作也适用与debian。而在其它一些采用其它包管理工具的发行版如redhat，centos,fedora等将不适用(redhat和centos使用rpm)。 例：比如安装一个软件，名字叫做 w3m(w3m是一个命令行的简易网页浏览器)，那么输入如下命令：1$ sudo apt-get install w3m 注意:如果在安装一个软件之后，无法立即使用Tab键补全这可命令，可尝试先执行source ~/.zshrc，然后就可以使用补全操作。 apt包管理工具介绍APT是Advance Packaging Tool（高级包装工具）的缩写，是Debian及其派生发行版的软件包管理器，APT可以自动下载，配置，安装二进制或者源代码格式的软件包，因此简化了Unix系统上管理软件的过程。APT最早被设计成dpkg的前端，用来处理deb格式的软件包。现在经过APT-RPM组织修改，APT已经可以安装在支持RPM的系统管理RPM包。这个包管理器包含以 apt- 开头的的多个工具，如 apt-get apt-cache apt-cdrom等，在Debian系列的发行版中使用。当执行安装操作时，首先apt-get 工具会在本地的一个数据库中搜索关于 w3m 软件的相关信息，并根据这些信息在相关的服务器上下载软件安装。需定期从服务器上下载一个软件包列表，使用sudo apt-get update 命令来保持本地的软件包列表是最新的（有时也需要手动执行这个操作，比如更换了软件源），而这个表里会有软件依赖信息的记录，对于软件依赖，如，安装 w3m 软件时，需要 libgc1c2 软件包才能正常工作，这时 apt-get 在安装软件的时候会一并安装了，以保证 w3m 能正常的工作。 apt-getapt-get 是用于处理 apt包的公用程序集，我们可以用它来在线安装、卸载和升级软件包等，下面列出一些apt-get包含的常用的一些工具： 工具 说明install 其后加上软件包名，用于安装一个软件包update 从软件源镜像服务器上下载/更新用于更新本地软件源的软件包列表upgrade 升级本地可更新的全部软件包，但存在依赖问题时将不会升级，通常会在更新之前执行一次updatedist-upgrade 解决依赖关系并升级(存在一定危险性)remove 移除已安装的软件包，包括与被移除软件包有依赖关系的软件包，但不包含软件包的配置文件autoremove 移除之前被其他软件包依赖，但现在不再被使用的软件包purge 与remove相同，但会完全移除软件包，包含其配置文件clean 移除下载到本地的已经安装的软件包，默认保存在/var/cache/apt/archives/autoclean 移除已安装的软件的旧版本软件包下面是一些apt-get常用的参数： 参数 说明-y 自动回应是否安装软件包的选项，在一些自动化安装脚本中使用这个参数将十分有用-s 模拟安装-q 静默安装方式，指定多个q或者-q=#,#表示数字，用于设定静默级别，这在你不想要在安装软件包时屏幕输出过多时很有用-f 修复损坏的依赖关系-d 只下载不安装–reinstall 重新安装已经安装但可能存在问题的软件包–install-suggests 同时安装APT给出的建议安装的软件包 安装软件包只需要执行apt-get install &lt;软件包名&gt;即可。可使用如下方式重新安装：1$ sudo apt-get --reinstall install w3m 在不知道软件包完整名的时候进行安装，通常是使用Tab键补全软件包名，有时候需要同时安装多个软件包，可使用正则表达式匹配软件包名进行批量安装。 软件升级123456# 更新软件源$ sudo apt-get update# 升级没有依赖问题的软件包$ sudo apt-get upgrade# 升级并解决依赖关系$ sudo apt-get dist-upgrade 卸载软件sudo apt-get remove w3m或者12345# 不保留配置文件的移除$ sudo apt-get purge w3m# 或者 sudo apt-get --purge remove# 移除不再需要的被依赖的软件包$ sudo apt-get autoremove 软件搜索当刚知道了一个软件想下载使用，需要确认软件仓库里面有没有，需要用到搜索功能，命令如下：1sudo apt-cache search softname1 softname2 softname3…… apt-cache 命令则是针对本地数据进行相关操作的工具，search顾名思义在本地的数据库中寻找有关 softname1 softname2 …… 相关软件的信息。 关于APT的资料：APT HowTo 使用dpkgdpkg 是 Debian 软件包管理器的基础，它被伊恩·默多克创建于 1993 年。dpkg 与 RPM 十分相似，同样被用于安装、卸载和供给和 .deb 软件包相关的信息。 dpkg 本身是一个底层的工具。上层的工具，像是 APT，被用于从远程获取软件包以及处理复杂的软件包关系。”dpkg”是”Debian Package”的简写。经常可在网络上见到以deb形式打包的软件包，就需要使用dpkg命令来安装。 dpkg常用参数介绍： 参数 说明-i 安装指定deb包-R 后面加上目录名，用于安装该目录下的所有deb安装包-r remove，移除某个已安装的软件包-I 显示deb包文件的信息-s 显示已安装软件的信息-S 搜索已安装的软件包-L 显示已安装软件包的目录信息 使用dpkg安装deb软件包先使用apt-get加上-d参数只下载不安装，下载emacs编辑器的deb包。然后将第一个deb拷贝到home目录下，并使用dpkg安装123$ cp /var/cache/apt/archives/emacs24_24.3+1-2ubuntu1_amd64.deb ~# 安装之前参看deb包的信息$ sudo dpkg -I emacs24_24.3+1-2ubuntu1_amd64.deb 这个包还额外依赖了一些软件包，这意味着，如果主机目前没有这些被依赖的软件包，直接使用dpkg安装可能会存在一些问题，因为dpkg并不能解决依赖关系。12# 使用dpkg安装$ sudo dpkg -i emacs24_24.3+1-2ubuntu1_amd64.deb 会报错，要解决错误，要用到apt-get，使用-f参数，修复依赖关系的安装。1$ sudo apt-get -f install 安装成功，然后可以运行emacs程序。 查看已安装软件包的安装目录使用dpkg -L查看deb包目录信息1$ sudo dpkg -L emacs 从二进制包安装二进制包的安装比较简单，我们需要做的只是将从网络上下载的二进制包解压后放到合适的目录，然后将包含可执行的主程序文件的目录添加进PATH环境变量即可。 目前linux基本操作已基本结束。感谢实验楼。","raw":null,"content":null,"categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://hubojing.github.io/categories/操作系统/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://hubojing.github.io/tags/Linux/"}]},{"title":"回归","slug":"回归","date":"2016-12-26T13:16:07.000Z","updated":"2016-12-26T14:06:06.000Z","comments":true,"path":"2016/12/26/回归/","link":"","permalink":"https://hubojing.github.io/2016/12/26/回归/","excerpt":"","text":"考研大战初试昨日结束，我回来写文了！考研不易，且行且珍惜！无论如何，人生开启新旅程！在技术的海洋里遨游吧！向成为一名优秀的工程师迈进！","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/tags/杂谈/"}]},{"title":"上海决赛之旅 | the trip for contest in Shanghai","slug":"上海决赛之旅","date":"2016-08-27T07:43:53.000Z","updated":"2016-10-23T15:47:54.000Z","comments":true,"path":"2016/08/27/上海决赛之旅/","link":"","permalink":"https://hubojing.github.io/2016/08/27/上海决赛之旅/","excerpt":"上海决赛后的简单的感受，具体的技术方面探讨将在考研后详细更新。","text":"上海决赛后的简单的感受，具体的技术方面探讨将在考研后详细更新。 从上海比赛回来，说说几点感受：1.大神技术过硬。2.大神为作品倾注很多。3.创意和灵感的重要性。4.团队合作，找到志同道合的朋友。5.大神演讲能力极强，不怯场。6.自己的心态和学习程度都需要改正加强，差距是明显可见的。 衷心感谢学校的支持，能为学院和学校争取荣誉，同时实现自己初涉竞赛的心愿，找到自己和大神的距离，不虚此行。 I would like to spare my thoughts after my coming back from Shanghai for my competition.1.Superiors are excellent in technology.2.Superiors take times in their work.3.Idea and inspiration are insignificant.4.Team-work is needed,and we should find like-minded firends.5.Superiors have ability in giving a speech and never afraid of it.6.My attitude and learning need to be changed and improved,and the distance between superior and me is clearly to see. Thank you for the support from my university,and I’m prond of doing credit to my school and university.In the meanwhile,I realise my dream for first involve in contest.附自拍上海美景 P.S.the view of Shanghai","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/tags/杂谈/"}]},{"title":"说明","slug":"说明","date":"2016-07-16T10:20:32.000Z","updated":"2016-07-24T12:18:18.000Z","comments":true,"path":"2016/07/16/说明/","link":"","permalink":"https://hubojing.github.io/2016/07/16/说明/","excerpt":"","text":"有朋友问我为何最近github和博客都没有较多的维护和更新，现作出说明： 因本人自身发展问题，正积极备考研究生考试，直至考研结束，所以github和博客的维护和更新会延缓，但不会停止维护。希望完全回归时，自己能收获理想！学习，永不止步。望各位朋友理解！谢谢大家！","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/tags/杂谈/"}]},{"title":"P图集|PS picture album","slug":"P图集","date":"2016-06-29T11:58:18.000Z","updated":"2016-07-06T04:48:08.000Z","comments":true,"path":"2016/06/29/P图集/","link":"","permalink":"https://hubojing.github.io/2016/06/29/P图集/","excerpt":"\n过去的水文大家就别点开了。。。\n ","text":"过去的水文大家就别点开了。。。 自从学会Photoshop这个好用的工具后，对照片的处理更得心应手了。这是我的P图集。I use photoshop more effectively after I learned it.This is my PS picture album. 1 原图 冷色 暖色 2 原图 修后 我是想调成新海诚动漫画风效果的…不过水平还欠佳……I want to do it as Makoto Shinkai’s animation style,but my level just not reachs that high apparently.","raw":null,"content":null,"categories":[{"name":"多媒体","slug":"多媒体","permalink":"https://hubojing.github.io/categories/多媒体/"}],"tags":[{"name":"Photoshop","slug":"Photoshop","permalink":"https://hubojing.github.io/tags/Photoshop/"}]},{"title":"Linux菜鸟初尝鲜 | First try on Linux","slug":"Linux菜鸟初尝鲜","date":"2016-06-14T15:10:30.000Z","updated":"2016-10-23T15:26:48.000Z","comments":true,"path":"2016/06/14/Linux菜鸟初尝鲜/","link":"","permalink":"https://hubojing.github.io/2016/06/14/Linux菜鸟初尝鲜/","excerpt":"\n大三认真学技术打开新世界，常叹为何不早入技术门！I have learned technology to my best in my junior time,and I feel I should step into the technological world earlier!\n ","text":"大三认真学技术打开新世界，常叹为何不早入技术门！I have learned technology to my best in my junior time,and I feel I should step into the technological world earlier! 奈何大三事务多，惟愿考研考上给我又几年自学的机会……更认真地对待技术！Too busy in the junior,may I can gain another several years to learn in the postgraduate stage.I will be more hard-working!这一年，接触git、css、html，前端知识，尝试java，这学期又选了数据库sql，嵌入式系统Linux，还学了好用的工具Labview，这学期选的课都很实用！只是知识需要消化…… This year,I get to know git,css,html and fore-end knowledge,try java,and chose sql,linux and labview this semester,which are practical nowadays!Indeed,it takes time to understand them deeply.一直想了解Linux，无从下手，最后还是在课堂上被老师带着走入了linux的世界。Always want to know something about linux,but I just have no idea about it.Luckliy,I become to see you finally,linux. 2016.6.22更新 Update 一要点 昨天考完了嵌入式系统实验考试，get一个简单的要点：I got a small but esstenial point in my linux exam,armv4l-unknown-linux-gcc -o 开发板上的编译 winSCP’s compilergcc -o 虚拟机上的编译 VM’s compiler分清两种编译器。Please make sure your compiler is right.考试内容是开发板与虚拟机通信。开发板是client，虚拟机是server.（和之前的记录是相反的）My exam is VM communicate with winSCP.The winCSP is client,and the VM is server. 2016.6.14更新 Update 基础实验 熟悉Linux开发环境 Basic experiment Be familiar with Linux development environment 熟悉Linux开发环境，学会基于S3C2410的Linux开发环境的配置和使用。使用Linux的armv4l-unknown-linux-gcc编译，使用基于NFS方式的下载调试，了解嵌入式开发的基本过程。Be familiar with Linux development environment and learn configuration of Linux development environment based on S3C2410.Use compile of armv41-unknown-linux-gcc，use download and debug based on NFS mode,to learn the embedded development process. 实验步骤 Experiment steps1、建立工作目录 Create work directory2、编写程序源代码 Write code3、编写Makefile Write makefile4、编译应用程序 Compile program5、下载调试 Download and debug 重难点 Important pointMakefile文件定义了一系列的规则，它指明了哪些文件需要编译，哪些文件需要先编译，哪些文件需要重新编译等等更为复杂的命令。使用它带来的好处就是自动编译，你只需要敲一个“make”命令整个工程就可以实现自动编译。Makefile definite a series of rules,and it shows which files need compile,which first to be compiled,and which need recompile.The benefit is a simple “make” can finish automatic compilation. mount -t nfs -o nolock 192.168.0.56:/arm2410cl /host //超级终端中执行 carried out under the super terminal注意：IP地址需要根据宿主PC机的实际情况修改成对应arm2410cl目录。Attention:IP should be changed according to the real condition. 编译、修改程序都是在宿主机（本地PC机）上进行，不能在超级终端下进行。Compile and modify the program both in the host (local PC), and it can not be carried out under the super terminal. 课堂笔记备忘服务器与客户端通信虚拟机上（地址192.168.1.12）VM：cd /arm2410cl/cd expcd basiccd server（先把server.c和client.c拷入对应文件夹下 into right files）lsgcc -o client client.c //编译compilearmv41-unkown-linux-gcc -o server server.c //编译compile注意：修改了源文件记得要编译，保存还不够。Attention:It is vital to compile,not just save file. ./client123456 开发板(地址192.168.1.121)winSCP：ifconfig eth0 192.168.1.121mount -t nfs -o nolock 192.168.1.12:/arm2410c1 /host （挂载mount）cd /hostcd expcd basiccd serverls（可以ping 192.168.1.12检查一下是否连通 test if it is linked.）./server123456 exit退出连接 程序只能是客户端向服务端发送信息，不能反过来。Information can only be sent to the server from client which can’t be reversed because of the program setting. 原程序Original program：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667int main()&#123; char buffer[BUFFER_SIZE]; struct sockaddr_in client_addr; socklen_t length; int conn; int len; //int fork_id;///定义sockfd int server_sockfd = socket(AF_INET,SOCK_STREAM, 0); ///定义sockaddr_in struct sockaddr_in server_sockaddr; server_sockaddr.sin_family = AF_INET; server_sockaddr.sin_port = htons(MYPORT); server_sockaddr.sin_addr.s_addr = htonl(INADDR_ANY); ///bind，成功返回0，出错返回-1 if(bind(server_sockfd,(struct sockaddr *)&amp;server_sockaddr,sizeof(server_sockaddr))==-1) &#123; perror(&quot;bind&quot;); exit(1); &#125; ///listen，成功返回0，出错返回-1 if(listen(server_sockfd,QUEUE) == -1) &#123; perror(&quot;listen&quot;); exit(1); &#125; ///客户端套接字 length = sizeof(client_addr); ///成功返回非负描述字，出错返回-1 //while(1) //&#123; conn = accept(server_sockfd, (struct sockaddr*)&amp;client_addr, &amp;length); if(conn&lt;0) &#123; perror(&quot;connect&quot;); exit(1); &#125; fork_id=fork(); if(fork_id==0) &#123; while(1) &#123; memset(buffer,0,sizeof(buffer)); len = recv(conn, buffer, sizeof(buffer),0); if(strcmp(buffer,&quot;exit\\n&quot;)==0) break; fputs(buffer, stdout); send(conn, buffer, len, 0); &#125; close(conn); close(server_sockfd); return(0);//新程序去掉了这一行 //exit(0);&#125;/*else&#123;&#125;&#125;*/ &#125; 原程序是一个服务器只能挂载一个客户端。 The original program is a server which can only mount one client.程序修改了下，使一个服务器可以挂载两个客户端（可以构建聊天系统）。 After modifing program,it can mount two clients(which can create a chat system).要先连接服务器，再连接客户端。 Connect the server first,then connect the client. rm server 删除server文件 delete server file两端ps -a看一下是否退出。 use”ps -a” to see if the system exits. 挂载驱动 Mount the drive在开发板上winSCP：mount -t nfs -o nolock 192.168.1.12:/arm2410cl /hostcd hostcd expcd basiccd pwm_motorlsmod pwm_ad.ocd pwm_ADinsmod pwm_ad.o//rmmod pwm_ad.o 删除cd pwm_test./test_dcm_main 虚拟机上VM：cd pwm_motorcd pwm_testmake cleanmakecd ..cd pwm_test 附录 客户端和服务器程序 Appendix Client.c &amp; Server.cserver.c12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;stdio.h&gt;#include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;fcntl.h&gt;#include &lt;sys/shm.h&gt; #define MYPORT 8887 #define QUEUE 20 #define BUFFER_SIZE 1024int main()&#123; char buffer[BUFFER_SIZE]; struct sockaddr_in client_addr; socklen_t length; int conn; int len;///定义sockfd int server_sockfd = socket(AF_INET,SOCK_STREAM, 0); ///定义sockaddr_in struct sockaddr_in server_sockaddr; server_sockaddr.sin_family = AF_INET; server_sockaddr.sin_port = htons(MYPORT); server_sockaddr.sin_addr.s_addr = htonl(INADDR_ANY); ///bind，成功返回0，出错返回-1 if(bind(server_sockfd,(struct sockaddr *)&amp;server_sockaddr,sizeof(server_sockaddr))==-1) &#123; perror(&quot;bind&quot;); exit(1); &#125; ///listen，成功返回0，出错返回-1 if(listen(server_sockfd,QUEUE) == -1) &#123; perror(&quot;listen&quot;); exit(1); &#125; ///客户端套接字 length = sizeof(client_addr); ///成功返回非负描述字，出错返回-1 conn = accept(server_sockfd, (struct sockaddr*)&amp;client_addr, &amp;length); if(conn&lt;0) &#123; perror(&quot;connect&quot;); exit(1); &#125; while(1) &#123; memset(buffer,0,sizeof(buffer)); len = recv(conn, buffer, sizeof(buffer),0); if(strcmp(buffer,&quot;exit\\n&quot;)==0) break; fputs(buffer, stdout); send(conn, buffer, len, 0); &#125; close(conn); close(server_sockfd); return 0; &#125; client.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;stdio.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/shm.h&gt;#define MYPORT 8887#define BUFFER_SIZE 1024int main()&#123; ///定义sockfd int sock_cli = socket(AF_INET,SOCK_STREAM, 0); ///定义sockaddr_in struct sockaddr_in servaddr; memset(&amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(MYPORT); ///服务器端口 servaddr.sin_addr.s_addr = inet_addr(&quot;192.168.1.12&quot;); ///服务器ip ///连接服务器，成功返回0，错误返回-1 if (connect(sock_cli, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0) &#123; perror(&quot;connect&quot;); exit(1); &#125; char sendbuf[BUFFER_SIZE]; char recvbuf[BUFFER_SIZE]; while (fgets(sendbuf, sizeof(sendbuf), stdin) != NULL) &#123; send(sock_cli, sendbuf, strlen(sendbuf),0); ///发送 if(strcmp(sendbuf,&quot;exit\\n&quot;)==0) break; recv(sock_cli, recvbuf, sizeof(recvbuf),0); ///接收 fputs(recvbuf, stdout); memset(sendbuf, 0, sizeof(sendbuf)); memset(recvbuf, 0, sizeof(recvbuf)); &#125; close(sock_cli); return 0;&#125;","raw":null,"content":null,"categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://hubojing.github.io/categories/操作系统/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://hubojing.github.io/tags/Linux/"}]},{"title":"将Hexo+Github博客同步托管至coding","slug":"将hexo-github博客同步托管至coding","date":"2016-04-06T08:14:56.000Z","updated":"2016-04-06T11:07:14.000Z","comments":true,"path":"2016/04/06/将hexo-github博客同步托管至coding/","link":"","permalink":"https://hubojing.github.io/2016/04/06/将hexo-github博客同步托管至coding/","excerpt":" 由于百度蜘蛛把github屏蔽了，导致百度搜不到博客文章，let me feel a little unhappy，为了扩大网站收录率，我将hexo-github博客同步托管到国内coding上。胡博靖的个人博客：http://hubojing.coding.me胡博靖的个人博客：http://hubojing.coding.me/hubojing胡博靖的个人博客：http://hubojing.github.ioBoth right!外网用github，内网用coding。","text":"由于百度蜘蛛把github屏蔽了，导致百度搜不到博客文章，let me feel a little unhappy，为了扩大网站收录率，我将hexo-github博客同步托管到国内coding上。胡博靖的个人博客：http://hubojing.coding.me胡博靖的个人博客：http://hubojing.coding.me/hubojing胡博靖的个人博客：http://hubojing.github.ioBoth right!外网用github，内网用coding。 coding创建新项目 创建页面 项目名称最好是和你的用户名相同，这样直接访问hubojing.coding.me即可，否则需要访问hubojing.coding.me/set-name。 ssh获取 复制后写入repo中。具体看下一步。 config文件配置hexo根目录文件_config.yml修改配置如下：12345deploy: type: git repo: coding: git@github.com:hubojing/hubojing.github.io.git github: git@git.coding.net:hubojing/hubojing.git SSH设置这里SSH设置和github类似。我直接用的部署github时生成的SSH。 coding中ssh设置 打开id_rsa.pub文件，复制全部内容，填写到SSH公钥一栏中，名称自定。完成后点击“添加”即可。 hexo根目录下 添加后，在git bash命令输入(我是在hexo根目录下bash here)：1ssh -T git@git.coding.net 它会弹出一个警告，是否允许操作，输入yes就可以。接着会询问你设置的密码，如果之前部署github时设置了，就输入密码，输入时频幕上是看不到任何反应的，但当你正确输入并回车后，它会显示：1Coding.net Tips : [Hello ! You've conected to Coding.net by SSH successfully! ] 这表示你的SSH设置成功了！ 开启Pages服务最后一步了！在hexo根目录下，12cd sourcetouch Staticfile #名字必须是Staticfile coding.net需要此文件来作为以静态文件部署的标志，就是说看到Staticfile就知道按照静态文件来发布。 Pages服务 注意：Pages服务分支填master！因为之前配置的分支是master。否则你将看到404 Not Found！（我不会告诉你我就是这样试了好几遍才找到原因……） OK!All have done!Congratulations!现在快去看看吧！胡博靖的技术博客欢迎在github上关注我：hubojing 参考资料hexo干货系列（四）hexo官网文档规范","raw":null,"content":null,"categories":[{"name":"博客","slug":"博客","permalink":"https://hubojing.github.io/categories/博客/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://hubojing.github.io/tags/hexo/"}]},{"title":"PPT动画制作之自定义动画","slug":"PPT动画制作之自定义动画","date":"2016-03-22T13:18:04.000Z","updated":"2016-03-26T13:34:14.000Z","comments":true,"path":"2016/03/22/PPT动画制作之自定义动画/","link":"","permalink":"https://hubojing.github.io/2016/03/22/PPT动画制作之自定义动画/","excerpt":"　ppt动画制作笔记。 ","text":"ppt动画制作笔记。 3.23更新昨天写完总觉得最终效果差点什么，后来发现是文字涌入时缺少了旋转效果。现修改完整。附上最新GIF图：（可看出差异） 修改后 话不多说，先看效果： 闪烁背景和文字涌入特效 该动画分为两部分：闪烁背景+文字涌入特效 闪烁背景 步骤： 改个色（背景色） 添个形（用基本形状添加） 改设置（形状外框透明、选择颜色） 复个制（多次复制，铺满画布） 改大小（不能每个形状一样大，那样闪烁不自然） 改透度（使闪烁更自然） 添动画（全选统一添加“渐变”动作） 调时间（显示高级进程表，调整时长，不要都从最开始出现；从“之前”开始） 完成。 文字涌入特效步骤： 抠个字（用PS写几个需要的文字，依次用魔棒选中每个文字，同时复制粘贴到另一图层，然后用裁剪工具剪到合适大小，另存） 插个图复个制（3-4次） 围一圈调大小添动画（外围一圈加退出中的“缩放”，缩小到屏幕中心。中间加“渐变式缩放”，下面文字“飞入”和强调里的“陀螺旋”） 调时间（时间控制好，先缩放，在渐变式缩放，最后飞入） 完工。","raw":null,"content":null,"categories":[{"name":"多媒体","slug":"多媒体","permalink":"https://hubojing.github.io/categories/多媒体/"}],"tags":[{"name":"PPT","slug":"PPT","permalink":"https://hubojing.github.io/tags/PPT/"},{"name":"动画","slug":"动画","permalink":"https://hubojing.github.io/tags/动画/"}]},{"title":"显示技术蹭课笔记 | Display Techique Learning Note","slug":"显示技术蹭课笔记","date":"2016-03-17T13:55:30.000Z","updated":"2016-10-23T15:26:32.000Z","comments":true,"path":"2016/03/17/显示技术蹭课笔记/","link":"","permalink":"https://hubojing.github.io/2016/03/17/显示技术蹭课笔记/","excerpt":"\n蹭课，科普为主。顺便复习一些基础电路知识。I am not a student of this class but want to listen to the lecture for popularization of science to myself.By the way reviewing some of the basic circuit knowledge.给这篇文章写英译好辛苦……It is hard to write English translation for this article.肖大大图书镇楼！Uncle Xiao’s book is superior!\n ","text":"蹭课，科普为主。顺便复习一些基础电路知识。I am not a student of this class but want to listen to the lecture for popularization of science to myself.By the way reviewing some of the basic circuit knowledge.给这篇文章写英译好辛苦……It is hard to write English translation for this article.肖大大图书镇楼！Uncle Xiao’s book is superior! 2016.5.20 更新 Update 显示技术实验部分 Experimental part学会了怎么把电路图和实物电路联系起来。学会了就好简单……果然授人以鱼不如授人以渔！Learnt how to link circuit diagram to the phhysical diagram.It’s easy enough.Give a man a fish and you feed him for a day.Teach him how to fish and you feed him for a lifetime.但不敢去测量上万伏的高压……为自身的局限性感到难过。But I dare not to measure the high pressure of tens of thousands of volts.I feel terrible for my own limitation. 几个名词 Several noums声表面波滤波器 Surface acoustic wave filter声表面波滤波器(SAWF，surface acoustic wave filter)是利用石英、铌酸锂、钛酸钡晶体具有压电效应的性质做成的。所谓压电效应，即是当晶体受到机械作用时，将产生与压力成正比的电场的现象。具有压电效应的晶体，在受到电信号的作用时，也会产生弹性形变而发出机械波（声波），即可把电信号转为声信号。由于这种声波只在晶体表面传播，故称为声表面波。SAWF uses the piezoelectric effect property of quartz,lithium niobate,barium titanate.As for piezoelectric effect,when the crystal is mechanical functioned,it will produce the electric field which is directly proportional to the pressure.Crystal which has the piezoelectric effect,when the electrical signal is added,will generate a elastic deformation and send a mechanical wave(sonic wave),so it converts electrical signal to acoustic signal.It is called surface acoustic wave for this wave only transmit on the crystal surface. 行可变电容 Line variable capacitor 行可变电感 Row variable inductor 中周 Medium cycle transformer电视中周：电视机里的中周标准称呼是中频变压器。The standard name is medium cycle transformer. 电路图上，三极管外带虚线的圆圈是指带散热的三极管，同时接地表屏蔽。On the circuit diagram,the dotted line with the circle triode refers to the triode with heat pipe,which is at earth potential to shield. 实验现场 （不配四张图，强迫症不要打我哟~） 2016.5.17 更新 Update大部分资料来自维基百科。Most of the information comes from Wikipedia. 平板显示器 Flat panel display简介 Brief introduction平板屏幕包含多种科技，使显示器（video display）比传统电视机（traditional television）或显示器（通常由阴极射线管制成）更加轻薄，厚度通常小于4英寸（100 mm）。Flat panel display includes many technologies,which makes video display lighter than traditional television or display(usually made of cathode ray tube),and thickness is usually less than 4 inches. 种类 TypeDLP (数位光处理) Digital light processing等离子显示器 Plasma panel display液晶显示器（LCDs） Liquid crystal display薄膜晶体管液晶显示器（TFT-LCDs） Thin film transistor liquid crystal display有机发光二极管显示器（OLEDs） Organic light emitting diode display发光二极管显示器（LED） Light-emitting diode display电致发光显示器（ELDs） Electroluminescent display表面传导电子发射显示器（SEDs） Surface conduction electron emission display场发射显示器（FEDs）（ 纳米-发射显示器（NEDs）） Field emission display 名字多么洋气~The names has foreign flavour~ 这张图有点意思~This picture is kind of interesting~ 显示器 CRT显示器 CRT display简介 Brief introduction阴极射线管（Cathode ray tube，缩写：CRT，又称“显像管”、布劳恩管）是一种用于显示系统的物理仪器，曾广泛应用于示波器、电视机和显示器上。它是利用阴极电子枪发射电子，在阳极高压的作用下，射向萤光屏，使萤光粉发光，同时电子束在偏转磁场的作用下，作上下左右的移动来达到扫描的目的。早期的阴极射线管仅能显示光线的强弱，展现黑白画面。而彩色阴极射线管具有红、绿色和蓝色三支电子枪，三支电子枪同时发射电子打在屏幕玻璃上磷化物上来显示颜色。由于它笨重、耗电且较占空间，2000年代起几乎被轻巧、省电且省空间的液晶显示器取代。阴极射线管的市场剩下极重视色彩表现及低温环境下等特殊用途。Cathode ray tube,is a physical instrument which uses to display system.It used to be applied to oscilloscope,TV and display.It uses the cathode electron gun for electron emission.Under the action of anode high voltage,it emits to the screen,which makes powder luminesce.At the same time, the electron beam moves up and down to reach the purpose of scanning by the action of the deflection magnetic field.Early cathode ray tube can only show the intensity of light,and to show black and white picture.Color cathode ray tube have red, green and blue electron guns, and this three electron guns emit electrons to hit the glass screen’s phosphides to show color.Because of its bulky, power consumption and space waste,light, power saving and space saving LCD monitor was used in the 2000s instead.A cathode ray tube market left pole attached color performance and low temperature environment and other special purposes. CRT在高精尖领域仍扮演着重要角色。CRT still plays an important role in the high-tech field. 液晶显示器 liquid-crystal display简介 Brief introduction液晶显示器（英语：liquid-crystal display，缩写：LCD）为平面薄型的显示设备，由一定数量的彩色或黑白像素组成，放置于光源或者反射面前方。液晶显示器功耗低，因此倍受工程师青睐，适用于使用电池的电子设备。Liquid-crystal display is the flat panel display device,which consists of a number of color or black and white pixels,and place in the light source or in front of the reflecting surface. 显示原理 Revelation principle在不加电压下，光线会沿着液晶分子的间隙前进而转折90度，所以光可通过。但加入电压后，光顺着液晶分子的间隙直线前进，因此光被滤光板所阻隔。（让我想到偏振……）液晶是具有流动特性的物质，所以只需外加很微小的力量即可使液晶分子运动，以最常见普遍的向列型液晶为例，液晶分子可轻易的借着电场作用使得液晶分子转向，由于液晶的光轴与其分子轴相当一致，故可借此产生光学效果，而当加于液晶的电场移除消失时，液晶将借着其本身的弹性及黏性，液晶分子将十分迅速的恢复原来未加电场前的状态。Without voltage, the light will move along the gap between the liquid crystal molecules and turn 90 degrees, so the light can pass.But after the voltage is added,light goes along the liquid crystal molecules of the gap straight forward,so the light is blocked by the filter board. (Let me think of polarization.) 等离子显示器 Plasma Display Panel简介 Brief introduction等离子显示器（Plasma Display Panel）又称为电浆显示屏，是一种平面显示屏幕，光线由两块玻璃之间的离子，射向磷质而发出。与液晶显示器不同，放出的气体并无水银成分，而是使用惰性气体氖及氙混合而成，这种气体是无害气体。等离子显示器甚为光亮（1000 lx或以上），可显示更多种颜色，也可制造出较大面积的显示屏，最大对角可达381厘米（150吋）。等离子显示屏的对比度亦高，可制造出全黑效果，对观看电影尤其适合。显示屏厚度只有6厘米，连同其他电路板，厚度亦只有10厘米。Plasma display panel is a flat display screen.Light is emitted to phosphorous by the ion between the two classes.Unlike liquid crystal display,the gas released has no mercury,it mixed inert gas such as neon,xenon and so on,which are harmless.The plasma display is very bright (1000 LX or above),and it can show more colors,it also can be made big screen,which the maximum diagonal up to 381 cm (150 inches).The contrast is high, and it can create a full black effect,especially suitable for watching movies.The thickness of screen is only 6 cm,combined with other circuit boards, the thickness is only 10 cm. 原理 Principle等离子的发光原理是在真空玻璃管中注入惰性气体或水银蒸气，加电压之后，使气体产生等离子效应，放出紫外线，激发荧光粉而产生可见光，利用激发时间的长短来产生不同的亮度。等离子显示器中，每一个像素都是三个不同颜色（三原色）的等离子发光体所产生的。由于它是每个独立的发光体在同一时间一次点亮的，所以特别清晰鲜明。等离子显示器的使用寿命约5~6万个小时。随着使用的时间的增加，其亮度会衰退。The principle of plasma luminescence is to inject inert gas or mercury vapor into a vacuum glass tube.After the voltage is added, the gas is produced by the plasma effect, the ultraviolet ray is emitted, and the fluorescent powder is excited to generate visible light, and the excitation time is used to generate different brightness.In the plasma display, each pixel has three different colors (RGB) of the plasma generated by the luminous body.Since each individual light body is litted at the same time, so it is clear and bright.The service life of the plasma display is about 5~6 ten thousand hours. With the increase of the use of time, the brightness of the plasma display will decline. 【区别】等离子显示器并不是液晶显示器。后者的显示器虽然也很轻薄，但是用的技术却是大不相同。液晶显示器通常会使用一到两个大型萤光灯或是LED当作其背光源，在背光源上面的液晶面板则是利用遮罩的原理让显示器显示出不同颜色。【Difference】Plasma display is not liquid crystal display.Although the latter is also very thin,the technology is different.Liquid crystal display usually use one or two large fluorescent lamp or LED as the backlight,above the backlight to the LCD panel using mask principle to show different colors. 云电视 Cloud TV简介 Brief introduciton云电视是应用云计算、云存储技术的电视产品，是云设备的一种。通俗地讲，就是用户不需要单独再为自家的电视配备所有互联网功能或内容，将电视连上网络，就可以随时从外界调取自己需要的资源或信息，比如说，可以在云电视里安装使用各种即时通讯软件，在看电视的同时，进行社交、办公等等。Cloud TV,which is the application of cloud computing and cloud storage technology,is a kind of cloud devices.Generally speaking,users do not need a separate device for their own television equipped with all Internet function or information.After the TV is connected to the network,you can get what you want at any times.For example, you can install and use a variety of instant messaging software, while watching TV at the same time, social, office and so on. 3D显示器 3D display简介 Brief introduciton传统的3D电影在荧幕上有两组图像（来源于在拍摄时的互成角度的两台摄影机），观众必须戴上偏光镜才能消除重影（让一只眼只接受一组图像），形成视差（parallax），产生立体感。利用自动立体显示（AutoSterocopic）技术，即所谓的“真3D技术”，你就不用戴上眼镜来观看立体影像了。这种技术利用所谓的“视差栅栏”，使两只眼睛分别接受不同的图像，来形成立体效果。平面显示器要形成立体感的影象，必须至少提供两组相位不同的图像。其中，快门式3D技术和不闪式3D技术是如今显示器中最常使用的两种。The traditional 3D movie has two sets of images on the screen (come from two cameras that are placed in angle difference),so viewers have to put on a polarizing lens to eliminate the ghost(so that a eye only accept a set of images), and form a parallax to generate a sense of three-dimensional.The use of automatic three-dimensional display (AutoSterocopic) technology, that is, the so-called “true 3D technology”, you do not have to wear glasses to watch the stereo image.This technology uses the so-called “parallax barrier”, so that the two eyes receive different images to form a three-dimensional effect. OLED显示器 OLED display简介 Brief introductionOLED有机发光二极管又称为有机电激光显示（Organic Light-Emitting Diode，OLED）。OLED显示技术具有自发光的特性，采用非常薄的有机材料涂层和玻璃基板，当有电流通过时，这些有机材料就会发光，而且OLED显示屏幕可视角度大，并且能够节省电能。对于有机电激发光器件，我们可按发光材料将其分为两种: 小分子OLED和高分子OLED（也可称为PLED）。它们的差异主要表现在器件的制备工艺不同：小分子器件主要采用真空热蒸发工艺，高分子器件则采用旋转涂覆或喷墨工艺。有机电激发光二极管由于同时具备自发光，不需背光源、对比度高、厚度薄、视角广、反应速度快、可用于挠曲性面板、使用温度范围广、构造及制程较简单等优异之特性，被认为是下一代的平面显示器新兴应用技术。Organic Light-Emitting Diode has the characteristic of self luminescence,which uses a thin organic material coating and glass substrate.When the current pass,these material will light.Also,OLED display screen viewing angle is big, and it can save electric energy. 发光原理 Principle of luminescenceOLED发光的颜色取决于有机发光层的材料，故厂商可由改变发光层的材料而得到所需之颜色。有源阵列有机发光显示屏具有内置的电子电路系统，因此每个像素都由一个对应的电路独立驱动。OLED具备有构造简单、自发光不需背光源、对比度高、厚度薄、视角广、反应速度快、可用于挠曲性面板、使用温度范围广等优点，技术提供了浏览照片和视频的最佳方式而且对相机的设计造成的限制较少。The color of the OLED depends on the material of the organic light emitting layer, so the manufacturer can obtain the required color by changing the material of the light emitting layer.The active array organic light emitting display screen has a built-in electronic circuit system, so each pixel is driven by a corresponding circuit.The OLED has the advantages of simple structure, no need of back light source, high contrast, thin thickness, wide viewing angle, quick reaction speed, and can be used for the flexible panel and wide temperature range,and technology offers the best way to view photos and videos and to little limit to the design of the camera. 户外大屏幕显示器 Outside big screen display这个范围就有点大啊……This range is broad~主要说来，CRT、LCD、DLP、LCOS、GLV用的较多。Generally speaking,CRT、LCD、DLP、LCOS、GLV are used a lot. 2016.3.17更新 update 记忆比较深的知识 Knowledge deeply remember1.白光透过棱镜分为紫、蓝、青、绿、黄、橙、红。波长依次减少。White light through the prism is divided into purple, blue, green, green, yellow, orange, red.The wavelength is reduced in turn. 2.绝对黑体是指既不反射也不透射，完全吸收入射辐射的物体。（黑洞……）The absolute black body is an object that absorbsthe incident radiation,neither reflected nor transmitted.(black hole~) 3.色温是表示光源光色的一种尺度。不是光源实际温度！只是一种光谱特性参量！Color is a representation of the actual temperature scale.Not real temperature!Just a Spectral characteristic parameter!例：电视屏幕是室温20℃（300K左右），但显像管显示的白颜色对应的是太阳光的那种白，那么色温是4874K！不要说温度有那么高……否则电视早就烧成灰了……For example,the temperature of the TV screen is 20 ℃（about 200K）,but the white color is corresponding to the white sunlight,which color temperature is 4874K!Never to say it~if it is so hot,your TV is firing ash already. 4.人眼对绿色最敏感！从光谱光效率图看出……所以红绿灯用绿色，显眼啊。Our eyes is sensitive to green!You can see it in spectral optical efficiency diagram.So this is why traffic light uses green color. 5.正好使人感到不闪烁的刷新频率称为临界闪烁频率。为45.8HZ。只要高于它，人眼就觉得不闪。Make people feel the refresh rate does not flicker is called the critical flicker frequency,which is 45.8HZ.Only over it,we feel comfortable.所谓市面上的不闪的电视，就是频率稍高一些的电视，如70HZ。因为部分人群的人眼敏感度较高，所以50HZ也许还是感觉到闪烁，这类人群需要不闪电视。但普通人并不需要。The so-called “not flash television” in the market is a slightly higher frequency of television,70HZ,for instance.Because some people are more sensitive to it, they need “not flash TV”.But it isn’t needed in common. 6.没必要追求4K的分辨率指标。人眼分辨力有限，所谓分辨，是指人眼能看清的扫描的两行。（美国比中国的扫描行数还低来着……）人眼极限就只能看清大约1K左右（这样说来1080P最好咯），高于这个指标人眼就分不清两行了，所以该指标更高便显得意义不大。4K代表我们有能力做到这么清晰，但日常我们是否需要，则并不见得。所以，往往并不需要追求最高的指标，够用就好。（买电脑一个理）It’s not necessary to persuit 4K resolution index for human eye resolution is limited.The resolution is the line we can see clearly.(The index in America is lower than that of China)Our eye resolution limit is to see about 1k(1080P maybe the best).If the index higher than this can not we distinguish the lines,so the higher index seems little meaning.4K means we have the ability to do it,but we don’t need it in daily life.Therefore,is not as high index as possible,but enough is alright(Buy a computer is the same way). 7.看电视最佳距离：电视频幕高度的4倍。（我回家特地量了一下距离……）The best distance to watch TV is four times the height of the TV screen.(I measure the size at home specifically~) 8.CRT显像管上加了上万伏高压，所以开启和关闭电视时常有静电。（我小时候还特喜欢那种有点漂浮的感觉……）修电视技巧get：如果开机关机时仍能感觉到静电，那么说明显像管是好的！（来自我们修了三千台电视的super肖老师语录……哦……少碰静电，毕竟几万伏呢……小心白血病……）CRT picture tube is added tens of thousands of volts,so you can feel the static electricity when open or close power supply.(I like the floating feel when I was a child~)KEY TO REPAIR TVIf you can feel the static electricity when open or close power supply,it is obvious that the picture tube is well.(From our super Mr.Xiao’s quotationswell,do not touch the static electricity as little as possible.Pay attention to leukemia,it is tens of thousands of volts after all) 9.彩色三要素：亮度、色调、色饱和度。色调与色饱和度合称为色度。Three elements in color,brightness, tinge, color saturation.Tinge and color saturation are called as chromaticity. 10.三基色原理 The principle of three primary colors（1）所有颜色可以由这三种基色按比例混合得到。（合成性） (1)All colors can be made from the three primary colors mixed in proportion (synthetic).（2）任意一种彩色可分解为三种基色。（分解性） (2)Any color can be decomposed into three primary colors (decomposition).（3）混合的亮度等于各基色亮度之和。（叠加性） (3)The mixed brightness is equal to all primary colors.(addition).（4）混合比例决定色调和色饱和度。（色度决定性） (4)The mix proportions determine tinge and color saturation.(chromaticity determination) 11.三基色 Three primary colorsR、G、B.记得小时候还学了个颜料的三原色……于是百度一下：红、黄、青Always remember that there exists primary colors of pigment~so I search it.It is red,yellow and cyan. 上图左侧为色光三原色，右侧为美术三原色 12.一个公式（亮度方程） A fomulaY=0.30R+0.59G+0.11B例：1R+2G+2B=浅青(light cyan)Why?∵1R+1G+1B=白(white)1G+1B=青(cyan)白+青=浅青(white+cyan=light cyan)这个算法莫名想笑……This idea makes me inexplicably laugh~ 13.互补色：加起来为白色的两种颜色。Complementary colors,the twocolors mixed up in white color. 14.15625！15625！15625！重要的数字说三遍！Important number should be repeated three times!行扫描的频率……听到这个数字要很快的反应过来……就像3.1415926一样……正程52us，逆程12us，全程64us，即行扫描周期。我国现行广播电视标准规定：帧数为25HZ，一帧图像分625行传送。所以行扫描频率25X625=15625HZ……就是这样来的……It is line scan frequency~everyone of us should reflect on the meaning as 3.1415926~Positive trace is 52us,negative trace is 12us,the whole trace is 64us,and it is just the line scan cycle.The existing provisions of broadcast standards in China,frames is 25HZ,and an image is divided into 625 transmission line.So,the line scan frequency is 25X625=15625HZ,that’s is. 15.对比度 Contrast我之前对这个的定义确实不清楚的说……就连PS上的对比度也是怎么看着舒服怎么调……对比度，通俗的讲，就是，实际的蓝天和白云的颜色，哦，是这么蓝和这么白，10000:100好了，反映到电视上，还是那么蓝和那么白！就100:1好了……让我想到比例尺。还是原来的配方，还是熟悉的味道！I didn’t get it clear before,and when I used PS,the contrast is adjusted to the degree that a image how to make me comfortable.Contrast, popular speaking, that is, the actual blue sky and white clouds of color,the component of blue and white is 10000:100,for example,which reflect to TV is 100:1,just like a scale.The original formula and the similar taste! 16.黑白全电视信号特指视频信号。Black and white television signal refers to the video signal. 17.基色信号-亮度信号=色差信号Primary signal - luminance signal = color difference signal 18.绿色幅值小，易受干扰，一般传送红、蓝信号。green has small amplitude,and it is vulnerable to be interfered,it transfers red and blue signal in general. 19.白！黄！青！绿！紫！红！蓝！黑！白！黄！青！绿！紫！红！蓝！黑！白！黄！青！绿！紫！红！蓝！黑！WHITE!YELLOW!CYAN!GREEN!PURPLE!RED!BLUE!BLACK!标准彩条测试信号。常识背背背！It is the standard color test signal.We should recite it as common sense. 20.一个记住的电路 A curcuit to remember 亮度调节电路和对比度调节电路 放大电路……如此的熟悉……So familiar with it.Rw1滑动调节对比度，Rw2滑动调节亮度！Rw1 to adjust contrast,and Rw2 to adjust brightness!感谢无私的好友把她上学期的书借给了我！Thanks my selfless friend for sending her books to me！ 21.指标如果要做到最顶级首选CRT。为什么我们现在都用薄的液晶啊什么的，因为日常使用不需要很高的指标，并且方便使用。If you want to achieve the top indicators,CRT is preferred.You may ask why we use today is liquid crystal,the reason is Top indicators are not needed in daily use,and it is convinient. 22. 阻尼式行输出级典型电路 铅笔写的是我的笔记，乱max……The writing is my note,you can ignore it~几个专有名词要知道：阻尼二极管、逆程电容、校正电容、行输出管（行管）、行输出变压器（高压包）、行推动变压器Several professional noums,Damping diode, reverse pass capacitor, correction capacitor, line output tube (line tube), line output transformer (high voltage package), line drive transformer.扩展：硅堆、桥堆Extension: silicon stack, bridge 段子或注意的地方 Something fun or details (It may lost its fun when translated into English)1.“B光源（色温4874K）近似为中午太阳光的光谱。”类似说法都不够准确，但经典教材上往往都采取这样模糊的说法。 2.用点燃的报纸烘烤灯丝……是为了激发电子发射。有个问题是灯坏了还是什么的，总之就是不行→_→因为激发不了电子发射。（写此文时突然短路……） 3.有个单位叫熙提……它的缩写………………自行百度或查书吧。（保持优雅） 4.隔壁的王叔叔…… 5.南京的声音优雅的车站播音员……强调音色的问题…… 6.列宁……（原名弗拉基米尔·伊里奇·乌里扬诺夫）（我竟然还百度了一下……） 7.小日本…… 偏题了……段子很多就不说了……注意的问题是重点！咳咳~ 回看本文…………简直就是帮他们要考试的勾了一遍重点（除了一些公式和计算……）我真是大写的可爱啊！啊。。。I AM CUTE~P.S.不吹不黑 上课就要像这样愉悦才是好的课堂 快乐学习不是梦~Pleasant classroom atmosphere is a excellent class.Happy learning is not a dream.真是一趟愉快的蹭课之旅~It was a pleasant trip to the class.感谢老师 感谢校园 感谢这个和平的时代thanks for the teacher,thanks for the campus,thanks for this peaceful time.","raw":null,"content":null,"categories":[{"name":"通信工程","slug":"通信工程","permalink":"https://hubojing.github.io/categories/通信工程/"}],"tags":[{"name":"显示技术","slug":"显示技术","permalink":"https://hubojing.github.io/tags/显示技术/"}]},{"title":"java自学笔记","slug":"java自学笔记","date":"2016-03-14T13:21:31.000Z","updated":"2016-04-04T09:37:02.000Z","comments":true,"path":"2016/03/14/java自学笔记/","link":"","permalink":"https://hubojing.github.io/2016/03/14/java自学笔记/","excerpt":"\n　现将以前分散的java自学笔记归总，方便查阅。　　 ","text":"现将以前分散的java自学笔记归总，方便查阅。 2019年前记录 2016.3.26更新快速打法与Scanner 两个快速打法 sysoalt+/快速打出 System.out.println(); mainalt+/ 回车快速打出：public static void main(String[] args) { } 使用Scanner工具类来获取用户输入信息 Scanner类似于java.util包中，使用时需要导入此包步骤：1.导入java.util.Scanner2.创建Scanner对象3.接收并保存用户输入的值package com;import java.util.Scanner; main函数里Scanner input=new Scanner(System.in);//创建Scanner对象System.out.println(“请输入信息：”);int a=input.nextInt();//获取用户输入的信息并保存在变量中 print和println区别：println输出信息后会换行，而print不会换行 2016.3.15更新java基础知识 关键字 java常用关键字 优秀攻城师的习惯 1、变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，俗称骆驼式命名法（也称驼峰命名法），如 myAge2、变量命名时，尽量简短且能清楚的表达变量的作用，做到见名知意。如：定义变量名stuName 保存“学生姓名”信息 java的数据结构 数据结构 常见的基本数据类型 数据类型 强制转换 强制转换 强制类型转换将 75.8 赋值给 int 型变量后，结果为 75，数值上并未进行四舍五入，而是直接将小数位截断。强制类型转换可能会造成数据的丢失。 常量名一般使用大写字符。 注释 Java 中注释有三种类型：单行注释、多行注释、文档注释单行：//多行：/ /文档：/* /我们可以通过 javadoc 命令从文档注释中提取内容，生成程序的 API 帮助文档。 javadoc 使用文档注释时还可以使用 javadoc 标记，生成更详细的文档信息： @author 标明开发该类模块的作者 @version 标明该类模块的版本 @see 参考转向，也就是相关主题 @param 对方法中某参数的说明 @return 对方法返回值的说明 @exception 对方法可能抛出的异常进行说明 java常用的比较运算符 比较运算符 &gt; 、 &lt; 、 &gt;= 、 &lt;= 只支持左右两边操作数是数值类型 == 、 != 两边的操作数既可以是数值类型，也可以是引用类型 运算符优先级 优先级 级别为 1 的优先级最高，级别 11 的优先级最低。 条件语句之 switch 可以把功能相同的 case 语句合并起来，如 case合并 循环语句之 for for 循环变量初始化和循环变量变化部分，可以是使用 “,” 同时初始化或改变多个循环 变量的值 for 循环跳转语句之 continue continue 的作用是跳过循环体中剩余的语句执行下一次循环。 2016.3.14更新java初体验 环境变量配置 1.jdk安装目录2.jdk下bin安装目录3.jdk下lib安装目录 第一个java程序 win8.1系统下win+R，输入cmd。dir查看磁盘文件java HelloWorld.java错误：java HelloWorld.classjava命令后不能跟文件后缀java HelloWorld 第一个java程序 使用Eclipse开发Java程序 安装eclipse后，弹出 错误 这是因为eclipse与JDK的版本不一致。（在cmd中输入java -version查看版本） 两种IDE 我选择的是下面这种。步骤：1.创建Java项目2.创建程序包3.编写Java源程序4.运行Java程序 使用myeclipse的步骤相同。 2019年更新 注解@Override:一般在实现了接口的方法上标识，作用是告诉编译器该方法是接口的方法。@Deprecated：一般在接口中的方法上进行标识，作用是该方法过时了。@Suppvisewarnings：忽视警告，@SuppressWarnings(“deprecation”)","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hubojing.github.io/categories/编程语言/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hubojing.github.io/tags/Java/"}]},{"title":"靖靖的脑洞大开 | Jinger's Special Ideas","slug":"靖靖的脑洞大开（一）","date":"2016-03-12T06:23:00.000Z","updated":"2017-08-20T10:04:00.000Z","comments":true,"path":"2016/03/12/靖靖的脑洞大开（一）/","link":"","permalink":"https://hubojing.github.io/2016/03/12/靖靖的脑洞大开（一）/","excerpt":" 　　一些天马行空的脑洞。　　有时稀奇古怪的thinking和idea就像柯南推理正确时被闪电般电流击中一样……　　愿创造力永不枯竭……","text":"一些天马行空的脑洞。 有时稀奇古怪的thinking和idea就像柯南推理正确时被闪电般电流击中一样…… 愿创造力永不枯竭…… 2017.8.20更新 关于超人工智能无意点开的一篇文章，配上这个毫无吸引力的名字，本来是拒绝阅读的。但浏览了下感觉很生动形象，不知不觉在这样碎片化阅读的地方看完了三万五千字，也是拼耐心了。为什么最近有很多名人，比如比尔盖茨，马斯克、霍金等，让人们警惕人工智能？文中有些观点于我而言很新颖，有些角度看的更深刻。 人类已掌握弱人工智能Artificial Narrow Intelligence (ANI)，正研究强人工智能Artificial General Intelligence (AGI)，而强人工智能一旦实现，到超人工智能Artificial Superintelligence (ASI)可能只是很短暂的时间（几个小时、几天或者几个月）。 实现强人工智能只是时间问题，而且，最大几率发生在未来的50年里。（尚年轻的我们能亲眼见证这伟大的时刻是多么的幸运） 我们处在一个充满弱人工智能的世界，只是可能我们没意识到“哦，这就是人工智能”。控制防抱死系统、地图软件导航、音乐电台推荐、查询明天的天气、Siri、垃圾邮件过滤器、谷歌翻译、IBM的华生……这些是消费级产品的例子。军事、制造、金融（高频算法交易占到了美国股票交易的一半）等领域广泛运用各种复杂的弱人工智能。 强人工智能的难点在：人工智能已经在几乎所有需要思考的领域超过了人类，但是在那些人类和其它动物不需要思考就能完成的事情上，还差得很远。 人工智能发展是指数型增长，无论是硬件、软件还是整个产业。 通往强人工智能的第一步：增加电脑处理速度，而目前天河二号已经做到并超过了。通往强人工智能的第二步：让电脑变得智能。1) 抄袭人脑 一个电脑架构模拟人脑的例子是人工神经网络。它是一个由晶体管作为“神经”组成的网络，晶体管和其它晶体管互相连接，有自己的输入、输出系统，而且什么都不知道。接着它会通过做任务来自我学习。最开始它的神经处理和猜测会是随机的，但是当它得到正确的回馈后，相关晶体管之间的连接就会被加强；如果它得到错误的回馈，连接就会变弱。经过一段时间的测试和回馈后，这个网络自身就会组成一个智能的神经路径，而处理这项任务的能力也得到了优化。 更加极端的“抄袭”方式是“整脑模拟”。具体来说就是把人脑切成很薄的片，用软件来准确的组建一个3D模型，然后把这个模型装在强力的电脑上。2）模仿生物演化 模拟演化使用“基因算法”，它大概是这样的：建立一个反复运作的表现/评价过程，就好像生物通过生存这种方式来表现，并且以能否生养后代为评价一样。一组电脑将执行各种任务，最成功的将会“繁殖”，把各自的程序融合，产生新的电脑，而不成功的将会被剔除。经过多次的反复后。这个自然选择的过程将产生越来越强大的电脑。3）让电脑来解决这些问题 总的思路是我们建造一个能进行两项任务的电脑——研究人工智能和修改自己的代码。 智能爆炸 这个词可以说是非常耸人听闻了。递归的自我改进将达到一个难以想象的水平。文中形象的比较：我们把130的智商叫作聪明，把85的智商叫作笨，但是我们不知道怎么形容12952的智商，人类语言中根本没这个概念。 我们无法理解超人工智能的智慧，它能解决所有的问题，如果出现了不能解决的问题，它只需要再自我智能提升一下，这些问题都将迎刃而解。而寄希望于尝试控制超人工智能是可笑的。当我们以为切断电源就能停止它的思考时，超人工智能早已在被切断电源之前，就想好了应对方法。我们的大脑很可能根本没法预测将会发生什么。 超人工智能虽然有超高的智慧，但它的目标不会随着智能提高而更改，因为它从不会遗忘。但它会用更先进的方式来更好地完成它的预设目标，哪怕会伤害人类，它的思维始终围绕着目标而言，我们给人工智能设定的目标是什么，它的动机就是什么。我们容易犯的一个错误是，当我们想到非常聪明的人工智能时，把它拟人化了。任何假设超级智能的达成会改变系统原本的目标的想法都是对人工智能的拟人化。我们应该明白，它是非常聪明，但是完全异己的东西。超出人类心理的范畴，道德和不道德之外，更多的是非道德性。而所有不是人类的，尤其是那些非生物的事物，默认都是非道德性的。 超人工智能会将人类带往截然不同的两种永恒状态：永生或灭绝。我想灭绝是讨论的最多的一种，但我还是第一次意识到，超人工智能也能让人类实现永生，同时，我们还没发现任何证据证明死亡是不可避免的。有一天人类会完全变成人工的。当我们看到生物材料，然后觉得生物材料实在太原始了，早年的人体居然是用这样的东西组成的，早期的人类居然会被微生物、意外、疾病杀死。人类最终战胜自己的生理，并且变得不可摧毁和永生。当然，前提还有一样，超人工智能的目标里设定了保护人类这些信息。 纳米机器人将会吞噬所有碳基材料来支持自我复制，而不巧的是，地球生命就是碳基的。科学家认为纳米机器人进行一次自我复制只要100秒左右，也就是说一个简单的错误可能就会在3.5小时内毁灭地球上全部的生命。生物技术、纳米技术、人工智能技术将统治世界。 费米悖论 人类最终是永生还是灭绝，很有可能决定者就是第一个实现超人工智能的人，而目前世界上各个国家各种组织都在紧锣密鼓的研究着，如果是有恶意的极端分子抢先一步，人类就会走向灭亡。加上现在各大公司，为了争当第一个强人工智能实现者，为了得到光环、荣誉、名声、金钱，只追求速度，并不考虑安全。最为可怕的是，这事儿世界上压根没法监管。 强人工智能浪潮是不可逆的，人类无论惶恐还是兴奋，都终将来临。而这一切，有可能在未来几十年就发生。 2017.6.7更新 关于量子传输前一段时间周末两天在学校过了一把监考瘾……考生的年纪都比我大，可是还是得叫我老师→_→（莫名占了便宜哈哈哈）监考4小时，腿酸1整天。 监考这件事儿，多么浪费人力财力，得找人来监考，发卷子，整理卷子……站着闲得慌，我就在想，能不能都给一体化解决了，不要人来监考。 脑洞：运用量子传输技术 、 量子传送技术 ，将卷子传送到每个考场。同时，每个考生的桌子有升降板，考试时自动升起成为隔板，还可以隔音。防止前后左右抄袭。桌面材料是那种无法用笔写字的光滑材料，内附电子屏显示考试要点，可以刷新和清屏。至于考生随身携带纸条等，在门上装的安检装置可检测。若考生遇到问题，可按桌上按钮与后台管理老师用语音或文字反馈问题。最后答题卡再传送回考务中心。 嗯，只有一个问题，就是费钱，哦，还有量子传输技术目前还在实验阶段。 2017.5.13更新 关于电脑病毒防范ONION勒索软件（永恒之蓝）病毒攻击毕设关键期，对大四毕业狗满满的恶意！ 再论备份的重要性论开启自动更新的重要性 【紧急通知！】请连接校园网的Windows用户注意了！近期，国内多所院校出现了ONION勒索软件感染情况，一旦感染，会对同学们的资料与数据造成严重损失，只有支付高额赎金才能解密恢复文件。请同学们将系统445端口关闭，并用免疫程序检查一下自己的电脑是否被进攻。 然后又去知乎逛了逛，果然推送一篇文章：关于防范 ONION 勒索软件（永恒之蓝）病毒攻击的紧急通知及应对办法关端口方法和补丁也在文中了。不过win10自动更新嘿嘿嘿 六点半看到这个新闻就爬起来了。心里默念，幸亏每日做毕设都U盘备份，机智如我。看着新闻里那张勒索弹窗图片，仿佛感受到毕设被锁的戳心之痛…… 不过最近慎点教育网，总是有些不放心。 事件评论：如何看待 5 月12 号爆发在各高校电脑勒索比特币的病毒？ 关于信息安全，突然就想起自己在信息安全课上做的一个关于RSA密钥的加密解密的玩意儿，当时听信息安全各种高大上，以至于我选择了教这门课的老师当导师……后来RSA的第一次亲密接触竟是在hexo的SSH连接上……人生处处是巧合 有次移动通信课上，老师说未来是云的天下，课下我找老师讨论说，我觉得云并不安全，比如我，宁愿花钱买硬盘备份，也不愿意将重要文件放到云端。老师只是说，以后技术发展，云可以做到相对安全。现在想来，如果数据量庞大到不可想象的数量级呢？买硬盘怕是不能解决问题了。可能这种时候还是得靠云技术。扯远了。 不过说实话，十年来，电脑安全好多了，十年前XP天天下各种防护工具还是拦不住各种病毒，后来换win7，到win8，到win8.1，到如今win10，就只用系统自带的杀软了，反而几乎不中毒了。 【脑洞】既然程序可以写病毒，也可以用程序反病毒。人工智能上啊！让程序自己学习病毒，然后以其人之道还治其人之身。 2016.6.13更新 关于电严格说是我室友的想法。她说，要是电像wifi一样不用线传输多好……（一个被各种电线搅的烦躁的girl的抱怨）→_→→_→→_→→_→→_→→_→“用一种气体包裹着电，这样就不会电死啦……”我百度了一下，发现真的可以耶…… 电能无线传输技术原理：利用电磁场，把电能像信号一样发射到用电设备上去，有点类似WiFi。电器不需再用电线，只需一个电能的发射装置和一个接收装置。看来，无线时代正在向我们走来。 2016.3.15更新 关于人工智能今天看到一篇评论，写的不错，发上来。其中有几句话说的很好：技术群体战胜了天赋极高的自然个体。就算真的有“征服”发生，那也是新人类征服了旧人类，而不是人类的末日。该文还提到了“虚拟现实”的概念，让我瞬间想到了柯南剧场版：贝克街的亡灵。带着头盔，仿佛身处他处。人工智能是让人类生活的劳作性内容越来越少，而虚拟现实是让人类生存生活的创造性意义大规模扩充。 整面 部分 AI向最近阿尔法狗赢李世石的新闻响遍全世界。（阿尔法狗是一种什么狗→_→）人工智能，这个神秘又让人畏惧的高科技哟… 人工智能人工智能（Artificial Intelligence），英文缩写为AI。它是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。 人工智能是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器，该领域的研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。人工智能从诞生以来，理论和技术日益成熟，应用领域也不断扩大，可以设想，未来人工智能带来的科技产品，将会是人类智慧的“容器”。 看它涉及的范围之广：实际应用机器视觉，指纹识别，人脸识别，视网膜识别，虹膜识别，掌纹识别，专家系统，自动规划，智能搜索，定理证明，博弈，自动程序设计，智能控制，机器人学，语言和图像理解，遗传编程等。 人工智能就其本质而言，是对人的思维的信息过程的模拟。 对于人的思维模拟可以从两条道路进行，一是结构模拟，仿照人脑的结构机制，制造出“类人脑”的机器；二是功能模拟，暂时撇开人脑的内部结构，而从其功能过程进行模拟。现代电子计算机的产生便是对人脑思维功能的模拟，是对人脑思维的信息过程的模拟。 以上转自百度百科…… 和室友辩论，阿尔法狗是否能赢所有人。我觉得可以，如果算法足够精确，存储足够大到可以容纳全部走法。（这个数量级是10^172次方……目前也许是远远达不到这个指标的。不知道从理论上讲，存储可以达到这么多吗？） 脑洞：我相信人类开发AI的初始目的一定是服务人类的。但是，人类不得不警惕，拥有人类智慧的机器人（或者其他形态的机器），在各个方面都优于人类机体时，是否有灭亡人类的可能性。有人和我辩论，认为机器永远不可能比人类有智慧。对此我持保留态度。也许现在的机器的核心是人类输入的程序算法，但当病毒入侵或机器足够智能化到可以自我优化代码时，甚至结合仿生学或者神经学相关，使机器能自我学习，具备类似于人类情感的机能，将是人类最大的敌人。（机器内心OS：我比你强比你壮，为什么还要服务于人……）况且总有些野心科学家……将这种技术用于战争→_→其结果还是世界大战，人类遭殃。所以AI发展也应该有个底线，就和克隆人一样，任何人不能触碰。","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"idea","slug":"idea","permalink":"https://hubojing.github.io/tags/idea/"}]},{"title":"PPT动画制作之登录等待","slug":"PPT动画制作之登录等待","date":"2016-03-08T13:36:48.000Z","updated":"2016-03-26T13:30:24.000Z","comments":true,"path":"2016/03/08/PPT动画制作之登录等待/","link":"","permalink":"https://hubojing.github.io/2016/03/08/PPT动画制作之登录等待/","excerpt":"　ppt动画制作笔记。 ","text":"ppt动画制作笔记。 坐在电脑前，我们常看见电脑页面等待的画面，就是一个圆不停的转。常让人等得怒火直冒，想碾碎电脑。（这么暴力的并不是我~）现在就来说说，怎么制作这个动画效果。并不难。先来看看效果怎么样： 效果图 具体步骤画个圆调个色添个动作路径复个制减个透明度对个齐延个时搞定！ 是不是还挺酷的~~~","raw":null,"content":null,"categories":[{"name":"多媒体","slug":"多媒体","permalink":"https://hubojing.github.io/categories/多媒体/"}],"tags":[{"name":"PPT","slug":"PPT","permalink":"https://hubojing.github.io/tags/PPT/"},{"name":"动画","slug":"动画","permalink":"https://hubojing.github.io/tags/动画/"}]},{"title":"Markdown语法简记","slug":"markdown语法简记","date":"2016-03-08T08:10:49.000Z","updated":"2021-08-08T14:13:35.000Z","comments":true,"path":"2016/03/08/markdown语法简记/","link":"","permalink":"https://hubojing.github.io/2016/03/08/markdown语法简记/","excerpt":"\n　　自查笔记。\n　　　　","text":"自查笔记。 标题# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 例： 一级标题二级标题三级标题四级标题五级标题六级标题加粗*斜体文本*例：斜体文本_斜体文本_例：斜体文本**粗体文本**例：粗体文本***粗斜体文本***例：粗斜体文本___粗斜体文本___例：粗斜体文本 链接 网址链接 [网站名](http://网址) 引用 链接用 1 作为网址变量[例子1][1]. 链接用 hubojing 作为网址变量[例子2][hubojing]. 然后在文档的结尾为变量赋值（网址）[1]:hubojing.github.io[hubojing]:https://hubojing.github.io 图片![引用名称](引用地址)例： 引用名称 内联方式：![alt text](/path/to/img.jpg “Title”)例： Title 分隔符三个星号***例： 三个减号---(上面一行文字需空一行，否则自动变为二级标题) 例：三个下划线___例： 转义符 如果描述中用到 markdown 符号，比如 _ # * 等，又不想它被转义，此时可在这些符号前加反斜杠，如 \\# 进行避免。 块注释（blockquote）- 是这样？> like this.例： 是这样？ like this. 删除线~~这是删除线~~例：这是删除线 换行打两个空格再回车 标记1`blockquote` 例：blockquote 语言使用范围http://blog.csdn.net/peng_hong_fu/article/details/52805408 缩进法一 将输入法切换成全角 两个空格法二 在每一行开头，先输入下面的代码，然后紧跟着输入文本即可。 半角空格: &amp; ensp;(去掉&amp;和ensp的空格)或 &amp;#8194; 全角空格: &amp; emsp;(去掉&amp;和emsp的空格)或 &amp;#8195; 不换行空格: &amp; nbsp;(去掉&amp;和nbsp的空格)或 &amp;#160; 注意分号 公式\\$y = x^2\\$公式居中 \\$\\$y = x^2\\$\\$例：$y = x^2$$$y = x^2$$ 分式法一\\frac例：\\$\\frac {a+b}{c+d}\\$$\\frac {a+b}{c+d}$法二\\over例：\\$a+1 \\over b+1\\$$a+1 \\over b+1$ 根号sqrt例：\\$sqrt[3]{\\frac xy}\\$\\$\\sqrt{a+b}\\$$\\sqrt[3]{\\frac xy}$$\\sqrt{a+b}$ 求和\\sum例：\\$\\sum_{k=1}^n\\$$\\sum_{k=1}^n$ 连乘\\prod例：\\$\\prod_{i=0}^n\\$$\\prod_{i=0}^n$ 符号关系运算符$\\ast$ \\ast$\\times$ \\times$\\div$ \\div$\\pm$ \\pm$\\approx$ \\approx$\\equiv$ \\equiv$\\neq$ \\neq$\\cdot$ \\cdot$\\circ$ \\circ$\\bigodot$ \\bigodot$\\bigotimes$ \\bigotimes$\\bigoplus$ \\bigoplus$\\prod$ \\prod$\\coprod$ \\coprod 集合运算符$\\in$ \\in$\\notin$ \\notin$\\emptyset$ \\emptyset$\\subset$ \\subset$\\supset$ \\supset$\\subseteq$ \\subseteq$\\supseteq$ \\supseteq$\\bigcap$ \\bigcap$\\bigcup$ \\bigcup 希腊字母ϵ \\epsilon∂ \\partialλ \\lambdaθ \\theta$\\eta$ \\eta 希腊字母 戴帽符号\\$\\hat{xy}\\$$\\hat{xy}$\\$\\widehat{xyz}\\$$\\widehat{xyz}$\\$\\tilde{xy}\\$$\\tilde{xy}$\\$\\widetilde{xyz}\\$$\\widetilde{xyz}$\\$\\check{x}\\$$\\check{x}$\\$\\breve{y}\\$$\\breve{y}$\\$\\grave{x}\\$$\\grave{x}$\\$\\acute{y}\\$$\\acute{y}$ 空心符号A~ZA \\mathbb{A}$\\mathbb{A}$ 花体字母A~ZA \\mathcal{A}$\\mathcal{A}$ 箭头$\\uparrow$ \\uparrow$\\downarrow$ \\downarrow$\\leftarrow$ \\leftarrow$\\rightarrow$ \\rightarrow$\\updownarrow$ \\updownarrow$\\leftrightarrow$ \\leftrightarrow$\\Uparrow$ \\Uparrow$\\Downarrow$ \\Downarrow$\\Leftarrow$ \\Leftarrow$\\Rightarrow$ \\Rightarrow$\\Updownarrow$ \\Updownarrow$\\Leftrightarrow$ \\Leftrightarrow 括号$$ f(x)=\\left{\\begin{aligned}x &amp; = &amp; 123 \\y &amp; = &amp; \\cos(t) \\z &amp; = &amp; \\frac 12\\end{aligned}\\right.$$1234567f(x)=\\left\\&#123;\\begin&#123;aligned&#125;x &amp; = &amp; 123 \\\\y &amp; = &amp; \\cos(t) \\\\z &amp; = &amp; \\frac 12\\end&#123;aligned&#125;\\right. 参考文章 Markdown编辑器语法指南 Markdown入门 Markdown 语法说明 (简体中文版) markdown中公式编辑教程 Markdown中数学公式及符号整理 Markdown箭头的输入方法汇总 Markdown常见数学符号和运算 KATRX","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"https://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://hubojing.github.io/tags/Markdown/"}]},{"title":"1602+24C08+4X4键盘密码锁","slug":"1602-24C08-4X4键盘密码锁","date":"2016-03-07T00:36:04.000Z","updated":"2016-03-26T13:29:28.000Z","comments":true,"path":"2016/03/07/1602-24C08-4X4键盘密码锁/","link":"","permalink":"https://hubojing.github.io/2016/03/07/1602-24C08-4X4键盘密码锁/","excerpt":"　　单片机课程设计。 ","text":"单片机课程设计。 【注】我的单片机课程设计选题是单片机密码锁。但是课题并没有要求用存储器存储密码，所以当时我的设计还是比较简陋的。那个设计只能设定一个内部密码，断电后又恢复到初始密码状态。但是实际生活中，必须能够存储密码。并且，在课程设计里我用的是数码管显示密码，在这里我用的是1602液晶显示。于是以下的设计着重于存储与1602相关，且代码是重新编写（参考了网上的案例），没有用课程设计的代码。在此提供我课程设计的单片机密码锁链接：胡博靖的单片机课程设计 设计思路现在程序内设定一个初始密码，然后用液晶显示提示用户输入密码，通过矩阵键盘输入密码，然后进行比较。如果密码正确，则绿灯亮起，否则红灯亮1S，并提示输入密码错误次数。如果输入错误次数达到三次则蜂鸣器报警并锁定键盘。 自用笔记数码管编码表（0到f）共阳：0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e共阴：0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71 protues仿真记载1602——LM016晶振——crystal蜂鸣器——buzzer/sounder/speaker可调电阻——pot-hg(课本写的是pot-lin,不过protues7.8没有) 不错的资料和方法I2C总线简介矩阵键盘行反转法 过程中所犯的低级错误 led 如图，LED所连接的电阻阻值太大，电流完全达不到使LED发光的值。改正后，LED正常发光。 led 尚未解决的问题蜂鸣器不响程序应该正确，蜂鸣器旁的控制点红蓝色变化正确，改过蜂鸣器电压值，12V、5V、3V、1.5V都试过，但是就是不响。可能的原因：蜂鸣器是用方波驱动的，若仅输出单一的高电平或低电平是没用的。蜂鸣器发出的声波也要靠人耳来听取，过高或过低的频率人耳是无法听到的。蜂鸣器的仿真模型应选择下图中后面两种，才能听到声音。（然而我并没有听到声音） 蜂鸣器 1234567Speaker &amp; Sounders BUZZER DEVICE Generic buzzer symbol BUZZER ACTIVE DC Operated Buzzer - Outputs Via Sound Card SOUNDER ACTIVE Piezo Sounder model (Digital) - Outputs Via Sound Card SPEAKER DEVICE Generic loudspeaker symbol SPEAKER ACTIVE loudspeaker model (Analog) - Outputs Via Sound Card 依次解释如下： 蜂鸣器 通用蜂鸣器符号 无仿真模型 蜂鸣器 活动的 阻抗12Ω直流蜂鸣器 仿真时通过声卡发声 讯响器 活动的 压电讯响器数字模型 仿真时通过声卡发声 扬声器 通用扬声器符号 扬声器 活动的 阻抗8Ω扬声器模拟模型 仿真时通过声卡发声 存储有问题。程序代码严格按照标准代码写的，常见的delay();的延时问题应该没有。但是明显仿真结果没有存储到新的修改密码，一直是初始密码。请各位指教。 源程序和仿真图 仿真图 若需要下载，请点击！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785#include&lt;reg52.h&gt;#define uint unsigned int#define uchar unsigned charvoid key_scan();uchar count0,count1,count3,num,n=0,temp,a,j,count4;uchar mima[8]; //初始密码存储区uchar tab_key[50]; //输入密码存储区uchar code table[]=&#123; 0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e&#125;;//led共阳数码管/*uchar code table[]=&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71&#125;; //led共阴数码管 */bit enterflag; //确认键按下与否的标志bit mimaflag; //密码正确与否的标志bit xiugaiflag; //修改密码标志 bit enter1flag; //修改密码确认键标志 sbit red=P2^1;sbit green=P2^0;sbit bell=P2^2; sbit rs=P2^6; sbit rw=P2^5; sbit lcden=P2^7; sbit scl=P3^0; sbit sda=P3^1; uchar code table1[]=\"input the passco\";uchar code table2[]=\"de: --------\";uchar code table3[]=\"*\";uchar code table4[]=\"right (^_^) \";uchar code table5[]=\"first error!!!!\";uchar code table6[]=\"second error!!!!\";uchar code table7[]=\"third error see \";uchar code table8[]=\"u tomorrow (^_^)\";uchar code table9[]=\"define the passc\";uchar code table10[]=\"ode: --------\";uchar code table11[]=\"code is new\";//******************************************************键盘消抖函数***********************************************************************void delay1()&#123; ;; &#125;void delay2(uchar x)&#123; uchar a,b; for(a=x;a&gt;0;a--) for(b=100;b&gt;0;b--);&#125;void delay3(uchar x)&#123; uchar a,b; for(a=x;a&gt;0;a--) for(b=200;b&gt;0;b--); &#125; void delay(uint z)&#123; uint x,y; for(x=z;x&gt;0;x--) for(y=110;y&gt;0;y--);&#125;//******************************************************e^2room的初始化********************************************************************void start() //开始信号&#123; sda=1; //书P171 时钟SCL线为高电平时，数据线SDA出现由高电平向低电平变化的情形时，启动I^2C总线数据传送。 delay1(); scl=1; // delay1(); sda=0; // delay1();&#125;void stop() //停止&#123; sda=0; //书P171时钟SCL线为高电平时，数据线SDA出现由低电平到高电平的变化的情形时，将停止I^2C总线数据传送。 delay1(); scl=1; delay1(); sda=1; delay1();&#125;//****************************应答信号*************************************void respond() &#123; uchar i; scl=1; delay1(); while((sda==1)&amp;&amp;(i&lt;250))i++; //书P176 应答sda为0，非应答为1 scl=0; //释放总线 ？ delay1();&#125;void noack()&#123;scl=1;delay1();scl=1;delay1();scl=0;delay1();sda=0;delay1();&#125;//*****************************写字节操作函数**********************************void write_byte(uchar date)&#123; uchar i,temp; temp=date; for(i=0;i&lt;8;i++) &#123; temp=temp&lt;&lt;1; //保持最高位，左移到进位CY scl=0; //scl上跳沿写入 delay1(); sda=CY; //溢出位 delay1(); scl=1; delay1(); scl=0;delay1(); &#125; scl=0; delay1(); sda=1;//总线释放 ？ delay1();&#125;//*******************************读字节操作函数*****************************uchar read_byte()&#123; uchar i,k; scl=0; delay1(); sda=1; delay1(); for(i=0;i&lt;8;i++) &#123; scl=1; delay1(); k=(k&lt;&lt;1)|sda; //或运算，放到最低位 scl=0; delay1(); &#125; return k;&#125;//**********************************写地址函数******************************void write_add(uchar address,uchar date)&#123; start(); write_byte(0xa0); //设备地址 respond(); write_byte(address); respond(); write_byte(date); respond(); stop();&#125;//*******************************读地址函数*************************************uchar read_add(uchar address)&#123; uchar date; start(); write_byte(0xa0); respond(); write_byte(address); respond(); start(); write_byte(0xa1); //表示接收地址 respond(); date=read_byte(); noack(); stop(); return date;&#125;//***********************************************************LCD1602的初始化**************************************************************void write_com(uchar com) //书P154 写命令函数&#123; rs=0; //RS为寄存器选择，高电平1时选择数据寄存器、低电平0时选择指令寄存器。 lcden=0; P0=com; delay(5); lcden=1; //LCD的使能端高电平有效 delay(5); lcden=0; &#125;void write_date(uchar date) //写数据函数&#123; rs=1; lcden=0; P0=date; delay(5); lcden=1; delay(5); lcden=0; &#125;//***************************************密码比较函数********************************bit mimacmp() &#123; bit flag; uchar i; for(i=0;i&lt;8;i++) &#123; if(mima[i]==tab_key[i]) flag=1; else &#123; flag=0; i=8; &#125; &#125; return(flag); //返回flag&#125;//**********************************LCD显示函数开始**************************************void lcd_display()&#123;uchar i=0;write_com(0x80+0x40+8);//液晶操作中的写入，地址是0x80开头的，加0x40为写入第二行，加8则为确定地址。for(i=0;i&lt;n;i++)&#123;write_date(table3[0]); //uchar code table3[]=\"*\"&#125;&#125;//***************************************************************键盘功能分配函数群开始*******************************************************// 0 1 2 3 // 4 5 6 7 // 8 9 确认（A） 无效（B）//取消（C）修改密码键（D）确认修改键（E） 无效（F）void key_manage1()&#123;tab_key[n]=0; //数组的存储顺序是从n=0开始的，因此无论是哪个键先按下都会存入tab_key[0]n++;if(xiugaiflag==1) //如果按下了修改键&#123;mima[count4]=0;count4++;&#125;&#125;void key_manage2()&#123;tab_key[n]=1;n++;if(xiugaiflag==1)&#123;mima[count4]=1;count4++;&#125;&#125;void key_manage3()&#123;tab_key[n]=2;n++;if(xiugaiflag==1)&#123;mima[count4]=2;count4++;&#125;&#125;void key_manage4()&#123;tab_key[n]=3;n++;if(xiugaiflag==1)&#123;mima[count4]=3;count4++;&#125;&#125;void key_manage5()&#123;tab_key[n]=4;n++;if(xiugaiflag==1)&#123;mima[count4]=4;count4++;&#125;&#125;void key_manage6()&#123;tab_key[n]=5;n++;if(xiugaiflag==1)&#123;mima[count4]=5;count4++;&#125;&#125;void key_manage7()&#123;tab_key[n]=6;n++;if(xiugaiflag==1)&#123;mima[count4]=6;count4++;&#125;&#125;void key_manage8()&#123;tab_key[n]=7;n++;if(xiugaiflag==1)&#123;mima[count4]=7;count4++;&#125;&#125;void key_manage9()&#123;tab_key[n]=8;n++;if(xiugaiflag==1)&#123;mima[count4]=8;count4++;&#125;&#125;void key_manage10()&#123;tab_key[n]=9;n++;if(xiugaiflag==1)&#123;mima[count4]=9;count4++;&#125;&#125;//**********************************确认键************************************************************** void key_manage11()&#123; enterflag=1; //确认键按下 if(n==8) //只有输入8个密码后按确认才做比较 &#123; mimaflag=mimacmp(); &#125; else &#123; mimaflag=0; &#125; if(enterflag==1) &#123; enterflag=0; //标志位清零 n=0; //用FFFFFFFF清除已经输入的密码 for(count3=0;count3&lt;8;count3++) &#123; delay(5); tab_key[count3]=0x0f; &#125; TR1=1; //打开计数器1 count1=0; //定时器1由50MS累计到1S所用的计数器 if(mimaflag==1) &#123; a=0; write_com(0x01); write_com(0x80); for(count3=0;count3&lt;16;count3++) &#123; write_date(table4[count3]); //密码正确，显示RIGHT，绿灯亮 green=0;red=1; bell=1; delay(5); &#125; &#125; else &#123; n=0; red=0; bell=0; a++; if(a==1) &#123; for(count3=0;count3&lt;8;count3++) //ffffffff清除密码 &#123; delay(5); tab_key[count3]=0x0f; &#125; write_com(0x01); write_com(0x80); for(count3=0;count3&lt;16;count3++) &#123; write_date(table5[count3]); //密码错误，显示 first error，红灯亮 green=1;red=0; bell=1; delay(5); &#125; TR1=1; &#125; if(a==2) &#123; for(count3=0;count3&lt;8;count3++) //ffffffff清除密码 &#123; delay(5); tab_key[count3]=0x0f; &#125; write_com(0x01); write_com(0x80); for(count3=0;count3&lt;16;count3++) &#123; write_date(table6[count3]); //密码错误，显示SECOND ERROR，红灯亮 green=1;red=0; bell=1; delay(5); &#125; TR1=1; &#125; if(a==3) &#123; for(count3=0;count3&lt;8;count3++) //ffffffff清除密码 &#123; delay(5); tab_key[count3]=0x0f; &#125; write_com(0x01); write_com(0x80); for(count3=0;count3&lt;16;count3++) &#123; write_date(table7[count3]); //密码错误，显示third error see，红灯亮 green=1;red=0; bell=0;//蜂鸣器报警 delay(5); &#125; write_com(0x80+0x40); for(count3=0;count3&lt;16;count3++) &#123; write_date(table8[count3]);//密码错误，显示 U TOMORROW ,红灯亮 green=1;red=0; bell=0;//蜂鸣器报警 delay(5); &#125; TR1=0; &#125; &#125; &#125;&#125;void key_manage12()&#123;tab_key[n]=11;n++; //密码计数清零&#125;//****************************************************取消键******************************************** void key_manage13()&#123;n=0; //密码计数清零write_com(0x80); //指针所指位置 第一行for(count3=0;count3&lt;16;count3++)&#123; write_date(table1[count3]); //第一行显示INPUT THE PASSPORD: delay(5);&#125;write_com(0x80+0x40); //第二行for(count3=0;count3&lt;16;count3++)&#123; write_date(table2[count3]); //开机显示-------- delay(5); tab_key[count3]=0x0f; //用FFFFFFFF清除已经输入的密码&#125;&#125;//*******************************************修改密码键**********************************void key_manage14()&#123; uchar aa=0; n=0; xiugaiflag=1; write_com(0x01); write_com(0x80);for(count3=0;count3&lt;16;count3++)&#123; write_date(table9[count3]); //显示define the password delay(5); tab_key[count3]=0x0f; //用FFFFFFFF清楚已经输入的密码&#125; write_com(0x80+0x40);for(count3=0;count3&lt;16;count3++)&#123; write_date(table10[count3]); //显示-------- delay(5);&#125;TR0=1;&#125;//******************************************修改密码键的确认键********************************void key_manage15()&#123;n=0;enter1flag=1;if(enter1flag==1)&#123; enter1flag=0; count4=0; for(count3=0;count3&lt;16;count3++) &#123; tab_key[count3]=0x0f; //用FFFFFFFF清除已经输入的密码 &#125; write_com(0x01); write_com(0x80); for(count3=0;count3&lt;16;count3++) &#123; write_date(table11[count3]); delay(100); &#125; TR1=1; count1=0;&#125;&#125;void key_manage16()&#123;tab_key[n]=15;n++;&#125;//****************************************定时器1的50MS,共延时1秒*****************************void time_1() interrupt 3&#123; TH1=(65536-50000)/256; TL1=(65536-50000)%256; if(count1&lt;20) &#123; count1++; &#125; else //计时到1S &#123; TR1=0; count1=0; mimaflag=0; red=1; bell=1; //显示FFFFFFFF write_com(0x01); write_com(0x80); for(count3=0;count3&lt;16;count3++) &#123; write_date(table1[count3]); //显示INPUT THE PASSCODE delay(5); &#125; write_com(0x80+0x40); for(count3=0;count3&lt;16;count3++) &#123; write_date(table2[count3]); //开机显示FFFFFFFF delay(5); &#125; &#125;&#125;//***********************************************定时0**********************************************void time_0() interrupt 1&#123; TH0=(65536-50000)/256; TL0=(65536-50000)%256;if(count4&lt;8)&#123; key_scan();&#125;else&#123; TR0=0; count4=0;&#125;&#125;//初始化函数void init()&#123; uchar i; lcden=0; write_com(0x38); //打开显示模式设置 write_com(0x0c); //打开显示，光标等等设置为零 write_com(0x06); //当读或写一个字符后地址指针加一，且光标加一，当写一个字符后整频显示左移， write_com(0x01); //清零指令 write_com(0x80); //指针所指位置 //定时器初始化 TMOD=0x11; //T0,T1工作方式1 TH0=(65536-2000)/256; TL0=(65536-2000)%256; //T0初始化2MS TH1=(65536-50000)/256; TL1=(65536-50000)%256; //T1初始化50MS TR1=0; ET1=1; EA=1; TR0=0; ET0=1; count0=0; //初始没有密码输入，故为零 enterflag=0; //没有确认键按下 mimaflag=0; //密码正确与否键先置零 red=1; //红灯不亮//************密码存入EPROM中********************************** sda=1; delay(5); scl=1;// SDA=1,SCL=1,使主从设备处于空闲状态 delay(5); for(i=0;i&lt;8;i++) &#123; write_add(i,8); delay3(100); &#125; for(i=0;i&lt;8;i++) &#123; mima[i]=read_add(i); delay(5); &#125;&#125;void main()&#123; rw=0; init(); write_com(0x80); //给com一个数值，com连着单片机 for(count3=0;count3&lt;16;count3++) &#123; write_date(table1[count3]); //第一行显示INPUT THE PASSPORD: delay(5); &#125; write_com(0x80+0x40); for(count3=0;count3&lt;16;count3++) &#123; write_date(table2[count3]); //开机显示FFFFFFFF delay(5); &#125; while(1) &#123; key_scan(); //调用键盘扫描函数 lcd_display(); &#125; &#125;//******************************************************************键盘扫描函数开始*******************************************************************void key_scan()&#123;//**********扫描第一行*********P1=0xfe; temp=P1;temp=temp&amp;0xf0;if(temp!=0xf0)&#123;delay(100);if(temp!=0xf0)&#123;temp=P1;switch(temp)&#123;case 0xee:key_manage1();break;case 0xde:key_manage2();break;case 0xbe:key_manage3();break;case 0x7e:key_manage4();break;&#125;while(temp!=0xf0)&#123;temp=P1;temp=temp&amp;0xf0;&#125;&#125;&#125;//**************************************************扫描第二行***********************************P1=0xfd; temp=P1;temp=temp&amp;0xf0;if(temp!=0xf0)&#123;delay(100);if(temp!=0xf0)&#123;temp=P1;switch(temp)&#123;case 0xed:key_manage5();break;case 0xdd:key_manage6();break;case 0xbd:key_manage7();break;case 0x7d:key_manage8();break;&#125;while(temp!=0xf0)&#123;temp=P1;temp=temp&amp;0xf0;&#125;&#125;&#125;//*********************************************扫描第三行***********************************P1=0xfb; temp=P1;temp=temp&amp;0xf0;if(temp!=0xf0)&#123;delay(100);if(temp!=0xf0)&#123;temp=P1;switch(temp)&#123;case 0xeb:key_manage9();break;case 0xdb:key_manage10();break;case 0xbb:key_manage11();break;case 0x7b:key_manage12();break;&#125;while(temp!=0xf0)&#123;temp=P1;temp=temp&amp;0xf0;&#125;&#125;&#125;//***************************************************扫描第四行****************************************P1=0xf7;temp=P1;temp=temp&amp;0xf0;if(temp!=0xf0)&#123;delay(100);if(temp!=0xf0)&#123;temp=P1;switch(temp)&#123;case 0xe7:key_manage13();break;case 0xd7:key_manage14();break;case 0xb7:key_manage15();break;case 0x77:key_manage16();break;&#125;while(temp!=0xf0)&#123;temp=P1;temp=temp&amp;0xf0;&#125;&#125;&#125;&#125;","raw":null,"content":null,"categories":[{"name":"通信工程","slug":"通信工程","permalink":"https://hubojing.github.io/categories/通信工程/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"https://hubojing.github.io/tags/单片机/"}]},{"title":"零碎知识记录","slug":"零碎知识记录","date":"2016-01-04T13:42:08.000Z","updated":"2016-03-26T13:28:26.000Z","comments":true,"path":"2016/01/04/零碎知识记录/","link":"","permalink":"https://hubojing.github.io/2016/01/04/零碎知识记录/","excerpt":"　　自用（单片机等）。 ","text":"自用（单片机等）。 位选就是要亮哪一个数码管,段选就是让这个数码管显示哪个数!!! #define uchar unsigned charunsigned char 用来声明无符号字符变量的，上面这个语句的作用就是在其之后 可以用uchar来代替unsigned char 简化编写，就是说 写了这条 下面在写 uchar i; 效果跟 unsigned char i; 一样蓝色是低电平。红色是高电平。黄色一般为不正常的情况，灰色为不确定（高阻？） 0xe0 P2.4P1=0x10 P1的第5位0x04是十六进制数，对应的二进制数为0000 0100，从低位到高位一次对应p1.0-p1.7，所以p1.2为高电平，其余为低电平。 temp=P3&0xf0;是个位与运算符0x80=1000 0000temp转换为二进制假设temp=1010 1010&amp;后temp=1000 0000如果temp=0010 1010&amp;后temp=0000 0000可见temp低7位无论是什么&amp;后都是0最高位由temp决定结果就是最高位保持其余全为0从而取出了最高位 &amp;是按位与的意思，就是说只将P3口的高四位读入，低四位为0，放到 temp里面 P2=0x01 对应 P2^0=1P2=0x02 对应 P2^1=1P2=0x04 对应 P2^2=1P2=0x08 对应 P2^3=1P2=0x10 对应 P2^4=1P2=0x20 对应 P2^5=1P2=0x40 对应 P2^6=1P2=0x80 对应 P2^7=1P2=0x11 对应 P2^4=1 与 P2^0=1P2=0xff 对应 P2^7=1 与 P2^6=1、P2^5=1、P2^4=1、P2^3=1、P2^2=1、P2^1=1、P2^0=1 数字信号处理 问题1.正弦型模拟信号xa(t)=Asin(Ω0t+φ)中t是时间变量，单位是秒（s），去连续数值，而正弦序列中x(n)=Asin(ω0n+φ)中n是无量纲数，取离散数值，因而造成Ω0越大，则xa(t)变化越快；但由于x(n)=sin(ω0n+φ)=sin[(ω0+2πm)n+φ]，当ω0变化时，x(n)是以2π为周期的，并不是ω0越大，x(n)变化越快。连续和离散的不都是以2π为周期的吗？为什么一个越来越大，一个却有周期性？","raw":null,"content":null,"categories":[{"name":"通信工程","slug":"通信工程","permalink":"https://hubojing.github.io/categories/通信工程/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"https://hubojing.github.io/tags/单片机/"},{"name":"数字信号处理","slug":"数字信号处理","permalink":"https://hubojing.github.io/tags/数字信号处理/"}]},{"title":"Flash动画制作学习心得","slug":"Flash动画制作学习心得","date":"2015-12-06T03:26:33.000Z","updated":"2016-03-26T13:27:58.000Z","comments":true,"path":"2015/12/06/Flash动画制作学习心得/","link":"","permalink":"https://hubojing.github.io/2015/12/06/Flash动画制作学习心得/","excerpt":"　Flash动画制作随手记。 ","text":"Flash动画制作随手记。 制作过程中发现的问题及解决方案1.音频不能导入最简单的解决方案：使用Adobe Adition内录。注意保存比特率不要高于160KHZ。（320KHZ导入不了） 2.按钮制作了没反应解决方案：首先新建一个图层，把按钮拖进去。在第一帧（注意是帧）动作里写上语句stop();然后在按钮的动作里写上语句on (release){play();}3.“开始”按钮控制不了声音最简单粗暴的方法：声音从第二帧开始。 4.点击“暂停”按钮声音停止不了动作里写上语句stopAllSounds(); 5.声音会不断循环在最后一帧（记住加入关键帧）动作里写上stopAllSounds(); 6.mc总是一闪而过是mc的长度没设置好。拖过到合适的长度即可。 7.按钮上的文字怎么改在按钮元件内部有一层是text，把默认的文本框删掉，在自己加一个上去。 还有一些细枝末节的问题，这儿就不提了。 实践后发现需要注意的地方1.名字标清楚方便修改！做到后来，图层、元件各种文件越来越多，一定要在新建的时候就尽量标明。 2.多建图层最好声音一个图层，按钮一个图层，背景一个图层，遮罩一个图层，mc一个图层，分好类！ 3.把同一类文件放入一个文件夹如逐帧动画的素材，一个小动画就有几十张，放入文件夹方便查看。 4.分清“插入帧”、“插入关键帧”、“插入空白关键帧”、“删除帧”、“清除关键帧”的区别插入帧：就是插入普通帧，是在前面一帧地基础上操作。插入关键帧：关键帧的前后都可以和这一帧毫无关联！删除帧：一点痕迹也不留。清除关键帧：关键帧是没了，还是一个普通帧。 5.已做逐帧动画的素材图片分类放入文件夹中时，不要剪切！可以直接拖进文件夹，千万不能剪切再粘贴进文件夹，否则之前做好的逐帧动画就都没了……我自己毁了两次才发现这个问题，上百帧啊…… 6.动画太快，把每一帧后面空一帧相当于延时的作用。 7.记住几个快捷键ctrl+F3 调出属性面板F5插入普通帧F6插入关键帧F7插入空白关键帧","raw":null,"content":null,"categories":[{"name":"多媒体","slug":"多媒体","permalink":"https://hubojing.github.io/categories/多媒体/"}],"tags":[{"name":"Flash","slug":"Flash","permalink":"https://hubojing.github.io/tags/Flash/"}]},{"title":"STC89C52RC单片机学习记录（1602篇）","slug":"STC89C52RC单片机学习记录","date":"2015-11-17T12:53:47.000Z","updated":"2016-03-26T13:27:34.000Z","comments":true,"path":"2015/11/17/STC89C52RC单片机学习记录/","link":"","permalink":"https://hubojing.github.io/2015/11/17/STC89C52RC单片机学习记录/","excerpt":"　　　　　　 \n\n四条相关的小记录。","text":"四条相关的小记录。 老式51单片机内部没有AD和DA转换模块51单片机是一种比较经典的单片机，因此问世时间比avr时间长，它的芯片内部没有集成ad转换，而avr单片机芯片内部集成了ad转换，因此传统的51需要外接ad转换芯片，而avr不需要。不过随着时间的发展，新型的51单片机也有内部集成了ad芯片的，比如stc12c2052ad。这也是为什么我们的课本上学AD、DA转换时，书上的例题都加了一个转换器如DAC0832、ADC0809的原因。 _nop_()这个函数是延时一个机器周期的意思，它包含在头文件intrins.h中，只要程序应用到_nop_()，就需要有头文件intrins.h的声明。 1602液晶相关 几个引脚功能备注 第4脚：RS为寄存器选择，高电平1时选择数据寄存器、低电平0时选择指令寄存器。第5脚：RW为读写信号线，高电平(1)时进行读操作，低电平(0)时进行写操作。第6脚：E(或EN)端为使能(enable)端,高电平（1）时读取信息，负跳变时执行指令。 液晶显示程序的几点注释LCD1602测忙：1result = (bit)(P0 &amp; 0x80) (bit)强制转换成位，P0与0X80：0X80换成二进制就10000000也就是P0口的P0^7位。 1lcd_write(0,pos|0x80); 变量pos按位或0x80，也就是取出变量pos的最高位数据，传递给函数lcd_write()。此函数下面应该会有用到变量pos的地方，那里得到的pos不再是原来的数据了，按位或0x80后，就只有最高位是pos原来最高位的数据，其它位全部置位0。这个函数是设定DDRAM地址，也就是设定字符显示的首地址，它只执行了一个指令“向控制器写入0x80|pos的值（这是一个或表达式，表示POS变量与0X80相或，取其结果，0x80是KS0066内部指令的关键字，是表示指定DDRAM首地址的）。 忙还是那么忙，累却到了一个极点。但还是感到莫大的幸福。","raw":null,"content":null,"categories":[{"name":"通信工程","slug":"通信工程","permalink":"https://hubojing.github.io/categories/通信工程/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"https://hubojing.github.io/tags/单片机/"}]},{"title":"Matlab函数杂谈","slug":"matlab函数杂谈","date":"2015-11-10T08:39:08.000Z","updated":"2016-03-26T13:27:12.000Z","comments":true,"path":"2015/11/10/matlab函数杂谈/","link":"","permalink":"https://hubojing.github.io/2015/11/10/matlab函数杂谈/","excerpt":"\n写了两篇正儿八经的技术文，我觉得这好像不是我的风格，我是小清新啊小清新[微笑]我是大家的开心果啊[微笑]  所以，学技术也要感受到快乐。来来，回归自己。\n　　　　","text":"写了两篇正儿八经的技术文，我觉得这好像不是我的风格，我是小清新啊小清新[微笑]我是大家的开心果啊[微笑] 所以，学技术也要感受到快乐。来来，回归自己。 浅谈最近用matlab遇到的几个函数：1.num2str str2num对于一个刚学matlab不久的人，看到回调函数里满篇num2str、str2num内心满满的问号……这感觉就和十年前学英语一样……然而这个2，让我觉得这个函数很有意思……是的，2就是two啊！two音同to啊！num2str，顾名思义，number to string，把数值转化成字符串。同理str2num我就不解释了。嗯，程序员都是懒人，能省就省必须的。 2.ezplotEasy to use function plotter！E Z PLOT 懒人的智慧翻译：易用的一元函数绘图函数使用之前要定义！要定义！要定义！符号函数定义法则：syms x;那么问题来了，syms是什么鬼？syms是定义符号变量。哦，我们就记得了，进行符号运算前要定义它，就用syms。 3.conv数字信号处理，嗯哼，眼熟是不是？卷积卷积卷积！ 辨析：filter、conv、impz函数的区别在MATLAB中，可以用函数y=filter(p,d,x)实现差分方程的仿真，也可以用函数 y=conv(x,h)计算卷积，用y=impz(p,d,N)求系统的冲激响应。具体例子百度一大推。 4.stem同样数字信号处理里出现的。Stem函数用于绘图，它是绘制针状图的好手。调用格式都为stem(n,x,’filled’);只需要将需要绘制的数据存放在一个数组中，然后将这个数组作为参数传递给“stem”函数就可以得到输出图形。例如，下面的代码可以绘制正弦函数的图形：n=1:50; %定义序列的长度是50x=zeros(1,50); %注意：MATLAB中数组下标从1开始x(1)=1; %冲击函数stem(x); %绘制函数图形 5.impulse函数impulse（）将绘出由向量 a 和 b 表示的连续系统在指定时间范围内的冲激响应h(t)的时域波形图，并能求出指定时间范围内冲激响应的数值解。impulse（）函数有如下四种调用格式：（1）impulse(b,a)：该调用格式以默认方式绘出向量 A和B定义的连续系统的冲激响应的时域波形。（2）impulse(b,a,t)：绘出系统在 0～t 时间范围内冲激响应的时域波形。（3）impulse(b,a,t1:p:t2)：绘出在 t1~t2 时间范围内，且以时间间隔 p均匀取样的冲激响应波形。（4）y=impulse(b,a,t1:p:t2)：不绘出波形，而是求出系统冲激响应的数值解。 6.stepstep（）函数可绘出连续系统的阶跃响应 g(t)在指定时间范围的时域波形并能求出其数值解，和impulse（）函数一样也有四种调用格式。（1）step(b,a)：该调用格式以默认方式绘出向量 A和B定义的连续系统的阶跃响应的时域波形。（2）step(b,a,t)：绘出系统在 0～t 时间范围内阶跃响应的时域波形。（3）step(b,a,t1:p:t2)：绘出在 t1~t2 时间范围内，且以时间间隔p均匀取样的阶跃响应波形。（4）y=step(b,a,t1:p:t2)：不绘出波形，而是求出系统阶跃响应的数值解。 惊人相似有木有！impulse 和 step 一定是一家人~~ 先说这么多。最近比较忙。","raw":null,"content":null,"categories":[{"name":"通信工程","slug":"通信工程","permalink":"https://hubojing.github.io/categories/通信工程/"}],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"https://hubojing.github.io/tags/Matlab/"}]},{"title":"Hexo优化·年轻就是折腾 | Promotion of the Blog & Young for Try","slug":"hexo优化","date":"2015-11-10T08:06:03.000Z","updated":"2016-11-20T09:28:26.000Z","comments":true,"path":"2015/11/10/hexo优化/","link":"","permalink":"https://hubojing.github.io/2015/11/10/hexo优化/","excerpt":"　　说明：本博客会长期优化，因此将之前所写相关文章合并到同一篇中，按倒序编排，以便查询。 ","text":"说明：本博客会长期优化，因此将之前所写相关文章合并到同一篇中，按倒序编排，以便查询。 2016.10.22更新 失踪人口短暂现身… 这么久没有更博内心有愧。其实有不定期更新github。 今天我十分惊讶于博客项目的deploy最近一次记录竟是8月，这说明了我近两个月来的微调都没有部署上来……难怪我的github不绿了！ 在仔细研读了我的config并确保没有问题后，我又一次hexo c,hexo g,hexo d三部曲，然后可怕的事情发生了：Cannot GET / 在搞垮博客几次后的我已经云淡风轻了，只有一个念头：我能修复好。废话不说了，进入正题：解决方法：将npm重新安装一遍。这两个月一直想做成双语切换样式（目前中英文混编有些凌乱），可能意外删除了nodejs的部分文件，造成不能部署。但英文版各种bug，暂时放下，等考完再战。 npm -v查看npm版本命令。 对博客进行了小的调整： 1.压缩背景图片，每张100KB以内，提高了访问速度。 2.替换了失效的图片链接，去掉了github里项目|collections|里的极简图床，以自身血的教训证明，还是七牛云本身最稳定，不要偷懒，否则失效时眼泪止不住的流（滑稽）。 3.部分文章更新、重新排版。（前期初学markdown写的确实凌乱，中英混排也一并修改） 4.拖欠的友链已添加，失效的友链已更改。 5.为部分没有封面图的文章增添了封面图。 6.降低了封面背景透明度。 7.修改了多说头像CSS。 8.修改了评论框背景图。（快去捕捉一只野生皮卡丘！） 今天算是懂了，要做好前端，一定要懂PS。(可我明明是一个想做后端的人……) 下次更新：提交sitemap给必应。 同步托管至coding具体操作之前我已另写一篇详细教程：http://hubojing.github.io/2016/04/06/%E5%B0%86hexo-github%E5%8D%9A%E5%AE%A2%E5%90%8C%E6%AD%A5%E6%89%98%E7%AE%A1%E8%87%B3coding/ 修改背景透明度yelee/source/css/_variables.stylBackground Color相关的4个变量，颜色为 RGBA.http://www.w3school.com.cn/cssref/css_colors_legal.asp12345// Background Colorleft-col-color = rgba(255,255,255,.85)mid-col-color = rgba(255,255,255,.8)article-color = rgba(255,255,255,.45)archives-color = rgba(255,255,255,.4) 左侧背景更换yelee/source/css/_partial/main.styl原CSS：12345678910111213141516171819202122232425.left-col &#123; background-image: url(http://lubiao.b0.upaiyun.com/c/2/2014/5/14/2/11/4d4059067181d8b7fbc9ac8920ff2764.jpg); width: left-col-width; position:fixed; opacity:1; transition:all .2s ease-in; height:100%; overflow-y: auto; .overlay&#123; width: 100%; height: 180px; background-color: black; position: absolute; opacity: 0.7; &#125; .intrude-less &#123; width: 76%; text-align: center; margin: 112px auto 0; &#125; li:hover &#123; background: none; font-weight: bold; &#125;; &#125; 效果图： before 现CSS：1234567891011121314151617181920.left-col &#123; background-image: url(/images/l1.jpg); background-size: cover; width: left-col-width; position:fixed; opacity:1; transition:all .2s ease-in; height:100%; overflow-y: auto; .intrude-less &#123; width: 76%; text-align: center; margin: 112px auto 0; &#125; li:hover &#123; background: none; font-weight: bold; &#125;; &#125; 效果图： after 也许您认为之前的更好看，因为时间紧促，我没有花很多时间在图片选取和P图上，只是为了成功实现左边栏背景不同的效果。后期还会不断调试。 2016.4.23更新 提交sitemap给google和百度 目的：使谷歌和百度能够搜索到本博客 测试：可在浏览器中输入谷歌：site:hubojing.github.io百度：site:hubojing.coding.me 效果： 百度搜索 谷歌搜索 说明：百度蜘蛛爬不了github的网址，所以只好将博客同步部署到coding。详细步骤见：将hexo-github博客同步托管至coding 步骤 百度提交sitemap: installif your hexo version is 2.x.x, you should install as follow:1npm install hexo-generator-baidu-sitemap@0.0.8 --save if version is 3.x.x, you should install as follow:1npm install hexo-generator-baidu-sitemap@0.1.1 --save Update12$ npm remove hexo-generator-baidu-sitemap$ npm install hexo-generator-baidu-sitemap --save Optionsif your hexo version is 2.x.x, you can configure this plugin in _config.yml.12baidusitemap: path: baidusitemap.xml if version is 3.x.x, you should configure this plugin in _config.yml.12baidusitemap:path: baidusitemap.xml path - Sitemap path. (Default: baidusitemap.xml) ErrorsMaybe response is “hexo is not definded”,then you should:12cd node_modules/hexo-generator-baidu-sitemap/npm install 谷歌的提交方法是类似的。 2016.3.1更新 公共/独立空间评论切换yelee/layout/_partial/article.ejs, 把 “key: post.path” 改为 “key: post.slug”，主题多说配置 domain: true这样就恢复到 Yilia 的公共评论了。 将“more”改为“阅读全文”主题配置_config.yml里更改：1excerpt_link: 阅读全文 2016.2.28更新 这轮优化很多都挺成功，就是之前的评论都丢失了……桑心。欢迎大家留言安慰我^_^ 主题更换 采取了更为美观的主题，并且有了文章内检索目录，我很喜欢。记得修改 Hexo 根目录对应配置文件。theme: yelee 图片插入 对于hexo，有两种方式： 1.使用本地路径：在hexo/source目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时链接即为/img/图片名称。 2.使用微博图床，地址http://weibotuchuang.sinaapp.com ，将图片拖入区域中，会生成图片的URL，这就是链接地址。以上是查找的资料。 2016.3.1更新 本地图片插入问题解决 效果： 测试图片 之前本地服务器浏览可以看到图片，但部署上去就无法加载。 这是因为\\ 测试图片](E:/hexo/source/images/test.jpg)是**绝对地址**。但有相关文章说绝对地址也是可以的，但我一直没有实现，这一点有待考察。上述成功用的是相对地址。![测试图片 后来准备用七牛作图床。～～用极简图床真是特别方便～～ About Page 关于我页面 使用以下代码添加一个新页面：$ hexo new page about Tags Cloud Page 标签云页面$ hexo new page tags Comment 评论 多说: http://duoshuo.com/create-site/ 登陆你的多说并创建站点，在 “domain” 中填入你设定的域名的前半部分。比如完整域名是: http://ABC.duoshuo.com ，只需填入 ABC 即可。 我之前就没设置站点……不知道还能不能找回来评论？（可以） 主页链接 我把我网易云音乐的主页链接放上来了，欢迎大家和我交流轻音乐。（移动端看不到我的主页，只有PC端可以看到。） 细节 一些细节改变挺多，不知道看过我之前博客样子的访客能找到多少改变之处？欢迎评论。 2015.11.10更新 关于主题 安装1$ git clone git@github.com:XXX/xxx.git themes/xxx 更新12$ cd themes/xxx$ git pull 关于统计 两种方法： 1.google/baidu统计 google登不上去，就用百度吧。先去百度统计注册一个账号，把你的域名输入作为被统计的网页。 它会自动生成一段代码，复制下来。 在主题下的_config.yml添加：1$ baidu_tongji: true 接着，在主题目录下的layout\\ _partial找到head.ejs 打开它，在 &lt; head&gt; 和 &lt; /head&gt; 中粘贴代码即可。 2.不蒜子不蒜子 两行代码解决。只不过只能显示总人数或每篇文章浏览数。 网站小图标 把.ico图标放入themes主题里的source目录下！ 推荐比特虫，在线制作图标。 同时加入代码。 categories、tags 在主题目录的_config.yml中修改成 XXX: /categories/XXX 或 XXX: /tags/XXX 注意空格和英文的冒号。 更改相关字体、颜色等细节 这个简单，找到hexo\\themes\\light\\source\\css_partial\\main.styl,里面就是基本构架，就是代码有点长，耐心找找。这个级别代码一点都不长…… 搭建问题的解决方案 具体操作之前我已另写一篇详细教程：http://hubojing.github.io/2015/11/06/hexo+github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/ 以上。 参考资料不蒜子为hexo主题添加多种图片样式hexo在github上构建免费的Web应用极简图床解决hexo置顶问题hexo全部模板比特虫hexo你的博客Sitemap generationHexo ：（三）高级进阶hexo主题中添加相册功能","raw":null,"content":null,"categories":[{"name":"博客","slug":"博客","permalink":"https://hubojing.github.io/categories/博客/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hubojing.github.io/tags/Hexo/"}]},{"title":"Hexo+Github博客搭建中出现的问题及解决方法 | The Solution of Troubles in Establishing My Blog","slug":"hexo+github博客搭建中出现的问题及解决方法","date":"2015-11-06T12:35:37.000Z","updated":"2016-10-23T15:28:36.000Z","comments":true,"path":"2015/11/06/hexo+github博客搭建中出现的问题及解决方法/","link":"","permalink":"https://hubojing.github.io/2015/11/06/hexo+github博客搭建中出现的问题及解决方法/","excerpt":"hexo+github博客搭建中出现的问题及解决方法。博客优化和高级进阶请看–&gt;hexo优化·年轻就是折腾","text":"hexo+github博客搭建中出现的问题及解决方法。博客优化和高级进阶请看–&gt;hexo优化·年轻就是折腾 2016.8.28更新 Update 插件 plug-in unit123456789npm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-server --savenpm install hexo-deployer-git --savenpm install hexo-generator-sitemap --savenpm install hexo-generator-feed --savenpm install hexo-git-backup --save hexo插件 2016.4.7更新 Update 每次hexo d之后都要输入密码，很影响心情，于是决定重新设定SSH，这次不再设定密码。现把流程记录下来备忘。It affects mood to input password everytime I execute hexo d.So I decide to reset SSH and no password.Now write the steps down. 几条重要指令 Several important instructions 查看是否存在SSH文件。To cheak if SSH file exists.1ls -al ~/.ssh 存在的话，直接删除.ssh文件夹里面所有文件，同时在github上删除SSH。Delete all the files if it exist and delete SSH on the github. 1ssh-keygen -t rsa -C \"4177997456@qq.com\" 回车三次（因为密码为空）。Press enter three times(for keyword is empty). 1ssh-agent -s 1ssh-add ~/.ssh/id_rsa 出错。Something wrong. 换成 Change into12eval `ssh-agent -s`ssh-add 完成。Finish. 可以直接打开.ssh文件夹里的id_rsa.pub复制全部内容，也可以输入You can copy id_rsa.pub in the .ssh file,or input1clip &lt; ~/.ssh/id_rsa.pub 然后在github里设置好SSH即可。then set SSH on the github. 最后测试一下：Test it finally,1ssh -T git@github.com 如果出现 成功画面 证明设置好了。If it shows sucess that all is done. 然而……However~ 依！然！报！错！Still wrong! 报错画面wrong 这是为什么……在hexo d好几次后的我凌乱在风中…… 但我没有放弃……毕竟不能把博客玩废啊是不是:-D 我想起来昨天把博客同步托管在github和coding上了。 因为我的repo先写的coding，再写的github，所以服务器先连接coding，后连接github！！！ 两个托管网站都要设置好SSH之后，才能顺利部署！ 完工！ 再也不用打密码啦~ WHY?!After several times hexo d,I was messy in the wind~But I’m never give up~I can’t destory my blog after all :DI remind of having got my blog hosted on GitHub and coding yesterday.My repo place coding to the front,so the sever links coding first,then the github!!!Only two host webs be setted SSH,can it be well deployed!Finish!Never using password~Say goodbye to you~ 2015.11.06更新 Update 今天建好了大体的框架，细节还需不断调整。现把我搭建过程中出现的若干问题以及解决方案写下来，方便自己及读者不再为这些地方犯难。Today the frame generally build,and details needs improving. Now I note my problems and solutions for the readers no longer to puzzle again. 安装 Install 安装顺序不要错，出现WARN不用管。 我们都知道需要安装git和node.js，然后才能安装hexo。 简单介绍：Hexo 是一个快速、简洁且高效的基于Node的静态博客框架。 按理来说，从官网把软件下载下来安装，一路next就行。 打开git bash命令行，输入： Installation sequence is important,and you can ignore the warning in the process.We know that git and node.js are needed,and then hexo can be installed.In brief,hexo is a fast, simple and efficient static blog framework which bases on Node.Having downloaded the software and installed,and then you just click “next”.Input this in the git bash: 1$ npm install -g hexo-cli 这时会发现，和很多教程所授不同啊！出现了多个WARN。不要慌！WARN可以不用管。我当时查了很久，怎么才能不WARN，后来发现其实不影响之后的搭建。 At this moment you will puzzle that it is different with many tutorials.It turns out some warning!Calm down,guys,you can ignore them.It doesn’t matter. 开始建站 Set 建站前直接在目标盘建立一个hexo文档，对hexo右键git bash。 记住一定在目标目录里建站！ 一开始我不清楚，点击桌面上的git bash就输命令，后来都不好找hexo文件在哪，严重影响之后的体验！ 之后同样的，npm加到目标目录中！ At first,you should create a hexo file,and git bash with right click.Remember to set your blog in the target file!I made the mistake that git bash on the desktop,which resulted in the loss of hexo file.It’s bad for later set.And then,the same,add npm to the target file! 1$ npm install 就这三步，本地的网站其实就建立好了！看起来好简单！运气不好的话就会像我一样，卡在最开始耽误了很多时间。 Having done these three steps,our local web is already set!Is it really easy?But you may waste much time as I did. 本地预览 Local preview 因为在Hexo 3.0后server被单独出来了,需要安装server,记住打下面一行代码：Because server was divided after hexo 3.0,you should install server,and remember these code,1$ npm install hexo-server --save 之后是：and then,1$ hexo server 本地端口已经打开，通过浏览器访问http://localhost:4000/ 可以看到网站。 The local port has set,and you can cheak on http://localhost:4000/ through browser. 注意细节 Pay attention to details 下载一个编辑器，我下载的是Sublime Text 2，一定要有编辑器，否则很多属性不能修改。 找到hexo文件夹，打开_config.yml，这里面就是网站的配置信息。具体配置hexo讲的很明白，我就不解释了。 我刚开始就是胡乱搭建，找不到hexo文件，更不用谈之后的配置。这里要擅用电脑里的文件搜索，有它还是可以方便的找出文件。 Hexo采用markdown语法格式书写博客，其中我们的博文就放在source里的_posts目录。 To download a editor.What I use now is Sublime 2.You need a editor for modify attributes.The _config.yml in the hexo file is the web configuration information.The specific configuration I won’t say it here.I structures it at random at first,because I couldn’t find hexo file.A good tip is to use file search to find what you want conveniently.Hexo uses markdown grammer to write,and our articles are saved in the _posts file. 写新文章 Create a new article1$ hexo new title 其中title为你的博文文件的文件名，不一定是博文的标题，只要自己看得懂就行。然后点开source里的_posts目录，打开title.md，我们就可以在里面进行写作了。当然，有一些语法规定及格式要求，我也还在学习中。 The title is your article file name,not your article name,so just you understand is alright. 之后需要静态化页面： 1$ hexo generate hexo部署：1$ hexo deploy 此时本地站点大体搭建好了。Now the local site is set. 如果配置_config.yml出错，本地网站是一定搭不好的！ 而_config.yml中比较难发现的就是，每一个红体单词冒号后要空格！！！ If the _config.yml is wrong,your site can’t be create.The detail easy to overlook is that there leaves a blank space after colon!!! 接下来把网站部署到github上。 首先去github上注册个账号。 再建立一个新的repositories。名称是username.github.io，这也是最终搭建好的博客的链接地址。 The following thing is to deploy the site on the github.At the beginning,you should have a github account.Then you should create a new repositories,which name is username.github.io,and it is your blog link address. 勿用github自动页面生成器 Do not use the github automatic page generator 尤其初学者！否则之后的hexo博客很难部署上去！ 如果已经用了自动页面生成器，可以删除这一个repositories，再新建一个。 在完成上述操作后，到Hexo文件夹下的_config.yml文件，将最下方的deploy部分修改为 Exspecially a beginer!If you use it already,you can delete this repositories,and create another.After all the steps done,revise the deploy of the _config.yml as 123$ deploy type: git repo: git@github.com:username/username.github.io.git 每个冒号后有一个空格！！！ 到此，github配置完成。 There leaves a blank space after each colon!!!*So much for that,the deploy is done. 现在要把hexo和github联系在一起，还需要SSH。 首先,打开git bash: If hexo links to github,SSH is needed.Open git bash, 12$ git config --global user.name \"XXX\"$ git config --global user.email \"XXXXXX@mail.com\" 邮箱是你注册github的邮箱。 生成密钥： The e-mail is your github e-mail.Create private key, 1$ ssh-keygen -t rsa -C “XXXXXX@mail.com” 然后设置路径，最好不要更改id_rsa和id_rsa.pub的名字。 密码可有可无(最好无)，但输入时你也看不到自己输的密码的。登录github，在右上角settings（不是repositories里的settings）有SSH keys。复制你设置路径里的id_rsa.pub用编辑器打开得到的代码，粘贴到SSH keys，标题自定义。验证： Set path,and don’t change id_rsa and id_rsa.pub name.The password is not esstial(none maybe convinent),but you can’t see it when you enter the code.Then you sign in the github,and finds SSH keys in the setting(not setting in the repositories).Copy your code in the id_rsa.pub,and paste it to SSH keys.Customizable title is needed.Verity, 1$ ssh -T git@github.com 一般来说，是会报错的。Permission denied (publickey).让多少人揪心的一句话。 Generally,something goes wrong.”Permission denied (publickey)”,may let you not happy. 复制公钥 Copy public key 用计算机搜索文件.ssh文件，找出目标路径，之前设置的id_rsa和id_rsa.pub复制到这里来！同时，如果多次设置SSH，最好把其中一个known开头的文件里前几次的公钥清空。成功的标志： Search .ssh file in the computer,and paste id_rsa and id_rsa.pub to it.If you set SSH many times,you’d better clear the previous public key in the known-start file.The success sign, 1$ Hi username! You've successfully authenticated, but GitHub does not provide shell access. 最后， In the end, 12$ npm install hexo-deployer-git --save$ hexo deploy 基本指令 Basic instructions 每次修改或者发文后，这两条命令一定要打，否则博客不能更新： Everytime you revise or create a article,two instrucions are needed,or your post can’t be updated. 12$ hexo generate$ hexo deploy $ hexo server 为在本地端口打开。(简记abbreviation hexo g hexo s hexo d) 期间还遇到一些小问题，不典型，就不说啦。总之，初学者刚开始搭建一定要有耐心，我仅是node.js就重装了五遍以上，有时候看教程很复杂，其实一步步做不难！不要放弃！跟着一个教程做出现问题时，及时在网上寻求答案，查看其它的教程。我在搭建此博客时，查阅的教程几十种了，很多人的方法很好，也算是走捷径了！ There exists many small problems in the process.In short,the patience is vital during the course.According to me,I reset node.js for more than five times.The tutorial maybe complex,but you can feel easy if you do it step by step!Never give up!When any problem arise,it is useful to search solutions on the internet or looking up in another tutorial.I call the tips a shortcut. 以上，就是我搭建过程中出现的问题及解决方案。 Above,it is the problems and solutions in the process. 参考资料 Reference material1.hexo与github_pages搭建博客教程2.hexo你的博客3.hexo干货系列（一）4.hexo常见问题解决方案","raw":null,"content":null,"categories":[{"name":"博客","slug":"博客","permalink":"https://hubojing.github.io/categories/博客/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hubojing.github.io/tags/Hexo/"}]},{"title":"HelloWorld","slug":"HelloWorld","date":"2015-11-06T05:23:40.000Z","updated":"2015-11-07T05:23:40.000Z","comments":true,"path":"2015/11/06/HelloWorld/","link":"","permalink":"https://hubojing.github.io/2015/11/06/HelloWorld/","excerpt":"利用一周零零碎碎的时间搭建起来，使用hexo在github上的个人独立博客初见雏形。 ","text":"利用一周零零碎碎的时间搭建起来，使用hexo在github上的个人独立博客初见雏形。 作为一名通信人，始终要记住科学技术是第一生产力！大三已至，也算入了互联网+通信领域的门。入门不难，深造不易。将把自己在学习中和实践中的技术经验以及点滴收获记录下来，作为自己在技术之路的见证和成长。读者可以随时在文章下方评论，以及与我联系，欢迎学术交流，难题沟通，批评指正，尤其是专业相关（比如数模电）、数学方面（数学虐我千百遍，我待数学如初恋[笑]）。自觉天资不高，但对于技术，心向往之，但愿各位指点一二。 I manage to find time to build this blog for a week,which used hexo static frame on the github,and it is finished preliminarily.As a Communication man,we should always keep in mind that science and technology are primary productive force!I’m already learn elementary courses since I’m a junior student today. To cross the threshold is not difficult, but mastery is another question.Therefore,I will take notes on the blog through the learning and practice process,to witness my growth on the way.Readers can commit on the bottom of the article,and contact with me.Welcome academic exchange and question communication.You can oblige me with your valuable comments about major related(digital electronic technology or analog electronic technology,for instance),especially math problem(^_^I am fond of mathematic).I’m not talent,but I’m adore of IT.I would appreciate it if you give me some guidance. Talk is cheap,show me the code!Just do IT！","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://hubojing.github.io/tags/杂谈/"}]}]}