{"meta":{"title":"胡博靖的技术博客","subtitle":"小清新工科女旅程　　　为中华之崛起而读书","description":"通信工程|学生|程序员|互联网|通信|研发|科技|IT|工程师|图像处理|软件|前端|应用|本科|大四","author":"胡博靖","url":"http://hubojing.github.io"},"pages":[{"title":"404 Not Found","date":"2016-04-23T09:26:38.115Z","updated":"2016-04-23T09:26:38.115Z","comments":false,"path":"/404.html","permalink":"http://hubojing.github.io//404.html","excerpt":"","text":"据说只有好看的人才能看到这个网页……\\ (≧▽≦) /~啦啦啦 那你就听听音乐吧~喵~ &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=450 src=&quot;http://music.163.com/outchain/player?type=0&amp;id=115991087&amp;auto=1&amp;height=430&quot;&gt;&lt;/iframe&gt; &lt;style type=&quot;text/css&quot;&gt; .article-header { padding: 0; padding-top: 26px; border-left: none; text-align: center; } .article-header:hover { border-left: none; } .article-title { font-size: 2.1em; } strong a { color: #747474; } .article-meta { display: none; } .share { display: none; } .ds-meta { display: none; } .player { margin-left: -10px; } .sign { text-align: right; font-style: italic; } #page-visit { display: none; } .center { text-align: center; height: 2.5em; font-weight: bold; } .article-entry hr { margin: 0; } .pic { text-align: center; margin: 0; } .pic br { display: none; } #container .article-info-post.article-info { display: none; } #container .article .article-title { padding: 0; } &lt;/style&gt;","raw":null,"content":null},{"title":"为中华之崛起而读书","date":"2016-02-28T07:59:38.000Z","updated":"2017-04-22T13:50:59.748Z","comments":true,"path":"about/index.html","permalink":"http://hubojing.github.io/about/index.html","excerpt":"","text":"&lt;embed wmode=&quot;transparent&quot; src=&quot;http://files2.17173.com/__flash/2011/10/21/honehone_clock_tr.swf&quot; quality=&quot;high&quot; bgcolor=&quot;#ffffff&quot; width=&quot;800&quot; height=&quot;300&quot; name=&quot;honehoneclock&quot; align=&quot;middle&quot; allowscriptaccess=&quot;always&quot; type=&quot;application/x-shockwave-flash&quot; pluginspage=&quot;http://www.macromedia.com/go/getflashplayer&quot;&gt; 学技术要折腾！ 关于我 13级通信工程专业，一名喜爱互联网的女生。 一直对IT有无限向往，对科技宅无比敬佩，立志成为一名有为的科技工作者。我虽不才，愿努力成才。 科学技术是第一生产力！科技作用是巨大的，通过它，我们的生活更好，我们的国家更好，世界更好！ 敬畏科技，敬畏生命！ 关于本博客 一个小白的学习历程。有时候是笔记，有时候是想法，有时候是细枝末节的记录。 希望在不停的撰写中，提升自己的技术水平，也记录一段青春的奋斗之路。 主操作系统 win 10 文本编辑器 Text editor Sublime 2 榜样&amp;偶像 钱学森 所学技术 通信工程科班所学课程、PS基础、Flash基础、音视频剪辑基础、PPT动画制作 了解：HTML、JAVA基础、CSS基础、数据库基础、linux、android 语言：C、C++、JAVA、MARKDOWN 兴趣爱好 计算机爱好者 从小热爱高科技，对IT充满兴趣。至今组装过两台电脑，维修过几部手机。对电脑操作有比较多的了解，学习过PS、Flash、音视频剪辑、PPT动画制作等具体软件应用。现在为了优化博客，正在学习前端知识。 纯音乐爱好者 最爱石进《夜的钢琴曲》系列。欢迎交流。点击进入我的网易云音乐 （PC端） 希望不久的将来能靠自己的力量买到一台三角钢琴。吉他学习者。 &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=450 src=&quot;http://music.163.com/outchain/player?type=0&amp;id=146049436&amp;auto=1&amp;height=430&quot;&gt;&lt;/iframe&gt; 运动爱好者 擅长羽毛球、乒乓球，热爱篮球、排球、游泳、瑜伽、舞蹈、武术。轮滑学习中。每天40分钟锻炼身体，调剂心情。曾学过6年舞蹈，也曾教授过班级一套武术拳法并在汇演时进行演出。 游戏体验者 不排斥游戏。有不少好游戏，能很好的锻炼反应能力和设计能力。曾对各大网游和单机游戏都有体验，但绝不沉迷。 文学、写作、历史爱好者 喜欢优美的文字、清新的文章和诗词。欢迎推荐相关纪录片和书籍。从2007年开始写博客。之前用新浪博客，点击数过万计。 读书追赶者 深知自己的阅读量远远不够。自从上了大学自主时间多了之后，便特别爱看书，其中推理和历史书籍居多。工科课程和学生事务占据了我大部分时间，但仍阅读了20多本优质好书。希望在大学毕业前，我能看够50本。我对书的选择是，出版书籍，并且是经典的或者优质畅销好书。 欢迎荐好书! 好书对人的思想的影响是深远的；同样地，满是糟粕的书，带给人的影响是毁灭性的。 动漫 名侦探柯南 火影忍者 那年那兔那些事儿 为人之道 己所不欲，勿施于人。 待人真诚，坚守原则。 努力成为真性情的人。 通讯 Communication QQ：417797456 邮箱Email：hubojing@outlook.com github:hubojing 小说明：知乎ID：胡博靖 不是本人，大概同名同姓吧。 愿技术改变生活，技术提升品质。愿与大家共同进步。 Always remember that infinite possibilities are given to youngsters. About me a senior girl likes internet and major in communication engineering. there is an infinite yearning for IT since I was a little child,also,I adore of science and technology researchers.So,I am determined to be a promising science and technology worker.I'm not talented,but I'm willing to work hard. Science and technology are the first productive forces!The role of science and technology attachs great importance in the society, via which, our life better, our country better, the world better! Reverence for science and technology, and reverence for life! About this blog a tyro's learning process.Sometimes it is notes,somestimes ideas,others detail records. I hope to improve my skills through my writing,and it is also a reflect of my youth. Main operating system win 10 Text editor Sublime 2 / Atom Role model and idol Hsue-shen Tsien What has learned My major courses,PS basics,Flash basics,Audio and video clip basics,PPT animation basics Self-study:HTML,JAVA basics,CSS basics,sql,linux language：C、C++、JAVA、MARKDOWN Hobby COMPUTER LOVER I love high-tech,and interested in it.Two computers has been assembled,and several mobile phones has been repaired.Be familiar with computer operations,and know some about Photoshop,Flash,audio or video clips,and Powerpoint animation.For optimizing the blog,I'm learning Front-end Now. ABSOLUTE MUSIC LOVER love &quot;Piano music of the night&quot; best.Welcome to communicate with me.Click to see my NetEase cloud music （PC client） I wish I can rely on myself to buy a tripod piano in the near future.Guitar is in the learning. SPORTS LOVER I'm good at badminton,table tennis,fond of basketball,volleyball,swim,yoga,dance,the martial art,and skidding of the wheel.Exercise 40 minutes a day to keep health and adjust the mood.I Had learned 6 years of dance, also taught my class of the martial arts and performed in the show. GAME PERSON Not reject the game.Because many good games can practice reaction and design ability.I have played all kinds of online games or stand-alone game,but I never indulge in the games. LITERATURE,WRITING,HISTORY LOVER Love beautiful words, grace articles and poems. Welcome to recommend related documentaries and books.I start using blog from 2007,and I write blog on Sina before,which Click over ten thousand.In the 22th,32th international Chucai Writing Competetion I won the first prize (ten years later see you again.) READING CHASER I understand deeply that my reading is far from enough,so I like reading different books when I have time.Reasoning and history books are in the majority.Although my courses and student work occupy most of my spare time,I still have read more than 20 high-quality books.I aim at reading 50 books at least before I graduate.My choice of book is published book, and it is classic or best seller one. Always like you to recommend books to me Good-books effect on people's thinking is profound; similarly, the book is full of dross, is devastating to effect. comics Detective Conan Naruto that year the rabbit those things The way of being a man Do not do to others what you would not have them do to you. Adhere to the principle and sincere to people. Try to be the true nature disposition person. Just do IT! May the technology to change the life and enhance the quality, I'm willing to work with you to make progress. 最近访客 Recent visitors &gt;&gt;&gt; &lt;ul class=&quot;ds-recent-visitors&quot; data-num-items=&quot;50&quot; data-avatar-size=&quot;40&quot; &gt;&lt;/ul&gt;","raw":null,"content":null},{"title":"tags","date":"2016-02-28T08:03:58.000Z","updated":"2016-02-28T08:03:58.827Z","comments":true,"path":"tags/index.html","permalink":"http://hubojing.github.io/tags/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"","date":"2016-08-06T09:18:24.980Z","updated":"2016-08-06T09:18:24.980Z","comments":true,"path":"public/en/baidu_verify_Js45iacGIY.html","permalink":"http://hubojing.github.io/public/en/baidu_verify_Js45iacGIY.html","excerpt":"","text":"","raw":null,"content":null},{"title":"404 Not Found","date":"2016-08-06T09:18:25.020Z","updated":"2016-08-06T09:18:25.020Z","comments":false,"path":"/404.html","permalink":"http://hubojing.github.io//404.html","excerpt":"","text":"据说只有好看的人才能看到这个网页……\\ (≧▽≦) /~啦啦啦 那你就听听音乐吧~喵~ &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=450 src=&quot;http://music.163.com/outchain/player?type=0&amp;id=115991087&amp;auto=1&amp;height=430&quot;&gt;&lt;/iframe&gt; &lt;style type=&quot;text/css&quot;&gt; .article-header { padding: 0; padding-top: 26px; border-left: none; text-align: center; } .article-header:hover { border-left: none; } .article-title { font-size: 2.1em; } strong a { color: #747474; } .article-meta { display: none; } .share { display: none; } .ds-meta { display: none; } .player { margin-left: -10px; } .sign { text-align: right; font-style: italic; } #page-visit { display: none; } .center { text-align: center; height: 2.5em; font-weight: bold; } .article-entry hr { margin: 0; } .pic { text-align: center; margin: 0; } .pic br { display: none; } #container .article-info-post.article-info { display: none; } #container .article .article-title { padding: 0; } &lt;/style&gt;","raw":null,"content":null},{"title":"","date":"2016-08-08T15:43:51.978Z","updated":"2016-08-08T15:43:51.978Z","comments":true,"path":"public/en/css/style.css","permalink":"http://hubojing.github.io/public/en/css/style.css","excerpt":"","text":"ol { list-style: decimal; padding-left: 20px; } ul { list-style: none; } input, button { margin: 0; padding: 0; } input::-moz-focus-inner, button::-moz-focus-inner { border: 0; padding: 0; } html { font-size: base-font-size; } body { font-family: font-sans, font-chs, sans-serif; background: #fff; text-rendering: optimizeLegibility; -moz-osx-font-smoothing: grayscale; -moz-font-feature-settings: \"liga\" on; color: #333; -webkit-overflow-scrolling: touch; } ::selection { background: rgba(147,181,224,0.6); color: #fff; } h2, h3, h4, h5, h6 { font-family: font-serif, serif; font-weight: bold; } h1, h2, h3 { display: block; } h1 { font-size: 1.6rem; font-family: \"Segoe UI\", font-sans, font-chs, sans-serif; } h2 { font-size: 1.4rem; } h3 { font-size: 1.15rem; } h4, h5, h6 { font-size: 1rem; } a { text-decoration: none; outline-width: 0; color: #258fb8; outline: none; } .alignleft { float: left; } .alignright { float: right; } .clearfix { *zoom: 1; } .clearfix:after { content: \"\"; display: table; clear: both; } .inner { width: 1000px; margin: 0 auto; } .hide { display: none; } @media screen and (max-width: 1040px) { .inner { width: 100%; } }","raw":null,"content":null},{"title":"为中华之崛起而读书","date":"2016-02-28T07:59:38.000Z","updated":"2016-08-06T09:18:25.025Z","comments":true,"path":"public/en/about/index.html","permalink":"http://hubojing.github.io/public/en/about/index.html","excerpt":"","text":"&lt;embed wmode=&quot;transparent&quot; src=&quot;http://files2.17173.com/__flash/2011/10/21/honehone_clock_tr.swf&quot; quality=&quot;high&quot; bgcolor=&quot;#ffffff&quot; width=&quot;800&quot; height=&quot;300&quot; name=&quot;honehoneclock&quot; align=&quot;middle&quot; allowscriptaccess=&quot;always&quot; type=&quot;application/x-shockwave-flash&quot; pluginspage=&quot;http://www.macromedia.com/go/getflashplayer&quot;&gt; 什么技术都想学！年轻·折腾折腾无限可能！ Want to learn everything well,and they are infinite possibilities for youngsters. 关于我 About me 一个喜欢互联网的13级通信工程专业女生。 一直对IT有无限向往，对科技宅无比敬佩，立志成为一名有为的科技工作者。我虽不才，愿努力成才。 科学技术是第一生产力！科技作用是巨大的，通过它，我们的生活更好，我们的国家更好，世界更好！ 敬畏科技，敬畏生命！ a junior girl likes internet and major in communication engineering. there is an infinite yearning for IT since I was a little child,also,I adore of science and technology researchers.So,I am determined to be a promising science and technology worker.I'm not talented,but I'm willing to work hard. Science and technology are the first productive forces!The role of science and technology attachs great importance in the society, via which, our life better, our country better, the world better! Reverence for science and technology, and reverence for life! 关于本博客 About blog 一个小白的学习历程。有时候是笔记，有时候是想法，有时候是细枝末节的记录。 希望在不停的撰写中，提升自己的技术水平，也记录一段青春的奋斗之路。 a tyro's learning process.Sometimes it is notes,somestimes ideas,others detail records. I hope to improve my skills through my writing,and it is also a reflect of my youth. 主操作系统 Main operating system win 10 文本编辑器 Text editor Sublime 2 榜样&amp;偶像 Role model and idol 钱学森 Hsue-shen Tsien 所学技术 What has learned 通信工程科班所学课程、PS基础、Flash基础、音视频剪辑基础、PPT动画制作 My major courses,PS basics,Flash basics,Audio and video clip basics,PPT animation basics 了解：HTML、JAVA基础、CSS基础、数据库基础、嵌入式系统 Self-study:HTML,JAVA basics,CSS basics,sql,linux 语言language：C、JAVA、MARKDOWN 兴趣爱好 Hobby 计算机爱好者 从小热爱高科技，对IT充满兴趣。至今组装过两台电脑，维修过几部手机。对电脑操作有比较多的了解，学习过PS、Flash、音视频剪辑、PPT动画制作等具体软件应用。现在为了优化博客，正在学习前端知识。 COMPUTER LOVER I love high-tech,and interested in it.Two computers has been assembled,and several mobile phones has been repaired.Be familiar with computer operations,and know some about Photoshop,Flash,audio or video clips,and Powerpoint animation.For optimizing the blog,I'm learning Front-end Now. 纯音乐爱好者 最爱石进《夜的钢琴曲》系列。欢迎交流。点击进入我的网易云音乐 （PC端） ABSOLUTE MUSIC LOVER love &quot;Piano music of the night&quot; best.Welcome to communicate with me.Click to see my NetEase cloud music （PC client） &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=450 src=&quot;http://music.163.com/outchain/player?type=0&amp;id=146049436&amp;auto=1&amp;height=430&quot;&gt;&lt;/iframe&gt; 希望不久的将来能靠自己的力量买到一台三角钢琴。吉他学习者。 I wish I can rely on myself to buy a tripod piano in the near future.Guitar is in the learning. 运动爱好者 擅长羽毛球、乒乓球，热爱篮球、排球、游泳、瑜伽、舞蹈、武术。轮滑学习中。每天40分钟锻炼身体，调剂心情。曾学过6年舞蹈，也曾教授过班级一套武术拳法并在汇演时进行演出。 SPORTS LOVER I'm good at badminton,table tennis,fond of basketball,volleyball,swim,yoga,dance,the martial art,and skidding of the wheel.Exercise 40 minutes a day to keep health and adjust the mood.I Had learned 6 years of dance, also taught my class of the martial arts and performed in the show. 游戏体验者 不排斥游戏。有不少好游戏，能很好的锻炼反应能力和设计能力。曾对各大网游和单机游戏都有体验，但绝不沉迷。 GAME PERSON Not reject the game.Because many good games can practice reaction and design ability.I have played all kinds of online games or stand-alone game,but I never indulge in the games. 文学、写作、历史爱好者 喜欢优美的文字、清新的文章和诗词。欢迎推荐相关纪录片和书籍。从2007年开始写博客。之前用新浪博客，点击数过万计。 LITERATURE,WRITING,HISTORY LOVER Love beautiful words, grace articles and poems. Welcome to recommend related documentaries and books.I start using blog from 2007,and I write blog on Sina before,which Click over ten thousand.In the 22th,32th international Chucai Writing Competetion I won the first prize (ten years later see you again.) 读书追赶者 深知自己的阅读量远远不够。自从上了大学自主时间多了之后，便特别爱看书，其中推理和历史书籍居多。工科课程和学生事务占据了我大部分时间，但仍阅读了20多本优质好书。希望在大学毕业前，我能看够50本。我对书的选择是，出版书籍，并且是经典的或者优质畅销好书。 READING CHASER I understand deeply that my reading is far from enough,so I like reading different books when I have time.Reasoning and history books are in the majority.Although my courses and student work occupy most of my spare time,I still have read more than 20 high-quality books.I aim at reading 50 books at least before I graduate.My choice of book is published book, and it is classic or best seller one. 欢迎荐书 Always like you to recommend books to me 好书对人的思想的影响是深远的；同样地，满是糟粕的书，带给人的影响是毁灭性的。 Good-books effect on people's thinking is profound; similarly, the book is full of dross, is devastating to effect. 两部动漫 Two comics 名侦探柯南 Detective Conan 火影忍者 Naruto 偏偏喜欢两部特别长的动漫…… These two have so many sets of animation…… 同时，强推《那年那兔那些事儿》！ Strong recommend &quot;that year the rabbit those things&quot;! 为人之道 The way of being a man 己所不欲，勿施于人。 Do not do to others what you would not have them do to you. 坚守原则，对人真诚。Adhere to the principle and sincere to people. 努力成为真性情的人。Try to be the true nature disposition person. 通讯 Communication QQ：417797456 邮箱Email：417797456@qq.com github:hubojing Just do IT! 愿技术改变生活，技术提升品质。愿与大家共同进步。 May the technology to change the life and enhance the quality, I'm willing to work with you to make progress. 最近访客 Recent visitors &gt;&gt;&gt; &lt;ul class=&quot;ds-recent-visitors&quot; data-num-items=&quot;70&quot; data-avatar-size=&quot;40&quot;&gt;&lt;/ul&gt;","raw":null,"content":null},{"title":"","date":"2016-08-06T09:18:25.135Z","updated":"2016-08-06T09:18:25.135Z","comments":true,"path":"public/en/js/GithubRepoWidget.js","permalink":"http://hubojing.github.io/public/en/js/GithubRepoWidget.js","excerpt":"","text":"/*! GitHub-Repo-Widget.js - Not depend on jQuery or Other Framework. License: MIT */ (function() { var rendered = 'github-widget-rendered', cssStr = '.path-divider{margin:0 .25em}.github-box *{-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;}.github-box{font-family:helvetica,arial,sans-serif;font-size:13px;line-height:18px;background:#fafafa;border:1px solid #ddd;color:#666;border-radius:3px}.github-box a{color:#4183c4;border:0;text-decoration:none}.github-box .github-box-title{position:relative;border-bottom:1px solid #ddd;border-radius:3px 3px 0 0;background:#fcfcfc;background:-moz-linear-gradient(#fcfcfc,#ebebeb);background:-webkit-linear-gradient(#fcfcfc,#ebebeb);}.github-box .github-box-title h3{word-wrap:break-word;font-family:helvetica,arial,sans-serif;font-weight:normal;font-size:16px;color:gray;margin:0;padding:10px 10px 10px 30px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAXBAMAAAD0LQLXAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAASUExURQAAAL29vc3NzcLCwsjIyNbW1pvTNOEAAAABdFJOUwBA5thmAAAATElEQVQI12MIFoQAEQZFYwcGEGBkUDRUQLCcsYjRXhbqKkEGZQYGqJgSnKXCwGgsAGYpqyobG4WGhioyhBhDgClI3EQAqpaZwQBEAQARmA4G2o55nQAAAABJRU5ErkJggg==) 7px center no-repeat; width: auto;}.github-box .github-box-title h3 .repo{font-weight:bold}.github-box .github-box-title .github-stats{float:right;position:absolute;top:8px;right:10px;font-size:11px;font-weight:bold;line-height:21px;height:auto;min-height:21px}.github-box .github-box-title .github-stats a{display:inline-block;height:21px;color:#666;border:1px solid #ddd;border-radius:3px;padding:0 5px 0 18px;background: white url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAqBAMAAABB12bjAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAYUExURf///5mZmdbW1u/v7/r6+rGxscXFxaSkpHLccIMAAABsSURBVBjTY2CgBmBODTOAsFgSi9TFHMBMc1Fmk8BiEItJUMhQWFFQAZXJoC7q7FJYhNBmgG7YQAIWMYTvEExXIbh8oAJWQQe4IGsIlKmowAZVwaKowgxlMgkKmwtCjRAUYBSEqnVkYBAm39EALMwNXwql3eYAAAAASUVORK5CYII=) no-repeat}.github-box .github-box-title .github-stats .watchers{border-right:1px solid #ddd}.github-box .github-box-title .github-stats .forks{background-position:-4px -21px;padding-left:15px}.github-box .github-box-content{padding:10px;font-weight:300}.github-box .github-box-content p{margin:0}.github-box .github-box-content .link{font-weight:bold}.github-box .github-box-download{position:relative;border-top:1px solid #ddd;background:white;border-radius:0 0 3px 3px;padding:10px;height:auto;min-height:24px;}.github-box .github-box-download .updated{word-wrap:break-word;margin:0;font-size:11px;color:#666;line-height:24px;font-weight:300;width:auto}.github-box .github-box-download .updated strong{font-weight:bold;color:#000}.github-box .github-box-download .download{float:right;position:absolute;top:10px;right:10px;height:24px;line-height:24px;font-size:12px;color:#666;font-weight:bold;text-shadow:0 1px 0 rgba(255,255,255,0.9);padding:0 10px;border:1px solid #ddd;border-bottom-color:#bbb;border-radius:3px;background:#f5f5f5;background:-moz-linear-gradient(#f5f5f5,#e5e5e5);background:-webkit-linear-gradient(#f5f5f5,#e5e5e5);}.github-box .github-box-download .download:hover{color:#527894;border-color:#cfe3ed;border-bottom-color:#9fc7db;background:#f1f7fa;background:-moz-linear-gradient(#f1f7fa,#dbeaf1);background:-webkit-linear-gradient(#f1f7fa,#dbeaf1);}@media (max-width: 767px) {.github-box .github-box-title{height:auto;min-height:60px}.github-box .github-box-title h3 .repo{display:block}.github-box .github-box-title .github-stats a{display:block;clear:right;float:right;}.github-box .github-box-download{height:auto;min-height:46px;}.github-box .github-box-download .download{top:32px;}}'; function _getAttribute(node, name, defaultValue) { return node.getAttribute(name) || defaultValue; } function _querySelector(dom, sel) { return dom.querySelector(sel); } function _setHtml(dom, h) { dom.innerHTML = h; } function _appendCss() { var x = document.createElement('div'); x.innerHTML = 'x'+cssStr+''; document.getElementsByTagName('head')[0].appendChild(x.lastChild); } function _renderGitHubWidget(repoEle, repo) { repo = JSON.parse(repo); _setHtml(_querySelector(repoEle, '.watchers'), repo.watchers); _setHtml(_querySelector(repoEle, '.forks'), repo.forks); _setHtml(_querySelector(repoEle, '.description span'), repo.description); _setHtml(_querySelector(repoEle, '.updated'), 'Latest commit to the ' + repo.default_branch+ ' branch on ' + repo.pushed_at.substring(0, 10) + ''); if(repo.homepage !== null) { _setHtml(_querySelector(repoEle, '.link'), ''+ repo.homepage +''); } repoEle.setAttribute(rendered, '1'); } function _ajaxReq(repoEle, repo) { var xmlhttp; if (window.XMLHttpRequest) { //code for IE7,firefox chrome and above xmlhttp = new XMLHttpRequest(); } else { //code for Internet Explorer xmlhttp = new ActiveXObject('Microsoft.XMLHTTP'); } xmlhttp.onreadystatechange = function() { if (xmlhttp.readyState == 4 && xmlhttp.status == 200) { _renderGitHubWidget(repoEle, xmlhttp.responseText); } else { } }; xmlhttp.open('GET', 'https://api.github.com/repos/' + repo, true); xmlhttp.send(); } function _init() { var github_eles = document.querySelectorAll('.github-widget'), repoEle, repo, vendorName, repoName, vendorUrl, repoUrl, widget; for (var i = 0; i '+ ''+ ''+ '' + vendorName + ''+ '/'+ '' + repoName + ''+ ''+ ''+ 'Star '+ '?'+ ' Fork '+ '?'+ ''+ ''+ ''+ ' &mdash; Read More'+ ''+ ''+ ''+ ''+ 'Download as zip'+ ''+ ''; _setHtml(repoEle, widget); _ajaxReq(repoEle, repo); } } } _appendCss(); _init(); window.GithubRepoWidget = { init: _init }; })();","raw":null,"content":null},{"title":"","date":"2016-08-06T09:18:25.181Z","updated":"2016-08-06T09:18:25.181Z","comments":true,"path":"public/en/js/instagram.js","permalink":"http://hubojing.github.io/public/en/js/instagram.js","excerpt":"","text":"var Instagram = (function(){ var _collection = []; var preLoad = function(data){ for(var em in data){ for(var i=0,len=data[em].srclist.length;i\\ \\ \\ \\ \\ '; } $(''+data[em].year+''+data[em].month+'月\\ '+liTmpl+'\\ ').appendTo($(\".instagram\")); } $(\".instagram\").lazyload(); changeSize(); setTimeout(function(){ preLoad(data); },3000); $(\"a[rel=example_group]\").fancybox(); } var replacer = function(str){ if(str.indexOf(\"outbound-distilleryimage\") >= 0 ){ var cdnNum = str.match(/outbound-distilleryimage([\\s\\S]*?)\\//)[1]; var arr = str.split(\"/\"); return \"http://distilleryimage\"+cdnNum+\".ak.instagram.com/\"+arr[arr.length-1]; }else{ var url = \"http://photos-g.ak.instagram.com/hphotos-ak-xpf1/\"; var arr = str.split(\"/\"); return url+arr[arr.length-1]; } } var ctrler = function(data){ var imgObj = {}; for(var i=0,len=data.length;i","raw":null,"content":null},{"title":"","date":"2016-08-06T09:18:25.138Z","updated":"2016-08-06T09:18:25.138Z","comments":true,"path":"public/en/js/mobile.js","permalink":"http://hubojing.github.io/public/en/js/mobile.js","excerpt":"","text":"define([], function(){ var _isShow = false; var $tag, $aboutme, $friends; var ctn,radio,scaleW,idx,basicwrap; //第一步 -- 初始化 var reset = function() { //设定窗口比率 radio = document.body.scrollHeight/document.body.scrollWidth; //设定一页的宽度 scaleW = document.body.scrollWidth; //设定初始的索引值 idx = 0; }; //第一步 -- 组合 var combine = function(){ if($tag){ document.getElementById(\"js-mobile-tagcloud\").innerHTML = $tag.innerHTML; } if($aboutme){ document.getElementById(\"js-mobile-aboutme\").innerHTML = $aboutme.innerHTML; } if($friends){ document.getElementById(\"js-mobile-friends\").innerHTML = $friends.innerHTML; } } //第三步 -- 根据数据渲染DOM var renderDOM = function(){ //生成节点 var $viewer = document.createElement(\"div\"); $viewer.id = \"viewer\"; $viewer.className = \"hide\"; $tag = document.getElementById(\"js-tagcloud\"); $aboutme = document.getElementById(\"js-aboutme\"); $friends = document.getElementById(\"js-friends\"); function menuList(name) { return $(\"link.menu-list\").attr(name); }; var tagStr = $tag?''+ menuList(\"tags\") + '':\"\"; var friendsStr = $friends?''+ menuList(\"friends\") + '':\"\"; var aboutmeStr = $aboutme?''+ menuList(\"about\") + '':\"\"; $viewer.innerHTML = '\\ \\ '+aboutmeStr+friendsStr+tagStr+'\\ \\ \\ '; //主要图片节点 document.getElementsByTagName(\"body\")[0].appendChild($viewer); var wrap = document.getElementById(\"viewer-box\"); basicwrap = wrap; wrap.style.height = document.body.scrollHeight + 'px'; }; var show = function(target, idx){ document.getElementById(\"viewer\").className = \"\"; setTimeout(function(){ basicwrap.className = \"anm-swipe\"; },0); _isShow = true; document.ontouchstart=function(e){ if(e.target.tagName != \"A\"){ return false; } } } var hide = function(){ document.getElementById(\"viewer-box\").className = \"\"; _isShow = false; document.ontouchstart=function(){ return true; } } //第四步 -- 绑定 DOM 事件 var bindDOM = function(){ var scaleW = scaleW; //滑动隐藏 document.getElementById(\"viewer-box\").addEventListener(\"webkitTransitionEnd\", function(){ if(_isShow == false){ document.getElementById(\"viewer\").className = \"hide\"; _isShow = true; }else{ } }, false); //点击展示和隐藏 ctn.addEventListener(\"touchend\", function(){ show(); }, false); var $right = document.getElementsByClassName(\"viewer-box-r\")[0]; var touchStartTime; var touchEndTime; $right.addEventListener(\"touchstart\", function(){ touchStartTime = + new Date(); }, false); $right.addEventListener(\"touchend\", function(){ touchEndTime = + new Date(); if(touchEndTime - touchStartTime = 69){ $overlay.addClass(\"fixed\"); }else{ $overlay.removeClass(\"fixed\"); } if(scrollTop >= 160){ $header.removeClass(\"hide\").addClass(\"fixed\"); }else{ $header.addClass(\"hide\").removeClass(\"fixed\"); } }; $header[0].addEventListener(\"touchstart\", function(){ $('html, body').animate({scrollTop:0}, 'slow'); }, false); }; return{ init: function(){ //构造函数需要的参数 ctn = document.getElementsByClassName(\"slider-trigger\")[0]; //构造四步 reset(); renderDOM(); combine(); bindDOM(); resetTags(); } } })","raw":null,"content":null},{"title":"","date":"2016-08-06T09:18:25.114Z","updated":"2016-08-06T09:18:25.114Z","comments":true,"path":"public/en/js/main.js","permalink":"http://hubojing.github.io/public/en/js/main.js","excerpt":"","text":"require([], function (){ var isMobileInit = false; var loadMobile = function(){ require([yiliaConfig.rootUrl + 'js/mobile.js'], function(mobile){ mobile.init(); isMobileInit = true; }) } var isPCInit = false; var loadPC = function(){ require([yiliaConfig.rootUrl + 'js/pc.js'], function(pc){ pc.init(); isPCInit = true; }) } var browser = { versions: function() { var u = window.navigator.userAgent; return { trident: u.indexOf('Trident') > -1, //IE内核 presto: u.indexOf('Presto') > -1, //opera内核 webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核 gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端 ios: !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器 iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器 iPad: u.indexOf('iPad') > -1, //是否为iPad webApp: u.indexOf('Safari') == -1 ,//是否为web应用程序，没有头部与底部 weixin: u.indexOf('MicroMessenger') == -1 //是否为微信浏览器 }; }() } $(window).bind(\"resize\", function() { if (isMobileInit && isPCInit) { $(window).unbind(\"resize\"); return; } var w = $(window).width(); if (w >= 700) { loadPC(); } else { loadMobile(); } }); if(!!browser.versions.mobile || $(window).width() \"); } $(\".article-inner .fancy-ctn\").fancybox({ type: \"image\" }); } }) } // Animate on Homepage if(!!yiliaConfig.animate) { if(!!yiliaConfig.isHome) { require([yiliaConfig.scrollreveal], function (ScrollReveal) { var animationNames = [ \"pulse\", \"fadeIn\",\"fadeInRight\", \"flipInX\", \"lightSpeedIn\",\"rotateInUpLeft\", \"slideInUp\",\"zoomIn\", ], len = animationNames.length, randomAnimationName = animationNames[Math.ceil(Math.random() * len) - 1]; // Fallback (CSS3 keyframe, requestAnimationFrame) if (!window.requestAnimationFrame) { $('.body-wrap > article').css({opacity: 1}); if (navigator.userAgent.match(/Safari/i)) { function showArticle(){ $(\".article\").each(function(){ if( $(this).offset().top article\" ;=\"\" $firstarticle=\"$(\" .body-wrap\"=\"\"> article:first-child\"); if ($firstArticle.height() > $(window).height()) { var animateScope = \".body-wrap > article:not(:first-child)\"; $firstArticle.css({opacity: 1}); } ScrollReveal({ duration: 0, afterReveal: function (domEl) { $(domEl).addClass('animated ' + randomAnimationName).css({opacity: 1}) } }).reveal(animateScope); }) } else { $('.body-wrap > article').css({opacity: 1}); } } // TOC if (yiliaConfig.toc) { require(['toc'], function(){ }) } // Random Color 边栏顶部随机颜色 var colorList = [\"#6da336\", \"#ff945c\", \"#66CC66\", \"#99CC99\", \"#CC6666\", \"#76becc\", \"#c99979\", \"#918597\", \"#4d4d4d\"]; var id = Math.ceil(Math.random()*(colorList.length-1)); // PC $(\"#container .left-col .overlay\").css({\"background-color\": colorList[id],\"opacity\": .3}); // Mobile $(\"#container #mobile-nav .overlay\").css({\"background-color\": colorList[id],\"opacity\": .7}); // Table $(\"table\").wrap(\"\"); // Hide Comment Button $(document).ready(function() { if ($(\"#comments\").length a:nth-child(2)\").hide(); } }) // Hide Labels if(yiliaConfig.isArchive || yiliaConfig.isTag || yiliaConfig.isCategory) { $(document).ready(function() { $(\"#footer\").after(\"TAGS\"); $(\".hide-labels\").click(function() { $(\".article-info\").toggle(200); }) }) } // Task lists in markdown $('ul > li').each(function() { var taskList = { field: this.textContent.substring(0, 2), check: function(str) { var re = new RegExp(str); return this.field.match(re); } } var string = [\"[ ]\", [\"[x]\", \"checked\"]]; var checked = taskList.check(string[1][0]); var unchecked = taskList.check(string[0]); var $current = $(this); function update(str, check) { var click = [\"disabled\", \"\"]; $current.html($current.html().replace( str, \"\") ) } if (checked || unchecked) { this.classList.add(\"task-list\"); if (checked) { update(string[1][0], string[1][1]); this.classList.add(\"check\"); } else { update(string[0], \"\"); } } }) })","raw":null,"content":null},{"title":"","date":"2016-08-06T09:18:25.129Z","updated":"2016-08-06T09:18:25.129Z","comments":true,"path":"public/en/js/pc.js","permalink":"http://hubojing.github.io/public/en/js/pc.js","excerpt":"","text":"define([], function(){ var Tips = (function(){ var $tipBox = $(\".tips-box\"); return { show: function(){ $tipBox.removeClass(\"hide\"); }, hide: function(){ $tipBox.addClass(\"hide\"); }, init: function(){ } } })(); var slide = function(idx){ // 修复IE10+切换无效的bug var $wrap = $(\".switch-wrap\"), transform = [ '-webkit-transform: translate(-' + idx * 100 + '%, 0);', '-moz-transform: translate(-' + idx * 100 + '%, 0);', '-o-transform: translate(-' + idx * 100 + '%, 0);', '-ms-transform: translate(-' + idx * 100 + '%, 0);', 'transform: translate(-' + idx * 100 + '%, 0);' ]; $wrap[0].style.cssText = transform.join(''); $(\".icon-wrap\").addClass(\"hide\"); $(\".icon-wrap\").eq(idx).removeClass(\"hide\"); } var bind = function(){ var switchBtn = $(\"#myonoffswitch\"); var tagcloud = $(\".second-part\"); var navDiv = $(\".first-part\"); switchBtn.click(function(){ if(switchBtn.hasClass(\"clicked\")){ switchBtn.removeClass(\"clicked\"); tagcloud.removeClass(\"turn-left\"); navDiv.removeClass(\"turn-left\"); }else{ switchBtn.addClass(\"clicked\"); tagcloud.addClass(\"turn-left\"); navDiv.addClass(\"turn-left\"); resetTags(); } }); var timeout; var isEnterBtn = false; var isEnterTips = false; $(\".icon\").bind(\"mouseenter\", function(){ isEnterBtn = true; Tips.show(); }).bind(\"mouseleave\", function(){ isEnterBtn = false; setTimeout(function(){ if(!isEnterTips){ Tips.hide(); } }, 100); }); $(\".tips-box\").bind(\"mouseenter\", function(){ isEnterTips = true; Tips.show(); }).bind(\"mouseleave\", function(){ isEnterTips = false; setTimeout(function(){ if(!isEnterBtn){ Tips.hide(); } }, 100); }); $(\".tips-inner li\").bind(\"click\", function(){ var idx = $(this).index(); slide(idx); Tips.hide(); }); } var miniArchives = function(){ if(yiliaConfig.isPost) { $(\".post-list\").addClass(\"toc-article\"); $(\"#post-nav-button > a:nth-child(2)\").click(function() { $(\"#post-nav-button .fa-bars,#post-nav-button .fa-times\").toggle(); $(\".post-list\").toggle(300); if ($(\".toc\").length > 0) { $(\"#toc, #tocButton\").toggle(200, function() { if ($(\".switch-area\").is(\":visible\")) { $(\"#toc, .switch-btn, .switch-area\").toggle(); $(\"#tocButton\").attr(\"value\", yiliaConfig.toc[0]); } }); } else { $(\".switch-btn, .switch-area\").fadeToggle(300); } }); } }() if (yiliaConfig.jquery_ui[0]) { var tooltip = function(){ require([yiliaConfig.jquery_ui[1]], function(){ var loadCSS = function (url, num) { var link = document.createElement(\"link\"); link.rel = \"stylesheet\"; link.href = url; var head = document.querySelector(\"head\"); head.insertBefore(link, head.childNodes[num]); } loadCSS(yiliaConfig.jquery_ui[2], 25); if (!$().tooltip) return; if (navigator.userAgent.match(/(iPhone|iPad|Android|ios|PlayBook|Touch)/i)) return; $(\"[title]\").tooltip({ show: { effect: 'blind', delay: 250, duration: 55, } }) $(\"#scroll\").tooltip({ show: { effect: 'clip', delay: 600, duration: 50, } }) $(\"#tocButton, #comments\").tooltip({ show: { delay: 1200, } }) $(\".ds-replybox form\").off(\"tooltip\") $(\"#post-nav-button\").tooltip({ show: { effect: 'clip', delay: 280, duration: 65, } }) $(\"#post-nav-button > a:nth-child(2)\").tooltip({ show: { delay: 1500, } }) $(\".social\").tooltip({ show: { effect: 'scale', delay: 350, duration: 70, } }) }) }() } if (yiliaConfig.search) { var search = function(){ require([yiliaConfig.rootUrl + 'js/search.js'], function(){ var inputArea = document.querySelector(\"#local-search-input\"); var $HideWhenSearch = $(\"#toc, #tocButton, .post-list, #post-nav-button a:nth-child(2)\"); var $resetButton = $(\"#search-form .fa-times\"); var $resultArea = $(\"#local-search-result\"); var getSearchFile = function(){ var search_path = \"search.xml\"; var path = yiliaConfig.rootUrl + search_path; searchFunc(path, 'local-search-input', 'local-search-result'); } var getFileOnload = inputArea.getAttribute('searchonload'); if (yiliaConfig.search && getFileOnload === \"true\") { getSearchFile(); } else { inputArea.onfocus = function(){ getSearchFile() } } var HideTocArea = function(){ $HideWhenSearch.css(\"visibility\",\"hidden\"); $resetButton.show(); } inputArea.oninput = function(){ HideTocArea() } inputArea.onkeydown = function(){ if(event.keyCode==13) return false} resetSearch = function(){ $HideWhenSearch.css(\"visibility\",\"initial\"); $resultArea.html(\"\"); document.querySelector(\"#search-form\").reset(); $resetButton.hide(); $(\".no-result\").hide(); } $resultArea.bind(\"DOMNodeRemoved DOMNodeInserted\", function(e) { if (!$(e.target).text()) { $(\".no-result\").show(200); } else { $(\".no-result\").hide(); } }) }) }() } return { init: function(){ resetTags(); bind(); Tips.init(); } } });","raw":null,"content":null},{"title":"","date":"2016-08-06T09:18:25.149Z","updated":"2016-08-06T09:18:25.149Z","comments":true,"path":"public/en/js/search.js","permalink":"http://hubojing.github.io/public/en/js/search.js","excerpt":"","text":"// A local search script with the help of [hexo-generator-search](https://github.com/PaicHyperionDev/hexo-generator-search) // Copyright (C) 2015 // Joseph Pan // Shuhao Mao // Edited by MOxFIVE var searchFunc = function(path, search_id, content_id) { 'use strict'; $.ajax({ url: path, dataType: \"xml\", success: function( xmlResponse ) { // get the contents from search data var datas = $( \"entry\", xmlResponse ).map(function() { return { title: $( \"title\", this ).text(), content: $(\"content\",this).text(), url: $( \"url\" , this).text() }; }).get(); var $input = document.getElementById(search_id); var $resultContent = document.getElementById(content_id); $input.addEventListener('input', function(){ var str=''; var keywords = this.value.trim().toLowerCase().split(/[\\s\\-]+/); $resultContent.innerHTML = \"\"; if (this.value.trim().length ]+>/g,\"\").toLowerCase(); var data_url = data.url; var index_title = -1; var index_content = -1; var first_occur = -1; // only match artiles with not empty titles and contents if(data_title != '' && data_content != '') { keywords.forEach(function(keyword, i) { index_title = data_title.indexOf(keyword); index_content = data_content.indexOf(keyword); if( index_title \"+ \"> \" + data_title +\"\"; var content = data.content.trim().replace(/]+>/g,\"\"); if (first_occur >= 0) { // cut out characters var start = first_occur - 6; var end = first_occur + 6; if(start content.length){ end = content.length; } var match_content = content.substr(start, end); // highlight all keywords keywords.forEach(function(keyword){ var regS = new RegExp(keyword, \"gi\"); match_content = match_content.replace(regS, \"\"+keyword+\"\"); }); str += \"\" + match_content +\"...\" } } }); $resultContent.innerHTML = str; }); } }); }","raw":null,"content":null},{"title":"","date":"2016-08-06T09:18:25.156Z","updated":"2016-08-06T09:18:25.156Z","comments":true,"path":"public/en/js/toc.js","permalink":"http://hubojing.github.io/public/en/js/toc.js","excerpt":"","text":"define(function (){ var toggleTocArea = function(){ var valueHide = yiliaConfig.toc[0]; var valueShow = yiliaConfig.toc[1]; if ($(\".left-col\").is(\":hidden\")) { $(\"#tocButton\").attr(\"value\", valueShow); } $(\"#tocButton\").click(function() { if ($(\"#toc\").is(\":hidden\")) { $(\"#tocButton\").attr(\"value\", valueHide); $(\"#toc\").slideDown(320); $(\".switch-btn, .switch-area\").fadeOut(300); } else { $(\"#tocButton\").attr(\"value\", valueShow); $(\"#toc\").slideUp(350); $(\".switch-btn, .switch-area\").fadeIn(500); } }) }() var HideTOCifNoHeader = function(){ if (!$(\".toc\").length) { $(\"#toc, #tocButton\").hide(); $(\".switch-btn, .switch-area\").show(); } }() var $itemHasChild = $(\"#toc .toc-item:has(> .toc-child)\"); var $titleHasChild = $itemHasChild.children(\".toc-link\"); $itemHasChild.prepend(\"\"); var clickIcon = function(){ $(\"#toc .toc-item > i\").click(function(){ $(this).siblings(\".toc-child\").slideToggle(100); $(this).toggleClass(\"hide\"); $(this).siblings(\"i\").toggleClass(\"hide\"); }) }() var clickTitle = function(){ $titleHasChild.dblclick(function(){ $(this).siblings(\".toc-child\").hide(100); $(this).siblings(\"i\").toggleClass(\"hide\"); }) // After dblclick enent $titleHasChild.click(function(){ var $curentTocChild = $(this).siblings(\".toc-child\"); if ($curentTocChild.is(\":hidden\")) { $curentTocChild.show(100); $(this).siblings(\"i\").toggleClass(\"hide\"); } }) }() var clickTocTitle = function(){ var $iconToExpand = $(\".toc-item > .fa-caret-right\"); var $iconToFold = $(\".toc-item > .fa-caret-down\"); var $subToc = $titleHasChild.next(\".toc-child\"); $iconToExpand.addClass(\"hide\"); var $tocTitle = $(\"#toc .toc-title\"); if ($titleHasChild.length) { $tocTitle.addClass(\"clickable\"); $tocTitle.click(function(){ if ($subToc.is(\":hidden\")) { $subToc.show(150); $iconToExpand.removeClass(\"hide\"); $iconToFold.addClass(\"hide\"); } else { $subToc.hide(100); $iconToExpand.addClass(\"hide\"); $iconToFold.removeClass(\"hide\"); } }) // TOC on mobile if ($(\".left-col\").is(\":hidden\")) { $(\"#container .toc-article .toc\").css(\"padding-left\", \"1.4em\"); $(\"#container .toc-article .toc-title\").css(\"display\", \"initial\"); } } }() var TocNoWarp = function(cond){ if (cond) { var $tocLink = $(\".toc li a\"); $tocLink.each(function(){ var title = $(this).find('.toc-text').text(); // Find elements with ellipsis if (this.offsetWidth < this.scrollWidth) { $(this).attr(\"title\", title); if (!!$().tooltip) { $(this).tooltip() } } }) var isSafari = !!navigator.userAgent.match(/Version\\/[\\d\\.]+.*Safari/); if (isSafari) { $(\"#toc .toc-item i\").css(\"bottom\", \".1em\"); } } } TocNoWarp(yiliaConfig.toc[2]); })","raw":null,"content":null},{"title":"tags","date":"2016-02-28T08:03:58.000Z","updated":"2016-08-06T09:18:25.018Z","comments":true,"path":"public/en/tags/index.html","permalink":"http://hubojing.github.io/public/en/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"折腾才是人生","slug":"折腾才是人生","date":"2017-04-20T16:02:54.000Z","updated":"2017-04-20T16:35:27.230Z","comments":true,"path":"2017/04/21/折腾才是人生/","link":"","permalink":"http://hubojing.github.io/2017/04/21/折腾才是人生/","excerpt":"","text":"&lt;div align=&quot;left&quot;&gt; &lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1492716014892&amp;di=39eb7cb27e728bbbea6be20b6d2501c8&amp;imgtype=0&amp;src=http%3A%2F%2Fjrsh.hangzhou.com.cn%2Fsale%2Fcontent%2Fattachement%2Fjpg%2Fsite2%2F20151215%2F90b11c6dae5a17da23d850.jpg&quot; width=&quot;300&quot; height=&quot;180&quot; style=&quot;float:right;&quot;/&gt; 其实是一篇吐槽贴和一个标准的Flag。 &lt;/div&gt; &lt;!--more--&gt; 虽然现在天色已深，哦，应该说是凌晨了，明天还要早起。但！我真的还是想吐槽…… 一篇文章怎么可以没有目录？ 啊？啊？啊？ 要我一篇上万字的文章怎么翻…… （于是抛弃了yilia,hueman） （认真脸：我试过给hueman加目录的，一个toc函数，明明很简单的样子……然后就把主题玩崩了，其实要还原还是可以的，只是我对没目录的怨念很深呐） 为什么每一种主题评论的格式都不能统一一下……我终于找到每换一次主题就丢评论的解决方法了……（虽然数据量有点庞大，周末看有没有时间搞定） 为什么换个主题，不蒜子计数就从头开始！（尤其是近期更换频繁）现在都打算不显示点击数（网站点击和每篇文章浏览量）了（几千的点击噢，好气）……（百度统计什么的用过，然而还是直接显示出来方便（主要是显得网站有人气哈哈哈）其实到底有几个人看，无所谓啦~） 快五月了，好愁，多说到底用什么替换？？ 另外，真的，图床贴图还没有CSDN博客上图来得方便。（比如刚才上传三十几张图，要是图床的话自己要不停复制外链，那效率可想而知。） 综上所述， 这都是自己不会写主题的后果！！！ Flag: 现在不敢说完全独立写一个主题出来（主要是时间、精力、学习工作、学习方向的问题），毕竟博客以文章质量为主，但我希望今年能修改出自己满意的样子来…… &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"主题","slug":"主题","permalink":"http://hubojing.github.io/tags/主题/"}]},{"title":"MFC傻瓜式教程","slug":"MFC傻瓜式教程","date":"2017-04-13T14:26:01.000Z","updated":"2017-04-22T13:53:17.813Z","comments":true,"path":"2017/04/13/MFC傻瓜式教程/","link":"","permalink":"http://hubojing.github.io/2017/04/13/MFC傻瓜式教程/","excerpt":"","text":"&lt;div align=&quot;left&quot;&gt; &lt;img src=&quot;http://img.blog.csdn.net/20170413231922633?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVib2ppbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; width=&quot;300&quot; height=&quot;180&quot; style=&quot;float:right;&quot;/&gt; 很多技术书废话连篇。——公司某优秀工程师 （本教程重操作，轻理论，为操作减负。需了解详细原理的朋友可以自行看各种书籍。） 直接上菜。 &lt;/div&gt; &lt;!--more--&gt; MFC：Microsoft Foundation Class ，微软基础类库。 对话框 对话框的创建和显示 新建MFC AppWizard(exe)工程，单文档类型。工程名：Mybole。编译运行。 点击帮助-关于Mybole。这是MFC自动创建的。 创建自己的对话框。点击Insert-Resource。选择Dialog，点击New。VC++自动将其标识设置为IDD_DIALOG1，并自动添加到ResourceView-Dialog项中。Dialog项下还有一个对话框资源标识：IDD_ABOUTBOX，即上一步中的“关于”对话框。 选中对话框本身，右键点击属性。将Caption设置为“测试”。 选择View-ClassWizard，点击create a new class，OK。出现下图，并输入下图选项。 在随后出现的MFC ClassWizard对话框上点击OK。 注意：看看左侧类列表中是否添加好了CTestDlg，否则会影响后续操作。 接下来，我们希望在程序中显示这个对话窗口。 点击右侧菜单Menu，选中IDR_MAINFRAME。点击帮助旁边的虚线框。 对虚线框右键属性，修改为下图。 关闭属性。点击View-ClassWizard（中文是建立类向导），选择CMyboleView，用COMMAND命令消息响应函数。如图。 模态对话框的创建 需要调用CDialog类的成员函数：DoModal，它能创建并显示一个模态对话框，其返回值将作为CDialog类的另一个成员函数：EndDialog的参数，后者功能是关闭模态对话框。 在FileView中选择MyboleView.cpp，编写程序。 记得在开头添加头文件 #include “testdlg.h” （头文件大小写问题，linux区分，windows不区分） 显示模态对话框的具体实现代码： 123456void CMyboleView::OnDialog() &#123; // TODO: Add your command handler code here CTestDlg dlg; dlg.DoModal();&#125; 编译运行，点击对话框。会发现若不确认该窗口，将无法点击其他窗口。 非模态对话框的创建 将上面的模态对话框代码注释掉。 改为： 12345678910void CMyboleView::OnDialog() &#123; // TODO: Add your command handler code here //CTestDlg dlg; //dlg.DoModal(); CTestDlg *pDlg = new CTestDlg; pDlg-&gt;Create(IDD_DIALOG1,this); pDlg-&gt;ShowWindow(SW_SHOW);&#125; 注意：需要把之前运行的对话框关掉才能编译成功。 然而，当它生命周期结束时，所保存的内存地址就丢失了，那么程序中也就无法再引用到它所指向的那块内存。于是，我们这样解决该问题。 注意：Message里双击添加函数或者点击add Class… void CTestDlg::PostNcDestroy() { // TODO: Add your specialized code here and/or call the base class delete this; CDialog::PostNcDestroy(); } 区别：点击确定，对话框都会消失。但是，模态对话框窗口对象被销毁了。对非模态对话框来说，只是隐藏起来了，并未被销毁。 因此，若要销毁对话框，若有一个ID为IDOK的按钮，就必须重写基类的OnOK这个虚函数，并在重写的函数中调用DestroyWindow函数，完成销毁。并不要再调用基类的OnOK函数。 同样地，若有一个ID为IDCANCEL的按钮，也必须重写基类的OnCancel虚函数，并在重写的函数中调用DestroyWindow函数，完成销毁。并不要再调用基类的OnCancel函数。 动态创建按钮 注释掉非模态对话框代码，还原模态对话框代码。 点击ResourceView-IDD_DIALOG1，打开资源，用鼠标拖出控件面板上的Button按钮控件，对按钮右键，选择属性，设置如下。 接下来，我们实现当单击Add按钮时，在对话框中动态创建一个按钮这一功能。 为CTestDlg类添加一个私有的CButton成员变量。 点击ClassView标签页右键，如图点击。 填入信息。 添加Add按钮单击消息的响应函数。 按钮点右键，选ClassWizard（建立类向导），如图。 单击Edit Code，即可定位到该函数定义处。 添加一下代码： 123456void CTestDlg::OnBtnAdd() &#123; // TODO: Add your control notification handler code here m_btn.Create(\"New\",BS_DEFPUSHBUTTON | WS_VISIBLE | WS_CHILD, CRect(0,0,100,100),this,123);&#125; 为避免多次点击Add出现非法操作，我们需要进行如下步骤。 为CTestDlg类增加一个私有的BOOL类型成员变量。 变量类型：BOOL 变量名称：m_bIsCreated Access: private 在TestDlg.cpp中找到构造函数，将m_bIsCreated初始为FALSE。如图所示。 或者改为如下亦可。 Static BOOL bIsCreated = FALSE; 回到Add，双击它，进入代码部分，改之。 12345678910111213141516void CTestDlg::OnBtnAdd() &#123; // TODO: Add your control notification handler code here if(m_bIsCreated==FALSE) &#123; m_btn.Create(\"New\",BS_DEFPUSHBUTTON | WS_VISIBLE | WS_CHILD, CRect(0,0,100,100),this,123); m_bIsCreated = TRUE; &#125; else &#123; m_btn.DestroyWindow(); m_bIsCreated = FALSE; &#125;&#125; 或者以下亦能实现。 1234567891011121314void CTestDlg::OnBtnAdd() &#123; // TODO: Add your control notification handler code here if(!m_btn.m_hWnd) &#123; m_btn.Create(\"New\",BS_DEFPUSHBUTTON | WS_VISIBLE | WS_CHILD, CRect(0,0,100,100),this,123); &#125; else &#123; m_btn.DestroyWindow(); &#125;&#125; 效果： 点击Add出现New窗口，再点击就销毁。 控件的访问 控件的调整 用Layout-Align，Layout-Make Same Size，Layout-Space Evenly里的选项进行调整。 静态文本控件 查看三个静态文本框，它们ID相同。我们可以更改第一个静态文本框ID为IDC_NUMBER1，再打开ClassWizard，可以在ObjectIDs看到新ID。 对BN_CLICKED进行Add Function，并Edit Code: 此时运行程序点击第一个静态文本框并没有反应。这是因为：静态文本控件在默认状态下是不发送通告消息的。 为了该控件能向父窗口发送鼠标事件，我们对该文本框右键-属性，切换到styles选项卡，勾上Notify。 现在可以显示了： 点击就改变。 总结：为了使一个静态文本控件能够响应鼠标单击消息，那么需要进行两个特殊的步骤：第一步，改变它的ID；第二步，在它的属性对话框中选中Notify选项。 编辑框控件 利用上面的对话框实现这样的功能：在前两个编辑框中分别输入一个数字，然后单击Add按钮，对前两个编辑框中的数字求和，并将结果显示在第三个编辑框中。 第一种方式 1234567891011121314void CTestDlg::OnBtnAdd() &#123; int num1, num2, num3; char ch1[10], ch2[10], ch3[10]; GetDlgItem(IDC_EDIT1)-&gt;GetWindowText(ch1,10); GetDlgItem(IDC_EDIT2)-&gt;GetWindowText(ch2,10); num1 = atoi(ch1); num2 = atoi(ch2); num3 = num1 + num2; itoa(num3,ch3,10); GetDlgItem(IDC_EDIT3)-&gt;SetWindowText(ch3);&#125; C语言转换函数：atoi 将一个由数字组成的字符串转换为相应的数值 itoa 数值转换为文本 itoa函数的第三个参数表示转换的进制，数字10表示十进制。 效果： 第二种方式 代码如下： 123456789101112131415161718void CTestDlg::OnBtnAdd() &#123; int num1, num2, num3; char ch1[10], ch2[10], ch3[10]; //GetDlgItem(IDC_EDIT1)-&gt;GetWindowText(ch1,10); //GetDlgItem(IDC_EDIT2)-&gt;GetWindowText(ch2,10); GetDlgItemText(IDC_EDIT1,ch1,10); GetDlgItemText(IDC_EDIT2,ch2,10); num1 = atoi(ch1); num2 = atoi(ch2); num3 = num1 + num2; itoa(num3,ch3,10); //GetDlgItem(IDC_EDIT3)-&gt;SetWindowText(ch3); SetDlgItemText(IDC_EDIT3,ch3);&#125; GetDlgItemText 将返回对话框中指定ID的控件上的文本，相当于将上面的GetDlgItem和GetWindowText这两个函数功能组合起来了。 与之对应的是SetDlgItemText，用来设置对话框中指定ID的控件上的文本。 第三种方式 12345678910111213141516171819202122void CTestDlg::OnBtnAdd() &#123; int num1, num2, num3; //char ch1[10], ch2[10], ch3[10]; //GetDlgItem(IDC_EDIT1)-&gt;GetWindowText(ch1,10); //GetDlgItem(IDC_EDIT2)-&gt;GetWindowText(ch2,10); //GetDlgItemText(IDC_EDIT1,ch1,10); //GetDlgItemText(IDC_EDIT2,ch2,10); num1 = GetDlgItemInt(IDC_EDIT1); num2 = GetDlgItemInt(IDC_EDIT2); //num1 = atoi(ch1); //num2 = atoi(ch2); num3 = num1 + num2; //itoa(num3,ch3,10); //GetDlgItem(IDC_EDIT3)-&gt;SetWindowText(ch3); //SetDlgItemText(IDC_EDIT3,ch3); SetDlgItemInt(IDC_EDIT3,num3);&#125; 第四种方式 将这三个编辑框分别与对话框类的三个成员变量相关联，然后通过这些成员变量来检索和设置编辑框的文本，这是最简单的访问控件的方式。 打开ClassWizard对话框，切换到Member Variables选项卡，如图。 首先为IDC_EDIT1编辑框添加一个关联的成员变量，方法是在Control IDs列表中选中IDC_EDIT1，再单击Add Variable按钮，如图。 同样地，为IDC_EDIT2和IDC_EDIT3分别添加好成员变量。 接着修改代码： 123456void CTestDlg::OnBtnAdd() &#123; UpdateData(); m_num3 = m_num1 + m_num2; UpdateData(FALSE);&#125; 对编辑框控件中输入的数值设定一个范围： 打开ClassWizard-Member Variable，选中IDC_EDIT1，下方输入0和100。同样为IDC_EDIT2也设置好。 第五种方式 将编辑框控件再与一个变量相关联，代表控件本身。为IDC_EDIT1增加一个控件类型的变量：m_edit1，类别为Control。同样地，也为IDC_EDIT2和IDC_EDIT3添加。 修改代码： 123456789101112131415161718void CTestDlg::OnBtnAdd() &#123; int num1, num2, num3; char ch1[10], ch2[10], ch3[10]; m_edit1.GetWindowText(ch1,10); m_edit2.GetWindowText(ch2,10); //num1 = GetDlgItemInt(IDC_EDIT1); //num2 = GetDlgItemInt(IDC_EDIT2); num1 = atoi(ch1); num2 = atoi(ch2); num3 = num1 + num2; itoa(num3,ch3,10); m_edit3.SetWindowText(ch3);&#125; 第六种方式 修改代码： 123456789101112131415void CTestDlg::OnBtnAdd() &#123; int num1, num2, num3; char ch1[10], ch2[10], ch3[10]; ::SendMessage(GetDlgItem(IDC_EDIT1)-&gt;m_hWnd, WM_GETTEXT, 10, (LPARAM)ch1); ::SendMessage(m_edit2.m_hWnd, WM_GETTEXT, 10, (LPARAM)ch2); num1 = atoi(ch1); num2 = atoi(ch2); num3 = num1 + num2; itoa(num3,ch3,10); m_edit3.SendMessage(WM_SETTEXT, 0, (LPARAM)ch3);&#125; 第七种方式 修改代码： 123456789101112131415void CTestDlg::OnBtnAdd() &#123; int num1, num2, num3; char ch1[10], ch2[10], ch3[10]; SendDlgItemMessage(IDC_EDIT1, WM_GETTEXT, 10, (LPARAM)ch1); SendDlgItemMessage(IDC_EDIT2, WM_GETTEXT, 10, (LPARAM)ch2); num1 = atoi(ch1); num2 = atoi(ch2); num3 = num1 + num2; itoa(num3,ch3,10); SendDlgItemMessage(IDC_EDIT3, WM_SETTEXT, 0, (LPARAM)ch3);&#125; 获得编辑框复选的内容： 在上述代码最后添加： SendDlgItemMessage(IDC_EDIT3, EM_SETSEL, 0, -1); //0,-1表示全选若1,3表示选中1-3位复选 m_edit3.SetFocus(); 效果： 总结 1 GetDlgItem()-&gt;Get(Set)WindowTest() 2 GetDlgItemText()/SetDlgItemText() 3 GetDlgItemInt()/SetDlgItemInt() 4 将控件和整型变量相关联 5 将控件和控件变量相关联 6 SendMessage() 7 SendDlgItemMessage() 最常用是1、4、5。在利用MFC编程时，6、7用得少。 对话框伸缩功能的实现 对话框上再添加一个按钮，Caption设置为“收缩&lt;&lt;”点击ClassWizard，添加一个命令相应函数（BN_CLICKED）。具体实现代码为： 123456789101112void CTestDlg::OnButton1() &#123; CString str; if(GetDlgItemText(IDC_BUTTON1,str), str == \"收缩&lt;&lt;\") &#123; SetDlgItemText(IDC_BUTTON1, \"拓展&gt;&gt;\"); &#125; else &#123; SetDlgItemText(IDC_BUTTON1, \"收缩&lt;&lt;\"); &#125;&#125; 拖动一个图像控件来划分对话框中要动态切除的部分。 修改该控件ID为IDC_SEPATATOR，styles选项卡勾上Sunken选项。 修改代码： 12345678910111213141516171819202122232425262728293031323334353637void CTestDlg::OnButton1() &#123; CString str; if(GetDlgItemText(IDC_BUTTON1,str), str == \"收缩&lt;&lt;\") &#123; SetDlgItemText(IDC_BUTTON1, \"拓展&gt;&gt;\"); &#125; else &#123; SetDlgItemText(IDC_BUTTON1, \"收缩&lt;&lt;\"); &#125; static CRect rectLarge; static CRect rectSmall; CRect rect1(10,10,10,10); CRect rect2(0,0,0,0); if(rectLarge.IsRectNull()) &#123; CRect rectSeparator; GetWindowRect(&amp;rectLarge); GetDlgItem(IDC_SEPARATOR)-&gt;GetWindowRect(&amp;rectSeparator); rectSmall.left=rectLarge.left; rectSmall.top=rectLarge.top; rectSmall.right=rectLarge.right; rectSmall.bottom=rectSeparator.bottom; &#125; if(str == \"收缩&lt;&lt;\") &#123; SetWindowPos(NULL, 0, 0, rectSmall.Width(), rectSmall.Height(), SWP_NOMOVE | SWP_NOZORDER); &#125; else &#123; SetWindowPos(NULL, 0, 0, rectLarge.Width(), rectLarge.Height(), SWP_NOMOVE | SWP_NOZORDER); &#125;&#125; 效果： 点击“收缩&lt;&lt;”： 若希望隐藏分隔条，则设置属性去掉“Visible”前的勾。 输入焦点的传递 为了屏蔽掉默认的回车键关闭对话框这一功能，应该在对话框子类（此处是CTestDlg类）中重写OK按钮的消息响应函数。 首先点击OK按钮，添加鼠标单击消息响应函数。注释掉原有函数。 法一 在ClassView选项卡的CTestDlg类添加WM_INITDIALOG消息的响应函数。对类右键，选择Add Windows Message Handler，在弹出的框左侧选择WM_INITDIALOG，直接单击Add and Edit，跳转。 修改代码为： 12345678910111213141516171819202122232425262728293031323334void CTestDlg::OnOK() &#123; // TODO: Add extra validation here //CDialog::OnOK();&#125;WNDPROC prevProc; LRESULT CALLBACK NewEditProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam ) &#123; if(uMsg == WM_CHAR &amp;&amp; wParam == 0x0d) &#123; ::SetFocus(GetNextWindow(hwnd,GW_HWNDNEXT)); return 1; &#125; else &#123; return prevProc(hwnd,uMsg,wParam,lParam); &#125; &#125;BOOL CTestDlg::OnInitDialog() &#123; CDialog::OnInitDialog(); prevProc=(WNDPROC)SetWindowLong(GetDlgItem(IDC_EDIT1)-&gt;m_hWnd, GWL_WNDPROC, (LONG)NewEditProc); return TRUE;&#125; 查看第一个编辑框的属性，打开styles选项卡，勾上MultiLine（多行）。即可实现焦点的传递。 法二 只需要改变一行代码： 12345678910111213141516171819WNDPROC prevProc; LRESULT CALLBACK NewEditProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam ) &#123; if(uMsg == WM_CHAR &amp;&amp; wParam == 0x0d) &#123; //::SetFocus(GetNextWindow(hwnd,GW_HWNDNEXT)); SetFocus(::GetWindow(hwnd,GW_HWNDNEXT)); return 1; &#125; else &#123; return prevProc(hwnd,uMsg,wParam,lParam); &#125; &#125; 法三 编辑框属性有一个WS_TABSTOP，如果勾选了，则在对话框中按下Tab键后，输入焦点可以转移到此控件上。 修改一行代码： 1234567891011121314151617181920WNDPROC prevProc; LRESULT CALLBACK NewEditProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam ) &#123; if(uMsg == WM_CHAR &amp;&amp; wParam == 0x0d) &#123; SetFocus(::GetNextDlgTabItem(::GetParent(hwnd),hwnd,FALSE)); //::SetFocus(GetNextWindow(hwnd,GW_HWNDNEXT)); //SetFocus(::GetWindow(hwnd,GW_HWNDNEXT)); return 1; &#125; else &#123; return prevProc(hwnd,uMsg,wParam,lParam); &#125; &#125; 三种方法的缺点：只修改了第一个编辑框的窗口过程，因此从第二到第三个编辑框的焦点转移无法实现，除非继续修改第二个编辑窗口。 再介绍一种方法解决这个问题。 法四 在MFC中，默认情况下，当在对话框窗口中按下回车键时，会调用对话框的默认按钮的响应函数，我们可以在此默认按钮的响应函数中把焦点依次向下传递。 首先取消第一个编辑框的MultiLine。 接着修改OnOK函数为： 123456789void CTestDlg::OnOK() &#123; // TODO: Add extra validation here //GetDlgItem(IDC_EDIT1)-&gt;GetNextWindow()-&gt;SetFocus(); //GetFocus()-&gt;GetNextWindow()-&gt;SetFocus(); //GetFocus()-&gt;GetWindow(GW_HWNDNEXT)-&gt;SetFocus(); GetNextDlgTabItem(GetFocus())-&gt;SetFocus(); //CDialog::OnOK();&#125; 注释掉的部分是各种失败的尝试，各有各的bug。现在程序是正常的。 **注意：然而该屏蔽回车键的方法并非是常规做法，应该在PreTranslateMessage中进行拦截。（return TRUE即拦截）** 具体做法： 现在Testdlg.h中添加： 123456789class CTestDlg : public CDialog&#123;protected: virtual BOOL PreTranslateMessage(MSG* pMsg);public: virtual void OnOK();…… 接着： 1234567891011121314151617181920212223242526CTestDlg::PreTranslateMessage(MSG* pMsg)&#123; //屏蔽ESC关闭窗体 if (pMsg-&gt;message == WM_KEYDOWN &amp;&amp; pMsg-&gt;wParam == VK_ESCAPE) &#123; return TRUE; &#125; //屏蔽回车关闭窗体，但会导致回车在窗体上失效. /* if (pMsg-&gt;message == WM_KEYDOWN &amp;&amp; pMsg-&gt;wParam == VK_RETURN &amp;&amp; pMsg-&gt;wParam) &#123; return TRUE; &#125; */ else &#123; return CDialog::PreTranslateMessage(pMsg); &#125;&#125;void CTestDlg::OnOK() &#123; // TODO: Add extra validation here //CDialog::OnOK();&#125; 点击Layout-Tab order，这些序号就是各控件的Tab顺序。顺序可改变，依次点击希望的顺序控件即可。 调用顺序：当用户按下回车键时，Windows将查看对话框中是否存在指定的默认按钮，如果有，就调用该默认按钮单击消息的响应函数。如果没有，就会调用虚拟的OnOK函数，即使对话框没有包含默认的OK按钮（这个默认OK按钮的ID是IDOK）。 文件和注册表操作 C语言对文件操作的支持 新建单文档类型的MFC应用程序，工程名为File，并为主菜单添加一个子菜单，名称为“文件操作”，然后为其添加两个菜单项，并分别为它们添加相应的命令响应函数（通过COMMAND），让CFileView类接收这些菜单项的命令响应。 文件的打开和写入 代码： 12345void CFileView::OnFileWrite() &#123; FILE *pFile = fopen(\"1.txt\",\"w\"); fwrite(\"http://www.sunxin.org\", 1, strlen(\"http://www.sunxin.org\"), pFile); &#125; 编译后可看到文件夹中生成了1.txt，打开有一行网址。 文件的关闭 增加一行代码： 123456void CFileView::OnFileWrite() &#123; FILE *pFile = fopen(\"1.txt\",\"w\"); fwrite(\"http://www.sunxin.org\", 1, strlen(\"http://www.sunxin.org\"), pFile); fclose(pFile);&#125; 文件指针定位 代码： 1234567void CFileView::OnFileWrite() &#123; FILE *pFile = fopen(\"1.txt\",\"w\"); fwrite(\"http://www.sunxin.org\", 1, strlen(\"http://www.sunxin.org\"), pFile); fwrite(\"欢迎访问\", 1, strlen(\"欢迎访问\"), pFile); fclose(pFile);&#125; 显示：http://www.sunxin.org欢迎访问 将文件指针移动到文件的开始位置处： 代码： 123456789void CFileView::OnFileWrite() &#123; FILE *pFile = fopen(\"1.txt\",\"w\"); fwrite(\"http://www.sunxin.org\", 1, strlen(\"http://www.sunxin.org\"), pFile); fseek(pFile, 0, SEEK_SET); fwrite(\"ftp:\", 1, strlen(\"ftp:\"),pFile); //fwrite(\"欢迎访问\", 1, strlen(\"欢迎访问\"), pFile); fclose(pFile);&#125; 显示：ftp:://www.sunxin.org 文件的读取 在OnFileRead函数中写入代码： 123456789void CFileView::OnFileRead() &#123; FILE *pFile = fopen(\"1.txt\",\"r\"); char ch[100]; fread(ch, 1, 100, pFile); fclose(pFile); MessageBox(ch); &#125; 编译运行： 原因：C语言以“\\0”结束。 解决方法： 法一： 修改代码： 12345678void CFileView::OnFileWrite() &#123; FILE *pFile = fopen(\"1.txt\",\"w\"); char buf[22] = \"http://www.sunxin.org\"; buf[21] = '\\0'; fwrite(buf, 1, 22, pFile); fclose(pFile);&#125; 先点击写入文件，再点击读取文件，就可以看到正确的内容。 缺点：增加了文件大小。 法二： 12345678910void CFileView::OnFileRead() &#123; FILE *pFile = fopen(\"1.txt\",\"r\"); char ch[100]; memset(ch, 0, 100); fread(ch, 1, 100, pFile); fclose(pFile); MessageBox(ch); &#125; 法三： 读取文件时，不知道文件大小时的做法。 12345678910111213void CFileView::OnFileRead() &#123; FILE *pFile = fopen(\"1.txt\",\"r\"); char *pBuf; fseek(pFile, 0, SEEK_END); int len=ftell(pFile); pBuf = new char[len+1]; rewind(pFile); fread(pBuf, 1, len, pFile); pBuf[len] = 0; fclose(pFile); MessageBox(pBuf);&#125; 二进制文件和文本文件 代码： 1234567891011121314151617181920void CFileView::OnFileWrite() &#123; FILE *pFile = fopen(\"2.txt\", \"w\"); char ch[3]; ch[0] = 'a'; ch[1] = 10; ch[2] = 'b'; fwrite(ch, 1, 3, pFile); fclose(pFile);&#125;void CFileView::OnFileRead() &#123; FILE *pFile = fopen(\"2.txt\",\"r\"); char ch[100]; fread(ch, 1, 3, pFile); ch[3] = 0; fclose(pFile); MessageBox(ch);&#125; 效果： 文本方式：10实际上是换行符的ASCII码。 以文本方式和二进制方式读取文件是有明显的区别的。 文本方式和二进制方式 二进制方式：换行是由两个字符组成的，即ASCII码10（回车符）和13（换行符）。 写入和读取文件时要保持一致。如果采用文本方式写入，应采用文本方式读取；如果采用二进制方式写入数据，在读取时也应采用二进制方式。 面试题：给你一个整数，如：98341，将这个整数保存到文件中，要求在以记事本程序打开该文件时，显示的是：98341。 法一： 1234567891011121314void CFileView::OnFileWrite() &#123; FILE *pFile = fopen(\"3.txt\", \"w\"); char ch[5]; ch[0] = 9 + 48; ch[1] = 8 + 48; ch[2] = 3 + 48; ch[3] = 4 + 48; ch[4] = 1 + 48; fwrite(ch, 1, 5, pFile); fclose(pFile);&#125; 或 1234567891011void CFileView::OnFileWrite() &#123; FILE *pFile = fopen(\"3.txt\", \"w\"); int i = 98341; char ch[5]; itoa(i, ch, 10); fwrite(ch, 1, 5, pFile); fclose(pFile);&#125; 面试题：给定一个字符串，其中既有数字字符，又有26个英文字母中的几个字符，让你判断一下哪些是数字字符。 对这种问题，实际上就是判断各字符的ASCII码，对于数字字符来说，它们的ASCII码大于等于48，小于等于57。 C++对文件操作的支持 1234567891011121314151617void CFileView::OnFileWrite() &#123; ofstream ofs(\"4.txt\"); ofs.write(\"http://www.sunxin.org\",strlen(\"http://www.sunxin.org\")); ofs.close;&#125;void CFileView::OnFileRead() &#123; ifstream ifs(\"4.txt\"); char ch[100]; memset(ch, 0, 100); ifs.read(ch,100); ifs.close(); MessageBox(ch);&#125; Win32 API 对文件操作的支持 文件的创建、打开和写入 123456789101112131415void CFileView::OnFileWrite() &#123; //定义一个句柄变量 HANDLE hFile; //创建文件 hFile = CreateFile(\"5.txt\", GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL); //接收实际写入的字节数 DWORD dwWrites; //写入数据 WriteFile(hFile,\"http://www.sunxin.org\",strlen(\"http://www.sunxin.org\"), &amp;dwWrites, NULL); //关闭文件句柄 CloseHandle(hFile);&#125; 文件的读取 123456789101112131415161718void CFileView::OnFileRead() &#123; HANDLE hFile; //打开文件 hFile = CreateFile(\"5.txt\", GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); //接收实际收到的数据 char ch[100]; //接收实际读取到的字节数 DWORD dwReads; //读取数据 ReadFile(hFile, ch, 100, &amp;dwReads, NULL); //设置字符串结束字符 ch[dwReads] = 0; //关闭打开的文件对象的句柄 CloseHandle(hFile); //显示读取到的数据 MessageBox(ch);&#125; 菜单 菜单命令响应函数 新建一个单文档的MFC AppWizard(exe)工程，工程名为Menu。Build运行。 左上角点击按钮，可以让属性框始终显示，不会因为点击对话框以外的地方就消失。 去掉Pop-up弹出前的勾，将ID改为ID_TEST。给Test添加响应函数在CMainFrame中，在函数中加入 MessageBox(&quot;MainFrame Clicked&quot;); 效果： 菜单命令的路由 程序类对菜单命令的响应顺序 响应Test 菜单项命令的顺序依次是：视类、文档类、框架类，最后才是应用程序类。 Windows消息的分类 凡是从CWnd派生的类，它们既可以接收标准消息，也可以接收命令消息和通告消息。而对于那些从CCmdTarget派生的类，则只能接收命令消息和通告消息，不能接收标准消息。 本例中的文档类（CMenuDoc）和应用程序类（CWinApp），因为它们都派生于CCmdTarget类，所以它们可以接收菜单命令消息。但它们不是从CWnd类派生的，所以不能接收标准消息。 菜单命令的路由 菜单命令消息路由的具体过程：当点击某个菜单项时，最先接收到这个菜单命令消息的是框架类。框架类将把接收到的这个消息交给它的子窗口，即视类，由视类首先进行处理。视类首先根据命令消息映射机制查找自身是否对此消息进行了响应，如果响应了，就调用相应响应函数对这个消息进行处理，消息路由过程结束；如果视类没有对此命令消息做出响应，就交由文档类，文档类同样查找自身是否对这个菜单命令进行了响应，如果响应了，就由文档类的命令消息响应函数进行处理，路由过程结束。如果文档类也未做出响应，就把这个命令消息交还给视类，后者又把该消息交还给框架类。框架类查看自己是否对这个命令消息进行了响应，如果它也没有做出响应，就把这个菜单命令消息交给应用程序类，由后者来进行处理。 基本菜单操作 标记菜单 运行刚才创建的Menu程序，点击查看，前面都有一个对号，这种类型就是标记菜单。 在CMainFrame类的OnCreate的return语句之前添加这句代码 GetMenu()-&gt;GetSubMenu(0)-&gt;CheckMenuItem(0, MF_BYPOSITION | MF_CHECKED); 或者GetMenu()-&gt;GetSubMenu(0)-&gt;CheckMenuItem(ID_FILE_NEW, MF_BYCOMMAND | MF_CHECKED); Build并运行，可发现新建左边已添加一个复选标记。 默认菜单项 在刚才的代码下，添加 GetMenu()-&gt;GetSubMenu(0)-&gt;SetDefaultItem(1, TRUE); 或者GetMenu()-&gt;GetSubMenu(0)-&gt;SetDefaultItem(ID_FILE_OPEN, FALSE); 编译运行，会发现“打开”变成了粗体。 注意：“打印”的索引是5，不是4。计算菜单项索引时，一定要把分割栏菜单项计算在内。并且，一个子菜单只能有一个默认菜单项。 图形标记菜单 Insert-Resource-Bitmap，创建一个位图资源。如图。 为CMainFrame类添加一个CBitmap类型的成员变量：m_bitmap。 接着添加代码： CString str; str.Format(&quot;x=%d&quot;,y=%d&quot;, GetSystemMetrics(SM_CXMENUCHECK),GetSystemMetrics(SM_CYMENUCHECK)); MessageBox(str); m_bitmap.LoadBitmap(IDB_BITMAP1); GetMenu()-&gt;GetSubMenu(0)-&gt;SetMenuItemBitmaps(0, MF_BYPOSITION, &amp;m_bitmap, &amp;m_bitmap); 禁用菜单项 通常把MF_GRAYED和MF_DISABLED这两个标志放在一起使用。不过这么做并不是必需的。 删除之前的代码，写入 GetMenu()-&gt;GetSubMenu(0)-&gt;EnableMenuItem(1, MF_BYPOSITION | MF_DISABLED | MF_GRAYED); 打开“文件”子菜单，发现“打开”菜单栏变灰，点击不起作用。 移除和装载菜单 再添加一行代码： SetMenu(NULL); 此时菜单栏被移除了。 再添加几行代码： CMenu menu; menu.LoadMenu(IDR_MAINFRAME); SetMenu(&amp;menu); menu.Detach(); 此时菜单栏又装载了。 1234567891011121314151617181920CMenu menu;menu.CreateMenu();GetMenu()-&gt;AppendMenu(MF_POPUP, (UINT)menu.m_hMenu, \"Test1\");menu.AppendMenu(MF_STRING, 111, \"Hello\");menu.AppendMenu(MF_STRING, 112, \"Bye\");menu.AppendMenu(MF_STRING, 113, \"Mybole\");menu.Detach();CMenu menu1;menu1.CreateMenu();GetMenu()-&gt;InsertMenu(2, MF_POPUP | MF_BYPOSITION, (UINT)menu1. m_hMenu,\"Test\");menu1.Detach();GetMenu()-&gt;GetSubMenu(2)-&gt;AppendMenu(MF_STRING, 118, \"Welcome\");GetMenu()-&gt;GetSubMenu(0)-&gt;AppendMenu(MF_STRING, 114, \"Welcome\");GetMenu()-&gt;GetSubMenu(0)-&gt;InsertMenu(ID_FILE_OPEN, MF_BYCOMMAND | MF_STRING, 115, \"VC编程\"); MFC菜单命令更新机制 MFC命令更新机制：当要显示菜单时，操作系统发出WM_INITMENUPOPOP消息，然后由程序窗口的基类如CFrameWnd接管，它会创建一个CCmdUI对象，并与程序的第一个菜单项相关联，调用该对象的一个成员函数DoUpdate()。这个函数发出CN_UPDATE_COMMAND_UI消息，这条消息带有一个指向CCmdUI对象的指针。这时，系统会判断是否存在一个ON_UPDATE_COMMAND_UI宏去捕获这个菜单项消息。如果找到这样一个宏，就调用相应的消息响应函数进行处理，在这个函数中，可以利用传递过来的CCmdUI对象去调用相应的函数，使该菜单项可以使用，或禁用该菜单项。当更新完第一个菜单项后，同一个CCmdUI对象就设置为与第二个菜单项相关联，依此顺序进行，直到完成所有菜单项的处理。 添加代码： 12345void CMainFrame::OnUpdateEditCut(CCmdUI* pCmdUI) &#123; // TODO: Add your command update UI handler code here pCmdUI-&gt;Enable();&#125; 编辑-剪切 可用了。 如果要把工具栏上的一个工具按钮与菜单栏中的某个菜单项相关联，只要将它们的ID设置为同一个标识就可以了。 如果希望禁用文件-新建，为ID_FILE_NEW添加UPDATE_COMMAND_UI消息响应函数。 代码如下： 123456void CMainFrame::OnUpdateFileNew(CCmdUI* pCmdUI) &#123; // TODO: Add your command update UI handler code here pCmdUI-&gt;Enable(FALSE);&#125; 或者 12345void CMainFrame::OnUpdateFileNew(CCmdUI* pCmdUI) &#123; if (2 == pCmdUI-&gt;m_nIndex) pCmdUI-&gt;Enable();&#125; 快捷菜单 1. 新增一个新的菜单资源。点开，顶级菜单设置任意的文本，如abc。添加两个菜单项： 显示 IDM_SHOW 退出 IDM_EXIT 2. 给CMenuView类添加WM_RBUTTONDOWN消息响应函数。 12345678910void CMenu2View::OnRButtonDown(UINT nFlags, CPoint point) &#123; CMenu menu; menu.LoadMenu(IDR_MENU1); CMenu* pPopup = menu.GetSubMenu(0); ClientToScreen(&amp;point); pPopup-&gt;TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this); CView::OnRButtonDown(nFlags, point);&#125; 效果： 3.对“显示”右键ClassWizard，可以取消创建新类的询问。分别为CMainFrame类和CMenuView类添加一个响应。 代码： 1234void CMenu2View::OnShow() &#123; MessageBox(\"View show\"); &#125; 1234void CMainFrame::OnShow() &#123; MessageBox(\"Main show\");&#125; 结果是显示“View show”。说明只有视类才能对快捷菜单项命令做出响应。若想让CMainView类对此快捷菜单项进行响应的话，修改代码： 1234567891011void CMenu2View::OnRButtonDown(UINT nFlags, CPoint point) &#123; CMenu menu; menu.LoadMenu(IDR_MENU1); CMenu* pPopup = menu.GetSubMenu(0); ClientToScreen(&amp;point); //pPopup-&gt;TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this); pPopup-&gt;TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, GetParent()); CView::OnRButtonDown(nFlags, point);&#125; 同时删去视类的显示。 动态菜单操作 添加菜单项目 在CMainFrame类的OnCreate函数中添加代码： 1234CMenu menu;menu.CreateMenu();GetMenu()-&gt;AppendMenu(MF_POPUP, (UINT)menu.m_hMenu, \"Test\");menu.Detach(); 插入菜单项目 123456CMenu menu;menu.CreateMenu();/*GetMenu()-&gt;AppendMenu(MF_POPUP, (UINT)menu.m_hMenu, \"Test\");menu.Detach();*/GetMenu()-&gt;InsertMenu(2, MF_POPUP | MF_BYPOSITION, (UINT)menu. m_hMenu,\"Test\");menu.Detach(); 如果要在新插入的子菜单中添加菜单项的话，同样可以使用AppendMenu函数来实现。 12345678910CMenu menu; menu.CreateMenu(); /*GetMenu()-&gt;AppendMenu(MF_POPUP, (UINT)menu.m_hMenu, \"Test\"); menu.Detach();*/ GetMenu()-&gt;InsertMenu(2, MF_POPUP | MF_BYPOSITION, (UINT)menu. m_hMenu,\"Test\"); menu.AppendMenu(MF_STRING, 111, \"Hello\"); menu.AppendMenu(MF_STRING, 112, \"Bye\"); menu.AppendMenu(MF_STRING, 113, \"Mybole\"); menu.Detach(); 111、112、113是随便赋予的ID号。 若要在“文件”子菜单下添加一个菜单项Welcome，再添加一行代码： GetMenu()-&gt;GetSubMenu(0)-&gt;AppendMenu(MF_STRING, 114, &quot;Welcome&quot;); 若要在“文件”中的“新建”和“打开”插入一个菜单项VC编程，再添加一行代码： GetMenu()-&gt;GetSubMenu(0)-&gt;InsertMenu(ID_FILE_OPEN, MF_BYCOMMAND | MF_STRING, 115， &quot;VC编程&quot;); 删除菜单 删除“编辑”：在CMainFrame类的OnCreate函数最后（return之前）添加： GetMenu()-&gt;DeleteMenu(1, MF_BYPOSITION); 删除“文件”下的“打开”： GetMenu()-&gt;GetSubMenu(0)-&gt;DeleteMenu(2, MF_BYPOSITION); 动态添加的菜单项的命令响应 Resource.h中添加新ID 123456789101112#define IDM_HELLO 111将menu.AppendMenu(MF_STRING, 111, “Hello”); 改为 menu.AppendMenu(MF_STRING, IDM_HELLO, “Hello”); 三部曲： 1. 点开MainFrm.h，增加为```C++//&#123;&#123;AFX_MSG(CMainFrame) afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct); afx_msg void OnShow(); //&#125;&#125;AFX_MSG afx_msg void OnHello(); DECLARE_MESSAGE_MAP() 2. 点开MainFrm.cpp，增加为 12345678BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd) //&#123;&#123;AFX_MSG_MAP(CMainFrame) ON_WM_CREATE() ON_COMMAND(IDM_SHOW, OnShow) ON_COMMAND(IDM_HELLO, OnHello) //&#125;&#125;AFX_MSG_MAPEND_MESSAGE_MAP() 3. CMainFrame类中添加 1234void CMainFrame::OnHello()&#123; MessageBox(\"Hello\");&#125; 电话本示例程序 删除之前写入CMainFrame类的OnCreate函数，留下原始函数。 动态添加子菜单的实现 利用ClassWizard添加WM_CHAR消息。在Menu2View.h中添加： 123private: int m_nIndex; CMenu m_menu; 在Menu2View.cpp里，添加： 12345CMenu2View::CMenu2View()&#123; // TODO: add construction code here m_nIndex = -1;&#125; 显示输入的字符 添加菜单项及其命令响应函数 在资源编辑器中打开程序的菜单，在“帮助”后添加一个新菜单abc，添加4个菜单项。名称为1，ID为IDM_PHONE1，以此类推。用ClassWizard为CMenu2View类分别加上这四个菜单项的命令响应函数。 修改CMenu2View类的头文件，如下： 12345678910protected: //&#123;&#123;AFX_MSG(CMenu2View) afx_msg void OnRButtonDown(UINT nFlags, CPoint point); afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags); afx_msg void OnPhone1(); afx_msg void OnPhone2(); afx_msg void OnPhone3(); afx_msg void OnPhone4(); //&#125;&#125;AFX_MSG DECLARE_MESSAGE_MAP() CMenu2View.cpp中， 123456789101112 //&#123;&#123;AFX_MSG_MAP(CMenu2View) ON_WM_CHAR() //&#125;&#125;AFX_MSG_MAP ON_COMMAND(IDM_PHONE1, OnPhone1) ON_COMMAND(IDM_PHONE2, OnPhone2) ON_COMMAND(IDM_PHONE3, OnPhone3) ON_COMMAND(IDM_PHONE4, OnPhone4) // Standard printing commands ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint) ON_COMMAND(ID_FILE_PRINT_DIRECT, CView::OnFilePrint) ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)END_MESSAGE_MAP() 123456789101112131415161718192021222324252627void CMenu2View::OnPhone1() &#123; CClientDC dc(this); dc.TextOut(0, 0, m_strArray.GetAt(0)); &#125;void CMenu2View::OnPhone2() &#123; CClientDC dc(this); dc.TextOut(0, 0, m_strArray.GetAt(1)); &#125;void CMenu2View::OnPhone3() &#123; CClientDC dc(this); dc.TextOut(0, 0, m_strArray.GetAt(2)); &#125;void CMenu2View::OnPhone4() &#123; CClientDC dc(this); dc.TextOut(0, 0, m_strArray.GetAt(3)); &#125; 框架类窗口截获菜单命令消息 右键单击CMainFrame，选择Add Virtual Functions-OnCommand，单击Add Handler，再点击Edit Existing。 代码： 12345678910111213BOOL CMainFrame::OnCommand(WPARAM wParam, LPARAM lParam) &#123; int MenuCmdID = LOWORD(wParam); CMenu2View *pView = (CMenu2View *)GetActiveView(); if (MenuCmdID &gt;= IDM_PHONE1 &amp;&amp; MenuCmdID &lt; IDM_PHONE1 + pView-&gt;m_strArray.GetSize()) &#123; //MessageBox(\"Test\"); CClientDC dc(pView); dc.TextOut(0, 0, pView-&gt;m_strArray.GetAt(MenuCmdID - IDM_PHONE1)); return TRUE; &#125; return CFrameWnd::OnCommand(wParam, lParam);&#125; 将MainFrm.cpp里添加#include “Menu2View.h” 。 将Menu2View.cpp中的#include “Menu2Doc.h”剪切到Menu2View.h文件的前部（#endif // _MSC_VER &gt; 1000下面）。 最终代码： 123456789101112131415161718192021222324void CMenu2View::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) &#123; CClientDC dc(this); if (0x0d == nChar) &#123; if (0 == ++m_nIndex) &#123; m_menu.CreatePopupMenu(); GetParent()-&gt;GetMenu()-&gt;AppendMenu(MF_POPUP, (UINT)m_menu.m_hMenu, \"PhoneBook\"); GetParent()-&gt;DrawMenuBar(); &#125; m_menu.AppendMenu(MF_STRING, IDM_PHONE1 + m_nIndex, m_strLine.Left(m_strLine.Find(' '))); m_strArray.Add(m_strLine); m_strLine.Empty(); Invalidate(); &#125; else &#123; m_strLine += nChar; dc.TextOut(0, 0, m_strLine); &#125; CView::OnChar(nChar, nRepCnt, nFlags);&#125; 效果： 简单绘图 MFC消息映射机制 与消息有关的三处信息：1.头文件XXXX.h中 2.源文件XXXX.cpp中 3.源文件XXXX.cpp的响应函数中 绘制线条 对CDrawView右键点击Add Member Variable，变量名称：m_ptOrigin，类型：CPoint，访问权限设置：Private。 代码： 12345void CDrawView::OnLButtonDown(UINT nFlags, CPoint point) &#123; m_ptOrigin = point; CView::OnLButtonDown(nFlags, point);&#125; 1234567891011121314void CDrawView::OnLButtonUp(UINT nFlags, CPoint point) &#123; //首先获得窗口的设备描述表 HDC hdc; hdc = ::GetDC(m_hWnd); //移动到线条的起点 MoveToEx(hdc, m_ptOrigin.x, m_ptOrigin.y, NULL); //画线 LineTo(hdc, point.x, point.y); //释放设备描述表 ::ReleaseDC(m_hWnd, hdc); CView::OnLButtonUp(nFlags, point);&#125; 利用MFC的CDC类实现画线功能 12345678910111213141516171819void CDrawView::OnLButtonUp(UINT nFlags, CPoint point) &#123; /*//首先获得窗口的设备描述表 HDC hdc; hdc = ::GetDC(m_hWnd); //移动到线条的起点 MoveToEx(hdc, m_ptOrigin.x, m_ptOrigin.y, NULL); //画线 LineTo(hdc, point.x, point.y); //释放设备描述表 ::ReleaseDC(m_hWnd, hdc);*/ CDC* pDC = GetDC(); pDC-&gt;MoveTo(m_ptOrigin); pDC-&gt;LineTo(point); ReleaseDC(pDC); CView::OnLButtonUp(nFlags, point);&#125; 利用MFC的CWindowDC类实现画线功能 12345678void CDrawView::OnLButtonUp(UINT nFlags, CPoint point) &#123; CWindowDC dc(GetParent()); dc.MoveTo(m_ptOrigin); dc.LineTo(point); CView::OnLButtonUp(nFlags, point);&#125; 在桌面窗口中画线 12345678void CDrawView::OnLButtonUp(UINT nFlags, CPoint point) &#123; CWindowDC dc(GetDesktopWindow()); dc.MoveTo(m_ptOrigin); dc.LineTo(point); CView::OnLButtonUp(nFlags, point);&#125; 注意：在桌面上画图需要权限（一般写代码时需要避免软件以外的操作）。 绘制彩色线条 在程序中，当构造一个GDI对象后，该对象并不会立即生效，必须选入设备描述表，它才会在以后的绘制操作中生效。 一般情况下，在完成绘图操作之后，都要利用SelectObject函数把之前的GDI对象选入设备描述表，以便使其恢复到先前的状态。 1234567891011void CDrawView::OnLButtonUp(UINT nFlags, CPoint point) &#123; CPen pen(PS_SOLID, 1, RGB(255, 0, 0)); CClientDC dc(this); CPen* pOldPen = dc.SelectObject(&amp;pen); dc.MoveTo(m_ptOrigin); dc.LineTo(point); dc.SelectObject(pOldPen); CView::OnLButtonUp(nFlags, point);&#125; 运行的效果是红色线条。 改为 CPen pen(PS_DASH, 1, RGB(255, 0, 0)); 是虚线。（其中第二个参数需小于等于10） CPen pen(PS_DOT, 1, RGB(255, 0, 0)); 是点线。 使用画刷绘图 简单画刷 1234567891011void CDrawView::OnLButtonUp(UINT nFlags, CPoint point) &#123; //创建一个红色画刷 CBrush brush(RGB(255, 0, 0)); //创建并获得设备描述表 CClientDC dc(this); //利用红色画刷填充鼠标拖拽过程中形成的矩形区域 dc.FillRect(CRect(m_ptOrigin, point),&amp;brush); CView::OnLButtonUp(nFlags, point);&#125; 位图画刷 Insert-Resource-Bitmap-New，在这里发挥灵魂画手的天赋吧！ 代码： 123456789101112131415void CDrawView::OnLButtonUp(UINT nFlags, CPoint point) &#123; //创建位图对象 CBitmap bitmap; //加载位图资源 bitmap.LoadBitmap(IDB_BITMAP1); //创建位图画刷 CBrush brush(&amp;bitmap); //创建并获得设备描述表 CClientDC dc(this); //利用位图画刷填充鼠标拖拽过程中形成的矩形区域 dc.FillRect(CRect(m_ptOrigin, point),&amp;brush); CView::OnLButtonUp(nFlags, point);&#125; 我画的是不是很滑稽（手动滑稽） 透明画刷 先进行一种尝试： 123456789void CDrawView::OnLButtonUp(UINT nFlags, CPoint point) &#123; //创建并获得设备描述表 CClientDC dc(this); //绘制一个矩形 dc.Rectangle(CRect(m_ptOrigin,point)); CView::OnLButtonUp(nFlags, point);&#125; 如果希望矩形内部是透明的，能够看到被遮挡的图形，就要创建一个透明画刷。 123456789101112131415void CDrawView::OnLButtonUp(UINT nFlags, CPoint point) &#123; //创建并获得设备描述表 CClientDC dc(this); //创建一个空画刷 CBrush *pBrush = CBrush::FromHandle((HBRUSH)GetStockObject(NULL_BRUSH)); //将空画刷选入设备描述表 CBrush *pOldBrush = dc.SelectObject(pBrush); //绘制一个矩形 dc.Rectangle(CRect(m_ptOrigin, point)); //恢复先前的画刷 dc.SelectObject(pOldBrush); CView::OnLButtonUp(nFlags, point);&#125; 绘制连续线条 首先为视类增加鼠标移动消息（WM_MOUSEMOVE）的响应函数（默认OnMouseMove），并为视类添加一个BOOL型的私有成员变量m_bDraw。 在视类头文件定义： 12 Private: BOOL m_bDraw; 在视类的构造函数中： 1m_bDraw = FALSE; 在OnLButtonDown中： 1m_bDraw = TRUE; 在OnLButtonUp中： 1m_bDraw = FALSE; 12345678910111213void CDrawView::OnMouseMove(UINT nFlags, CPoint point) &#123; CClientDC dc(this); if(m_bDraw == TRUE) &#123; dc.MoveTo(m_ptOrigin); dc.LineTo(point); //修改线段的起点 m_ptOrigin = point; &#125; CView::OnMouseMove(nFlags, point);&#125; 给线条换色： 12345678910111213141516171819void CDrawView::OnMouseMove(UINT nFlags, CPoint point) &#123; CClientDC dc(this); //创建一个红色的、宽度为1的实线画笔 CPen pen(PS_SOLID, 1, RGB(255, 0, 0)); //把创建的画笔选入设备描述表 CPen *pOldPen = dc.SelectObject(&amp;pen); if (m_bDraw == TRUE) &#123; dc.MoveTo(m_ptOrigin); dc.LineTo(point); //修改线段的起点 m_ptOrigin = point; &#125; //恢复设备描述表 dc.SelectObject(pOldPen); CView::OnMouseMove(nFlags, point);&#125; 绘制扇形效果的线条 去掉上述代码中的 m_ptOrigin = point; 效果： 绘制一个带边线的扇形： 为CDrawView类增加一个CPoint类型的私有成员变量m_ptOld，用来保存鼠标上一个移动点。 在OnLButton中： 1m_ptOld = point; 在OnMouseMove中： 123456789101112131415161718192021void CDrawView::OnMouseMove(UINT nFlags, CPoint point) &#123; CClientDC dc(this); //创建一个红色的、宽度为1的实线画笔 CPen pen(PS_SOLID, 1, RGB(255, 0, 0)); //把创建的画笔选入设备描述表 CPen *pOldPen = dc.SelectObject(&amp;pen); if (m_bDraw == TRUE) &#123; dc.MoveTo(m_ptOrigin); dc.LineTo(point); dc.LineTo(m_ptOld); //修改线段的起点 //m_ptOrigin = point; m_ptOld = point; &#125; //恢复设备描述表 dc.SelectObject(pOldPen); CView::OnMouseMove(nFlags, point);&#125; 最好将OnLButtonUp里原来写的代码删除或注释之。 效果： MFC提供一个设置绘图模式的函数SetROP2，带有一个参数R2_BLACK、R2_WHITE、R2_MERGENOTPEN等。 例如，在CClientDC dc(this); 下方添加代码： dc.SetROP2(R2_MERGENOTPEN); 编译运行后看不到绘制的线条，这就是设置了R2_MERGENOTPEN这种绘图模式。 使用R2_BLACK，将会发现绘制的线条颜色始终都是黑色的。 文本编程 插入符 创建文本插入符 创建一个单文档类型的MFC AppWizard(exe)工程，取名为Text。 为CTextView类添加WM_CREATE消息的响应函数OnCreate，在此函数中创建一个宽度为20、高度为100的插入符。代码如下。 123456789int CTextView::OnCreate(LPCREATESTRUCT lpCreateStruct) &#123; if (CView::OnCreate(lpCreateStruct) == -1) return -1; CreateSolidCaret(20,100); ShowCaret(); return 0;&#125; 让插入符适应于当前字体的大小： 123456789101112131415161718int CTextView::OnCreate(LPCREATESTRUCT lpCreateStruct) &#123; if (CView::OnCreate(lpCreateStruct) == -1) return -1; //创建设备描述表 CClientDC dc(this); //定义文本信息结构体变量 TEXTMETRIC tm; //获得设备描述表中的文本信息 dc.GetTextMetrics(&amp;tm); //根据字体大小，创建何时的插入符（除以8是经验值） CreateSolidCaret(tm.tmAveCharWidth/8, tm.tmHeight); //显示插入符 ShowCaret(); return 0;&#125; 运行结果就比较符合常规了。 创建图形插入符 新建一个位图资源，画一个图形。 在TextView.h中添加 12private: CBitmap bitmap; 代码： 123456789101112int CTextView::OnCreate(LPCREATESTRUCT lpCreateStruct) &#123; if (CView::OnCreate(lpCreateStruct) == -1) return -1; bitmap.LoadBitmap(IDB_BITMAP1); CreateCaret(&amp;bitmap); ShowCaret(); return 0;&#125; 窗口重绘 OnDraw函数 实现在程序窗口中输出一串文字的功能。 12345678void CTextView::OnDraw(CDC* pDC)&#123; CTextDoc* pDoc = GetDocument(); ASSERT_VALID(pDoc); CString str(\"VC++ 深入编程\"); pDC-&gt;TextOut(50, 50, str);&#125; 添加字符串资源 点击Resource View-String Table选项，在此字符串表最底部的空行上双击，即可弹出添加新字符串资源的对话框。ID：IDS_STRINGVC，Caption：“VC++编程 文本编程”。代码如下。 12345678910111213void CTextView::OnDraw(CDC* pDC)&#123; CTextDoc* pDoc = GetDocument(); ASSERT_VALID(pDoc); //CString str(\"VC++ 深入编程\"); CString str; str = \"VC++ 深入编程\"; pDC-&gt;TextOut(50, 50, str); str.LoadString(IDS_STRINGVC); pDC-&gt;TextOut(0, 200, str);&#125; 路径 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061void CTextView::OnDraw(CDC* pDC)&#123; CTextDoc* pDoc = GetDocument(); ASSERT_VALID(pDoc); //CString str(\"VC++ 深入编程\"); CString str; str = \"VC++ 深入编程\"; pDC-&gt;TextOut(50, 50, str); CSize sz = pDC-&gt;GetTextExtent(str); str.LoadString(IDS_STRINGVC); pDC-&gt;TextOut(0, 200, str); pDC-&gt;BeginPath(); pDC-&gt;Rectangle(50, 50, 50+sz.cx, 50+sz.cy); pDC-&gt;EndPath(); for(int i=0; i&lt;300; i+=10) &#123; pDC-&gt;MoveTo(0, i); pDC-&gt;LineTo(300, i); pDC-&gt;MoveTo(i,0); pDC-&gt;LineTo(i,300); &#125; ![这里写图片描述](http://img.blog.csdn.net/20170420230830380?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVib2ppbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)```C++void CTextView::OnDraw(CDC* pDC)&#123; CTextDoc* pDoc = GetDocument(); ASSERT_VALID(pDoc); //CString str(\"VC++ 深入编程\"); CString str; str = \"VC++ 深入编程\"; pDC-&gt;TextOut(50, 50, str); CSize sz = pDC-&gt;GetTextExtent(str); str.LoadString(IDS_STRINGVC); pDC-&gt;TextOut(0, 200, str); pDC-&gt;BeginPath(); pDC-&gt;Rectangle(50, 50, 50+sz.cx, 50+sz.cy); pDC-&gt;EndPath(); pDC-&gt;SelectClipPath(RGN_DIFF); for(int i=0; i&lt;300; i+=10) &#123; pDC-&gt;MoveTo(0, i); pDC-&gt;LineTo(300, i); pDC-&gt;MoveTo(i,0); pDC-&gt;LineTo(i,300); &#125;&#125; 这正是RGN_DIFF模式的效果。 如果是RGN_AND，效果是新的裁剪区域是当前裁剪区域和当前路径层的交集。 路径层的作用：实现特殊效果。如，希望整幅图形中某一部分与其他部分有所区别，就可以把这部分的图形设置到一个路径层中，然后利用SelectClipPath函数设置一种模式，让路径层和裁剪区域进行互操作以达到一种特殊效果。 字符输入 当用户在键盘上按下某个字符按键后，要把该字符输出到程序窗口上。 首先让CTextView捕获WM_CHAR消息，接着为该类定义一个CString类型的成员变量：m_strLine，并在CTextView类的构造函数中将这个变量初始化：m_strLine = “”; 123456void CTextView::OnLButtonDown(UINT nFlags, CPoint point) &#123; SetCaretPos(point); CView::OnLButtonDown(nFlags, point);&#125; 为CTextView类再增加一个CPoint类型的成员变量，取名m_ptOrigin，权限为私有。在CTextView类的构造函数中设置其初值为0。 12345678void CTextView::OnLButtonDown(UINT nFlags, CPoint point) &#123; SetCaretPos(point); m_strLine.Empty(); m_ptOrigin = point; CView::OnLButtonDown(nFlags, point);&#125; 注意：回车字符的ASCII码十六进制是0x0d，退格键的ASCII码十六进制值是0x08。 最终代码： 1234567891011121314151617181920212223242526272829303132void CTextView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) &#123; CClientDC dc(this); TEXTMETRIC tm; dc.GetTextMetrics(&amp;tm); if (0x0d == nChar) &#123; m_strLine.Empty(); m_ptOrigin.y += tm.tmHeight; &#125; else if(0x08 == nChar) &#123; COLORREF clr = dc.SetTextColor(dc.GetBkColor()); dc.TextOut(m_ptOrigin.x, m_ptOrigin.y, m_strLine); m_strLine = m_strLine.Left(m_strLine.GetLength() - 1); dc.SetTextColor(clr); &#125; else &#123; m_strLine += nChar; &#125; CSize sz = dc.GetTextExtent(m_strLine); CPoint pt; pt.x = m_ptOrigin.x + sz.cx; pt.y = m_ptOrigin.y; SetCaretPos(pt); dc.TextOut(m_ptOrigin.x, m_ptOrigin.y, m_strLine); CView::OnChar(nChar, nRepCnt, nFlags);&#125; 设置字体 1234567891011void CTextView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) &#123; CClientDC dc(this); CFont font; font.CreatePointFont(300, \"华文行楷\", NULL); CFont *pOldFont = dc.SelectObject(&amp;font);…… dc.SelectObject(pOldFont); CView::OnChar(nChar, nRepCnt, nFlags);&#125; 字幕变色功能的实现 在这个Text例子中，我们在视类的OnCreate 函数中设置定时器，设置一个时间间隔为100ms，标识为1的定时器。 12345678int CTextView::OnCreate(LPCREATESTRUCT lpCreateStruct) &#123; …… SetTimer(1, 100, NULL); return 0;&#125; 给CTextView类添加WM_TIMER消息的响应函数。 1234567891011121314151617181920212223242526272829303132void CTextView::OnTimer(UINT nIDEvent) &#123; m_nWidth += 5; CClientDC dc(this); TEXTMETRIC tm; dc.GetTextMetrics(&amp;tm); CRect rect; rect.left =0; rect.top = 200; rect.right = m_nWidth; rect.bottom = rect.top + tm.tmHeight; dc.SetTextColor(RGB(255, 0, 0)); CString str; str.LoadString(IDS_STRINGVC); dc.DrawText(str, rect, DT_LEFT); rect.top = 150; rect.bottom = rect.top + tm.tmHeight; dc.DrawText(str, rect, DT_RIGHT); CSize sz = dc.GetTextExtent(str); if (m_nWidth &gt; sz.cx) &#123; m_nWidth = 0; dc.SetTextColor(RGB(0, 255, 0)); dc.TextOut(0, 200, str); &#125; CView::OnTimer(nIDEvent);&#125; 红色渐变效果可看到。 绘图控制 简单绘图 新建一个单文档类型的MFC AppWizard(exe)工程，取名：Graphic。 添加的菜单项： 给CGraphicView类中添加一个私有变量： 1UINT m_nDrawType; 在视类构造函数中将此变量初始化为0。 1234567891011121314151617181920void CGraphicView::OnDot() &#123; m_nDrawType = 1; &#125;void CGraphicView::OnLine() &#123; m_nDrawType = 2; &#125;void CGraphicView::OnRectangle() &#123; m_nDrawType = 3; &#125;void CGraphicView::OnEllipse() &#123; m_nDrawType = 4; &#125; CGraphicView类再增加一个CPoint类型的私有成员变量：m_ptOrigin。在CGraphicView类构造函数中，将该变量的值设置为0。 1234567891011121314151617181920212223242526272829303132333435void CGraphicView::OnLButtonDown(UINT nFlags, CPoint point) &#123; m_ptOrigin = point; CView::OnLButtonDown(nFlags, point);&#125;void CGraphicView::OnLButtonUp(UINT nFlags, CPoint point) &#123; CClientDC dc(this); //为边框设定颜色 CPen pen(PS_SOLID, 1, RGB(255, 0, 0)); dc.SelectObject(&amp;pen); //能看到图形内部内容(透明) CBrush *pBrush = CBrush::FromHandle((HBRUSH)GetStockObject(NULL_BRUSH)); dc.SelectObject(pBrush); switch(m_nDrawType) &#123; case 1: dc.SetPixel(point,RGB(255, 0, 0)); break; case 2: dc.MoveTo(m_ptOrigin); dc.LineTo(point); break; case 3: dc.Rectangle(CRect(m_ptOrigin,point)); break; case 4: dc.Ellipse(CRect(m_ptOrigin, point)); break; &#125; CView::OnLButtonUp(nFlags, point);&#125; 设置对话框 再增加一个对话框资源，ID为IDD_DLG_SETTING，Caption为Setting，Font为宋体。 设置线宽 添加一个静态文本框，并将Caption设为“线宽”。再添加一个编辑框，ID：IDC_LINE_WIDTH。 12345void CGraphicView::OnSetting() &#123; CSettingDlg dlg; dlg.DoModal();&#125; 在源文件前部添加： 1Include “SettingDlg.h” &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"http://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"MFC","slug":"MFC","permalink":"http://hubojing.github.io/tags/MFC/"},{"name":"C++","slug":"C","permalink":"http://hubojing.github.io/tags/C/"}]},{"title":"多说关闭引发的麻烦","slug":"多说关闭引发的麻烦","date":"2017-04-05T08:44:21.000Z","updated":"2017-04-16T09:17:07.960Z","comments":true,"path":"2017/04/05/多说关闭引发的麻烦/","link":"","permalink":"http://hubojing.github.io/2017/04/05/多说关闭引发的麻烦/","excerpt":"","text":"&lt;div align=&quot;left&quot;&gt; &lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1491392241106&amp;di=d26487a68371b445aa7b604ab2883ce1&amp;imgtype=0&amp;src=http%3A%2F%2Fimage103.360doc.com%2FDownloadImg%2F2017%2F02%2F1715%2F91672979_2.png&quot; width=&quot;300&quot; height=&quot;180&quot; style=&quot;float:right;&quot;/&gt; 多说八百年不发邮件通知我有评论，在我换为网易云跟帖后，竟然邮件通知我有评论了！ &lt;/div&gt; &lt;!--more--&gt; 多说关闭带来的评论区何去何从让我颇为困扰。 现在能用的大概只有这些：畅言（需备案）、网易云跟帖（github.io不支持）、友言（也有倒闭趋势）、来必力（韩国）。 没有一个像多说这样好用的！ 虽然多说也有很多问题，但它至少解决了核心问题： 1.评论显示正确的网友名称。 来看看我换上网易云跟帖后的效果： 都是有态度网友…… 我压根分不清谁是谁！ 2.点击头像可以回访人家的独立博客。 这一点真的很重要，这往往是我们小众的独立博客人交朋友的主要途径啊！ 3.可以自定义。 头像旋转、评论框自定义，真的可以很好看。这些跟帖做不到。 4.盖楼模式多样。 而跟帖只能一种，我不太喜欢，重复率太高，我还是喜欢多说的嵌套。 多说名字没起好啊！多说无益必自毙→_→ 先换回多说吧，再等一个月看看。","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"多说","slug":"多说","permalink":"http://hubojing.github.io/tags/多说/"}]},{"title":"DigitalOcean购买服务器教程","slug":"DigitalOcean购买服务器教程","date":"2017-03-28T13:50:20.000Z","updated":"2017-04-16T09:14:42.267Z","comments":true,"path":"2017/03/28/DigitalOcean购买服务器教程/","link":"","permalink":"http://hubojing.github.io/2017/03/28/DigitalOcean购买服务器教程/","excerpt":"","text":"&lt;div align=&quot;left&quot;&gt; &lt;img src=&quot;http://img.blog.csdn.net/20170326174446026?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVib2ppbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; width=&quot;300&quot; height=&quot;180&quot; style=&quot;float:right;&quot;/&gt; GitHub教育礼包有50美金优惠券，加上朋友的链接送的10美金，自己充值的5美金，正好可以买一个服务器用一年了。 &lt;/div&gt; &lt;!--more--&gt; 步骤 注册、优惠码 1.点击https://m.do.co/c/9d7b9b7b94ba/ 进入DigitalOcean注册。 （通过以上链接，你可以多获得10美金！同时，我也将得到10美金。） 注册时，需要支付5美金完成支付，最好用paypal支付（可以去注册一个账号），最好不要用信用卡（土豪可以用……）。 2.点击头像下的Setting，再点击右侧的Billing 3.输入教育礼包优惠码 注意：很有可能显示“ Account not eligible to use this promo code.”可能滥用优惠码却不是学生的人太多，DO加强了监管，审查比较严格。反正我的是没有通过。 于是，需要向客服反映情况。 点击Support， 点击Create ticket，把你的情况写清楚，最好说明你是学生，并附带你的优惠码。之后官方会帮你搞定。（在三小时后就处理好了我的） 购买服务器 点击创建Droplet， 学生……穷啊……只能买最便宜的……这样刚好可以用一年。 选择centos6.8x64 旧金山比较快。 这个的第一个和第三个可以选，最好不选第三个。 改名 点击create，服务器购买成功。 DO会给你发送一封带有初始密码的邮件。 使用 下载puTTY或xshell。 puTTY 我以shell为例， 新建会话。 IP地址填你的服务器IP，接受并保存你的主机密钥。 输入用户名。 输入初始密码。 再修改密码。（密码最好复杂一点） 完成。 可以愉快地使用你的服务器啦！ 致谢 感谢小忆的耐心指导和大力帮助！","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"http://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"DigitalOcean","slug":"DigitalOcean","permalink":"http://hubojing.github.io/tags/DigitalOcean/"},{"name":"服务器","slug":"服务器","permalink":"http://hubojing.github.io/tags/服务器/"}]},{"title":"更换为.me域名教程","slug":"更换为.me域名教程","date":"2017-03-26T13:01:21.000Z","updated":"2017-04-16T09:15:29.091Z","comments":true,"path":"2017/03/26/更换为.me域名教程/","link":"","permalink":"http://hubojing.github.io/2017/03/26/更换为.me域名教程/","excerpt":"","text":"&lt;div align=&quot;left&quot;&gt; &lt;img src=&quot;http://img.blog.csdn.net/20170326164253754?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVib2ppbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; width=&quot;300&quot; height=&quot;180&quot; style=&quot;float:right;&quot;/&gt; 既然申请得到Github教育礼包，就应开始使用。 我的博客是基于Hexo搭建于Github的博客，原域名：http://hubojing.github.io/ ，现在的新域名是 http://www.hubojing.me/ 。 &lt;/div&gt; &lt;!--more--&gt; 注册.me域名 1.打开教育礼包中的namecheap优惠页面https://nc.me/，使用你的github账号登录。 登陆后，显示已成功。 搜索你想要的域名。 2.如果该域名未被注册，那么你可以注册该域名。 点击ADD。 点击Complete Order。 点击下方的Finish Up完成注册，这样该域名就属于你了。 紧接着，会要求你登录你的namecheap账号，如果之前没有用过该网站，就点register注册一个账号。 注册完成后，是以下的页面显示。 在和你的Github账户绑定在一起： 这样.me域名注册就算是全部完成了。 域名管理 打开网址http://www.namecheap.com/，登录自己的账户。 点击Domain List， 你将看到域名列表。 由于国外的DNS可能很慢，于是最好托管到国内的服务商来。我选择的是腾讯云。 转移到腾讯云 进入https://www.dnspod.cn/，注册新账号（可以用QQ、微信等直接登录免注册）。 点击添加域名，将刚才的.me域名输入。保存。 控制台全局外观： 再回到namecheap控制台，修改NAMESERVERS，选择Custom DNS，如图。 需要等待一会儿才能成功。（最晚48h，我就等了几分钟就好了。） 回到腾讯云，域名是红的。 点击进去看看，再返回，等待一下，再刷新。 变成蓝色，说明已经更新成功了。 点击进入，点击添加记录， 保存。 GitHub博客项目设置 进入项目页（是博客项目页，非个人资料页），点击Setting， 将Custom domain改为你刚才解析的域名，比如我的 www.hubojing.me ，点击Save保存。 大功告成！你的新域名已能正常使用，并且也能通过旧域名自动跳转到新域名！（记得重启浏览器，或者使用IE或Edge浏览器打开查看效果！） 致谢 感谢 小忆 在我更换域名时提供的大力帮助！","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"http://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://hubojing.github.io/tags/教程/"},{"name":"域名","slug":"域名","permalink":"http://hubojing.github.io/tags/域名/"}]},{"title":"Github教育礼包","slug":"Github教育礼包","date":"2017-03-25T03:21:23.000Z","updated":"2017-04-16T09:13:21.975Z","comments":true,"path":"2017/03/25/Github教育礼包/","link":"","permalink":"http://hubojing.github.io/2017/03/25/Github教育礼包/","excerpt":"","text":"&lt;div align=&quot;left&quot;&gt; &lt;img src=&quot;http://img.blog.csdn.net/20170325152139513?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVib2ppbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; width=&quot;300&quot; height=&quot;180&quot; style=&quot;float:right;&quot;/&gt; 感谢小伙伴让我知道github教育礼包，并教我怎么申请： &lt;/div&gt; &lt;!--more--&gt; 到教育优惠页面申请：https://education.github.com/ 填写学校信息及申请理由，如果有edu邮箱一般很快就通过了；如果没有，需要提供证件来证明。 一般来说一小时到几天就申请成功了。（我当天晚上收到了邮件） 有用的主要三个东西： me域名免费一年 DO的免费VPS代金券50美金（有效期1年），可以使用最低配置11个月 免费SSL证书 收到的邮件（截取片段）： If you need help getting started with Git and GitHub, check out: https://help.github.com/articles/good-resources-for-learning-git-and-github We've also given you access to the Student Developer Pack, available at: https://education.github.com/pack If you have any questions, contact us: https://education.github.com/contact Spread the word: we love giving educational discounts to students, teachers, administrators, and researchers! Please send them to: https://education.github.com Have an Octotastic day!（这个 Octotastic 我不造是什么意思……词典也没这个词 望大神解答） My Pack: A hackable text editor for the 21st Century 来自21世纪的可定制文本编辑器 免费使用 Access to the AWS cloud, free training, and collaboration resources AWS云，免费教程和资源。 Install cloud applications in a single click 轻松安装云应用 An open and powerful platform for spatial data analysis, visualization, and application creation. 一个开放有力的空间、视觉、应用创建数据分析平台。 Crowdsourcing and data enrichment platform 众包与数据富集平台 Cloud-based infrastructure monitoring 云基础设施监控 Simple cloud hosting, built for developers 简单云托管，为开发者而生 Simple DNS management with one-click services and a robust API 简单的DNS管理，包括一键服务和强大的API Learn Web Development from the premier coding bootcamp for launching developers. 从最开始的代码集训营开始学习Web开发成为开发者。 Powerful collaboration, code review, and code management 强大的协作、代码审查和代码管理 The downright luxurious Git client for Windows, Mac and Linux Windows，Mac和Linux上的超级豪华Git客户端 Live programming help available 24/7 编程帮助 A suite of Microsoft Azure cloud services and developer tools, including the Visual Studio IDE 一套微软Azure的云服务和开发工具，包括Visual Studio IDE Affordable registration, hosting, and domain management 便宜的注册，托管和域管理 Email infrastructure as a service 电子邮件基础设施服务 Web and mobile payments, built for developers 网络和移动支付，为开发者而生 Dynamic A/B testing, smart push notifications and custom analytics for native mobile apps 动态A / B测试，智能推送通知和自定义分析本地移动应用程序 Localization platform that easily integrates with your code base 易于与代码库集成的本地化平台 Continuous integration platform for open source and private projects 开源和私有项目的连续集成平台 Enroll in a Nanodegree program, and launch your career in Web and Mobile Development, Machine Learning, Data Science, and more. Enroll in a Nanodegree program, and launch your career in Web and Mobile Development, Machine Learning, Data Science, and more. 报名参加一个nanodegree项目，在Web、移动开发、机器学习、数据科学以及等多方面，开启你的职业生涯。 A complete suite of game development tools for PC, console, mobile, web and VR 一套完整的游戏开发工具，用于PC，控制台，移动，网络和虚拟现实 正在学习其中一些工具的使用中……未完待续。","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://hubojing.github.io/tags/Github/"}]},{"title":"简易计算器（Android）","slug":"制作简易计算器APP（线性结构）","date":"2017-03-21T16:19:25.000Z","updated":"2017-03-30T15:54:21.400Z","comments":true,"path":"2017/03/22/制作简易计算器APP（线性结构）/","link":"","permalink":"http://hubojing.github.io/2017/03/22/制作简易计算器APP（线性结构）/","excerpt":"","text":"&lt;div align=&quot;left&quot;&gt; &lt;img src=&quot;http://img.blog.csdn.net/20170321231830210?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVib2ppbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; width=&quot;300&quot; height=&quot;180&quot; style=&quot;float:right;&quot;/&gt; 安卓端简易计算器APP实现。 &lt;/div&gt; &lt;!--more--&gt; 目标 制作简易计算器（Android）。 思路 第一步：页面布局 第二步：事件监听以及实现运算 成品 代码 MainActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206package com.example.calculator;import android.app.Activity;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;public class MainActivity extends Activity implements OnClickListener&#123; Button btn_0;//0按钮 Button btn_1;//1按钮 Button btn_2;//2按钮 Button btn_3;//3按钮 Button btn_4;//4按钮 Button btn_5;//5按钮 Button btn_6;//6按钮 Button btn_7;//7按钮 Button btn_8;//8按钮 Button btn_9;//9按钮 Button btn_point;//小数点按钮 Button btn_clear;//清除按钮 Button btn_del;//删除按钮 Button btn_plus;//加按钮 Button btn_minus;//减按钮 Button btn_multiply;//乘按钮 Button btn_divide;//除按钮 Button btn_equal;//等号按钮 EditText et_input;//显示输入内容的显示屏 boolean clear_flag;//清空标识 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); btn_0 = (Button) findViewById(R.id.btn_0); btn_1 = (Button) findViewById(R.id.btn_1); btn_2 = (Button) findViewById(R.id.btn_2); btn_3 = (Button) findViewById(R.id.btn_3); btn_4 = (Button) findViewById(R.id.btn_4); btn_5 = (Button) findViewById(R.id.btn_5); btn_6 = (Button) findViewById(R.id.btn_6); btn_7 = (Button) findViewById(R.id.btn_7); btn_8 = (Button) findViewById(R.id.btn_8); btn_9 = (Button) findViewById(R.id.btn_9); btn_point = (Button) findViewById(R.id.btn_point); btn_clear = (Button) findViewById(R.id.btn_clear); btn_del = (Button) findViewById(R.id.btn_del); btn_plus = (Button) findViewById(R.id.btn_plus); btn_minus = (Button) findViewById(R.id.btn_minus); btn_multiply = (Button) findViewById(R.id.btn_multiply); btn_divide = (Button) findViewById(R.id.btn_divide); btn_equal = (Button) findViewById(R.id.btn_equal); //以上是实例化按钮 et_input=(EditText)findViewById(R.id.et_input);//实例化显示屏 btn_0.setOnClickListener(this); btn_1.setOnClickListener(this); btn_2.setOnClickListener(this); btn_3.setOnClickListener(this); btn_4.setOnClickListener(this); btn_5.setOnClickListener(this); btn_6.setOnClickListener(this); btn_7.setOnClickListener(this); btn_8.setOnClickListener(this); btn_9.setOnClickListener(this); btn_point.setOnClickListener(this); btn_clear.setOnClickListener(this); btn_del.setOnClickListener(this); btn_plus.setOnClickListener(this); btn_minus.setOnClickListener(this); btn_multiply.setOnClickListener(this); btn_divide.setOnClickListener(this); btn_equal.setOnClickListener(this); //以上设置按钮的点击事件 &#125; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub String str =et_input.getText().toString(); switch (v.getId()) &#123; case R.id.btn_0: case R.id.btn_1: case R.id.btn_2: case R.id.btn_3: case R.id.btn_4: case R.id.btn_5: case R.id.btn_6: case R.id.btn_7: case R.id.btn_8: case R.id.btn_9: case R.id.btn_point: if(clear_flag)&#123; clear_flag=false; str=&quot;&quot;; et_input.setText(&quot;&quot;); &#125; et_input.setText(str+((Button)v).getText()); break; case R.id.btn_plus: case R.id.btn_minus: case R.id.btn_multiply: case R.id.btn_divide: if(clear_flag)&#123; clear_flag=false; str=&quot;&quot;; et_input.setText(&quot;&quot;); &#125; et_input.setText(str+&quot; &quot;+((Button)v).getText()+&quot; &quot;); break; case R.id.btn_clear: clear_flag=false; str=&quot;&quot;; et_input.setText(&quot;&quot;); break; case R.id.btn_del: if(clear_flag)&#123; clear_flag=false; str=&quot;&quot;; et_input.setText(&quot;&quot;); &#125;else if(str!=null&amp;&amp;!str.equals(&quot;&quot;))&#123; et_input.setText(str.substring(0, str.length()-1)); &#125; break; case R.id.btn_equal: getResult(); break; &#125; &#125; /** * 运算结果 */ private void getResult()&#123; String exp=et_input.getText().toString(); if(exp==null||exp.equals(&quot;&quot;))&#123; return; &#125; if(!exp.contains(&quot; &quot;))&#123; return; &#125; if(clear_flag)&#123; clear_flag=false; return; &#125; clear_flag=true; double result=0; String s1=exp.substring(0, exp.indexOf(&quot; &quot;));//运算符前面的字符串 String op=exp.substring(exp.indexOf(&quot; &quot;)+1, exp.indexOf(&quot; &quot;)+2);//运算符 String s2=exp.substring(exp.indexOf(&quot; &quot;)+3);//运算符后面的字符串 if(!s1.equals(&quot;&quot;)&amp;&amp;!s2.equals(&quot;&quot;))&#123; double d1=Double.parseDouble(s1); double d2=Double.parseDouble(s2); if(op.equals(&quot;+&quot;))&#123; result=d1+d2; &#125;else if(op.equals(&quot;-&quot;))&#123; result=d1-d2; &#125;else if(op.equals(&quot;×&quot;))&#123; result=d1*d2; &#125;else if(op.equals(&quot;÷&quot;))&#123; if(d2==0)&#123; result=0; &#125;else&#123; result=d1/d2; &#125; &#125; if(!s1.contains(&quot;.&quot;)&amp;&amp;!s2.contains(&quot;.&quot;)&amp;&amp;!op.equals(&quot;÷&quot;))&#123; int r=(int)result; et_input.setText(r+&quot;&quot;); &#125;else&#123; et_input.setText(result+&quot;&quot;); &#125; &#125;else if(!s1.equals(&quot;&quot;)&amp;&amp;s2.equals(&quot;&quot;))&#123; et_input.setText(exp); &#125;else if(s1.equals(&quot;&quot;)&amp;&amp;!s2.equals(&quot;&quot;))&#123; double d2=Double.parseDouble(s2); if(op.equals(&quot;+&quot;))&#123; result=0+d2; &#125;else if(op.equals(&quot;-&quot;))&#123; result=0-d2; &#125;else if(op.equals(&quot;×&quot;))&#123; result=0; &#125;else if(op.equals(&quot;÷&quot;))&#123; result=0; &#125; if(!s2.contains(&quot;.&quot;))&#123; int r=(int)result; et_input.setText(r+&quot;&quot;); &#125;else&#123; et_input.setText(result+&quot;&quot;); &#125; &#125;else&#123; et_input.setText(&quot;&quot;); &#125; &#125;&#125; activity_main.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot; android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot; android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; tools:context=&quot;com.example.calculator.MainActivity&quot; &gt; &lt;EditText android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;60dip&quot; android:id=&quot;@+id/et_input&quot; android:editable=&quot;false&quot; android:gravity=&quot;right|bottom&quot; android:background=&quot;@drawable/white_bg&quot; /&gt; &lt;LinearLayout android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;20dp&quot; android:orientation=&quot;horizontal&quot; android:gravity=&quot;center_horizontal&quot; &gt; &lt;Button android:layout_width=&quot;60dp&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;C&quot; android:paddingRight=&quot;10dp&quot; android:paddingBottom=&quot;10dp&quot; android:background=&quot;@drawable/white_selector&quot; android:textSize=&quot;20sp&quot; android:gravity=&quot;right|bottom&quot; android:id=&quot;@+id/btn_clear&quot; /&gt; &lt;Button android:layout_width=&quot;60dp&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;DEL&quot; android:paddingRight=&quot;10dp&quot; android:paddingBottom=&quot;10dp&quot; android:background=&quot;@drawable/white_selector&quot; android:layout_marginLeft=&quot;10dp&quot; android:textSize=&quot;20sp&quot; android:gravity=&quot;right|bottom&quot; android:id=&quot;@+id/btn_del&quot; /&gt; &lt;Button android:layout_width=&quot;60dp&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;÷&quot; android:paddingRight=&quot;10dp&quot; android:paddingBottom=&quot;10dp&quot; android:background=&quot;@drawable/white_selector&quot; android:layout_marginLeft=&quot;10dp&quot; android:textSize=&quot;20sp&quot; android:gravity=&quot;right|bottom&quot; android:id=&quot;@+id/btn_divide&quot; /&gt; &lt;Button android:layout_width=&quot;60dp&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;×&quot; android:paddingRight=&quot;10dp&quot; android:paddingBottom=&quot;10dp&quot; android:background=&quot;@drawable/white_selector&quot; android:layout_marginLeft=&quot;10dp&quot; android:textSize=&quot;20sp&quot; android:gravity=&quot;right|bottom&quot; android:id=&quot;@+id/btn_multiply&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot; android:orientation=&quot;horizontal&quot; android:gravity=&quot;center_horizontal&quot; &gt; &lt;Button android:layout_width=&quot;60dp&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;7&quot; android:paddingRight=&quot;10dp&quot; android:paddingBottom=&quot;10dp&quot; android:background=&quot;@drawable/white_selector&quot; android:textSize=&quot;20sp&quot; android:gravity=&quot;right|bottom&quot; android:id=&quot;@+id/btn_7&quot; /&gt; &lt;Button android:layout_width=&quot;60dp&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;8&quot; android:paddingRight=&quot;10dp&quot; android:paddingBottom=&quot;10dp&quot; android:background=&quot;@drawable/white_selector&quot; android:layout_marginLeft=&quot;10dp&quot; android:textSize=&quot;20sp&quot; android:gravity=&quot;right|bottom&quot; android:id=&quot;@+id/btn_8&quot; /&gt; &lt;Button android:layout_width=&quot;60dp&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;9&quot; android:paddingRight=&quot;10dp&quot; android:paddingBottom=&quot;10dp&quot; android:background=&quot;@drawable/white_selector&quot; android:layout_marginLeft=&quot;10dp&quot; android:textSize=&quot;20sp&quot; android:gravity=&quot;right|bottom&quot; android:id=&quot;@+id/btn_9&quot; /&gt; &lt;Button android:layout_width=&quot;60dp&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;-&quot; android:paddingRight=&quot;10dp&quot; android:paddingBottom=&quot;10dp&quot; android:background=&quot;@drawable/white_selector&quot; android:layout_marginLeft=&quot;10dp&quot; android:textSize=&quot;20sp&quot; android:gravity=&quot;right|bottom&quot; android:id=&quot;@+id/btn_minus&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot; android:orientation=&quot;horizontal&quot; android:gravity=&quot;center_horizontal&quot; &gt; &lt;Button android:layout_width=&quot;60dp&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;4&quot; android:paddingRight=&quot;10dp&quot; android:paddingBottom=&quot;10dp&quot; android:background=&quot;@drawable/white_selector&quot; android:textSize=&quot;20sp&quot; android:gravity=&quot;right|bottom&quot; android:id=&quot;@+id/btn_4&quot; /&gt; &lt;Button android:layout_width=&quot;60dp&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;5&quot; android:paddingRight=&quot;10dp&quot; android:paddingBottom=&quot;10dp&quot; android:background=&quot;@drawable/white_selector&quot; android:layout_marginLeft=&quot;10dp&quot; android:textSize=&quot;20sp&quot; android:gravity=&quot;right|bottom&quot; android:id=&quot;@+id/btn_5&quot; /&gt; &lt;Button android:layout_width=&quot;60dp&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;6&quot; android:paddingRight=&quot;10dp&quot; android:paddingBottom=&quot;10dp&quot; android:background=&quot;@drawable/white_selector&quot; android:layout_marginLeft=&quot;10dp&quot; android:textSize=&quot;20sp&quot; android:gravity=&quot;right|bottom&quot; android:id=&quot;@+id/btn_6&quot; /&gt; &lt;Button android:layout_width=&quot;60dp&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;+&quot; android:paddingRight=&quot;10dp&quot; android:paddingBottom=&quot;10dp&quot; android:background=&quot;@drawable/white_selector&quot; android:layout_marginLeft=&quot;10dp&quot; android:textSize=&quot;20sp&quot; android:gravity=&quot;right|bottom&quot; android:id=&quot;@+id/btn_plus&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; android:layout_marginTop=&quot;10dp&quot; android:gravity=&quot;center_horizontal&quot; &gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; &gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; &gt; &lt;Button android:layout_width=&quot;60dp&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;1&quot; android:paddingRight=&quot;10dp&quot; android:paddingBottom=&quot;10dp&quot; android:background=&quot;@drawable/white_selector&quot; android:textSize=&quot;20sp&quot; android:gravity=&quot;right|bottom&quot; android:id=&quot;@+id/btn_1&quot; /&gt; &lt;Button android:layout_width=&quot;60dp&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;2&quot; android:paddingRight=&quot;10dp&quot; android:paddingBottom=&quot;10dp&quot; android:background=&quot;@drawable/white_selector&quot; android:textSize=&quot;20sp&quot; android:gravity=&quot;right|bottom&quot; android:layout_marginLeft=&quot;10dp&quot; android:id=&quot;@+id/btn_2&quot; /&gt; &lt;Button android:layout_width=&quot;60dp&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;3&quot; android:paddingRight=&quot;10dp&quot; android:paddingBottom=&quot;10dp&quot; android:background=&quot;@drawable/white_selector&quot; android:textSize=&quot;20sp&quot; android:gravity=&quot;right|bottom&quot; android:layout_marginLeft=&quot;10dp&quot; android:id=&quot;@+id/btn_3&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot; android:orientation=&quot;horizontal&quot; &gt; &lt;Button android:layout_width=&quot;130dp&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;0&quot; android:paddingRight=&quot;10dp&quot; android:paddingBottom=&quot;10dp&quot; android:background=&quot;@drawable/white_selector&quot; android:textSize=&quot;20sp&quot; android:gravity=&quot;right|bottom&quot; android:id=&quot;@+id/btn_0&quot; /&gt; &lt;Button android:layout_width=&quot;60dp&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;.&quot; android:paddingRight=&quot;10dp&quot; android:paddingBottom=&quot;10dp&quot; android:background=&quot;@drawable/white_selector&quot; android:textSize=&quot;20sp&quot; android:gravity=&quot;right|bottom&quot; android:layout_marginLeft=&quot;10dp&quot; android:id=&quot;@+id/btn_point&quot; /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;Button android:layout_width=&quot;60dp&quot; android:layout_height=&quot;130dp&quot; android:text=&quot;=&quot; android:paddingRight=&quot;10dp&quot; android:paddingBottom=&quot;10dp&quot; android:background=&quot;@drawable/orange_selector&quot; android:layout_marginLeft=&quot;10dp&quot; android:textSize=&quot;20sp&quot; android:gravity=&quot;right|bottom&quot; android:id=&quot;@+id/btn_equal&quot; /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; color.xml res/values下新建一个xml. 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;color name=&quot;white&quot;&gt;#FFFFFF&lt;/color&gt; &lt;color name=&quot;red&quot;&gt;#FF0000&lt;/color&gt; &lt;color name=&quot;black&quot;&gt;#000000&lt;/color&gt; &lt;color name=&quot;gray&quot;&gt;#808080&lt;/color&gt; &lt;color name=&quot;orange&quot;&gt;#FFA500&lt;/color&gt; &lt;color name=&quot;ashen&quot;&gt;#CD853F&lt;/color&gt;&lt;/resources&gt; white_bg.xml 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt; &lt;corners android:radius=&quot;5dp&quot;/&gt; &lt;solid android:color=&quot;@color/white&quot; /&gt; &lt;!-- &lt;gradient android:startColor=&quot;@color/white&quot; android:endColor=&quot;@color/red&quot; /&gt; &lt;stroke android:width=&quot;1dp&quot; android:color=&quot;@color/black&quot; /&gt; --&gt;&lt;/shape&gt; white_selector.xml 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt; &lt;item android:drawable=&quot;@drawable/gray_bg&quot; android:state_pressed=&quot;true&quot;/&gt; &lt;item android:drawable=&quot;@drawable/white_bg&quot;/&gt;&lt;/selector&gt; 出现的问题及解决方法 1.新建工程时，出现报错： \\res\\values\\styles.xml:7: error: Error retrieving parent for item: No resource found that matches the given name 'Theme.AppCompat.Light'. \\res\\values-v11\\styles.xml:7: error: Error retrieving parent for item: No resource found that matches the given name 'Theme.AppCompat.Light'. \\res\\values-v14\\styles.xml:8: error: Error retrieving parent for item: No resource found that matches the given name 'Theme.AppCompat.Light.DarkActionBar'. 解决方法： 顺着改为： style name=&quot;AppBaseTheme&quot; parent=&quot;android:Theme.Light&quot; style name=&quot;AppBaseTheme&quot; parent=&quot;android:Theme.Holo.Light&quot; style name=&quot;AppBaseTheme&quot;parent=&quot;android:Theme.Holo.Light.DarkActionBar&quot; 然后menu会报错，改为： android:showAsAction=&quot;never&quot; 2.导入工程时报错The import android cannot be resolved 解决：在新建Android项目的时候，eclipes新更新的ADT，在创建的Android版本最低版本低于4.0的时候，会新建一个v7的项目，把里面的包导入就可以。如果不想有警告的话，直接在创建项目的时候把最低版本设置为4.0以上就可以。并且不会出现第一个问题。 3.定义按钮时错误提示：Button cannot be resolved to a type 解决：没导包，快捷键ctrl+shift+o搞定。 笔记 去掉标题栏 在res/values/string.xml中和AndroidManifest.xml去掉相应代码即可。 颜色需新建xml 存放在res/values/colors中，RGB颜色表示。 drawble下文件结构 注意 Main_Activity.java中，首先命名控件，给一个id，其次，按钮要设置点击事件，监听到该控件动作。 activity_main.xml中，线性结构可以嵌套使用。 思考：线性结构代码显臃肿，换成TableLayout也许更佳。并且计算器需要进一步优化，目前存在小的问题，例如，加减乘除符号可以在没有数字输入时顺序打印在屏幕上。总之，基本实现了计算器的功能。 APP下载 https://github.com/hubojing/Calculator","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"http://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hubojing.github.io/tags/Java/"},{"name":"android","slug":"android","permalink":"http://hubojing.github.io/tags/android/"}]},{"title":"模拟借书系统（Java异常机制实现）","slug":"模拟借书系统（java异常机制实现）","date":"2017-03-19T09:09:12.000Z","updated":"2017-03-30T15:56:21.142Z","comments":true,"path":"2017/03/19/模拟借书系统（java异常机制实现）/","link":"","permalink":"http://hubojing.github.io/2017/03/19/模拟借书系统（java异常机制实现）/","excerpt":"","text":"&lt;div align=&quot;left&quot;&gt; &lt;img src=&quot;http://img.blog.csdn.net/20170319164926044?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVib2ppbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; width=&quot;300&quot; height=&quot;180&quot; style=&quot;float:right;&quot;/&gt; java语言实现一个控制台版的模拟借书系统。 &lt;/div&gt; &lt;!--more--&gt; 目标 用java语言实现一个控制台版的模拟借书系统，旨在练习java异常机制。 要求 成品 参考代码及注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.jinger;import java.util.Scanner;//导入Scanner包public class BookManagerEasy &#123; private static Scanner console = new Scanner(System.in);//接收系统输入 public static void main(String[] args) &#123; //定义”图书“数组 String[] books = &#123; \"C语言\", \"数据结构\", \"汇编语言\", \"高数\", \"大学语文\", \"毛概\" &#125;; while (true) &#123; System.out.println(\"输入命令：1-按照名称查找图书；2-按照序号查找图书\"); String book; try &#123; //取得整型命令 int command = inputCommand(); //根据不同命令值，进行不同操作 switch (command) &#123; case 1://按照图书名称选择图书 book = getBookByName(books); System.out.println(\"book:\" + book); break; case 2://按照图书序号（数组下标）选择图书 book = getBookByNumber(books); System.out.println(\"book:\" + book); break; case -1://返回值为-1，说明输入有误 System.out.println(\"命令输入错误！请根据提示输入数字命令！\"); continue; default://其他值的命令均认为是错误命令 System.out.println(\"命令输入错误！\"); continue; &#125; break;//退出程序 &#125; catch (Exception bne) &#123; //捕获“图书不存在异常”时，要求重新输入命令 System.out.println(bne.getMessage()); continue; &#125; &#125; &#125; //按照图书名称查询图书 private static String getBookByName(String[] books) throws Exception &#123; System.out.println(\"输入图书名称：\"); //获取输入的图书名称 String name = console.next(); for (int i = 0; i &lt; books.length; i++) &#123; if (name.equals(books[i])) //输入的名称与某一图书名称匹配，返回该图书 return books[i]; &#125; //若无匹配，抛出”图书不存在异常“ throw new Exception(\"图书不存在！\"); &#125; //根据图书序号（数组下标）查询图书 private static String getBookByNumber(String[] books) throws Exception &#123; while (true) &#123; System.out.println(\"输入图书序号：\"); try &#123; //获取输入的图书序号（数组下标） int index = inputCommand(); //若返回值为-1 if(index == -1)&#123; System.out.println(\"命令输入错误！请根据提示输入数字命令！\"); continue; &#125; //若不出现“数组下标越界异常”，则返回相应位置的图书 String book = books[index]; return book; &#125; catch (ArrayIndexOutOfBoundsException e) &#123; //输入的序号不存在（引发“数组下标越界异常”），则抛出“图书不存在异常” Exception bookNotExists = new Exception(\"图书不存在！\"); bookNotExists.initCause(e); throw bookNotExists; &#125; &#125; &#125; //从控制台输入命令，用于输入命令和输入图书序号 private static int inputCommand()&#123; int command; try &#123; command = console.nextInt(); return command; &#125; catch (Exception e) &#123; //若输入字符型或者字符串，则抛出异常，捕获该异常，抛出“错误命令异常” console = new Scanner(System.in); //返回-1 return -1; &#125; &#125;&#125; &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"http://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hubojing.github.io/tags/Java/"}]},{"title":"达达租车系统（Java实现）","slug":"达达租车系统（Java实现）","date":"2017-03-18T10:52:48.000Z","updated":"2017-03-30T15:55:02.244Z","comments":true,"path":"2017/03/18/达达租车系统（Java实现）/","link":"","permalink":"http://hubojing.github.io/2017/03/18/达达租车系统（Java实现）/","excerpt":"","text":"&lt;div align=&quot;left&quot;&gt; &lt;img src=&quot;http://img.blog.csdn.net/20170318155606137?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVib2ppbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; width=&quot;300&quot; height=&quot;180&quot; style=&quot;float:right;&quot;/&gt; java编写一个控制台版的“达达租车系统”。 &lt;/div&gt; &lt;!--more--&gt; 目标 java编写一个控制台版的“达达租车系统” 功能 1.展示所有可租车辆 2.选择车型、租车量 3.展示租车清单，包含：总金额、总载货量及其车型、总载人量及其车型 三大分析 数据模型分析 业务模型分析 显示和流程分析 成品 思路 首先定义一个Car类，它包含基本功能：车名、载客数、载货量、日租金。接着创建三个小类，分别是客车类、货车类和皮卡类（既能载客又能载货），它们都继承Car类。最后需要一个主类，用于开启整个系统，调用每个小类。 代码 12345678910111213141516171819202122232425262728293031323334package com.jinger;public abstract class Car &#123; public int rent;//日租金 public int people;//载客人数 public int loads;//载货量 public String name;//车名public int getRent()&#123; return rent;&#125;public void setRent(int rent)&#123; this.rent=rent;&#125;public int getPeople()&#123; return people;&#125;public void setPeople(int people)&#123; this.people=people;&#125;public int getLoads()&#123; return loads;&#125;public void setLoads(int loads)&#123; this.loads=loads;&#125;public String getName()&#123; return name;&#125;public void setName(String name)&#123; this.name=name;&#125;&#125; 客车类 123456789101112131415package com.jinger;public class PassageCar extends Car&#123; public PassageCar(String name,int people,int rent)&#123; this.setName(name); this.setPeople(people); this.setRent(rent); &#125; public String toString()&#123; return this.getName()+\"\\t\"+this.getPeople()+\"\\t\\t\\t\\t\"+this.getRent(); &#125; &#125; 卡车类 12345678910111213package com.jinger;public class Truck extends Car &#123; public Truck(String name,int loads,int rent)&#123; this.setName(name); this.setLoads(loads); this.setRent(rent); &#125; public String toString()&#123; return this.getName()+\"\\t\\t\\t\"+this.getLoads()+\"\\t\\t\"+this.getRent(); &#125; &#125; 皮卡类 1234567891011121314package com.jinger;public class Pickup extends Car &#123; public Pickup(String name,int people,int loads,int rent)&#123; this.setName(name); this.setPeople(people); this.setLoads(loads); this.setRent(rent); &#125; public String toString()&#123; return this.getName()+\"\\t\"+this.getPeople()+\"\\t\\t\"+this.getLoads()+\"\\t\\t\"+this.getRent(); &#125; &#125; 主类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.jinger;import java.util.*;public class Initial &#123; public static void main(String[] args) &#123; //对各类车实例化并保存到cars数组 Car[] cars=&#123; new PassageCar(\"奥迪A4\",4,500), new PassageCar(\"马自达6\",4,400), new Pickup(\"皮卡雪6\",4,2,450), new PassageCar(\"金龙\",20,800), new Truck(\"松花江\",4,400), new Truck(\"依维柯\",20,1000)&#125;; System.out.println(\"****欢迎使用达达租车系统！****\"); System.out.println(\"****您确认租车吗？****\"+\"\\n\"+\"是（请输入1） \\t 否（请输入2）\"); Scanner in1=new Scanner(System.in); int is=in1.nextInt(); if(is!=1)&#123; System.out.println(\"****欢迎下次光临！****\"); System.exit(0); &#125; if(is==1)&#123; System.out.println(\"****您可租车的类型及价目表****\"); System.out.println(\"序号\"+\"\\t车名\"+\"\\t载客数（人）\"+\"\\t载货量（吨）\"+\"\\t日租金（元/天）\"); //使用循环方式将各类车输出 for(int i=0;i&lt;cars.length;i++)&#123; System.out.println((i+1)+\"\\t\"+cars[i]); &#125; System.out.println(\"****请输入您的租车数量：****\"); int num1=in1.nextInt(); Car[] rentcar=new Car[num1]; int price=0;//总价格 int totalpeople=0;//总人数 int totalloads=0;//总载货量 for(int i=0;i&lt;num1;i++)&#123; System.out.println(\"****请输入第\"+(i+1)+\"辆车的序号：****\"); int numx=in1.nextInt(); rentcar[i]=cars[numx-1]; &#125; System.out.println(\"****请输入天数：****\"); int day=in1.nextInt(); for(int i=0;i&lt;num1;i++)&#123; price=price+rentcar[i].rent *day; &#125; System.out.println(\"****您的账单：****\"); System.out.println(\"已选载人车：\"); for(int i=0;i&lt;num1;i++)&#123; if(rentcar[i].people!=0)&#123; System.out.println(rentcar[i].name+\"\\t\"); &#125; totalpeople=totalpeople+rentcar[i].people; &#125; System.out.println('\\n'); System.out.println(\"已选载货车：\"); for(int i=0;i&lt;num1;i++)&#123; if(rentcar[i].loads!=0)&#123; System.out.println(rentcar[i].name+\"\\t\"); &#125; totalloads=totalloads+rentcar[i].loads; &#125; System.out.println('\\n'); System.out.println(\"共载客：\"+totalpeople+\"人\"); System.out.println(\"共载货：\"+totalloads+\"吨\"); System.out.println(\"租车总价格：\"+price+\"元\"); System.out.println('\\n'); System.out.println(\"****感谢您的惠顾，欢迎再次光临！****\"); &#125; &#125; &#125; 收获 思路决定编码。 编程要注重自顶而下、逐步求精的设计方法。 源程序下载 https://github.com/hubojing/Car-rental-system &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"http://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://hubojing.github.io/tags/Java/"}]},{"title":"别做井底之蛙","slug":"反省","date":"2017-03-05T16:11:48.000Z","updated":"2017-03-30T15:55:52.118Z","comments":true,"path":"2017/03/06/反省/","link":"","permalink":"http://hubojing.github.io/2017/03/06/反省/","excerpt":"","text":"&lt;div align=&quot;left&quot;&gt; &lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1488743337927&amp;di=4273153cdba587ffa9e9dba1db8737fc&amp;imgtype=0&amp;src=http%3A%2F%2Fupload.admin5.com%2F2015%2F1121%2F1448071304470.jpg&quot; width=&quot;300&quot; height=&quot;180&quot; style=&quot;float:right;&quot;/&gt; 即将毕业了，谈谈最近我关于技术的思考。 &lt;/div&gt; &lt;!--more--&gt; 最近总想给自己的四年打个分。 给个70分吧。 四年来，我一直认为，自己没有辜负这四年。这四年里，自己很多方面得到了成长。但直到最近，我发现了些什么。 这四年来，我一直是大家眼中的优秀学生，绩点高，学生工作也做得好。我时刻提醒自己，千万不要被眼前的赞誉迷了眼。我之所以显得优秀，是因为我所处的环境还不够好。 这是我的技术博客，关于其他方面就不提了。尤谈技术。 大一大二沉浸在繁忙的学生工作中，忽略了自己是个十足的工科生，只注重课堂学习，忽视了动手实践。大二在实验室的半年，收获有，却不是很大。一方面是学校实验室的建设不完善，最重要的是实验室方向不是我所感兴趣的，再加上我当时过于急于求成，收效甚微就心烦意乱。 大三卸任部分学生工作，时间多了出来。突然就意识到了自己的专业被自己落下了。于是就诞生了这个技术博客，记录我所学的知识。算是对自己学技术的一点弥补。后来表示不服，自己报名了计算机比赛，最后竟意外抱得国奖回，让自己开心了一阵。我就算没在实验室了，我还是能自己干出事情来！我是有些倔。 再后来考研。过程不说了，和所有考研人一样平常。 考完后让自己彻底放松了二个月，所有和学习的事情都放下了，包括这里。这也是为什么这段时间我的github绿的很少，以及博客长久未更的原因。 简历看似让人羡慕，可我近来愈发觉得，自己就是一只井底之蛙。 没有实验室的帮助，没有老师的指导，没有志同道合的伙伴，全靠自己一个人，自己的学习时常走入歧途。不过这都不重要，重要的是我只要愿意不断学习，总会越懂越多。 最近我看了大神和牛人甚至是认识的同学们的学习过程，自己的努力与之相比不值一提。之前即使我总是警告自己不要感动自己，可最终还是让自己浮在了表面。 我是通信工程专业的学生，却常“不务正业”地倒弄计算机专业的东西（不过这是我的兴趣所在，我也从不觉得是错误，通信和计算机本是一家），有时候我在想，我的本家知识还没学通学透呢？ 寒假放松的两个月，有个网友隔几天就问我有没有敲代码。我都说没有。他当时批评我说，女生果然不适合干技术。我回复他，你可以指责我，但我不能代表整个女性群体。后来想想，他的批评是有理的，像我那样三天打鱼、两天晒网的学习，怎么会有效果？ 最近我常常在想，我口口声声说爱技术，还有一个做学术做科研的愿望，到底是不是发自心底的？我在还没深入了解它的时候，有什么资格说爱它？ 感觉自己被越甩越远，但自己不想在做井底之蛙了。虽然醒悟地有些晚，但好歹是想过来了。 即将毕业的我，让自己重新做回一个普通的学生，耐心的学习，安心做毕设，回归一个工科学生对技术所抱有的憧憬之心。 先给自己定一个小目标：让github重新绿起来。欢迎各位监督。 写于2017年3月6日凌晨1点 &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"思考","slug":"思考","permalink":"http://hubojing.github.io/tags/思考/"}]},{"title":"虚拟实验平台比赛项目记录","slug":"虚拟实验平台","date":"2017-02-10T10:27:55.000Z","updated":"2017-02-25T13:29:34.955Z","comments":true,"path":"2017/02/10/虚拟实验平台/","link":"","permalink":"http://hubojing.github.io/2017/02/10/虚拟实验平台/","excerpt":"","text":"&lt;div align=&quot;left&quot;&gt; &lt;img src=&quot;http://7xray0.com1.z0.glb.clouddn.com/hb.jpg&quot; width=&quot;300&quot; height=&quot;180&quot; style=&quot;float:right;&quot;/&gt; 说话算数，许诺的上海决赛详细情况记录。 &lt;/div&gt; &lt;!--more--&gt; 项目名称 数字图像处理教学辅助虚拟实验平台 项目平台 matlab GUI 项目简述 利用matlabGUI可视化，设计一个方便数字图像处理教学的虚拟实验平台，加深学生兴趣，让学生直观了解。 项目框架 虚拟实验平台分为实验主窗口和手写数字识别案例。 原理相关 数字图像处理是通过计算机对图像进行去除噪声、增强、复原、分割、提取特征等处理的方法和技术，它是指将图像信号转换成数字信号并利用计算机对其进行处理的过程。可以用来提高图像的视感质量，提取图像中所包含的某些特征或特殊信息，对图像数据进行变换、编码和压缩，以便于图像的存储和传输。 最近邻插值法 最近邻插值法nearest_neighbor是最简单的灰度值插值。也称作零阶插值，就是令变换后像素的灰度值等于距它最近的输入像素的灰度值。 双三次插值法 双三次插值是一种更加复杂的插值方式，它能创造出比双线性插值更平滑的图像边缘。又叫双立方插值，用于在图像中“插值”（Interpolating）或增加“像素”（Pixel）数量/密度的一种方法。通常利用插值技术增加图形数据，以便在它打印或其他形式输出的时候，能够增大打印面积以及（或者）分辨率。 属性：通过双三次插值可以得到一个连续的插值函数，它的一阶偏导数连续，并且交叉导数处处连续。 公式： 计算系数 的过程依赖于插值数据的特性。如果已知插值函数的导数，常用的方法就是使用四个顶点的高度以及每个顶点的三个导数。一阶导数 与 表示 x 与 y 方向的表面斜率，二阶相互导数 表示同时在 x 与 y 方向的斜率。这些值可以通过分别连续对 x 与 y 向量取微分得到。对于网格单元的每个顶点，将局部坐标（0,0, 1,0, 0,1 和 1,1) 带入这些方程，再解这 16 个方程。 图像增强 1.直方图作用 直方图的观看规则就是“左黑右白”，左边代表暗部，右边代表亮部，而中间则代表中间调。 纵向上的高度代表像素密集程度，越高，代表的就是分布在这个亮度上的像素很多。 2.分为空间域和频域 空域分为点运算和领域去噪 直方图修正属于点运算，平滑和锐化属于领域去噪。 平滑是在添加噪声之后进行的处理 滤波的本义是指信号有各种频率的成分,滤掉不想要的成分,即为滤掉常说的噪声,留下想要的成分.这即是滤波的过程,也是目的。 图像锐化是补偿图像的轮廓，增强图像的边缘及灰度跳变的部分，使图像变得清晰，分为空域处理和频域处理两类。 图像平滑往往使图像中的边界、轮廓变得模糊，为了减少这类不利效果的影响，这就需要利用图像锐化技术，使图像的边缘变的清晰 直方图修正法 分为直方图均衡化和直方图规定化（直方图匹配） 目的：采用直方图修整后可使图像的灰度间距拉开或使灰度分布均匀，从而增大反差，使图像细节清晰，从而增强图像。 直方图均衡化：通过对原图像进行某种变换使原图像的灰度直方图修正为均匀的直方图的一种方法。 直方图规定化：使原图像灰度直方图变成规定形状的直方图而对图像作修正的增强方法。 频域增强 频谱图 图像从圆心到外是由低频到高频的一个过程 同心圆表示在不同方向上的同一频率 而频谱有明暗表示分解成的多个正弦波由于相位的不同叠加后就形成了有大小的分别 而相位不同的正弦波又是由在不同位置的原图像的圆（也是不同位置的频率变化组成的） 图像分割 方法：阈值分割、区域分割、边缘分割、基于特定理论的分割 图像分割方法依照分割时所依据的图像特性不同，大致可以分为四大类。第一类是阈值方法，这种方法是根据图像灰度值得分布特性确定某个阈值来进行图像分割的。第二类为边缘检测方法，这类方法是通过检测出封闭某个区域的边界来进行图像分割的。通俗地讲，这类方法实际上是沿着闭合的边缘线将其包围的区域剪切出来。第三类方法是区域提取方法，这类方法的特点是根据特定区域与其他背景区域特性上的不同来进行图像分割的。另外，还有一种基于形态学的分水岭算法。 阈值分割：基本原理是：通过设定不同的特征阈值，把图像象素点分为若干类。 常用的特征包括：直接来自原始图像的灰度或彩色特征；由原始灰度或彩色值变换得到的特征。 设原始图像为f(x，y)，按照一定的准则f(x，y)中找到特征值T，将图像分割为两个部分，分割后的图像为：若取：b0=0(黑)，b1=1(白)，即为我们通常所说的图像二值化。 直方图阈值双峰法：双峰法是一种简单的阈值分割方法，即如果灰度级直方图呈现明显的双峰状，则选双峰之间的谷底所对应的灰度级作为阈值分割。 均匀性度量法： 均匀性度量法的设计思想是，假设当图像被分为目标物和背景两个类别时，属于同一类别内的像素值分布应该具有均匀性。在这里采用方差来度量像素间的均匀性。设原图像为f(x,y)，结果图像为g(x,y)。 类间最大方差法（Otsu法）： Otsu是一种使类间方差最大的自动确定阈值的方法，该方法具有简单、处理速度快的特点，是一种常用的阈值选取方法。MATLAB中的graythresh函数求取阈值采用的就是Otsu法。 局部阈值法：局部阈值图像分割的原理与全局阈值分割相似，只是在使用之前的程序前，将图像分割成若干子图像进行处理，在处理后，在将各自的结果拼接起来。 边缘检测：最简单的边缘检测方法是边缘检测算子，它利用相邻区域的像素值不连续的性质，采用一阶或二阶导数来检测边缘点。 边缘检测是图像处理和计算机视觉中的基本问题，边缘检测的目的是标识数字图像中亮度变化明显的点。图像属性中的显著变化通常反映了属性的重要事件和变化。 这些包括（i）深度上的不连续、（ii）表面方向不连续、（iii）物质属性变化和（iv）场景照明变化。 边缘检测是图像处理和计算机视觉中，尤其是特征提取中的一个研究领域。 图像分割的意义 图像分割是图像分析的第一步，图像分割接下来的任务，如特征提取、目标识别等的好坏，都取决于图像分割的质量如何。 图像变换 Fourier变换有两个好处，即：可以获得信号的频域特性；可以将卷积运算转换为乘积运算。 因此二维Fourier变换的应用也是根据这两个特点来进行的。 在图像滤波中的应用 首先，我们来看Fourier变换后的图像，中间部分为低频部分，越靠外边频率越高。因此，我们可以在Fourier变换图中，选择所需要的高频或是低频滤波。 离散余弦变换，尤其是它的第二种类型，经常被信号处理和图像处理使用，用于对信号和图像(包括静止图像和运动图像)进行有损数据压缩。这是由于离散余弦变换具有很强的&quot;能量集中&quot;特性:大多数的自然信号(包括声音和图像)的能量都集中在离散余弦变换后的低频部分，而且当信号具有接近马尔科夫过程(Markov processes)的统计特性时，离散余弦变换的去相关性接近于K-L变换(Karhunen-Loève 变换--它具有最优的去相关性)的性能。 图像的形态学 数字图像处理中的形态学处理是指将数字形态学作为工具从图像中提取对于表达和描绘区域形状有用处的图像分量，比如边界、骨架以及凸壳，还包括用于预处理或后处理的形态学过滤、细化和修剪等。图像形态学处理中我们感兴趣的主要是二值图像。 在二值图像中，所有黑色像素的集合是图像完整的形态学描述，二值图像的各个分量是Z2的元素。假定二值图像A和形态学处理的结构元素B是定义在笛卡儿网格上的集合，网格中值为1的点是集合的元素，当结构元素的原点移到点(x,y)时，记为Sxy，为简单起见，结构元素为3x3，且全都为1，在这种限制下，决定输出结果的是逻辑运算。 膨胀和腐蚀这两种操作是形态学处理的基础，许多形态学算法都是以这两种运算为基础的。 开操作是先腐蚀、后膨胀处理。闭操作是先膨胀、后腐蚀处理。 腐蚀和膨胀，看上去好像是一对互逆的操作，实际上，这两种操作不具有互逆的关系。 开运算和闭运算正是依据腐蚀和膨胀的不可逆性，演变而来的。 先腐蚀后膨胀的过程就称为开运算。 闭运算是通过对腐蚀和膨胀的另一种不同次序的执行而得到的， 闭运算是先膨胀后腐蚀的过程，其功能是用来填充物体内细小空洞、连接邻近物体、平滑其边界，同时不明显改变不明显改变其面积。 #相关函数 有关函数的意义 inputdlg 输入对话框 创建一个输入对话框，prompt为提示字符串，title为对话框名称，num_line为显示的行数，defans为默认的数值 imresize 缩放 'nearest'：改变图像尺寸时采用最近邻插值算法； 'bilinear'：采用双线性插值算法； 'bicubic'： 采用双三次插值算法 msgbox 创建对话框 imshow 显示图像 ndims 求一个数组维数 numel 计算数组中满足指定条件的元素个数 若是一幅图像，则numel(A)将给出它的像素数。 I(:,:,1) :在矩阵引用里，表示所有元素。 比如一个二维矩阵A，A(:,1)就表示A的第一列元素。 flipl中提供了许多对矩阵操作的函数，可以实现矩阵的三角矩阵的提取（triu、tril）、矩阵的翻转（flipud、fliplr、Flipdim）和旋转（rot90）等各种操作。 size size(X,1),返回矩阵X的行数； size(X,2),返回矩阵X的列数； N=size(X,2)，就是把矩阵X的列数赋值给N size（）：获取矩阵的行数和列数 （1）s=size(A), 当只有一个输出参数时，返回一个行向量，该行向量的第一个元素时矩阵的行数，第二个元素是矩阵的列数。 （2）[r,c]=size(A), 当有两个输出参数时，size函数将矩阵的行数返回到第一个输出变量r，将矩阵的列数返回到第二个输出变量c。 （3）size(A,n)如果在size函数的输入参数中再添加一项n，并用1或2为n赋值，则 size将返回矩阵的行数或列数。其中r=size(A,1)该语句返回的时矩阵A的行数， c=size(A,2) 该语句返回的时矩阵A的列数。 imrotate 旋转 B = imrotate(A,angle,method,bbox) 将图像A（图像的数据矩阵）绕图像的中心点旋转angle度， 正数表示逆时针旋转， 负数表示顺时针旋转。返回旋转后的图像矩阵。 使用method参数可以改变插值算法，method参数可以为下面这三个值： 'nearest'：最邻近线性插值（Nearest-neighbor interpolation） 'bilinear'： 双线性插值（Bilinear interpolation） 'bicubic'： 双三次插值（或叫做双立方插值）（Bicubic interpolation） bbox参数用于指定输出图像属性： 'crop'： 通过对旋转后的图像B进行裁剪， 保持旋转后输出图像B的尺寸和输入图像A的尺寸一样。 'loose'： 使输出图像足够大， 以保证源图像旋转后超出图像尺寸范围的像素值没有丢失。 一般这种格式产生的图像的尺寸都要大于源图像的尺寸。 imadd 两个图像相加，或者一个图像加上一个常量 imsubstract 两个图像相减，或者一个图像减掉一个常量 immultiply 两个图像相乘，或者一个图像乘上一个常量 imdivide 两个图像相除，或者一个图像除以一个常量 imabsdiff 两个图像的差的绝对值 imcomplement 求一个图像的反色图 inlincomb 求一组图像的线性组合 imadjust 调节灰度图像的亮度或彩色图像的颜色矩阵 histeq 直方图均衡 bar(x,y) 其中x必须是严格递增的且一维向量x和一维向量y长度相同。以一维向量x的值为x坐标，对应的y为y坐标画直方图。 var函数实际上求的并不是方差，而是误差理论中“有限次测量数据的标准偏差的估计值”。 graythresh函数用法：使用最大类间方差法找到图片的一个合适的阈值（threshold）。在使用im2bw函数将灰度图像转换为二值图像时，需要设定一个阈值，这个函数可以帮助我们获得一个合适的阈值。利用这个阈值通常比人为设定的阈值能更好地把一张灰度图像转换为二值图像。 手写归纳 手写数字模块小结 handwrite 1.exit函数，存在即返回非0值，不存在即返回0 2.load template pattern; %将template文件中的pattern加载到工作环境中 3.pattern(1,1).num=0; %pattern是一个数组，这里.num表示样本数量 4.pattern(1,1).feature=[]; %.feature表示特征值（样本） 5.save template pattern; %将pattern保存在template.mat文件中 6.pos0=get(handles.WritingAxes,'currentpoint'); %获取最近一次点击的位置，返回一个2x3的矩阵，矩阵的每行代表一个点的坐标 这两个点的具体含义，和坐标系的投影类型以及鼠标点击位置是否位于坐标系内有关。对于典型情况（正交投影，鼠标点击位于坐标系范围内），可以通过鼠标点击的位置，作一条垂直于屏幕的直线，则该线与坐标系的六个面必然会有两个交点（想象一下，2D坐标系的外框是一个矩形，3D坐标系外框是一个长方体），这两个交点的坐标就是上面所说的pos0，其第一行是靠近观察者的那个面上的点，而第二行是离观察者稍远的那个面上的点。 7.x0=pos0(1,1); %靠近观察者那个面上点的第一个坐标（即x） y0=pos0(1,2); %靠近观察者那个面上点的第一个坐标（即y） 8.line(x,y, 'marker', '.','markerSize',18, 'LineStyle','-','LineWidth',2,'Color','black'); %默认选择黑笔画线，设定点的模型大小，线的模型宽度颜色 9.X=x0:stepX:x; %设定坐标参数，0.1单位 Y=(y-y0)*(X-x0)/(x-x0)+y0; %两点直线方程 11.Img=getframe(handles.WritingAxes); %获取坐标轴内图像 %getframe获得的是一个架构struct类型的数据，其中cdata子域的内容才可以用imwrite内容保存，用Img.cdata表示，是截取区域的数据 12.imwrite(I,'当前手写数字.bmp','bmp'); %将图像数据写入图像文件 13.data=GetFeature(I); %对手写数字进行处理，获取特征向量 14.pattern(1,1).num=pattern(1,1).num+1; %样本容量加一 15.pattern(1,1).feature(:,pattern(1,1).num)=data; %新增样本（保存的是特征向量）放在最后 16.pattern(1,1).num=pattern(1,1).num-1; %样本容量减一 17.pattern(1,1).feature(:,pattern(1,1).num)=[]; %删除倒数第二个 18.set(handles.RecognitionResult,'String',Result); %显示识别结果 feature 1.[row,col]=find(I==0); %返回数字的上下左右的边界 2.I=I(min(row):max(row),min(col):max(col)); %截取手写数字图像，使其紧包含数字边界，不包含多余的空白 3.[row,col]=size(I); %求截取后图像的宽和高，数组的行和列 4.r=fix(row/5); %fix朝0方向取整 5.data=data'; %将当前手写数字的特征向量由行向量变为列向量 BayesTwoValue 1.sum = sum+pattern(1,i).num; %样本总数求和 2.pw(i) = pattern(1,i).num/sum; %每个数字的样本概率,先验概率 3.[maxval,maxpos] = max(pwx); %取后验概率中最大的 %第一个参数是序列中的最大值 第二个参数是最大值在序列中位置 4.Result= maxpos-1; %最大值即为最匹配的数字，其数值为它所处位置序号减一 BayesLeastError 1.[pc_template,pc_data]=pcapro(data); %主成分分析 2.mean_data(i).data=mean(pattern(1,i).feature')'; %求各个类型样品的平均值 %mean(x)表示对列向量x求平均值 3.h(i)=(pc_data-mean_data(i).data)'s_inv(i).data(pc_data-mean_data(i).data)... (-0.5)+log(pw(i))+log(abs(s_det(i)))(-0.5); %判别函数 BayesLeastRisk 1.[minval minpos]=min(risk); %取损失最小的 答辩 我们准备的答辩稿（部分）： 思路： 为更好的协助老师的教学，充实课堂内容，从而设计的辅助教学实验软件，并拓展手写数字识别系统，用来丰富课堂知识。 首先我们选择matlab软件来设计虚拟实验平台，因为大部分工科院校都或多或少 接触过matlab，上手容易。然后由于MatlabGUI强大的可视化界面，让我们决定实现它。一开始我们只设计了手写数字识别，但感觉过于单一，且只涉及到数字图像处理中数字识别模式识别这一块，不够全面，而且学生初学时是从最基本的操作学起，因此，我们根据学习顺序，补充了每一章节的基本实验，使我们的平台更加完善。 遇到的困难： 主要就是程序的问题，这是一个很需要耐心细心的模块，经常会遇到各种奇怪的问题，比如某个功能失效，界面无响应这些，其次就是生成的可执行文件不能很好的适应所有电脑，拓展模块里的手写也可能因为样本的不足出现错误，所以样本的填充也很复杂很需要时间。 作品的优点和缺点： 优点：操作相对简单，界面比较整洁，知识覆盖面广 缺点：可执行文件适应性不够强，部分功能有延迟，没有更详细的解释相关操作的意义，可能还需要一个使用说明的嵌入模块，手写数字模块样本容量不够大。 运用技术： 软件的设计基本上全部由matlab/GUI 完成，并使用其特定的命令生成可执行文件，编程时运用了各种简单或复杂的算法，如缩小放大的最近邻插值法，双三次插值法，图像增强里的直方图均衡化、阈值分割的直方图双峰法、均匀性度量法、otsu法、局部阈值法等等。这对于我们两个没有系统学习过这门课的人来说，还是很具有挑战性。 贝叶斯决策的原理。 贝叶斯决策理论方法是统计模型决策中的一个基本方法，其基本思想是： 已知类条件概率密度参数表达式和先验概率。 利用贝叶斯公式转换成后验概率。 根据后验概率大小进行决策分类。 这个手写识别案例的用处： 是对这门课程的一个拓展，通过对写入的图像灰度化，裁剪，提取特征参数，与贝叶斯决策结合，进行概率分析，匹配，显示最符合的数字，算是部分操作的小应用，同时也涉及到数字图像处理较难的部分：模式识别一块；同时可以用来延伸出车牌识别或人脸识别等更高级的应用系统。 现场老师问了几个问题，回忆了下，有问和PS的区别和项目的意义。 项目获奖 第九届中国计算机设计大赛国家三等奖、中南赛区二等奖 P.S.配图为我设计的作品海报。 &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！ The article has been viewed &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; times.Thank you for your visit! &lt;/span&gt;","raw":null,"content":null,"categories":[{"name":"通信工程","slug":"通信工程","permalink":"http://hubojing.github.io/categories/通信工程/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://hubojing.github.io/tags/matlab/"},{"name":"竞赛","slug":"竞赛","permalink":"http://hubojing.github.io/tags/竞赛/"}]},{"title":"yelee --> hueman主题更换","slug":"hueman主题更换","date":"2017-01-03T09:45:10.000Z","updated":"2017-04-05T09:52:34.845Z","comments":true,"path":"2017/01/03/hueman主题更换/","link":"","permalink":"http://hubojing.github.io/2017/01/03/hueman主题更换/","excerpt":"","text":"&lt;div align=&quot;left&quot;&gt; &lt;img src=&quot;http://7xray0.com1.z0.glb.clouddn.com/17-1-3/18721350-file_1483437231403_721.png&quot; width=&quot;300&quot; height=&quot;180&quot; style=&quot;float:right;&quot;/&gt; 我又双叒叕把博客玩崩了…… 淡定—— &lt;/div&gt; &lt;!--more--&gt; 前两天调双语博客页面失败，顺带着把yelee主题玩垮了。[拆毁天才girl NO.1] MoXFIVE也很久没有更新yelee的文档了，索性我就换了个主题。现在的主题是hueman。 换个主题就仿佛整个人都整容了一样→_→什么都要变！ 改config，调样式，换logo，整个人都不好了！ hueman很漂亮，优点突出，但对比yelee，也有一些缺点，例如：没有网站计数，没有文章目录等。 把折腾几个小时的成果记录一下，方便以后接着折腾[手动滑稽]。 主题文档 https://github.com/ppoffice/hexo-theme-hueman/wiki 更改背景 hueman\\source\\css_partial\\header.styl 12-background: color-header-background+ background-image: url(\"地址\") 记得把footer里的背景也给改了，对称美！ 更换logo hueman\\source\\css\\images 把logo-header.png更换为自己的logo。 我在网上随便在线生成了个艺术字就贴上来了…… #加入网站计数 \\themes\\hueman\\layout\\common\\footer.ejs 和yelee一样，交给不蒜子[http://ibruce.info/2015/04/04/busuanzi/] 。 安装脚本 12&lt;script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; 安装标签 1.显示站点总访问量 要显示站点总访问量，复制以下代码添加到你需要显示的位置。有两种算法可选： 算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。 123&lt;span id=\"busuanzi_container_site_pv\"&gt; 本站总访问量&lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt;次&lt;/span&gt; 算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。 123&lt;span id=\"busuanzi_container_site_uv\"&gt; 本站访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人次&lt;/span&gt; 2.显示单页面访问量 要显示每篇文章的访问量，复制以下代码添加到你需要显示的位置。 算法：pv的方式，单个用户点击1篇文章，本篇文章记录1次阅读量。 123&lt;span id=\"busuanzi_container_page_pv\"&gt; 本文总阅读量&lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt;次&lt;/span&gt; 后续待解决（欢迎各位大神们给建议）： 1.文章目录问题（不知道在哪里改，toc怎么调用，&lt;%- toc(str, [options]) %&gt;需点拨） 2.博客内搜索问题（insight插件总是安装失败，估计是node版本问题，可是有点不敢动node，害怕博客又崩了(瑟瑟发抖.jpg)） 3.分类顺序问题（应该是互联网、通信工程、杂谈，不知道为什么成了互联网、杂谈、通信工程） 4.文章浏览量丢失（蓝瘦香菇…） 5.双语页面问题（就是不！死！心！） 6.微言板块（类似空间的说说，每条下面可以评论，未来会把自己的问题放在这里，等待高手解答） …… &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"http://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://hubojing.github.io/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"http://hubojing.github.io/tags/hexo/"},{"name":"主题","slug":"主题","permalink":"http://hubojing.github.io/tags/主题/"}]},{"title":"一天一点linux","slug":"linux整理笔记","date":"2016-12-26T15:31:29.000Z","updated":"2017-01-22T14:16:25.415Z","comments":true,"path":"2016/12/26/linux整理笔记/","link":"","permalink":"http://hubojing.github.io/2016/12/26/linux整理笔记/","excerpt":"","text":"&lt;div align=&quot;left&quot;&gt; &lt;img src=&quot;http://img.mukewang.com/55ece9d70001fb7f06000375.jpg&quot; width=&quot;300&quot; height=&quot;180&quot; style=&quot;float:right;&quot;/&gt; 从头学linux，为后续学习打基础。 笔记整理，一天一点linux。 &lt;/div&gt; &lt;!--more--&gt; 基本概念及操作 Linux 桌面环境介绍 相对于现在的 Windows 系统，UNIX/Linux 本身是没有图形界面的，我们通常在 Unix/Linux 发行版上看到的图形界面实际都只是运行在 Linux 系统之上的一套软件，类似 Windows95 之前的Windows 的图形界面实则也只是运行在 DOS 环境的一套软件。而 Linux 上的这套软件以前是XFree86，现在则是 xorg（X.Org），而这套软件又是通过 X 窗口系统（X Window System，也常被称为X11或X）实现的，X 本身只是工具包及架构协议，而 xorg 便是 X 架构规范的一个实现体，也就是说它是实现了 X 协议规范的一个提供图形用户界面服务的服务器，就像实现了 http 协议提供 web 服务的 Apache。如果只有服务器也是不能实现一个完整的桌面环境的，当然还需要一个客户端，我们称为 X Client，像如下几个大家熟知也最流行的实现了客户端功能的桌面环境KDE，GNOME，XFCE，LXDE。这也意味着在 Linux 上你可以自己选择安装不同的桌面环境，甚至可以定制自己的专属桌面。 Linux终端 Terminal（终端） 通常在我们使用 Linux 时，我们并不是直接与系统打交道，而是通过一个叫做 Shell 的中间程序来完成的，在图形界面下为了实现让我们在一个窗口中完成接受用户输入和显示输出，Linux 系统还提供了一个叫做终端模拟器的程序（Terminal），下面几个比较常见的终端模拟器，例如 gnome-terminal，kconsole，xterm，rxvt，kvt，nxterm 和 eterm。 终端本质上是对应着 Linux 上的 /dev/tty 设备，Linux 的多用户登陆就是通过不同的 /dev/tty 设备完成的，Linux 默认提供了 6 个纯命令行界面的 “terminal”（准确的说这里应该是 6 个 virtual consoles）来让用户登录，在物理机系统上你可以通过使用[Ctrl]+[Alt]+[F1]～[F6]进行切换，不过在我们的在线实验环境中可能无法切换，因为特殊功能按键会被你主机系统劫持。当你切换到其中一个终端后想要切换回图形界面，你可以按下[Ctrl]+[Alt]+[F7]来完成。 Shell 通常在图形界面中对实际体验带来差异的不是上述的不同发行版的各种终端模拟器，而大都是这个 Shell（壳），有壳就有核，这里的核就是指的 UNIX/Linux 内核，Shell 是指“提供给使用者使用界面”的软件（命令解析器），类似于 DOS 下的 command（命令行）和后来的 cmd.exe。普通意义上的 Shell 就是可以接受用户输入命令的程序。它之所以被称作 Shell 是因为它隐藏了操作系统底层的细节。同样的 Unix/Linux 下的图形用户界面 GNOME 和 KDE，有时也被叫做“虚拟 shell”或“图形 shell”。 Unix/Linux 操作系统下的 Shell 既是用户交互的界面，也是控制系统的脚本语言。当然在这点也有别于 Windows 下的命令行，虽然也提供了很简单的控制语句。在Windows 操作系统下，可能有些用户从来都不会直接的使用 Shell，然而在 UNIX 系列操作系统下，Shell 仍然是控制系统启动、X11 启动和很多其他实用工具的脚本解释程序。 在 UNIX/Linux 中比较流行的常见的 Shell 有 bash，zsh，ksh，csh 等等，Ubuntu 终端默认使用的是 bash，默认的桌面环境是 GNOME 或者 Unity（基于 GNOME）。 命令行操作 重要快捷键 Tab 补全命令、目录、参数 Ctrl+c 强行终止当前程序（不会使终端退出） Ctrl+d 键盘输入结束或退出终端 Ctrl+s 暂停当前程序，暂停后按下任意键恢复运行 Ctrl+z 将当前程序放到后台运行，恢复到前台为命令fg Ctrl+a 将光标移至输入行头，相当于Home键 Ctrl+e 将光标移至输入行末，相当于End键 Ctrl+k 删除从光标所在位置到行末 Alt+Backspace 向前删除一个单词 Shift+PgUp 将终端显示向上滚动 Shift+PgDn 将终端显示向下滚动 历史输入命令： 方向键 上 通配符：星号（*）和问号（?），用来对对字符串进行模糊匹配（比如文件名，参数名）。当查找文件夹时，可以使用它来代替一个或多个真正字符；当不知道真正字符或者懒得输入完整名字时，常常使用通配符代替一个或多个真正的字符。 一次性创建多个文件 在创建文件的时候，如果需要一次性创建多个文件，比如：“love_1_linux.txt，love_2_linux.txt，... love_10_linux.txt”。在 Linux 中十分方便： 1$ touch love_&#123;1..10&#125;_linux.txt Shell 常用通配符 字符 含义 匹配 0 或多个字符 ? 匹配任意一个字符 [list] 匹配 list 中的任意单一字符 [!list] 匹配 除list 中的任意单一字符以外的字符 [c1-c2] 匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z] {string1,string2,...} 匹配 sring1 或 string2 (或更多)其一字符串 {c1..c2} 匹配 c1-c2 中全部字符 如{1..10} 在命令行中获取帮助 man 命令 Manual pages 是在 UNIX 或类 UNIX 操作系统在线软件文档的一种普遍的形式。 内容包括计算机程序（包括库和系统调用），正式的标准和惯例，甚至是抽象的概念。用户可以通过执行 man 命令调用手册页。 你可以使用如下方式来获得某个命令的说明和使用方式的详细介绍： $ man &lt;command_name&gt; 比如你想查看 man 命令本身的使用方式，你可以输入： man man 通常情况下，man 手册里面的内容都是英文的，这就要求你有一定的英文基础。man 手册的内容很多，涉及了 Linux 使用过程中的方方面面，为了便于查找，是做了分册（分区段）处理的，在Research UNIX、BSD、OS X 和 Linux 中，手册通常被分为8个区段，安排如下： 区段 说明 1 一般命令 2 系统调用 3 库函数，涵盖了C标准函数库 4 特殊文件（通常是/dev中的设备）和驱动程序 5 文件格式和约定 6 游戏和屏保 7 杂项 8 系统管理命令和守护进程 要查看相应区段的内容，就在 man 后面加上相应区段的数字即可，如： 1$ man 1 ls 会显示第一区段中的ls命令man页面。 所有的手册页遵循一个常见的布局，其为通过简单的 ASCII 文本展示而优化，而这种情况下可能没有任何形式的高亮或字体控制。一般包括以下部分内容： NAME（名称） 该命令或函数的名称，接着是一行简介。 SYNOPSIS（概要） 对于命令，正式的描述它如何运行，以及需要什么样的命令行参数。对于函数，介绍函数所需的参数，以及哪个头文件包含该函数的定义。 DESCRIPTION（说明） 命令或函数功能的文本描述。 EXAMPLES（示例） 常用的一些示例。 SEE ALSO（参见） 相关命令或函数的列表。 也可能存在其他部分内容，但这些部分没有得到跨手册页的标准化。常见的例子包括：OPTIONS（选项），EXIT STATUS（退出状态），ENVIRONMENT（环境），BUGS（程序漏洞），FILES（文件），AUTHOR（作者），REPORTING BUGS（已知漏洞），HISTORY（历史）和COPYRIGHT（版权）。 通常 man 手册中的内容很多，不容易找到想要的结果，可以在 man 中使用搜索，/&lt;要搜索的关键字&gt;，查找到后使用n键切换到下一个关键字所在处，shift+n为上一个关键字所在处。使用Space(空格键)翻页，Enter(回车键)向下滚动一行，或者使用j,k（vim编辑器的移动键）进行向前向后滚动一行。按下h键为显示使用帮助(因为man使用less作为阅读器，实为less工具的帮助)，按下q退出。 想要获得更详细的帮助，使用info命令，不过通常使用man足够。如果知道某个命令的作用，只是想快速查看一些它的某个具体参数的作用，使用--help参数，大部分命令都会带有这个参数，如： 1$ ls --help 用户及文件权限管理 Linux 用户管理 Linux 是一个可以实现多用户登陆的操作系统。 查看用户 12345$ who am i或者$ who mom likes who 命令其它常用参数 参数 说明 -a 打印能打印的全部 -d 打印死掉的进程 -m 同am i,mom likes -q 打印当前登录用户数及用户名 -u 打印当前登录用户登录信息 -r 打印运行等级 创建用户 在 Linux 系统里， root 账户拥有整个系统至高无上的权利，比如 新建/添加 用户。 su，su- 与 sudo su &lt;user&gt;可以切换到用户user，执行时需要输入目标用户的密码，sudo &lt;cmd&gt;可以以特权级别运行cmd命令，需要当前用户属于sudo组，且需要输入当前用户密码。su - &lt;user&gt;命令也是切换用户，同时环境变量也会跟着改变成目标用户的环境变量。 新建一个叫 lilei 的用户： 1$ sudo adduser lilei 这个命令不但可以添加用户到系统，同时也会默认为新用户创建 home 目录： $ ls /home 现在你已经创建好一个用户，并且你可以使用你创建的用户登录了，使用如下命令切换登录用户： $ su -l lilei 输入刚刚设置的 lilei 的密码。退出当前用户跟退出终端一样可以使用 exit 命令或者使用快捷键 Ctrl+d。 用户组 每个用户都有一个归属（用户组），用户组简单地理解就是一组用户的集合，它们共享一些资源和权限，同时拥有私有资源，就跟家的形式差不多，你的兄弟姐妹（不同的用户）属于同一个家（用户组），你们可以共同拥有这个家（共享资源），爸妈对待你们都一样（共享权限），你偶尔写写日记，其他人未经允许不能查看（私有资源和权限）。当然一个用户是可以属于多个用户组的，正如你既属于家庭，又属于学校或公司。 知道自己属于哪些用户组的方法 方法一：使用groups命令 1$ groups nancy 每次新建用户如果不指定用户组的话，默认会自动创建一个与用户名相同的用户组（差不多就相当于家长的意思，或者说是老总）。默认情况下在sudo用户组里的可以使用sudo命令获得root权限。 方法二：查看/etc/group文件 1$ cat /etc/group | sort cat 命令用于读取指定文件的内容并打印到终端输出。| sort 表示将读取的文本进行一个字典排序再输出。使用命令过滤掉一些你不想看到的结果： 1$ cat /etc/group | grep -E \"nancy\" etc/group 文件格式说明 /etc/group 的内容包括用户组（Group）、用户组口令、GID 及该用户组所包含的用户（User），每个用户组一条记录。格式如下： group_name:password:GID:user_list 你看到上面的 password 字段为一个 'x' 并不是说密码就是它，只是表示密码不可见而已。 将其它用户加入 sudo 用户组 默认情况下新创建的用户是不具有 root 权限的，也不在 sudo 用户组，可以让其加入sudo用户组从而获取 root 权限。 12$ su -l lilei$ sudo ls 使用 usermod 命令可以为用户添加用户组，同样使用该命令你必需有 root 权限，你可以直接使用 root 用户为其它用户添加用户组，或者用其它已经在 sudo 用户组的用户使用 sudo 命令获取权限来执行该命令。 用 nancy 用户执行 sudo 命令将 lilei 添加到 sudo 用户组，让它也可以使用 sudo 命令获得 root 权限 $ su nancy # 此处需要输入nancy用户密码，可以点击右侧工具栏中的“SSH直连”查看 $ groups lilei $ sudo usermod -G sudo lilei $ groups lilei 然后你再切换回 lilei 用户，现在就可以使用 sudo 获取 root 权限了。 删除用户 1$ sudo deluser lilei --remove-home Linux 文件权限 查看文件权限 使用较长格式列出文件： 1$ ls -l Linux 里面一切皆文件。 ls 命令的一些其它常用的用法： 显示除了 '.'(当前目录)，'..' 上一级目录之外的所有包含隐藏文件（Linux 下以 '.' 开头的文件为隐藏文件） 1$ ls -A 可以同时使用 '-A' 和 '-l' 参数： 1$ ls -Al 查看某一个目录的完整属性，而不是显示目录里面的文件属性： 1$ ls -dl &lt;目录名&gt; 显示所有文件大小，并以普通人类能看懂的方式呈现： 1$ ls -AsSh 其中小 s 为显示文件大小，大 S 为按文件大小排序，若需要知道如何按其它方式排序，使用“man”命令查询。 变更文件所有者 假设目前是 lilei 用户登录，新建一个文件，命名为 “iphone6”： $ touch iphone6 可见文件所有者是 lilei 。 现在，换回到nancy用户身份，使用以下命令变更文件所有者为 nancy ： $ cd /home/lilei $ ls iphone6 $ sudo chown nancy iphone6 $ cp iphone6 /home/nancy 现在查看，发现 文件所有者成功修改为 nancy 。 修改文件权限 方式一：二进制数字表示 每个文件的三组权限（拥有者，所属用户组，其他用户,记住这个顺序是一定的）就对应这一个 &quot;rwx&quot;，也就是一个 '7'。 1$ echo \"echo \\\"hello nancy\\\"\" &gt; iphone6 然后修改权限： 1$ chmod 700 iphone6 现在，其他用户已经不能读这个“iphone6”文件了 方式二：加减赋值操作 完成上述相同的效果： 1$ chmod go-rw iphone6 'g''o'还有'u'，分别表示group，others，user，'+'，'-' 就分别表示增加和去掉相应的权限。 Linux 目录结构及文件基本操作 Linux 目录结构 Linux 是以树形目录结构的形式来构建整个系统的，可以理解为一个用户可操作系统的骨架。虽然本质上无论是目录结构还是操作系统内核都是存储在磁盘上的，但从逻辑上来说 Linux 的磁盘是“挂在”（挂载在）目录上的，每一个目录不仅能使用本地磁盘分区的文件系统，也可以使用网络上的文件系统。举例来说，可以利用网络文件系统（Network File System，NFS）服务器载入某特定目录等。 FHS 标准 FHS 定义了两层规范，第一层是， / 下面的各个目录应该要放什么文件数据，例如 /etc 应该要放置设置文件，/bin 与 /sbin 则应该要放置可执行文件等等。 第二层则是针对 /usr 及 /var 这两个目录的子目录来定义。例如 /var/log 放置系统登录文件、/usr/share 放置共享数据等等。 目录路径 cd 切换目录， . 表示当前目录，.. 表示上一级目录（以 . 开头的文件都是隐藏文件，所以这两个目录必然也是隐藏的， ls -a 命令查看隐藏文件）, - 表示上一次所在目录，～ 通常表示当前用户的&quot;home&quot;目录。使用 pwd 命令可以获取当前所在路径（绝对路径）。 进入上一级目录： 1$ cd .. 进入你的“home”目录： 12$ cd ~ # 或者 cd /home/&lt;你的用户名&gt; 使用 pwd 获取当前路径： 1$ pwd 绝对路径 以根&quot;/&quot;目录为起点的完整路径，以你所要到的目录为终点，表现形式如： /usr/local/bin，表示根目录下的 usr 目录中的 local 目录中的 bin 目录。 相对路径 相对于当前的目录的路径，相对路径是以当前目录 . 为起点，以所要到的目录为终点，表现形式如： usr/local/bin （这里假设当前目录为根目录）。表示相对路径实际并没有加上表示当前目录的那个 . ，而是直接以目录名开头，因为这个 usr 目录为 / 目录下的子目录，是可以省略 . 的（也有类似不能省略的情况）；如果是当前目录的上一级目录，则需要使用 .. ，比如当前目录为“home”目录，根目录就应该表示为 ../../ ,表示上一级目录（&quot;home&quot;目录）的上一级目录（&quot;/&quot;目录）。 以&quot;home&quot;目录为起点，分别以绝对路径和相对路径的方式进入 /usr/local/bin 目录： 1234# 绝对路径$ cd /usr/local/bin# 相对路径$ cd ../../usr/local/bin 在进行目录切换的过程中请多使用 Tab 键自动补全，可避免输入错误，连续按两次Tab可以显示全部候选结果。 Linux 文件的基本操作 新建 新建空白文件 使用 touch 命令创建空白文件，关于 touch 命令，其主要是来更改已有文件的时间戳的（比如，最近访问时间，最近修改时间），但其在不加任何参数的情况下，只指定一个文件名，则可以创建一个为指定文件名的空白文件（不会覆盖已有同名文件），当然你也可以同时指定该文件的时间戳。 创建名为 test 的空白文件，因为在其他目录没有权限，所以需要先 cd ~ 切换回用户的 /home/nancy 目录： 12$ cd ~$ touch test 新建目录 使用 mkdir（make directories）命令可以创建一个空目录,也可同时指定创建目录的权限属性 创建名为&quot;mydir&quot;的空目录： 1$ mkdir mydir 使用 -p 参数，同时创建父目录（如果不存在该父目录），如下同时创建一个多级目录（这在有时候安装软件，配置安装路径时非常有用）： 1$ mkdir -p father/son/grandson 后面的目录路径，以绝对路径的方式表示也是可以的。 复制 使用cp（copy）命令复制一个文件或目录到指定目录。将之前创建的&quot;test&quot;文件复制到&quot;/home/nancy/father/son/grandson&quot;目录中： 1$ cp test father/son/grandson 复制目录 要成功复制目录需要加上-r或者-R参数，表示递归复制，就是说有点“株连九族”的意思： 1$ cp -r father family 删除 删除文件 使用rm（remove files or directories）命令，删除一个文件或目录： 1$ rm test 有时候你会遇到想要删除一些为只读权限的文件，直接使用rm删除会显示一个提示,你如果想忽略这提示，直接删除文件，可以使用-f参数强制删除： 1$ rm -f test 删除目录 跟复制目录一样，要删除一个目录，也需要加上-r或-R参数： 1$ rm -r family 移动文件与文件重命名 移动文件 使用mv(move or rename files)命令，移动文件（剪切）。将文件&quot;file1&quot;移动到&quot;Documents&quot;目录mv 源目录文件 目的目录： 12$ mkdir Documents$ mv file1 Documents 重命名文件 将文件&quot;file1&quot;重命名为&quot;myfile&quot; mv 旧的文件名 新的文件名： 1$ mv file1 myfile 批量重命名 12345678# 使用通配符批量创建 5 个文件$ touch file&#123;1..5&#125;.txt# 批量将这 5 个后缀为 .txt 的文本文件重命名为以 .c 为后缀的文件$ rename 's/\\.txt/\\.c/' *.txt# 批量将这 5 个文件，文件名改为大写$ rename 'y/a-z/A-Z/' *.c 简单解释下上面的命令，rename是先使用第二个参数的通配符匹配所有后缀为.txt的文件，然后使用第一个参数提供的正则表达式将匹配的这些文件的.txt后缀替换为.c 。 查看文件 使用cat,tac和nl命令查看文件 打印文件内容到标准输出（终端）,其中cat为正序显示，tac倒序显示。 查看之前从&quot;/etc&quot;目录下拷贝来的passwd文件： 1$ cat passwd 可以加上-n参数显示行号： 1$ cat -n passwd nl命令，添加行号并打印，这是个比cat -n更专业的行号打印命令。 它的常用的几个参数： 12345678-b : 指定添加行号的方式，主要有两种： -b a:表示无论是否为空行，同样列出行号(\"cat -n\"就是这种方式) -b t:只列出非空行的编号并列出（默认为这种方式）-n : 设置行号的样式，主要有三种： -n ln:在行号字段最左端显示 -n rn:在行号字段最右边显示，且不加 0 -n rz:在行号字段最右边显示，且加 0-w : 行号字段占用的位数(默认为 6 位) 使用more和less命令分页查看文件 其中more命令比较简单，只能向一个方向滚动，而&quot;less&quot;为基于&quot;more&quot;和&quot;vi&quot;(编辑器)开发，功能更强大。less 的使用基本和 more 一致。 使用more工具打开passwd文件： 1$ more passwd 打开后默认只显示一屏内容，终端底部显示当前阅读的进度(百分比)。可以使用Enter键向下滚动一行，使用Space键向下滚动一屏，按下h显示帮助，q退出。 使用head和tail命令查看文件 head是只查看的头几行（默认为10行，不足10行则显示全部），tail是查看尾几行。 1$ tail /etc/passwd 甚至更直接的只看一行， 加上-n参数，后面紧跟行数： 1$ tail -n 1 /etc/passwd 参数-f，这个参数可以实现不停地读取某个文件的内容并显示。这可让我们动态查看日志起到实时监视的作用。 查看文件类型 在 Linux 下面文件的类型不是根据文件后缀来判断的，我们通常使用file命令可以查看文件的类型： 1$ file /bin/ls 编辑文件 Linux 内部的 vim 学习教程，输入如下命令即可开始： 1$ vimtutor 环境变量与文件查找 环境变量 变量 准确的说应该是 Shell 变量，所谓变量就是计算机中用于记录一个值（不一定是数值，也可以是字符或字符串）的符号，而这些符号将用于不同的运算处理中。 在 Shell 中如何创建一个变量，如何给变量赋值和如何读取变量的值呢？ 使用declare命令创建一个变量名为 tmp 的变量： 1$ declare tmp 使用=号赋值运算符为变量 tmp 赋值为 nancy： 1$ tmp=nancy 读取变量的值，使用echo命令和$符号（$符号用于表示引用一个变量的值，初学易忘）： 1$ echo $tmp 注意:关于变量名，并不是任何形式的变量名都是可用的，变量名只能是英文字母,数字或者下划线，且不能以数字作为开头。 环境变量 环境变量就是作用域比自定义变量要大，如Shell 的环境变量作用于自身和它的子进程。在所有的 UNIX 和类 UNIX 系统中，每个进程都有其各自的环境变量设置，且默认情况下，当一个进程被创建时，处理创建过程中明确指定的话，它将继承其父进程的绝大部分环境设置。Shell 程序也作为一个进程运行在操作系统之上，而在 Shell中运行的大部分命令都将以 Shell 的子进程的方式运行。 通常会涉及到的环境变量有三种： 当前 Shell 进程私有用户自定义变量，如上面我们创建的 temp 变量，只在当前 Shell 中有效。 Shell 本身内建的变量。 从自定义变量导出的环境变量。 也有三个与上述三种环境变量相关的命令，set，env，export。这三个命令都可用于打印相关环境变量,区别在于涉及的是不同范围的环境变量，详见下表： 命令 说明 set 显示当前 Shell 所有环境变量，包括其内建环境变量（与 Shell 外观等相关），用户自定义变量及导出的环境变量 env 显示与当前用户相关的环境变量，还可以让命令在指定环境中运行 export 显示从 Shell 中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量 关于环境变量，可以简单的理解成在当前进程的子进程是否有效，有效则为环境变量，否则不是（有人也将所有变量统称为环境变量，只是以全局环境变量和局部环境变量进行区分，只要理解它们的实质区别即可）。 注意：为了与普通变量区分，通常我们习惯将环境变量名设为大写。 命令的查找路径与顺序 Shell 中输入一个命令，Shell 是通过环境变量PATH来进行搜索去找到这个命令然后执行的。Windows 中的也是有这么一个 PATH 环境变量。这个PATH里面就保存了Shell中执行的命令的搜索路径。 查看PATH环境变量的内容： 1$ echo $PATH 默认情况下有输出： 1/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games 通常这一类目录下放的都是可执行文件，当我们在 Shell 中执行一个命令时，系统就会按照 PATH 中设定的路径按照顺序依次到目录中去查找，如果存在同名的命令，则执行先找到的那个。 练习创建一个最简单的可执行 Shell 脚本和一个使用 C 语言创建的&quot;hello world&quot;程序。 创建一个 Shell 脚本文件： 1$ vim hello_shell.sh 在脚本中添加如下内容，保存并退出（注意不要省掉第一行）： 1234567#!/bin/zshfor ((i=0; i&lt;10; i++));do echo \"hello shell\"doneexit 0 为文件添加可执行权限： 1$ chmod 755 hello_shell.sh 执行脚本 1$ ./hello_shell.sh 创建一个 C 语言&quot;hello world&quot;程序： 1$ vim hello_world.c 1234567#include &lt;stdio.h&gt;int main(void)&#123; printf(\"hello world!\\n\"); return 0;&#125; 使用 gcc 生成可执行文件： 1$ gcc -o hello_world hello_world.c gcc 生成二进制文件默认具有可执行权限，不需要修改 在 nancy 家目录创建一个mybin目录，并将上述 hello_shell.sh 和 hello_world 文件移动到其中： 12$ mkdir mybin$ mv hello_shell.sh hello_world mybin/ 在mybin目录中分别运行刚刚创建的两个程序： 123$ cd mybin$ ./hello_shell.sh$ ./hello_world 回到上一级目录，也就是nancy家目录，当再想运行那两个程序时，会发现提示命令找不到，除非加上命令的完整路径，但那样很不方便，要做到想使用系统命令一样执行自己创建的脚本文件或者程序，那就要将命令所在路径添加到PATH环境变量了。 添加自定义路径到“PATH”环境变量 PATH里面的路径是以：作为分割符，可这样添加自定义路径： 1$ PATH=$PATH:/home/shiyanlou/mybin 注意这里一定要使用绝对路径。 可以在其他任意目录执行那两个命令了（注意需要去掉前面的./）。这给 PATH 环境变量追加了一个路径，它也只是在当前 Shell 有效，一旦退出终端，再打开就会发现又失效了。 让添加的环境变量全局有效或者每次启动 Shell 时自动执行上面添加自定义路径到 PATH 的命令——后一种方式——让它自动执行。 在每个用户的 home 目录中有一个 Shell 每次启动时会默认执行一个配置脚本，以初始化环境，包括添加一些用户自定义环境变量等等。zsh 的配置文件是.zshrc，相应 Bash 的配置文件为.bashrc。它们在etc下还都有一个或多个全局的配置文件，不过一般只修改用户目录下的配置文件。 简单的使用下面命令直接添加内容到.zshrc中： 1$ echo \"PATH=$PATH:/home/shiyanlou/mybin\" &gt;&gt; .zshrc 上述命令中&gt;&gt;表示将标准输出以追加的方式重定向到一个文件中，注意前面用到的&gt;是以覆盖的方式重定向到一个文件中，使用的时候一定要注意分辨。在指定文件不存在的情况下都会创建新的文件。 修改和删除已有变量 变量修改 变量的修改有以下几种方式： 变量设置方式 说明 ${变量名#匹配字串} 从头向后开始匹配，删除符合匹配字串的最短数据 ${变量名##匹配字串} 从头向后开始匹配，删除符合匹配字串的最长数据 ${变量名%匹配字串} 从尾向前开始匹配，删除符合匹配字串的最短数据 ${变量名%%匹配字串} 从尾向前开始匹配，删除符合匹配字串的最长数据 ${变量名/旧的字串/新的字串} 将符合旧字串的第一个字串替换为新的字串 ${变量名//旧的字串/新的字串} 将符合旧字串的全部字串替换为新的字串 比如要修改前面添加到 PATH 的环境变量。为了避免操作失误导致命令找不到，先将 PATH 赋值给一个新的自定义变量 path： 12345$ path=$PATH$ echo $path$ path=$&#123;path%/home/shiyanlou/mybin&#125;# 或使用通配符,*表示任意多个任意字符$ path=$&#123;path%*/mybin&#125; 变量删除 可以使用unset命令删除一个环境变量： 1$ unset temp 如何让环境变量立即生效 上面在Shell 中修改了一个配置脚本文件之后（比如 zsh 的配置文件 home 目录下的.zshrc），每次都要退出终端重新打开甚至重启主机之后其才能生效，很麻烦，使用source命令来让其立即生效，如： 1$ source .zshrc source命令还有一个别名就是.，注意与表示当前路径的那个点区分开，虽然形式一样，但作用和使用方式一样，上面的命令如果替换成.的方式就该是 1$ . ./.zshrc 注意第一个点后面有一个空格，而且后面的文件必须指定完整的绝对或相对路径名，source 则不需要。 搜索文件 与搜索相关的命令常用的有如下几个whereis,which,find,locate。 whereis简单快速 1$whereis who whereis只能搜索二进制文件(-b)，man帮助文件(-m)和源代码文件(-s)。如果想要获得更全面的搜索结果可用locate命令。 locate快而全 通过&quot;/var/lib/mlocate/mlocate.db&quot;数据库查找，不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行updatedb命令更新一次，所以有时刚添加的文件，它可能会找不到，需要手动执行一次updatedb命令（在我们的环境中必须先执行一次该命令）。它可以用来查找指定目录下的不同文件类型，如查找 /etc 下所有以 sh 开头的文件： 1$ locate /etc/sh 注意,它不只是在 etc 目录下查找并会自动递归子目录进行查找。 查找 /usr/share/ 下所有 jpg 文件： 1$ locate /usr/share/\\*.jpg 注意要添加号前面的反斜杠转义，否则会无法找到。* 如果想只统计数目可以加上-c参数，-i参数可以忽略大小写进行查找，whereis 的-b,-m，-s同样可以是使用。 which小而精 which本身是 Shell 内建的一个命令，通常使用which来确定是否安装了某个指定的软件，因为它只从PATH环境变量指定的路径中去搜索命令： 1$ which man find精而细 find应该是这几个命令中最强大的了，它不但可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索。 在指定目录下搜索指定文件名的文件： 1$ find /etc/ -name interfaces **注意 find 命令的路径是作为第一个参数的， 基本命令格式为 find [path] [option] [action] ** 与时间相关的命令参数： 参数 说明 -atime 最后访问时间 -ctime 创建时间 -mtime 最后修改时间 下面以-mtime参数举例： -mtime n: n 为数字，表示为在n天之前的”一天之内“修改过的文件 -mtime +n: 列出在n天之前（不包含n天本身）被修改过的文件 -mtime -n: 列出在n天之内（包含n天本身）被修改过的文件 newer file: file为一个已存在的文件，列出比file还要新的文件名 列出 home 目录中，当天（24 小时之内）有改动的文件： 1$ find ~ -mtime 0 列出用户家目录下比Code文件夹新的文件： 1$ find ~ -newer /home/shiyanlou/Code 《黑客帝国》电影里满屏幕代码的“数字雨”，在 Linux 里面也可以轻松实现这样的效果，只需要一个命令cmatrix。 需要先安装，因为 Ubuntu 没有预装： 1$ sudo apt-get update;sudo apt-get install cmatrix 文件打包与解压缩 文件打包和解压缩 在 Windows 上最常见的不外乎这三种*.zip,.rar,.7z后缀的压缩文件，而在 Linux 上面常见常用的除了以上这三种外，还有*.gz,.xz,.bz2,.tar,.tar.gz,*.tar.xz,*tar.bz2，简单介绍如下： 文件后缀名 说明 *.zip zip程序打包压缩的文件 *.rar rar程序压缩的文件 *.7z 7zip程序压缩的文件 *.tar tar程序打包，未压缩的文件 *.gz gzip程序(GNU zip)压缩的文件 *.xz xz程序压缩的文件 *.bz2 bzip2程序压缩的文件 *.tar.gz tar打包，gzip程序压缩的文件 *.tar.xz tar打包，xz程序压缩的文件 *tar.bz2 tar打包，bzip2程序压缩的文件 *.tar.7z tar打包，7z程序压缩的文件 zip压缩打包程序 使用zip打包文件夹： 123$ zip -r -q -o nancy.zip /home/nancy$ du -h nancy.zip$ file nancy.zip 上面命令将 nancy 的 home 目录打包成一个文件，并查看了打包后文件的大小和类型。-r参数表示递归打包包含子目录的全部内容，-q参数表示为安静模式，即不向屏幕输出信息，-o，表示输出文件，需在其后紧跟打包输出文件名。后面使用du命令查看打包后文件的大小。 设置压缩级别为9和1（9最大,1最小），重新打包： 12$ zip -r -9 -q -o nancy_9.zip /home/nancy -x ~/*.zip$ zip -r -1 -q -o nancy_1.zip /home/nancy -x ~/*.zip 这里添加了一个参数用于设置压缩级别-[1-9]，1表示最快压缩但体积大，9表示体积最小但耗时最久。最后那个-x是为了排除我们上一次创建的 zip 文件，否则又会被打包进这一次的压缩文件中，注意:这里只能使用绝对路径，否则不起作用。 我们再用du命令分别查看默认压缩级别、最低、最高压缩级别及未压缩的文件的大小： 1$ du -h -d 0 *.zip ~ | sort 通过man 手册可知： h, --human-readable（顾名思义，你可以试试不加的情况） d, --max-depth（所查看文件的深度） 在环境中操作之后看到的大小可能跟图上的有些不同，因为在使用过程中，会随时还生成一些缓存文件在当前用户的家目录中，这对于学习命令使用来说，是无关紧要的，可以忽略这些不同。 创建加密zip包 使用-e参数可以创建加密压缩包： 1$ zip -r -e -o nancy_encryption.zip /home/nancy 注意: 关于zip命令，因为 Windows 系统与 Linux/Unix 在文本文件格式上的一些兼容问题，比如换行符（为不可见字符），在 Windows 为 CR+LF（Carriage-Return+Line-Feed：回车加换行），而在 Linux/Unix 上为 LF（换行），所以如果在不加处理的情况下，在 Linux 上编辑的文本，在 Windows 系统上打开可能看起来是没有换行的。如果你想让你在 Linux 创建的 zip 压缩文件在 Windows 上解压后没有任何问题，那么你还需要对命令做一些修改： 1$ zip -r -l -o nancy.zip /home/nancy 需要加上-l参数将LF转换为CR+LF来达到以上目的。 使用unzip命令解压缩zip文件 将shiyanlou.zip解压到当前目录： 1$ unzip shiyanlou.zip 使用安静模式，将文件解压到指定目录： 1$ unzip -q shiyanlou.zip -d ziptest 上述指定目录不存在，将会自动创建。如果不想解压只想查看压缩包的内容可以使用-l参数： 1$ unzip -l shiyanlou.zip 注意： 使用unzip解压文件时我们同样应该注意兼容问题，不过这里我们关心的不再是上面的问题，而是中文编码的问题，通常 Windows 系统上面创建的压缩文件，如果有有包含中文的文档或以中文作为文件名的文件时默认会采用 GBK 或其它编码，而 Linux 上面默认使用的是 UTF-8 编码，如果不加任何处理，直接解压的话可能会出现中文乱码的问题（有时候它会自动帮你处理），为了解决这个问题，我们可以在解压时指定编码类型。 使用-O（英文字母，大写o）参数指定编码类型： 1unzip -O GBK 中文压缩文件.zip rar打包压缩命令 rar也是 Windows 上常用的一种压缩文件格式，在 Linux 上可以使用rar和unrar工具分别创建和解压 rar 压缩包。 安装rar和unrar工具： 12$ sudo apt-get update$ sudo apt-get install rar unrar 从指定文件或目录创建压缩包或添加文件到压缩包： 12$ rm *.zip$ rar a nancy.rar . 上面的命令使用a参数添加一个目录～到一个归档文件中，如果该文件不存在就会自动创建。 注意：rar 的命令参数没有-，如果加上会报错。 从指定压缩包文件中删除某个文件： 1$ rar d nancy.rar .zshrc 查看不解压文件： 1$ rar l nancy.rar 使用unrar解压rar文件 全路径解压： 1$ unrar x nancy.rar 去掉路径解压： 12$ mkdir tmp$ unrar e nancy.rar tmp/ rar命令参数非常多，上面只涉及了一些基本操作。 tar打包工具 创建一个 tar 包： 1$ tar -cf nancy.tar ~ -c表示创建一个 tar 包文件，-f用于指定创建的文件名，注意文件名必须紧跟在-f参数之后，比如不能写成tar -fc nancy.tar，可以写成tar -f nancy.tar -c ~。你还可以加上-v参数以可视的的方式输出打包的文件。上面会自动去掉表示绝对路径的/，你也可以使用-P保留绝对路径符。 解包一个文件(-x参数)到指定路径的已存在目录(-C参数)： 12$ mkdir tardir$ tar -xf nancy.tar -C tardir 只查看不解包文件-t参数： 1$ tar -tf nancy.tar 保留文件属性和跟随链接（符号链接或软链接），有时候我们使用tar备份文件当你在其他主机还原时希望保留文件的属性(-p参数)和备份链接指向的源文件而不是链接本身(-h参数)： 1$ tar -cphf etc.tar /etc 对于创建不同的压缩格式的文件，对于tar来说是相当简单的，需要的只是换一个参数，这里我们就以使用gzip工具创建*.tar.gz文件为例来说明。 我们只需要在创建 tar 文件的基础上添加-z参数，使用gzip来压缩文件： 1$ tar -czf nancy.tar.gz ~ 解压*.tar.gz文件： 1$ tar -xzf nancy.tar.gz 要使用其他的压缩工具创建或解压相应文件只需要更改一个参数即可： 压缩文件格式 参数 *.tar.gz -z *.tar.xz -J *tar.bz2 -j 趣味程序（火炉）： 12$ sudo apt-get install libaa-bin $ aafire 文件系统操作与磁盘管理 简单文件系统操作 使用 df 命令查看磁盘的容量 1$ df 物理主机上的 /dev/sda2 是对应着主机硬盘的分区，后面的数字表示分区号，数字前面的字母 a 表示第几块硬盘（也可能是可移动磁盘），如果主机上有多块硬盘则可能还会出现 /dev/sdb，/dev/sdc 这些磁盘设备都会在 /dev 目录下以文件的存在形式。 还会看到&quot;1k-blocks&quot;，它表示以磁盘块大小的方式显示容量，后面为相应的以块大小表示的已用和可用容量。 使用 du 命令查看目录的容量 1234# 默认同样以 blocks 的大小展示$ du # 加上`-h`参数，以更易读的方式展示$ du -h -d参数指定查看目录的深度 1234# 只查看1级目录的信息$ du -h -d 0 ~# 查看2级$ du -h -d 1 ~ 简单的磁盘管理 下面涉及的命令具有一定的危险性，操作不当可能会丢失你的个人数据，初学者建议在虚拟环境中进行操作 创建虚拟磁盘 dd 命令简介 dd命令用于转换和复制文件，不过它的复制不同于cp。之前提到过关于 Linux 的很重要的一点，一切即文件，在 Linux 上，硬件的设备驱动（如硬盘）和特殊设备文件（如/dev/zero和/dev/random）都像普通文件一样，只要在各自的驱动程序中实现了对应的功能，dd 也可以读取自和/或写入到这些文件。这样，dd也可以用在备份硬件的引导扇区、获取一定数量的随机数据或者空数据等任务中。dd程序也可以在复制时处理数据，例如转换字节序、或在 ASCII 与 EBCDIC 编码间互换。 dd的命令行语句与其他的 Linux 程序不同，因为它的命令行选项格式为选项=值，而不是更标准的--选项 值或-选项=值。dd默认从标准输入中读取，并写入到标准输出中，但可以用选项if（input file，输入文件）和of（output file，输出文件）改变。 我们先来试试用dd命令从标准输入读入用户输入到标准输出或者一个文件： 1234# 输出到文件$ dd of=test bs=10 count=1 # 或者 dd if=/dev/stdin of=test bs=10 count=1# 输出到标准输出$ dd if=/dev/stdin of=/dev/stdout bs=10 count=1 明天继续。 感谢实验楼。 &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！ The article has been viewed &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; times.Thank you for your visit! &lt;/span&gt;","raw":null,"content":null,"categories":[{"name":"通信工程","slug":"通信工程","permalink":"http://hubojing.github.io/categories/通信工程/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://hubojing.github.io/tags/linux/"}]},{"title":"回归","slug":"回归","date":"2016-12-26T13:16:07.000Z","updated":"2016-12-26T14:06:06.482Z","comments":true,"path":"2016/12/26/回归/","link":"","permalink":"http://hubojing.github.io/2016/12/26/回归/","excerpt":"","text":"&lt;div align=&quot;left&quot;&gt; &lt;img src=&quot;http://www.jingyanbus.com/uploads/allimg/c160518/1463534500XK0-3G2b.jpg&quot; width=&quot;300&quot; height=&quot;180&quot; alt=&quot;配图&quot; style=&quot;float:right;&quot;/&gt; 考研大战初试昨日结束，我回来写文了！ 考研不易，且行且珍惜！ 无论如何，人生开启新旅程！在技术的海洋里遨游吧！向成为一名优秀的工程师迈进！ [点开有福利] &lt;/div&gt; &lt;!--more--&gt; P.S. 顺便卖个资料，赚些买域名的费用。想考研的各位可以找我，资料非常齐全（百度云4T）市面上的基本都有，价格0-10元，好商量，关系好可以免费送（嘿嘿嘿）。我也算是过来人了，绝不坑人，那些正儿八经卖资料的动辄几百简直是压榨穷苦的学生们…… &lt;img src=&quot;/images/h_2.jpg&quot; width=&quot;300&quot; height=&quot;400&quot; alt=&quot;联系方式&quot; style=&quot;float:middle;&quot;/&gt; &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！ The article has been viewed &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; times.Thank you for your visit! &lt;/span&gt;","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"说明","slug":"说明","permalink":"http://hubojing.github.io/tags/说明/"}]},{"title":"上海决赛之旅 | the trip for contest in Shanghai","slug":"上海决赛之旅","date":"2016-08-27T07:43:53.000Z","updated":"2016-10-23T15:47:53.624Z","comments":true,"path":"2016/08/27/上海决赛之旅/","link":"","permalink":"http://hubojing.github.io/2016/08/27/上海决赛之旅/","excerpt":"","text":"&lt;div align=&quot;left&quot;&gt; &lt;img src=&quot;http://7xray0.com1.z0.glb.clouddn.com/IMG_20160823_183005.jpg&quot; width=&quot;300&quot; height=&quot;180&quot; alt=&quot;配图&quot; style=&quot;float:right;&quot;/&gt; 上海决赛后的简单的感受，具体的技术方面探讨将在考研后详细更新。 &lt;/div&gt; &lt;!--more--&gt; 从上海比赛回来，说说几点感受： 1.大神技术过硬。 2.大神为作品倾注很多。 3.创意和灵感的重要性。 4.团队合作，找到志同道合的朋友。 5.大神演讲能力极强，不怯场。 6.自己的心态和学习程度都需要改正加强，差距是明显可见的。 衷心感谢学校的支持，能为学院和学校争取荣誉，同时实现自己初涉竞赛的心愿，找到自己和大神的距离，不虚此行。 I would like to spare my thoughts after my coming back from Shanghai for my competition. 1.Superiors are excellent in technology. 2.Superiors take times in their work. 3.Idea and inspiration are insignificant. 4.Team-work is needed,and we should find like-minded firends. 5.Superiors have ability in giving a speech and never afraid of it. 6.My attitude and learning need to be changed and improved,and the distance between superior and me is clearly to see. Thank you for the support from my university,and I'm prond of doing credit to my school and university.In the meanwhile,I realise my dream for first involve in contest. 附自拍上海美景 P.S.the view of Shanghai &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！ The article has been viewed &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; times.Thank you for your visit! &lt;/span&gt;","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://hubojing.github.io/tags/杂谈/"}]},{"title":"说明","slug":"说明","date":"2016-07-16T10:20:32.000Z","updated":"2016-07-24T12:18:17.861Z","comments":true,"path":"2016/07/16/说明/","link":"","permalink":"http://hubojing.github.io/2016/07/16/说明/","excerpt":"","text":"&lt;div align=&quot;left&quot;&gt; &lt;img src=&quot;http://i2.w.yun.hjfile.cn/doc/201304/bc1b70e4e74d48c4ab99e3db21a052f0.png&quot; width=&quot;300&quot; height=&quot;180&quot; alt=&quot;配图&quot; style=&quot;float:right;&quot;/&gt; 有朋友问我为何最近github和博客都没有较多的维护和更新，现作出说明： 因本人自身发展问题，正积极备考研究生考试，直至考研结束，所以github和博客的维护和更新会延缓，但不会停止维护。 希望完全回归时，自己能收获理想！ 学习，永不止步。 望各位朋友理解！谢谢大家！ &lt;!--more--&gt; &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！ The article has been viewed &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; times.Thank you for your visit! &lt;/span&gt;","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"说明","slug":"说明","permalink":"http://hubojing.github.io/tags/说明/"}]},{"title":"P图集 | PS picture album","slug":"P图集","date":"2016-06-29T11:58:18.000Z","updated":"2016-07-06T04:48:06.736Z","comments":true,"path":"2016/06/29/P图集/","link":"","permalink":"http://hubojing.github.io/2016/06/29/P图集/","excerpt":"","text":"&lt;div align=&quot;left&quot;&gt; &lt;img src=&quot;http://7xray0.com1.z0.glb.clouddn.com/16-6-29/63527525.jpg&quot; width=&quot;300&quot; height=&quot;180&quot; alt=&quot;配图&quot; style=&quot;float:right;&quot;/&gt; 自从学会Photoshop这个好用的工具后，对照片的处理更得心应手了。 这是我的P图集。 I use photoshop more effectively after I learned it. This is my PS picture album. &lt;/div&gt; &lt;!--more--&gt; 1 2 我是想调成新海诚动漫画风效果的…不过水平还欠佳…… I want to do it as Makoto Shinkai's animation style,but my level just not reachs that high apparently. &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！ The article has been viewed &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; times.Thank you for your visit! &lt;/span&gt;","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"http://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"photoshop","slug":"photoshop","permalink":"http://hubojing.github.io/tags/photoshop/"}]},{"title":"Linux菜鸟初尝鲜 | First try on Linux","slug":"Linux菜鸟初尝鲜","date":"2016-06-14T15:10:30.000Z","updated":"2016-10-23T15:26:46.338Z","comments":true,"path":"2016/06/14/Linux菜鸟初尝鲜/","link":"","permalink":"http://hubojing.github.io/2016/06/14/Linux菜鸟初尝鲜/","excerpt":"","text":"&lt;div align=&quot;left&quot;&gt; &lt;img src=&quot;http://news.mydrivers.com/Img/20110826/2011082609513918.jpg&quot; width=&quot;300&quot; height=&quot;180&quot; alt=&quot;配图&quot; style=&quot;float:right;&quot;/&gt; 大三认真学技术打开新世界，常叹为何不早入技术门！ I have learned technology to my best in my junior time,and I feel I should step into the technological world earlier! &lt;/div&gt; &lt;!--more--&gt; 奈何大三事务多，惟愿考研考上给我又几年自学的机会……更认真地对待技术！ Too busy in the junior,may I can gain another several years to learn in the postgraduate stage.I will be more hard-working! 这一年，接触git、css、html，前端知识，尝试java，这学期又选了数据库sql，嵌入式系统Linux，还学了好用的工具Labview，这学期选的课都很实用！只是知识需要消化…… This year,I get to know git,css,html and fore-end knowledge,try java,and chose sql,linux and labview this semester,which are practical nowadays!Indeed,it takes time to understand them deeply. 一直想了解Linux，无从下手，最后还是在课堂上被老师带着走入了linux的世界。 Always want to know something about linux,but I just have no idea about it.Luckliy,I become to see you finally,linux. 2016.6.22更新 Update 一要点 昨天考完了嵌入式系统实验考试，get一个简单的要点： I got a small but esstenial point in my linux exam, armv4l-unknown-linux-gcc -o 开发板上的编译 winSCP's compiler gcc -o 虚拟机上的编译 VM's compiler 分清两种编译器。Please make sure your compiler is right. 考试内容是开发板与虚拟机通信。开发板是client，虚拟机是server.（和之前的记录是相反的） My exam is VM communicate with winSCP.The winCSP is client,and the VM is server. 2016.6.14更新 Update 基础实验 熟悉Linux开发环境 Basic experiment Be familiar with Linux development environment 熟悉Linux开发环境，学会基于S3C2410的Linux开发环境的配置和使用。使用Linux的armv4l-unknown-linux-gcc编译，使用基于NFS方式的下载调试，了解嵌入式开发的基本过程。 Be familiar with Linux development environment and learn configuration of Linux development environment based on S3C2410.Use compile of armv41-unknown-linux-gcc，use download and debug based on NFS mode,to learn the embedded development process. 实验步骤 Experiment steps 1、建立工作目录 Create work directory 2、编写程序源代码 Write code 3、编写Makefile Write makefile 4、编译应用程序 Compile program 5、下载调试 Download and debug 重难点 Important point Makefile文件定义了一系列的规则，它指明了哪些文件需要编译，哪些文件需要先编译，哪些文件需要重新编译等等更为复杂的命令。使用它带来的好处就是自动编译，你只需要敲一个“make”命令整个工程就可以实现自动编译。 Makefile definite a series of rules,and it shows which files need compile,which first to be compiled,and which need recompile.The benefit is a simple &quot;make&quot; can finish automatic compilation. mount -t nfs -o nolock 192.168.0.56:/arm2410cl /host //超级终端中执行 carried out under the super terminal 注意：IP地址需要根据宿主PC机的实际情况修改成对应arm2410cl目录。 Attention:IP should be changed according to the real condition. 编译、修改程序都是在宿主机（本地PC机）上进行，不能在超级终端下进行。 Compile and modify the program both in the host (local PC), and it can not be carried out under the super terminal. 课堂笔记备忘 服务器与客户端通信 虚拟机上（地址192.168.1.12）VM： cd /arm2410cl/ cd exp cd basic cd server（先把server.c和client.c拷入对应文件夹下 into right files） ls gcc -o client client.c //编译compile armv41-unkown-linux-gcc -o server server.c //编译compile 注意：修改了源文件记得要编译，保存还不够。 Attention:It is vital to compile,not just save file. ./client 123456 开发板(地址192.168.1.121)winSCP： ifconfig eth0 192.168.1.121 mount -t nfs -o nolock 192.168.1.12:/arm2410c1 /host （挂载mount） cd /host cd exp cd basic cd server ls （可以ping 192.168.1.12检查一下是否连通 test if it is linked.） ./server 123456 exit退出连接 程序只能是客户端向服务端发送信息，不能反过来。 Information can only be sent to the server from client which can't be reversed because of the program setting. 原程序Original program： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667int main()&#123; char buffer[BUFFER_SIZE]; struct sockaddr_in client_addr; socklen_t length; int conn; int len; //int fork_id;///定义sockfd int server_sockfd = socket(AF_INET,SOCK_STREAM, 0); ///定义sockaddr_in struct sockaddr_in server_sockaddr; server_sockaddr.sin_family = AF_INET; server_sockaddr.sin_port = htons(MYPORT); server_sockaddr.sin_addr.s_addr = htonl(INADDR_ANY); ///bind，成功返回0，出错返回-1 if(bind(server_sockfd,(struct sockaddr *)&amp;server_sockaddr,sizeof(server_sockaddr))==-1) &#123; perror(\"bind\"); exit(1); &#125; ///listen，成功返回0，出错返回-1 if(listen(server_sockfd,QUEUE) == -1) &#123; perror(\"listen\"); exit(1); &#125; ///客户端套接字 length = sizeof(client_addr); ///成功返回非负描述字，出错返回-1 //while(1) //&#123; conn = accept(server_sockfd, (struct sockaddr*)&amp;client_addr, &amp;length); if(conn&lt;0) &#123; perror(\"connect\"); exit(1); &#125; fork_id=fork(); if(fork_id==0) &#123; while(1) &#123; memset(buffer,0,sizeof(buffer)); len = recv(conn, buffer, sizeof(buffer),0); if(strcmp(buffer,\"exit\\n\")==0) break; fputs(buffer, stdout); send(conn, buffer, len, 0); &#125; close(conn); close(server_sockfd); return(0);//新程序去掉了这一行 //exit(0);&#125;/*else&#123;&#125;&#125;*/ &#125; 原程序是一个服务器只能挂载一个客户端。 The original program is a server which can only mount one client. 程序修改了下，使一个服务器可以挂载两个客户端（可以构建聊天系统）。 After modifing program,it can mount two clients(which can create a chat system). 要先连接服务器，再连接客户端。 Connect the server first,then connect the client. rm server 删除server文件 delete server file 两端ps -a看一下是否退出。 use&quot;ps -a&quot; to see if the system exits. 挂载驱动 Mount the drive 在开发板上winSCP： mount -t nfs -o nolock 192.168.1.12:/arm2410cl /host cd host cd exp cd basic cd pwm_motor lsmod pwm_ad.o cd pwm_AD insmod pwm_ad.o //rmmod pwm_ad.o 删除 cd pwm_test ./test_dcm_main 虚拟机上VM： cd pwm_motor cd pwm_test make clean make cd .. cd pwm_test 附录 客户端和服务器程序 Appendix Client.c &amp; Server.c server.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;stdio.h&gt;#include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;fcntl.h&gt;#include &lt;sys/shm.h&gt; #define MYPORT 8887 #define QUEUE 20 #define BUFFER_SIZE 1024int main()&#123; char buffer[BUFFER_SIZE]; struct sockaddr_in client_addr; socklen_t length; int conn; int len;///定义sockfd int server_sockfd = socket(AF_INET,SOCK_STREAM, 0); ///定义sockaddr_in struct sockaddr_in server_sockaddr; server_sockaddr.sin_family = AF_INET; server_sockaddr.sin_port = htons(MYPORT); server_sockaddr.sin_addr.s_addr = htonl(INADDR_ANY); ///bind，成功返回0，出错返回-1 if(bind(server_sockfd,(struct sockaddr *)&amp;server_sockaddr,sizeof(server_sockaddr))==-1) &#123; perror(\"bind\"); exit(1); &#125; ///listen，成功返回0，出错返回-1 if(listen(server_sockfd,QUEUE) == -1) &#123; perror(\"listen\"); exit(1); &#125; ///客户端套接字 length = sizeof(client_addr); ///成功返回非负描述字，出错返回-1 conn = accept(server_sockfd, (struct sockaddr*)&amp;client_addr, &amp;length); if(conn&lt;0) &#123; perror(\"connect\"); exit(1); &#125; while(1) &#123; memset(buffer,0,sizeof(buffer)); len = recv(conn, buffer, sizeof(buffer),0); if(strcmp(buffer,\"exit\\n\")==0) break; fputs(buffer, stdout); send(conn, buffer, len, 0); &#125; close(conn); close(server_sockfd); return 0; &#125; client.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;stdio.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/shm.h&gt;#define MYPORT 8887#define BUFFER_SIZE 1024int main()&#123; ///定义sockfd int sock_cli = socket(AF_INET,SOCK_STREAM, 0); ///定义sockaddr_in struct sockaddr_in servaddr; memset(&amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(MYPORT); ///服务器端口 servaddr.sin_addr.s_addr = inet_addr(\"192.168.1.12\"); ///服务器ip ///连接服务器，成功返回0，错误返回-1 if (connect(sock_cli, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0) &#123; perror(\"connect\"); exit(1); &#125; char sendbuf[BUFFER_SIZE]; char recvbuf[BUFFER_SIZE]; while (fgets(sendbuf, sizeof(sendbuf), stdin) != NULL) &#123; send(sock_cli, sendbuf, strlen(sendbuf),0); ///发送 if(strcmp(sendbuf,\"exit\\n\")==0) break; recv(sock_cli, recvbuf, sizeof(recvbuf),0); ///接收 fputs(recvbuf, stdout); memset(sendbuf, 0, sizeof(sendbuf)); memset(recvbuf, 0, sizeof(recvbuf)); &#125; close(sock_cli); return 0;&#125; &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！ The article has been viewed &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; times.Thank you for your visit! &lt;/span&gt;","raw":null,"content":null,"categories":[{"name":"通信工程","slug":"通信工程","permalink":"http://hubojing.github.io/categories/通信工程/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://hubojing.github.io/tags/linux/"},{"name":"嵌入式系统","slug":"嵌入式系统","permalink":"http://hubojing.github.io/tags/嵌入式系统/"}]},{"title":"将hexo+github博客同步托管至coding","slug":"将hexo-github博客同步托管至coding","date":"2016-04-06T08:14:56.000Z","updated":"2016-04-06T11:07:13.218Z","comments":true,"path":"2016/04/06/将hexo-github博客同步托管至coding/","link":"","permalink":"http://hubojing.github.io/2016/04/06/将hexo-github博客同步托管至coding/","excerpt":"","text":"由于百度蜘蛛把github屏蔽了，导致百度搜不到博客文章，let me feel a little unhappy，为了扩大网站收录率，我将hexo-github博客同步托管到国内coding上。 胡博靖的个人博客：http://hubojing.coding.me 胡博靖的个人博客：http://hubojing.coding.me/hubojing 胡博靖的个人博客：http://hubojing.github.io Both right! 外网用github，内网用coding。 &lt;!--more--&gt; coding创建新项目 项目名称最好是和你的用户名相同，这样直接访问hubojing.coding.me即可，否则需要访问hubojing.coding.me/set-name。 复制后写入repo中。具体看下一步。 config文件配置 hexo根目录文件_config.yml修改配置如下： 12345deploy: type: git repo: coding: git@github.com:hubojing/hubojing.github.io.git github: git@git.coding.net:hubojing/hubojing.git SSH设置 这里SSH设置和github类似。我直接用的部署github时生成的SSH。 打开id_rsa.pub文件，复制全部内容，填写到SSH公钥一栏中，名称自定。完成后点击“添加”即可。 添加后，在git bash命令输入(我是在hexo根目录下bash here)： 1ssh -T git@git.coding.net 它会弹出一个警告，是否允许操作，输入yes就可以。 接着会询问你设置的密码，如果之前部署github时设置了，就输入密码，输入时频幕上是看不到任何反应的，但当你正确输入并回车后，它会显示： 1Coding.net Tips : [Hello ! You've conected to Coding.net by SSH successfully! ] 这表示你的SSH设置成功了！ 开启Pages服务 最后一步了！ 在hexo根目录下， 12cd sourcetouch Staticfile #名字必须是Staticfile coding.net需要此文件来作为以静态文件部署的标志，就是说看到Staticfile就知道按照静态文件来发布。 注意：Pages服务分支填master！因为之前配置的分支是master。否则你将看到404 Not Found！（我不会告诉你我就是这样试了好几遍才找到原因……） OK!All have done!Congratulations! 现在快去看看吧！胡博靖的技术博客 欢迎在github上关注我：hubojing 参考资料 hexo干货系列（四） hexo官网文档规范 &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！ &lt;/span&gt;","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"http://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://hubojing.github.io/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"http://hubojing.github.io/tags/hexo/"},{"name":"优化","slug":"优化","permalink":"http://hubojing.github.io/tags/优化/"},{"name":"教程","slug":"教程","permalink":"http://hubojing.github.io/tags/教程/"}]},{"title":"PPT动画制作之自定义动画","slug":"PPT动画制作之自定义动画","date":"2016-03-22T13:18:04.000Z","updated":"2016-03-26T13:34:12.974Z","comments":true,"path":"2016/03/22/PPT动画制作之自定义动画/","link":"","permalink":"http://hubojing.github.io/2016/03/22/PPT动画制作之自定义动画/","excerpt":"","text":"3.23更新 昨天写完总觉得最终效果差点什么，后来发现是文字涌入时缺少了旋转效果。 现修改完整。 附上最新GIF图：（可看出差异） &lt;!--more--&gt; 话不多说，先看效果： 该动画分为两部分：闪烁背景+文字涌入特效 闪烁背景 ** 步骤：** 1.改个色 （背景色） 2.添个形 （用基本形状添加） 3.改设置 （形状外框透明、选择颜色） 4.复个制 （多次复制，铺满画布） 5.改大小 （不能每个形状一样大，那样闪烁不自然） 6.改透度 （使闪烁更自然） 7.添动画 （全选统一添加“渐变”动作） 8.调时间 （显示高级进程表，调整时长，不要都从最开始出现；从“之前”开始） 完成。 文字涌入特效 步骤： 1.抠个字 （用PS写几个需要的文字，依次用魔棒选中每个文字，同时复制粘贴到另一图层，然后用裁剪工具剪到合适大小，另存） 2.插个图 3.复个制 （3-4次） 4.围一圈 5.调大小 6.添动画 （外围一圈加退出中的“缩放”，缩小到屏幕中心。中间加“渐变式缩放”，下面文字“飞入”和强调里的“陀螺旋”） 7.调时间 （时间控制好，先缩放，在渐变式缩放，最后飞入） 完工。 &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！ &lt;/span&gt;","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"http://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"PPT动画","slug":"PPT动画","permalink":"http://hubojing.github.io/tags/PPT动画/"}]},{"title":"显示技术蹭课笔记 | Display Techique Learning Note","slug":"显示技术蹭课笔记","date":"2016-03-17T13:55:30.000Z","updated":"2016-10-23T15:26:30.935Z","comments":true,"path":"2016/03/17/显示技术蹭课笔记/","link":"","permalink":"http://hubojing.github.io/2016/03/17/显示技术蹭课笔记/","excerpt":"","text":"&lt;div align=&quot;left&quot;&gt; &lt;img src=&quot;http://img10.360buyimg.com/popWaterMark/g13/M02/09/0C/rBEhUlKdmzIIAAAAAAA7TyA5YywAAGS_wDaFdAAADtn918.jpg&quot; width=&quot;300&quot; height=&quot;180&quot; alt=&quot;配图&quot; style=&quot;float:right;&quot;/&gt; 蹭课，科普为主。顺便复习一些基础电路知识。 I am not a student of this class but want to listen to the lecture for popularization of science to myself.By the way reviewing some of the basic circuit knowledge. 给这篇文章写英译好辛苦…… It is hard to write English translation for this article. 肖大大图书镇楼！ Uncle Xiao's book is superior! &lt;/div&gt; &lt;!--more--&gt; 2016.5.20 更新 Update 显示技术实验部分 Experimental part 学会了怎么把电路图和实物电路联系起来。学会了就好简单……果然授人以鱼不如授人以渔！ Learnt how to link circuit diagram to the phhysical diagram.It's easy enough.Give a man a fish and you feed him for a day.Teach him how to fish and you feed him for a lifetime. 但不敢去测量上万伏的高压……为自身的局限性感到难过。 But I dare not to measure the high pressure of tens of thousands of volts.I feel terrible for my own limitation. 几个名词 Several noums 声表面波滤波器 Surface acoustic wave filter 声表面波滤波器(SAWF，surface acoustic wave filter)是利用石英、铌酸锂、钛酸钡晶体具有压电效应的性质做成的。所谓压电效应，即是当晶体受到机械作用时，将产生与压力成正比的电场的现象。具有压电效应的晶体，在受到电信号的作用时，也会产生弹性形变而发出机械波（声波），即可把电信号转为声信号。由于这种声波只在晶体表面传播，故称为声表面波。 SAWF uses the piezoelectric effect property of quartz,lithium niobate,barium titanate.As for piezoelectric effect,when the crystal is mechanical functioned,it will produce the electric field which is directly proportional to the pressure.Crystal which has the piezoelectric effect,when the electrical signal is added,will generate a elastic deformation and send a mechanical wave(sonic wave),so it converts electrical signal to acoustic signal.It is called surface acoustic wave for this wave only transmit on the crystal surface. 行可变电容 Line variable capacitor &lt;img src=&quot;http://7xray0.com1.z0.glb.clouddn.com/16-5-20/33612917.jpg&quot; width=&quot;600&quot; height=&quot;400&quot; alt=&quot;行可变电容&quot;/&gt; 行可变电感 Row variable inductor &lt;img src=&quot;http://www.liheng-dg.cn/uploads/allimg/140221/1-14022115052H18.png&quot; width=&quot;600&quot; height=&quot;400&quot; alt=&quot;行可变电感&quot;/&gt; 中周 Medium cycle transformer 电视中周：电视机里的中周标准称呼是中频变压器。 The standard name is medium cycle transformer. &lt;img src=&quot;http://img.qy6.com/new5/szvena/1313633487.jpg&quot; width=&quot;600&quot; height=&quot;400&quot; alt=&quot;中周&quot;/&gt; 电路图上，三极管外带虚线的圆圈是指带散热的三极管，同时接地表屏蔽。 On the circuit diagram,the dotted line with the circle triode refers to the triode with heat pipe,which is at earth potential to shield. 实验现场 &lt;img src=&quot;http://7xray0.com1.z0.glb.clouddn.com/16-5-20/58196995.jpg&quot; width=&quot;400&quot; height=&quot;250&quot; alt=&quot;电路图&quot;/&gt; &lt;img src=&quot;http://7xray0.com1.z0.glb.clouddn.com/16-5-20/69333137.jpg&quot; width=&quot;400&quot; height=&quot;250&quot; alt=&quot;故障示教板&quot;/&gt; &lt;img src=&quot;http://7xray0.com1.z0.glb.clouddn.com/16-5-20/29028249.jpg&quot; width=&quot;400&quot; height=&quot;250&quot; alt=&quot;实验&quot;/&gt; （不配四张图，强迫症不要打我哟~） 2016.5.17 更新 Update 大部分资料来自维基百科。 Most of the information comes from Wikipedia. 平板显示器 Flat panel display 简介 Brief introduction 平板屏幕包含多种科技，使显示器（video display）比传统电视机（traditional television）或显示器（通常由阴极射线管制成）更加轻薄，厚度通常小于4英寸（100 mm）。 Flat panel display includes many technologies,which makes video display lighter than traditional television or display(usually made of cathode ray tube),and thickness is usually less than 4 inches. 种类 Type DLP (数位光处理) Digital light processing 等离子显示器 Plasma panel display 液晶显示器（LCDs） Liquid crystal display 薄膜晶体管液晶显示器（TFT-LCDs） Thin film transistor liquid crystal display 有机发光二极管显示器（OLEDs） Organic light emitting diode display 发光二极管显示器（LED） Light-emitting diode display 电致发光显示器（ELDs） Electroluminescent display 表面传导电子发射显示器（SEDs） Surface conduction electron emission display 场发射显示器（FEDs）（ 纳米-发射显示器（NEDs）） Field emission display 名字多么洋气~ The names has foreign flavour~ 这张图有点意思~ This picture is kind of interesting~ CRT显示器 CRT display 简介 Brief introduction 阴极射线管（Cathode ray tube，缩写：CRT，又称“显像管”、布劳恩管）是一种用于显示系统的物理仪器，曾广泛应用于示波器、电视机和显示器上。它是利用阴极电子枪发射电子，在阳极高压的作用下，射向萤光屏，使萤光粉发光，同时电子束在偏转磁场的作用下，作上下左右的移动来达到扫描的目的。早期的阴极射线管仅能显示光线的强弱，展现黑白画面。而彩色阴极射线管具有红、绿色和蓝色三支电子枪，三支电子枪同时发射电子打在屏幕玻璃上磷化物上来显示颜色。 由于它笨重、耗电且较占空间，2000年代起几乎被轻巧、省电且省空间的液晶显示器取代。阴极射线管的市场剩下极重视色彩表现及低温环境下等特殊用途。 Cathode ray tube,is a physical instrument which uses to display system.It used to be applied to oscilloscope,TV and display.It uses the cathode electron gun for electron emission.Under the action of anode high voltage,it emits to the screen,which makes powder luminesce.At the same time, the electron beam moves up and down to reach the purpose of scanning by the action of the deflection magnetic field.Early cathode ray tube can only show the intensity of light,and to show black and white picture.Color cathode ray tube have red, green and blue electron guns, and this three electron guns emit electrons to hit the glass screen's phosphides to show color. Because of its bulky, power consumption and space waste,light, power saving and space saving LCD monitor was used in the 2000s instead.A cathode ray tube market left pole attached color performance and low temperature environment and other special purposes. CRT在高精尖领域仍扮演着重要角色。 CRT still plays an important role in the high-tech field. 液晶显示器 liquid-crystal display 简介 Brief introduction 液晶显示器（英语：liquid-crystal display，缩写：LCD）为平面薄型的显示设备，由一定数量的彩色或黑白像素组成，放置于光源或者反射面前方。液晶显示器功耗低，因此倍受工程师青睐，适用于使用电池的电子设备。 Liquid-crystal display is the flat panel display device,which consists of a number of color or black and white pixels,and place in the light source or in front of the reflecting surface. 显示原理 Revelation principle 在不加电压下，光线会沿着液晶分子的间隙前进而转折90度，所以光可通过。但加入电压后，光顺着液晶分子的间隙直线前进，因此光被滤光板所阻隔。（让我想到偏振……） 液晶是具有流动特性的物质，所以只需外加很微小的力量即可使液晶分子运动，以最常见普遍的向列型液晶为例，液晶分子可轻易的借着电场作用使得液晶分子转向，由于液晶的光轴与其分子轴相当一致，故可借此产生光学效果，而当加于液晶的电场移除消失时，液晶将借着其本身的弹性及黏性，液晶分子将十分迅速的恢复原来未加电场前的状态。 Without voltage, the light will move along the gap between the liquid crystal molecules and turn 90 degrees, so the light can pass.But after the voltage is added,light goes along the liquid crystal molecules of the gap straight forward,so the light is blocked by the filter board. (Let me think of polarization.) 等离子显示器 Plasma Display Panel 简介 Brief introduction 等离子显示器（Plasma Display Panel）又称为电浆显示屏，是一种平面显示屏幕，光线由两块玻璃之间的离子，射向磷质而发出。与液晶显示器不同，放出的气体并无水银成分，而是使用惰性气体氖及氙混合而成，这种气体是无害气体。 等离子显示器甚为光亮（1000 lx或以上），可显示更多种颜色，也可制造出较大面积的显示屏，最大对角可达381厘米（150吋）。等离子显示屏的对比度亦高，可制造出全黑效果，对观看电影尤其适合。显示屏厚度只有6厘米，连同其他电路板，厚度亦只有10厘米。 Plasma display panel is a flat display screen.Light is emitted to phosphorous by the ion between the two classes.Unlike liquid crystal display,the gas released has no mercury,it mixed inert gas such as neon,xenon and so on,which are harmless. The plasma display is very bright (1000 LX or above),and it can show more colors,it also can be made big screen,which the maximum diagonal up to 381 cm (150 inches).The contrast is high, and it can create a full black effect,especially suitable for watching movies.The thickness of screen is only 6 cm,combined with other circuit boards, the thickness is only 10 cm. 原理 Principle 等离子的发光原理是在真空玻璃管中注入惰性气体或水银蒸气，加电压之后，使气体产生等离子效应，放出紫外线，激发荧光粉而产生可见光，利用激发时间的长短来产生不同的亮度。等离子显示器中，每一个像素都是三个不同颜色（三原色）的等离子发光体所产生的。由于它是每个独立的发光体在同一时间一次点亮的，所以特别清晰鲜明。等离子显示器的使用寿命约5~6万个小时。随着使用的时间的增加，其亮度会衰退。 The principle of plasma luminescence is to inject inert gas or mercury vapor into a vacuum glass tube.After the voltage is added, the gas is produced by the plasma effect, the ultraviolet ray is emitted, and the fluorescent powder is excited to generate visible light, and the excitation time is used to generate different brightness.In the plasma display, each pixel has three different colors (RGB) of the plasma generated by the luminous body.Since each individual light body is litted at the same time, so it is clear and bright.The service life of the plasma display is about 5~6 ten thousand hours. With the increase of the use of time, the brightness of the plasma display will decline. **【区别】**等离子显示器并不是液晶显示器。后者的显示器虽然也很轻薄，但是用的技术却是大不相同。液晶显示器通常会使用一到两个大型萤光灯或是LED当作其背光源，在背光源上面的液晶面板则是利用遮罩的原理让显示器显示出不同颜色。 **【Difference】**Plasma display is not liquid crystal display.Although the latter is also very thin,the technology is different.Liquid crystal display usually use one or two large fluorescent lamp or LED as the backlight,above the backlight to the LCD panel using mask principle to show different colors. 云电视 Cloud TV 简介 Brief introduciton 云电视是应用云计算、云存储技术的电视产品，是云设备的一种。通俗地讲，就是用户不需要单独再为自家的电视配备所有互联网功能或内容，将电视连上网络，就可以随时从外界调取自己需要的资源或信息，比如说，可以在云电视里安装使用各种即时通讯软件，在看电视的同时，进行社交、办公等等。 Cloud TV,which is the application of cloud computing and cloud storage technology,is a kind of cloud devices.Generally speaking,users do not need a separate device for their own television equipped with all Internet function or information.After the TV is connected to the network,you can get what you want at any times.For example, you can install and use a variety of instant messaging software, while watching TV at the same time, social, office and so on. 3D显示器 3D display 简介 Brief introduciton 传统的3D电影在荧幕上有两组图像（来源于在拍摄时的互成角度的两台摄影机），观众必须戴上偏光镜才能消除重影（让一只眼只接受一组图像），形成视差（parallax），产生立体感。利用自动立体显示（AutoSterocopic）技术，即所谓的“真3D技术”，你就不用戴上眼镜来观看立体影像了。这种技术利用所谓的“视差栅栏”，使两只眼睛分别接受不同的图像，来形成立体效果。 平面显示器要形成立体感的影象，必须至少提供两组相位不同的图像。其中，快门式3D技术和不闪式3D技术是如今显示器中最常使用的两种。 The traditional 3D movie has two sets of images on the screen (come from two cameras that are placed in angle difference),so viewers have to put on a polarizing lens to eliminate the ghost(so that a eye only accept a set of images), and form a parallax to generate a sense of three-dimensional.The use of automatic three-dimensional display (AutoSterocopic) technology, that is, the so-called &quot;true 3D technology&quot;, you do not have to wear glasses to watch the stereo image.This technology uses the so-called &quot;parallax barrier&quot;, so that the two eyes receive different images to form a three-dimensional effect. OLED显示器 OLED display 简介 Brief introduction OLED 有机发光二极管又称为有机电激光显示（Organic Light-Emitting Diode，OLED）。OLED显示技术具有自发光的特性，采用非常薄的有机材料涂层和玻璃基板，当有电流通过时，这些有机材料就会发光，而且OLED显示屏幕可视角度大，并且能够节省电能。 对于有机电激发光器件，我们可按发光材料将其分为两种: 小分子OLED和高分子OLED（也可称为PLED）。它们的差异主要表现在器件的制备工艺不同：小分子器件主要采用真空热蒸发工艺，高分子器件则采用旋转涂覆或喷墨工艺。 有机电激发光二极管由于同时具备自发光，不需背光源、对比度高、厚度薄、视角广、反应速度快、可用于挠曲性面板、使用温度范围广、构造及制程较简单等优异之特性，被认为是下一代的平面显示器新兴应用技术。 Organic Light-Emitting Diode has the characteristic of self luminescence,which uses a thin organic material coating and glass substrate.When the current pass,these material will light.Also,OLED display screen viewing angle is big, and it can save electric energy. 发光原理 Principle of luminescence OLED发光的颜色取决于有机发光层的材料，故厂商可由改变发光层的材料而得到所需之颜色。有源阵列有机发光显示屏具有内置的电子电路系统，因此每个像素都由一个对应的电路独立驱动。OLED具备有构造简单、自发光不需背光源、对比度高、厚度薄、视角广、反应速度快、可用于挠曲性面板、使用温度范围广等优点，技术提供了浏览照片和视频的最佳方式而且对相机的设计造成的限制较少。 The color of the OLED depends on the material of the organic light emitting layer, so the manufacturer can obtain the required color by changing the material of the light emitting layer.The active array organic light emitting display screen has a built-in electronic circuit system, so each pixel is driven by a corresponding circuit.The OLED has the advantages of simple structure, no need of back light source, high contrast, thin thickness, wide viewing angle, quick reaction speed, and can be used for the flexible panel and wide temperature range,and technology offers the best way to view photos and videos and to little limit to the design of the camera. 户外大屏幕显示器 Outside big screen display 这个范围就有点大啊…… This range is broad~ 主要说来，CRT、LCD、DLP、LCOS、GLV用的较多。 Generally speaking,CRT、LCD、DLP、LCOS、GLV are used a lot. 2016.3.17更新 update 记忆比较深的知识 Knowledge deeply remember 1.白光透过棱镜分为紫、蓝、青、绿、黄、橙、红。波长依次减少。 White light through the prism is divided into purple, blue, green, green, yellow, orange, red.The wavelength is reduced in turn. 2.绝对黑体是指既不反射也不透射，完全吸收入射辐射的物体。（黑洞……） The absolute black body is an object that absorbsthe incident radiation,neither reflected nor transmitted.(black hole~) 3.色温是表示光源光色的一种尺度。不是光源实际温度！只是一种光谱特性参量！ Color is a representation of the actual temperature scale.Not real temperature!Just a Spectral characteristic parameter! 例：电视屏幕是室温20℃（300K左右），但显像管显示的白颜色对应的是太阳光的那种白，那么色温是4874K！不要说温度有那么高……否则电视早就烧成灰了…… For example,the temperature of the TV screen is 20 ℃（about 200K）,but the white color is corresponding to the white sunlight,which color temperature is 4874K!Never to say it~if it is so hot,your TV is firing ash already. 4.人眼对绿色最敏感！从光谱光效率图看出……所以红绿灯用绿色，显眼啊。 Our eyes is sensitive to green!You can see it in spectral optical efficiency diagram.So this is why traffic light uses green color. 5.正好使人感到不闪烁的刷新频率称为临界闪烁频率。为45.8HZ。只要高于它，人眼就觉得不闪。 Make people feel the refresh rate does not flicker is called the critical flicker frequency,which is 45.8HZ.Only over it,we feel comfortable. 所谓市面上的不闪的电视，就是频率稍高一些的电视，如70HZ。因为部分人群的人眼敏感度较高，所以50HZ也许还是感觉到闪烁，这类人群需要不闪电视。但普通人并不需要。 The so-called &quot;not flash television&quot; in the market is a slightly higher frequency of television,70HZ,for instance.Because some people are more sensitive to it, they need &quot;not flash TV&quot;.But it isn't needed in common. 6.没必要追求4K的分辨率指标。人眼分辨力有限，所谓分辨，是指人眼能看清的扫描的两行。（美国比中国的扫描行数还低来着……）人眼极限就只能看清大约1K左右（这样说来1080P最好咯），高于这个指标人眼就分不清两行了，所以该指标更高便显得意义不大。4K代表我们有能力做到这么清晰，但日常我们是否需要，则并不见得。所以，往往并不需要追求最高的指标，够用就好。（买电脑一个理） It's not necessary to persuit 4K resolution index for human eye resolution is limited.The resolution is the line we can see clearly.(The index in America is lower than that of China)Our eye resolution limit is to see about 1k(1080P maybe the best).If the index higher than this can not we distinguish the lines,so the higher index seems little meaning.4K means we have the ability to do it,but we don't need it in daily life.Therefore,is not as high index as possible,but enough is alright(Buy a computer is the same way). 7.看电视最佳距离：电视频幕高度的4倍。（我回家特地量了一下距离……） The best distance to watch TV is four times the height of the TV screen.(I measure the size at home specifically~) 8.CRT显像管上加了上万伏高压，所以开启和关闭电视时常有静电。（我小时候还特喜欢那种有点漂浮的感觉……） 修电视技巧get：如果开机关机时仍能感觉到静电，那么说明显像管是好的！（来自我们修了三千台电视的super肖老师语录……哦……少碰静电，毕竟几万伏呢……小心白血病……） CRT picture tube is added tens of thousands of volts,so you can feel the static electricity when open or close power supply.(I like the floating feel when I was a child~) KEY TO REPAIR TVIf you can feel the static electricity when open or close power supply,it is obvious that the picture tube is well.(From our super Mr.Xiao's quotationswell,do not touch the static electricity as little as possible.Pay attention to leukemia,it is tens of thousands of volts after all) 9.彩色三要素：亮度、色调、色饱和度。色调与色饱和度合称为色度。 Three elements in color,brightness, tinge, color saturation.Tinge and color saturation are called as chromaticity. 10.三基色原理 The principle of three primary colors （1）所有颜色可以由这三种基色按比例混合得到。（合成性） (1)All colors can be made from the three primary colors mixed in proportion (synthetic). （2）任意一种彩色可分解为三种基色。（分解性） (2)Any color can be decomposed into three primary colors (decomposition). （3）混合的亮度等于各基色亮度之和。（叠加性） (3)The mixed brightness is equal to all primary colors.(addition). （4）混合比例决定色调和色饱和度。（色度决定性） (4)The mix proportions determine tinge and color saturation.(chromaticity determination) 11.三基色 Three primary colors R、G、B. 记得小时候还学了个颜料的三原色……于是百度一下：红、黄、青 Always remember that there exists primary colors of pigment~so I search it.It is red,yellow and cyan. 12.一个公式（亮度方程） A fomula Y=0.30R+0.59G+0.11B 例：1R+2G+2B=浅青(light cyan) Why? ∵1R+1G+1B=白(white) 1G+1B=青(cyan) 白+青=浅青(white+cyan=light cyan) 这个算法莫名想笑…… This idea makes me inexplicably laugh~ 13.互补色：加起来为白色的两种颜色。 Complementary colors,the twocolors mixed up in white color. 14.15625！15625！15625！重要的数字说三遍！Important number should be repeated three times! 行扫描的频率……听到这个数字要很快的反应过来……就像3.1415926一样…… 正程52us，逆程12us，全程64us，即行扫描周期。 我国现行广播电视标准规定：帧数为25HZ，一帧图像分625行传送。所以行扫描频率25X625=15625HZ……就是这样来的…… It is line scan frequency~everyone of us should reflect on the meaning as 3.1415926~ Positive trace is 52us,negative trace is 12us,the whole trace is 64us,and it is just the line scan cycle. The existing provisions of broadcast standards in China,frames is 25HZ,and an image is divided into 625 transmission line.So,the line scan frequency is 25X625=15625HZ,that's is. 15.对比度 Contrast 我之前对这个的定义确实不清楚的说……就连PS上的对比度也是怎么看着舒服怎么调…… 对比度，通俗的讲，就是，实际的蓝天和白云的颜色，哦，是这么蓝和这么白，10000:100好了，反映到电视上，还是那么蓝和那么白！就100:1好了……让我想到比例尺。还是原来的配方，还是熟悉的味道！ I didn't get it clear before,and when I used PS,the contrast is adjusted to the degree that a image how to make me comfortable.Contrast, popular speaking, that is, the actual blue sky and white clouds of color,the component of blue and white is 10000:100,for example,which reflect to TV is 100:1,just like a scale.The original formula and the similar taste! 16.黑白全电视信号特指视频信号。 Black and white television signal refers to the video signal. 17.基色信号-亮度信号=色差信号 Primary signal - luminance signal = color difference signal 18.绿色幅值小，易受干扰，一般传送红、蓝信号。 green has small amplitude,and it is vulnerable to be interfered,it transfers red and blue signal in general. 19.白！黄！青！绿！紫！红！蓝！黑！ 白！黄！青！绿！紫！红！蓝！黑！ 白！黄！青！绿！紫！红！蓝！黑！ WHITE!YELLOW!CYAN!GREEN!PURPLE!RED!BLUE!BLACK! 标准彩条测试信号。常识背背背！ It is the standard color test signal.We should recite it as common sense. 20.一个记住的电路 A curcuit to remember 放大电路……如此的熟悉…… So familiar with it. Rw1滑动调节对比度，Rw2滑动调节亮度！ Rw1 to adjust contrast,and Rw2 to adjust brightness! 感谢无私的好友把她上学期的书借给了我！ Thanks my selfless friend for sending her books to me！ 21.指标如果要做到最顶级首选CRT。为什么我们现在都用薄的液晶啊什么的，因为日常使用不需要很高的指标，并且方便使用。 If you want to achieve the top indicators,CRT is preferred.You may ask why we use today is liquid crystal,the reason is Top indicators are not needed in daily use,and it is convinient. 22. 铅笔写的是我的笔记，乱max…… The writing is my note,you can ignore it~ 几个专有名词要知道：阻尼二极管、逆程电容、校正电容、行输出管（行管）、行输出变压器（高压包）、行推动变压器 Several professional noums,Damping diode, reverse pass capacitor, correction capacitor, line output tube (line tube), line output transformer (high voltage package), line drive transformer. 扩展：硅堆、桥堆 Extension: silicon stack, bridge 段子或注意的地方 Something fun or details (It may lost its fun when translated into English) 1.“B光源（色温4874K）近似为中午太阳光的光谱。”类似说法都不够准确，但经典教材上往往都采取这样模糊的说法。 2.用点燃的报纸烘烤灯丝……是为了激发电子发射。有个问题是灯坏了还是什么的，总之就是不行→_→因为激发不了电子发射。（写此文时突然短路……） 3.有个单位叫熙提……它的缩写………………自行百度或查书吧。（保持优雅） 4.隔壁的王叔叔…… 5.南京的声音优雅的车站播音员……强调音色的问题…… 6.列宁……（原名弗拉基米尔·伊里奇·乌里扬诺夫）（我竟然还百度了一下……） 7.小日本…… 偏题了……段子很多就不说了……注意的问题是重点！咳咳~ 回看本文…………简直就是帮他们要考试的勾了一遍重点（除了一些公式和计算……）我真是大写的可爱啊！啊。。。 I AM CUTE~ P.S.不吹不黑 上课就要像这样愉悦才是好的课堂 快乐学习不是梦~ Pleasant classroom atmosphere is a excellent class.Happy learning is not a dream. 真是一趟愉快的蹭课之旅~ It was a pleasant trip to the class. 感谢老师 感谢校园 感谢这个和平的时代 thanks for the teacher,thanks for the campus,thanks for this peaceful time. &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！ The article has been viewed &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; times.Thank you for your visit! &lt;/span&gt;","raw":null,"content":null,"categories":[{"name":"通信工程","slug":"通信工程","permalink":"http://hubojing.github.io/categories/通信工程/"}],"tags":[{"name":"显示技术","slug":"显示技术","permalink":"http://hubojing.github.io/tags/显示技术/"}]},{"title":"java自学笔记","slug":"java自学笔记","date":"2016-03-14T13:21:31.000Z","updated":"2016-04-04T09:37:00.171Z","comments":true,"path":"2016/03/14/java自学笔记/","link":"","permalink":"http://hubojing.github.io/2016/03/14/java自学笔记/","excerpt":"","text":"现将以前分散的java自学笔记归总，方便查阅。 &lt;!--more--&gt; 2016.3.26更新 快速打法与Scanner 两个快速打法 syso alt+/ 快速打出 System.out.println(); main alt+/ 回车 快速打出： public static void main(String[] args) { } 使用Scanner工具类来获取用户输入信息 Scanner类似于java.util包中，使用时需要导入此包 步骤： 1.导入java.util.Scanner 2.创建Scanner对象 3.接收并保存用户输入的值 package com; import java.util.Scanner; main函数里 Scanner input=new Scanner(System.in);//创建Scanner对象 System.out.println(&quot;请输入信息：&quot;); int a=input.nextInt();//获取用户输入的信息并保存在变量中 print和println区别：println输出信息后会换行，而print不会换行 2016.3.15更新 java基础知识 关键字 优秀攻城师的习惯 1、变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，俗称骆驼式命名法（也称驼峰命名法），如 myAge 2、变量命名时，尽量简短且能清楚的表达变量的作用，做到见名知意。如：定义变量名 stuName 保存“学生姓名”信息 java的数据结构 常见的基本数据类型 强制转换 强制类型转换将 75.8 赋值给 int 型变量后，结果为 75，数值上并未进行四舍五入，而是直接将小数位截断。 强制类型转换可能会造成数据的丢失。 常量名一般使用大写字符。 注释 Java 中注释有三种类型：单行注释、多行注释、文档注释 单行：// 多行：/* / 文档：/* */ 我们可以通过 javadoc 命令从文档注释中提取内容，生成程序的 API 帮助文档。 使用文档注释时还可以使用 javadoc 标记，生成更详细的文档信息： @author 标明开发该类模块的作者 @version 标明该类模块的版本 @see 参考转向，也就是相关主题 @param 对方法中某参数的说明 @return 对方法返回值的说明 @exception 对方法可能抛出的异常进行说明 java常用的比较运算符 ** &gt; 、 &lt; 、 &gt;= 、 &lt;= 只支持左右两边操作数是数值类型** ** == 、 != 两边的操作数既可以是数值类型，也可以是引用类型** 运算符优先级 级别为 1 的优先级最高，级别 11 的优先级最低。 条件语句之 switch 可以把功能相同的 case 语句合并起来，如 循环语句之 for for 循环变量初始化和循环变量变化部分，可以是使用 “,” 同时初始化或改变多个循环 变量的值 循环跳转语句之 continue continue 的作用是跳过循环体中剩余的语句执行下一次循环。 2016.3.14更新 java初体验 环境变量配置 1.jdk安装目录 2.jdk下bin安装目录 3.jdk下lib安装目录 第一个java程序 win8.1系统下 win+R，输入cmd。 dir查看磁盘文件 java HelloWorld.java 错误：java HelloWorld.class java命令后不能跟文件后缀 java HelloWorld 使用Eclipse开发Java程序 安装eclipse后，弹出 这是因为eclipse与JDK的版本不一致。 （在cmd中输入java -version查看版本） 我选择的是下面这种。 步骤： 1.创建Java项目 2.创建程序包 3.编写Java源程序 4.运行Java程序 使用myeclipse的步骤相同。 &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！ &lt;/span&gt;","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"http://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"java","slug":"java","permalink":"http://hubojing.github.io/tags/java/"}]},{"title":"靖靖的脑洞大开 | Jinger's Special Ideas","slug":"靖靖的脑洞大开（一）","date":"2016-03-12T06:23:00.000Z","updated":"2016-07-02T08:18:52.324Z","comments":true,"path":"2016/03/12/靖靖的脑洞大开（一）/","link":"","permalink":"http://hubojing.github.io/2016/03/12/靖靖的脑洞大开（一）/","excerpt":"","text":"&lt;div align=&quot;left&quot;&gt; &lt;img src=&quot;http://7xray0.com1.z0.glb.clouddn.com/16-6-14/19192858.jpg&quot; width=&quot;300&quot; height=&quot;180&quot; alt=&quot;配图&quot; style=&quot;float:right;&quot;/&gt; &lt;/div&gt; 本文属于胡博靖的创意（偶尔天马行空的脑洞）。 稀奇古怪的idea有时就像柯南每次推理正确时被闪电般电流击中一样…… 愿创造力永不枯竭…… &lt;!--more--&gt; 2016.6.13更新 关于电 严格说是我室友的想法。 她说，要是电像wifi一样不用线传输多好……（一个被各种电线搅的烦躁的girl的抱怨） →_→→_→→_→→_→→_→→_→“用一种气体包裹着电，这样就不会电死啦……” 我百度了一下，发现真的可以耶…… 电能无线传输技术 原理：利用电磁场，把电能像信号一样发射到用电设备上去，有点类似WiFi。电器不需再用电线，只需一个电能的发射装置和一个接收装置。 看来，无线时代正在向我们走来。 2016.3.15更新 关于人工智能 今天看到一篇评论，写的不错，发上来。其中有几句话说的很好： 技术群体战胜了天赋极高的自然个体。 就算真的有“征服”发生，那也是新人类征服了旧人类，而不是人类的末日。 该文还提到了“虚拟现实”的概念，让我瞬间想到了柯南剧场版：贝克街的亡灵。带着头盔，仿佛身处他处。 **人工智能是让人类生活的劳作性内容越来越少，而虚拟现实是让人类生存生活的创造性意义大规模扩充。 AI向 最近阿尔法狗赢李世石的新闻响遍全世界。（阿尔法狗是一种什么狗→_→） 人工智能，这个神秘又让人畏惧的高科技哟… 人工智能 人工智能（Artificial Intelligence），英文缩写为AI。它是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。 人工智能是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器，该领域的研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。人工智能从诞生以来，理论和技术日益成熟，应用领域也不断扩大，可以设想，未来人工智能带来的科技产品，将会是人类智慧的“容器”。 看它涉及的范围之广：实际应用 机器视觉，指纹识别，人脸识别，视网膜识别，虹膜识别，掌纹识别，专家系统，自动规划，智能搜索，定理证明，博弈，自动程序设计，智能控制，机器人学，语言和图像理解，遗传编程等。 人工智能就其本质而言，是对人的思维的信息过程的模拟。 对于人的思维模拟可以从两条道路进行，一是结构模拟，仿照人脑的结构机制，制造出“类人脑”的机器；二是功能模拟，暂时撇开人脑的内部结构，而从其功能过程进行模拟。现代电子计算机的产生便是对人脑思维功能的模拟，是对人脑思维的信息过程的模拟。 以上转自百度百科…… 和室友辩论，阿尔法狗是否能赢所有人。我觉得可以，如果算法足够精确，存储足够大到可以容纳全部走法。（这个数量级是10^172次方……目前也许是远远达不到这个指标的。不知道从理论上讲，存储可以达到这么多吗？） 脑洞：我相信人类开发AI的初始目的一定是服务人类的。但是，人类不得不警惕，拥有人类智慧的机器人（或者其他形态的机器），在各个方面都优于人类机体时，是否有灭亡人类的可能性。有人和我辩论，认为机器永远不可能比人类有智慧。对此我持保留态度。也许现在的机器的核心是人类输入的程序算法，但当病毒入侵或机器足够智能化到可以自我优化代码时，甚至结合仿生学或者神经学相关，使机器能自我学习，具备类似于人类情感的机能，将是人类最大的敌人。（机器内心OS：我比你强比你壮，为什么还要服务于人……）况且总有些野心科学家……将这种技术用于战争→_→其结果还是世界大战，人类遭殃。 所以AI发展也应该有个底线，就和克隆人一样，任何人不能触碰。 &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！ &lt;/span&gt;","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://hubojing.github.io/tags/idea/"},{"name":"创意","slug":"创意","permalink":"http://hubojing.github.io/tags/创意/"},{"name":"思维","slug":"思维","permalink":"http://hubojing.github.io/tags/思维/"}]},{"title":"PPT动画制作之登录等待","slug":"PPT动画制作之登录等待","date":"2016-03-08T13:36:48.000Z","updated":"2016-03-26T13:30:22.717Z","comments":true,"path":"2016/03/08/PPT动画制作之登录等待/","link":"","permalink":"http://hubojing.github.io/2016/03/08/PPT动画制作之登录等待/","excerpt":"","text":"坐在电脑前，我们常看见电脑页面等待的画面，就是一个圆不停的转。常让人等得怒火直冒，想碾碎电脑。（这么暴力的并不是我~） 现在就来说说，怎么制作这个动画效果。并不难。 先来看看效果怎么样： &lt;!--more--&gt; 具体步骤 画个圆 调个色 添个动作路径 复个制 减个透明度 对个齐 延个时 搞定！ 是不是还挺酷的~~~ &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！ &lt;/span&gt;","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"http://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://hubojing.github.io/tags/blog/"},{"name":"PPT动画","slug":"PPT动画","permalink":"http://hubojing.github.io/tags/PPT动画/"}]},{"title":"markdown语法简记","slug":"markdown语法简记","date":"2016-03-08T08:10:49.000Z","updated":"2016-10-23T15:28:47.844Z","comments":true,"path":"2016/03/08/markdown语法简记/","link":"","permalink":"http://hubojing.github.io/2016/03/08/markdown语法简记/","excerpt":"","text":"&lt;div align=&quot;left&quot;&gt; &lt;img src=&quot;http://www.onethink.cn/Uploads/Editor/2013-12-13/52aaabb4e7486.png&quot; width=&quot;300&quot; height=&quot;180&quot; alt=&quot;配图&quot; style=&quot;float:right;&quot;/&gt; 本文属于我的自查笔记，不定期更新。 &lt;/div&gt; &lt;!--more--&gt; 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 例： 一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 加粗 *斜体文本* 斜体文本 _斜体文本_ 斜体文本 **粗体文本** 粗体文本 ***粗斜体文本*** 粗斜体文本 ___粗斜体文本___ 粗斜体文本 链接 文字链接 [](http://网址) 网址链接 http://网址 高级链接 链接用 1 作为网址变量[例子1][1]. 链接用 hubojing 作为网址变量[例子2][hubojing]. 然后在文档的结尾为变量赋值（网址） [1]:hubojing.github.io [hubojing]:hubojing.github.io 引用 !(引用名称)[引用地址] 高级引用 链接用 1 作为网址变量 [hubojing][1]. 然后在文档的结尾位变量赋值（网址） [1]:hubojing.github.io 分隔符 三个星号 *** 三个减号 ---(上面一行文字需空一行，否则自动变为二级标题) 三个下划线 ___ 转义符 如果描述中用到 markdown 符号，比如 _ # * 等，又不想它被转义，此时可在这些符号前加反斜杠，如 \\_ \\# \\* 进行避免。 例： 不想加粗 **不想加粗** 强调 - &gt; 是这样？ like this. 删除线 ~~这是删除线~~ 这是删除线 换行 在末尾打两个空格 开头空两格 输入法切换成全角，打两个空格。（虽然这理应是CSS的负责范围） 参考文章 1.Markdown编辑器语法指南 2.Markdown入门 &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！ The article has been viewed &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; times.Thank you for your visit! &lt;/span&gt;","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"http://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://hubojing.github.io/tags/blog/"},{"name":"markdown","slug":"markdown","permalink":"http://hubojing.github.io/tags/markdown/"}]},{"title":"1602+24C08+4X4键盘密码锁","slug":"1602-24C08-4X4键盘密码锁","date":"2016-03-07T00:36:04.000Z","updated":"2016-03-26T13:29:27.311Z","comments":true,"path":"2016/03/07/1602-24C08-4X4键盘密码锁/","link":"","permalink":"http://hubojing.github.io/2016/03/07/1602-24C08-4X4键盘密码锁/","excerpt":"","text":"【注】我的单片机课程设计选题是单片机密码锁。但是课题并没有要求用存储器存储密码，所以当时我的设计还是比较简陋的。那个设计只能设定一个内部密码，断电后又恢复到初始密码状态。但是实际生活中，必须能够存储密码。并且，在课程设计里我用的是数码管显示密码，在这里我用的是1602液晶显示。于是以下的设计着重于存储与1602相关，且代码是重新编写（参考了网上的案例），没有用课程设计的代码。 在此提供我课程设计的单片机密码锁链接：胡博靖的单片机课程设计 &lt;!--more--&gt; 设计思路 现在程序内设定一个初始密码，然后用液晶显示提示用户输入密码，通过矩阵键盘输入密码，然后进行比较。如果密码正确，则绿灯亮起，否则红灯亮1S，并提示输入密码错误次数。如果输入错误次数达到三次则蜂鸣器报警并锁定键盘。 自用笔记 数码管编码表（0到f） 共阳：0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e 共阴：0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71 protues仿真记载 1602——LM016 晶振——crystal 蜂鸣器——buzzer/sounder/speaker 可调电阻——pot-hg(课本写的是pot-lin,不过protues7.8没有) 不错的资料和方法 I2C总线简介 矩阵键盘行反转法 过程中所犯的低级错误 如图，LED所连接的电阻阻值太大，电流完全达不到使LED发光的值。 改正后，LED正常发光。 尚未解决的问题 蜂鸣器不响。 程序应该正确，蜂鸣器旁的控制点红蓝色变化正确，改过蜂鸣器电压值，12V、5V、3V、1.5V都试过，但是就是不响。 可能的原因： 蜂鸣器是用方波驱动的，若仅输出单一的高电平或低电平是没用的。 蜂鸣器发出的声波也要靠人耳来听取，过高或过低的频率人耳是无法听到的。 蜂鸣器的仿真模型应选择下图中后面两种，才能听到声音。（然而我并没有听到声音） Speaker &amp; Sounders BUZZER DEVICE Generic buzzer symbol BUZZER ACTIVE DC Operated Buzzer - Outputs Via Sound Card SOUNDER ACTIVE Piezo Sounder model (Digital) - Outputs Via Sound Card SPEAKER DEVICE Generic loudspeaker symbol SPEAKER ACTIVE loudspeaker model (Analog) - Outputs Via Sound Card 依次解释如下： 蜂鸣器 通用蜂鸣器符号 无仿真模型 蜂鸣器 活动的 阻抗12Ω直流蜂鸣器 仿真时通过声卡发声 讯响器 活动的 压电讯响器数字模型 仿真时通过声卡发声 扬声器 通用扬声器符号 扬声器 活动的 阻抗8Ω扬声器模拟模型 仿真时通过声卡发声 存储有问题。 程序代码严格按照标准代码写的，常见的delay();的延时问题应该没有。但是明显仿真结果没有存储到新的修改密码，一直是初始密码。 请各位指教。 源程序和仿真图 若需要下载，请点击！ #include&lt;reg52.h&gt; #define uint unsigned int #define uchar unsigned char void key_scan(); uchar count0,count1,count3,num,n=0,temp,a,j,count4; uchar mima[8]; //初始密码存储区 uchar tab_key[50]; //输入密码存储区 uchar code table[]={ 0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e };//led共阳数码管 /uchar code table[]={ 0x3f,0x06,0x5b,0x4f, 0x66,0x6d,0x7d,0x07, 0x7f,0x6f,0x77,0x7c, 0x39,0x5e,0x79,0x71}; //led共阴数码管 / bit enterflag; //确认键按下与否的标志 bit mimaflag; //密码正确与否的标志 bit xiugaiflag; //修改密码标志 bit enter1flag; //修改密码确认键标志 sbit red=P2^1; sbit green=P2^0; sbit bell=P2^2; sbit rs=P2^6; sbit rw=P2^5; sbit lcden=P2^7; sbit scl=P3^0; sbit sda=P3^1; uchar code table1[]=&quot;input the passco&quot;; uchar code table2[]=&quot;de: --------&quot;; uchar code table3[]=&quot;&quot;; uchar code table4[]=&quot;right (^^) &quot;; uchar code table5[]=&quot;first error!!!!&quot;; uchar code table6[]=&quot;second error!!!!&quot;; uchar code table7[]=&quot;third error see &quot;; uchar code table8[]=&quot;u tomorrow (^^)&quot;; uchar code table9[]=&quot;define the passc&quot;; uchar code table10[]=&quot;ode: --------&quot;; uchar code table11[]=&quot;code is new&quot;; //键盘消抖函数**************** void delay1() { ;; } void delay2(uchar x) { uchar a,b; for(a=x;a&gt;0;a--) for(b=100;b&gt;0;b--); } void delay3(uchar x) { uchar a,b; for(a=x;a&gt;0;a--) for(b=200;b&gt;0;b--); } void delay(uint z) { uint x,y; for(x=z;x&gt;0;x--) for(y=110;y&gt;0;y--); } //e^2room的初始化************** void start() //开始信号 { sda=1; //书P171 时钟SCL线为高电平时，数据线SDA出现由高电平向低电平变化的情形时，启动I^2C总线数据传送。 delay1(); scl=1; // delay1(); sda=0; // delay1(); } void stop() //停止 { sda=0; //书P171时钟SCL线为高电平时，数据线SDA出现由低电平到高电平的变化的情形时，将停止I^2C总线数据传送。 delay1(); scl=1; delay1(); sda=1; delay1(); } //应答信号********* void respond() { uchar i; scl=1; delay1(); while((sda==1)&amp;&amp;(i&lt;250))i++; //书P176 应答sda为0，非应答为1 scl=0; //释放总线 ？ delay1(); } void noack() { scl=1; delay1(); scl=1;delay1(); scl=0;delay1(); sda=0;delay1(); } //写字节操作函数***** void write_byte(uchar date) { uchar i,temp; temp=date; for(i=0;i&lt;8;i++) { temp=temp&lt;&lt;1; //保持最高位，左移到进位CY scl=0; //scl上跳沿写入 delay1(); sda=CY; //溢出位 delay1(); scl=1; delay1(); scl=0;delay1(); } scl=0; delay1(); sda=1;//总线释放 ？ delay1(); } //读字节操作函数 uchar read_byte() { uchar i,k; scl=0; delay1(); sda=1; delay1(); for(i=0;i&lt;8;i++) { scl=1; delay1(); k=(k&lt;&lt;1)|sda; //或运算，放到最低位 scl=0; delay1(); } return k; } //写地址函数 void write_add(uchar address,uchar date) { start(); write_byte(0xa0); //设备地址 respond(); write_byte(address); respond(); write_byte(date); respond(); stop(); } //读地址函数 uchar read_add(uchar address) { uchar date; start(); write_byte(0xa0); respond(); write_byte(address); respond(); start(); write_byte(0xa1); //表示接收地址 respond(); date=read_byte(); noack(); stop(); return date; } //LCD1602的初始化*** void write_com(uchar com) //书P154 写命令函数 { rs=0; //RS为寄存器选择，高电平1时选择数据寄存器、低电平0时选择指令寄存器。 lcden=0; P0=com; delay(5); lcden=1; //LCD的使能端高电平有效 delay(5); lcden=0; } void write_date(uchar date) //写数据函数 { rs=1; lcden=0; P0=date; delay(5); lcden=1; delay(5); lcden=0; } //**密码比较函数 bit mimacmp() { bit flag; uchar i; for(i=0;i&lt;8;i++) { if(mima[i]==tab_key[i]) flag=1; else { flag=0; i=8; } } return(flag); //返回flag } //LCD显示函数开始 void lcd_display() { uchar i=0; write_com(0x80+0x40+8);//液晶操作中的写入，地址是0x80开头的，加0x40为写入第二行，加8则为确定地址。 for(i=0;i&lt;n;i++) { write_date(table3[0]); //uchar code table3[]=&quot;&quot; } } //********键盘功能分配函数群开始 // 0 1 2 3 // 4 5 6 7 // 8 9 确认（A） 无效（B） //取消（C）修改密码键（D）确认修改键（E） 无效（F） void key_manage1() { tab_key[n]=0; //数组的存储顺序是从n=0开始的，因此无论是哪个键先按下都会存入tab_key[0] n++; if(xiugaiflag==1) //如果按下了修改键 { mima[count4]=0; count4++; } } void key_manage2() { tab_key[n]=1; n++; if(xiugaiflag==1) { mima[count4]=1; count4++; } } void key_manage3() { tab_key[n]=2; n++; if(xiugaiflag==1) { mima[count4]=2; count4++; } } void key_manage4() { tab_key[n]=3; n++; if(xiugaiflag==1) { mima[count4]=3; count4++; } } void key_manage5() { tab_key[n]=4; n++; if(xiugaiflag==1) { mima[count4]=4; count4++; } } void key_manage6() { tab_key[n]=5; n++; if(xiugaiflag==1) { mima[count4]=5; count4++; } } void key_manage7() { tab_key[n]=6; n++; if(xiugaiflag==1) { mima[count4]=6; count4++; } } void key_manage8() { tab_key[n]=7; n++; if(xiugaiflag==1) { mima[count4]=7; count4++; } } void key_manage9() { tab_key[n]=8; n++; if(xiugaiflag==1) { mima[count4]=8; count4++; } } void key_manage10() { tab_key[n]=9; n++; if(xiugaiflag==1) { mima[count4]=9; count4++; } } //确认键**************************** void key_manage11() { enterflag=1; //确认键按下 if(n==8) //只有输入8个密码后按确认才做比较 { mimaflag=mimacmp(); } else { mimaflag=0; } if(enterflag==1) { enterflag=0; //标志位清零 n=0; //用FFFFFFFF清除已经输入的密码 for(count3=0;count3&lt;8;count3++) { delay(5); tab_key[count3]=0x0f; } TR1=1; //打开计数器1 count1=0; //定时器1由50MS累计到1S所用的计数器 if(mimaflag==1) { a=0; write_com(0x01); write_com(0x80); for(count3=0;count3&lt;16;count3++) { write_date(table4[count3]); //密码正确，显示RIGHT，绿灯亮 green=0;red=1; bell=1; delay(5); } } else { n=0; red=0; bell=0; a++; if(a==1) { for(count3=0;count3&lt;8;count3++) //ffffffff清除密码 { delay(5); tab_key[count3]=0x0f; } write_com(0x01); write_com(0x80); for(count3=0;count3&lt;16;count3++) { write_date(table5[count3]); //密码错误，显示 first error，红灯亮 green=1;red=0; bell=1; delay(5); } TR1=1; } if(a==2) { for(count3=0;count3&lt;8;count3++) //ffffffff清除密码 { delay(5); tab_key[count3]=0x0f; } write_com(0x01); write_com(0x80); for(count3=0;count3&lt;16;count3++) { write_date(table6[count3]); //密码错误，显示SECOND ERROR，红灯亮 green=1;red=0; bell=1; delay(5); } TR1=1; } if(a==3) { for(count3=0;count3&lt;8;count3++) //ffffffff清除密码 { delay(5); tab_key[count3]=0x0f; } write_com(0x01); write_com(0x80); for(count3=0;count3&lt;16;count3++) { write_date(table7[count3]); //密码错误，显示third error see，红灯亮 green=1;red=0; bell=0;//蜂鸣器报警 delay(5); } write_com(0x80+0x40); for(count3=0;count3&lt;16;count3++) { write_date(table8[count3]);//密码错误，显示 U TOMORROW ,红灯亮 green=1;red=0; bell=0;//蜂鸣器报警 delay(5); } TR1=0; } } } } void key_manage12() { tab_key[n]=11; n++; //密码计数清零 } //********取消键 void key_manage13() { n=0; //密码计数清零 write_com(0x80); //指针所指位置 第一行 for(count3=0;count3&lt;16;count3++) { write_date(table1[count3]); //第一行显示INPUT THE PASSPORD: delay(5); } write_com(0x80+0x40); //第二行 for(count3=0;count3&lt;16;count3++) { write_date(table2[count3]); //开机显示-------- delay(5); tab_key[count3]=0x0f; //用FFFFFFFF清除已经输入的密码 } } //*********修改密码键 void key_manage14() { uchar aa=0; n=0; xiugaiflag=1; write_com(0x01); write_com(0x80); for(count3=0;count3&lt;16;count3++) { write_date(table9[count3]); //显示define the password delay(5); tab_key[count3]=0x0f; //用FFFFFFFF清楚已经输入的密码 } write_com(0x80+0x40); for(count3=0;count3&lt;16;count3++) { write_date(table10[count3]); //显示-------- delay(5); } TR0=1; } //**********修改密码键的确认键 void key_manage15() { n=0; enter1flag=1; if(enter1flag==1) { enter1flag=0; count4=0; for(count3=0;count3&lt;16;count3++) { tab_key[count3]=0x0f; //用FFFFFFFF清除已经输入的密码 } write_com(0x01); write_com(0x80); for(count3=0;count3&lt;16;count3++) { write_date(table11[count3]); delay(100); } TR1=1; count1=0; } } void key_manage16() { tab_key[n]=15; n++; } //***********定时器1的50MS,共延时1秒 void time_1() interrupt 3 { TH1=(65536-50000)/256; TL1=(65536-50000)%256; if(count1&lt;20) { count1++; } else //计时到1S { TR1=0; count1=0; mimaflag=0; red=1; bell=1; //显示FFFFFFFF write_com(0x01); write_com(0x80); for(count3=0;count3&lt;16;count3++) { write_date(table1[count3]); //显示INPUT THE PASSCODE delay(5); } write_com(0x80+0x40); for(count3=0;count3&lt;16;count3++) { write_date(table2[count3]); //开机显示FFFFFFFF delay(5); } } } //*定时0 void time_0() interrupt 1 { TH0=(65536-50000)/256; TL0=(65536-50000)%256; if(count4&lt;8) { key_scan(); } else { TR0=0; count4=0; } } //初始化函数 void init() { uchar i; lcden=0; write_com(0x38); //打开显示模式设置 write_com(0x0c); //打开显示，光标等等设置为零 write_com(0x06); //当读或写一个字符后地址指针加一，且光标加一，当写一个字符后整频显示左移， write_com(0x01); //清零指令 write_com(0x80); //指针所指位置 //定时器初始化 TMOD=0x11; //T0,T1工作方式1 TH0=(65536-2000)/256; TL0=(65536-2000)%256; //T0初始化2MS TH1=(65536-50000)/256; TL1=(65536-50000)%256; //T1初始化50MS TR1=0; ET1=1; EA=1; TR0=0; ET0=1; count0=0; //初始没有密码输入，故为零 enterflag=0; //没有确认键按下 mimaflag=0; //密码正确与否键先置零 red=1; //红灯不亮 //密码存入EPROM中********************** sda=1; delay(5); scl=1;// SDA=1,SCL=1,使主从设备处于空闲状态 delay(5); for(i=0;i&lt;8;i++) { write_add(i,8); delay3(100); } for(i=0;i&lt;8;i++) { mima[i]=read_add(i); delay(5); } } void main() { rw=0; init(); write_com(0x80); //给com一个数值，com连着单片机 for(count3=0;count3&lt;16;count3++) { write_date(table1[count3]); //第一行显示INPUT THE PASSPORD: delay(5); } write_com(0x80+0x40); for(count3=0;count3&lt;16;count3++) { write_date(table2[count3]); //开机显示FFFFFFFF delay(5); } while(1) { key_scan(); //调用键盘扫描函数 lcd_display(); } } //键盘扫描函数开始* void key_scan() { //*扫描第一行 P1=0xfe; temp=P1; temp=temp&amp;0xf0; if(temp!=0xf0) { delay(100); if(temp!=0xf0) { temp=P1; switch(temp) { case 0xee: key_manage1(); break; case 0xde: key_manage2(); break; case 0xbe: key_manage3(); break; case 0x7e: key_manage4(); break; } while(temp!=0xf0) { temp=P1; temp=temp&amp;0xf0; } } } //***************扫描第二行 P1=0xfd; temp=P1; temp=temp&amp;0xf0; if(temp!=0xf0) { delay(100); if(temp!=0xf0) { temp=P1; switch(temp) { case 0xed: key_manage5(); break; case 0xdd: key_manage6(); break; case 0xbd: key_manage7(); break; case 0x7d: key_manage8(); break; } while(temp!=0xf0) { temp=P1; temp=temp&amp;0xf0; } } } //**********扫描第三行 P1=0xfb; temp=P1; temp=temp&amp;0xf0; if(temp!=0xf0) { delay(100); if(temp!=0xf0) { temp=P1; switch(temp) { case 0xeb: key_manage9(); break; case 0xdb: key_manage10(); break; case 0xbb: key_manage11(); break; case 0x7b: key_manage12(); break; } while(temp!=0xf0) { temp=P1; temp=temp&amp;0xf0; } } } //***********扫描第四行 P1=0xf7; temp=P1; temp=temp&amp;0xf0; if(temp!=0xf0) { delay(100); if(temp!=0xf0) { temp=P1; switch(temp) { case 0xe7: key_manage13(); break; case 0xd7: key_manage14(); break; case 0xb7: key_manage15(); break; case 0x77: key_manage16(); break; } while(temp!=0xf0) { temp=P1; temp=temp&amp;0xf0; } } } } &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！ &lt;/span&gt;","raw":null,"content":null,"categories":[{"name":"通信工程","slug":"通信工程","permalink":"http://hubojing.github.io/categories/通信工程/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"http://hubojing.github.io/tags/单片机/"},{"name":"密码锁","slug":"密码锁","permalink":"http://hubojing.github.io/tags/密码锁/"},{"name":"矩阵键盘","slug":"矩阵键盘","permalink":"http://hubojing.github.io/tags/矩阵键盘/"},{"name":"1602","slug":"1602","permalink":"http://hubojing.github.io/tags/1602/"}]},{"title":"零碎知识记录","slug":"零碎知识记录","date":"2016-01-04T13:42:08.000Z","updated":"2016-03-26T13:28:24.268Z","comments":true,"path":"2016/01/04/零碎知识记录/","link":"","permalink":"http://hubojing.github.io/2016/01/04/零碎知识记录/","excerpt":"","text":"位选就是要亮哪一个数码管,段选就是让这个数码管显示哪个数!!! #define uchar unsigned char unsigned char 用来声明无符号字符变量的，上面这个语句的作用就是在其之后 可以用uchar来代替unsigned char 简化编写，就是说 写了这条 下面在写 uchar i; 效果跟 unsigned char i; 一样 &lt;!--more--&gt; 蓝色是低电平。红色是高电平。黄色一般为不正常的情况，灰色为不确定（高阻？） 0xe0 P2.4 P1=0x10 P1的第5位 0x04是十六进制数，对应的二进制数为0000 0100，从低位到高位一次对应p1.0-p1.7，所以p1.2为高电平，其余为低电平。 temp=P3&amp;0xf0; 是个位与运算符 0x80=1000 0000 temp转换为二进制 假设temp=1010 1010 &amp;后temp=1000 0000 如果temp=0010 1010 &amp;后temp=0000 0000 可见temp低7位无论是什么&amp;后都是0 最高位由temp决定 结果就是最高位保持其余全为0从而取出了最高位 &amp;是按位与的意思，就是说只将P3口的高四位读入，低四位为0，放到 temp里面 P2=0x01 对应 P2^0=1 P2=0x02 对应 P2^1=1 P2=0x04 对应 P2^2=1 P2=0x08 对应 P2^3=1 P2=0x10 对应 P2^4=1 P2=0x20 对应 P2^5=1 P2=0x40 对应 P2^6=1 P2=0x80 对应 P2^7=1 P2=0x11 对应 P2^4=1 与 P2^0=1 P2=0xff 对应 P2^7=1 与 P2^6=1、P2^5=1、P2^4=1、P2^3=1、P2^2=1、P2^1=1、P2^0=1 数字信号处理 问题 1.正弦型模拟信号xa(t)=Asin(Ω0t+φ)中t是时间变量，单位是秒（s），去连续数值，而正弦序列中x(n)=Asin(ω0n+φ)中n是无量纲数，取离散数值，因而造成Ω0越大，则xa(t)变化越快；但由于x(n)=sin(ω0n+φ)=sin[(ω0+2πm)n+φ]，当ω0变化时，x(n)是以2π为周期的，并不是ω0越大，x(n)变化越快。 连续和离散的不都是以2π为周期的吗？为什么一个越来越大，一个却有周期性？ &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！ &lt;/span&gt;","raw":null,"content":null,"categories":[{"name":"通信工程","slug":"通信工程","permalink":"http://hubojing.github.io/categories/通信工程/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"http://hubojing.github.io/tags/单片机/"},{"name":"数字信号处理","slug":"数字信号处理","permalink":"http://hubojing.github.io/tags/数字信号处理/"},{"name":"问题","slug":"问题","permalink":"http://hubojing.github.io/tags/问题/"}]},{"title":"Flash动画制作学习心得","slug":"Flash动画制作学习心得","date":"2015-12-06T03:26:33.000Z","updated":"2016-03-26T13:27:56.283Z","comments":true,"path":"2015/12/06/Flash动画制作学习心得/","link":"","permalink":"http://hubojing.github.io/2015/12/06/Flash动画制作学习心得/","excerpt":"","text":"制作过程中发现的问题及解决方案： 1.音频不能导入 最简单的解决方案：使用Adobe Adition内录。注意保存比特率不要高于160KHZ。（320KHZ导入不了） 2.按钮制作了没反应 解决方案：首先新建一个图层，把按钮拖进去。在第一帧（注意是帧）动作里写上语句stop();然后在按钮的动作里写上语句on (release){play();} &lt;!--more--&gt; 3.“开始”按钮控制不了声音 最简单粗暴的方法：声音从第二帧开始。 4.点击“暂停”按钮声音停止不了 动作里写上语句stopAllSounds(); 5.声音会不断循环 在最后一帧（记住加入关键帧）动作里写上stopAllSounds(); 6.mc总是一闪而过 是mc的长度没设置好。拖过到合适的长度即可。 7.按钮上的文字怎么改 在按钮元件内部有一层是text，把默认的文本框删掉，在自己加一个上去。 还有一些细枝末节的问题，这儿就不提了。 实践后发现需要注意的地方： 1.名字标清楚 方便修改！做到后来，图层、元件各种文件越来越多，一定要在新建的时候就尽量标明。 2.多建图层 最好声音一个图层，按钮一个图层，背景一个图层，遮罩一个图层，mc一个图层，分好类！ 3.把同一类文件放入一个文件夹 如逐帧动画的素材，一个小动画就有几十张，放入文件夹方便查看。 4.分清“插入帧”、“插入关键帧”、“插入空白关键帧”、“删除帧”、“清除关键帧”的区别 插入帧：就是插入普通帧，是在前面一帧地基础上操作。 插入关键帧：关键帧的前后都可以和这一帧毫无关联！ 删除帧：一点痕迹也不留。 清除关键帧：关键帧是没了，还是一个普通帧。 5.已做逐帧动画的素材图片分类放入文件夹中时，不要剪切！ 可以直接拖进文件夹，千万不能剪切再粘贴进文件夹，否则之前做好的逐帧动画就都没了……我自己毁了两次才发现这个问题，上百帧啊…… 6.动画太快，把每一帧后面空一帧 相当于延时的作用。 7.记住几个快捷键 ctrl+F3 调出属性面板 F5插入普通帧 F6插入关键帧 F7插入空白关键帧 &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！ &lt;/span&gt;","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"http://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"Flash","slug":"Flash","permalink":"http://hubojing.github.io/tags/Flash/"},{"name":"动画","slug":"动画","permalink":"http://hubojing.github.io/tags/动画/"}]},{"title":"STC89C52RC单片机学习记录（1602篇）","slug":"STC89C52RC单片机学习记录","date":"2015-11-17T12:53:47.000Z","updated":"2016-03-26T13:27:33.245Z","comments":true,"path":"2015/11/17/STC89C52RC单片机学习记录/","link":"","permalink":"http://hubojing.github.io/2015/11/17/STC89C52RC单片机学习记录/","excerpt":"","text":"1.老式51单片机内部没有AD和DA转换模块 51单片机是一种比较经典的单片机，因此问世时间比avr时间长，它的芯片内部没有集成ad转换，而avr单片机芯片内部集成了ad转换，因此传统的51需要外接ad转换芯片，而avr不需要。不过随着时间的发展，新型的51单片机也有内部集成了ad芯片的，比如stc12c2052ad。 这也是为什么我们的课本上学AD、DA转换时，书上的例题都加了一个转换器如DAC0832、ADC0809的原因。 &lt;!--more--&gt; 2._nop_() 这个函数是延时一个机器周期的意思，它包含在头文件intrins.h中，只要程序应用到_nop_()，就需要有头文件intrins.h的声明。 1602液晶相关 3.几个引脚功能备注 第4脚：RS为寄存器选择，高电平1时选择数据寄存器、低电平0时选择指令寄存器。 第5脚：RW为读写信号线，高电平(1)时进行读操作，低电平(0)时进行写操作。 第6脚：E(或EN)端为使能(enable)端,高电平（1）时读取信息，负跳变时执行指令。 4.液晶显示程序的几点注释： LCD1602测忙： 1result = (bit)(P0 &amp; 0x80) (bit)强制转换成位，P0与0X80：0X80换成二进制就10000000也就是P0口的P0^7位。 1lcd_write(0,pos|0x80); 变量pos按位或0x80，也就是取出变量pos的最高位数据，传递给函数lcd_write()。此函数下面应该会有用到变量pos的地方，那里得到的pos不再是原来的数据了，按位或0x80后，就只有最高位是pos原来最高位的数据，其它位全部置位0。这个函数是设定DDRAM地址，也就是设定字符显示的首地址，它只执行了一个指令“向控制器写入0x80|pos的值（这是一个或表达式，表示POS变量与0X80相或，取其结果，0x80是KS0066内部指令的关键字，是表示指定DDRAM首地址的）。 忙还是那么忙，累却到了一个极点。但还是感到莫大的幸福。 &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！ &lt;/span&gt;","raw":null,"content":null,"categories":[{"name":"通信工程","slug":"通信工程","permalink":"http://hubojing.github.io/categories/通信工程/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"http://hubojing.github.io/tags/单片机/"}]},{"title":"matlab函数杂谈","slug":"matlab函数杂谈","date":"2015-11-10T08:39:08.000Z","updated":"2016-03-26T13:27:11.771Z","comments":true,"path":"2015/11/10/matlab函数杂谈/","link":"","permalink":"http://hubojing.github.io/2015/11/10/matlab函数杂谈/","excerpt":"","text":"写了两篇正儿八经的技术文，我觉得这好像不是我的风格，我是小清新啊小清新[微笑] 我是大家的开心果啊[微笑] 所以，学技术也要感受到快乐。来来，回归自己。 浅谈最近用matlab遇到的几个函数： 1.num2str str2num 对于一个刚学matlab不久的人，看到回调函数里满篇num2str、str2num内心满满的问号……这感觉就和十年前学英语一样…… 然而这个2，让我觉得这个函数很有意思…… 是的，2就是two啊！two音同to啊！ num2str，顾名思义，number to string，把数值转化成字符串。同理str2num我就不解释了。 嗯，程序员都是懒人，能省就省必须的。 &lt;!--more--&gt; 2.ezplot Easy to use function plotter！E Z PLOT 懒人的智慧 翻译：易用的一元函数绘图函数 使用之前要定义！要定义！要定义！ 符号函数定义法则：syms x; 那么问题来了，syms是什么鬼？ syms是定义符号变量。哦，我们就记得了，进行符号运算前要定义它，就用syms。 3.conv 数字信号处理，嗯哼，眼熟是不是？ 卷积卷积卷积！ 辨析：filter、conv、impz函数的区别 在MATLAB中，可以用函数y=filter(p,d,x)实现差分方程的仿真，也可以用函数 y=conv(x,h)计算卷积，用y=impz(p,d,N)求系统的冲激响应。具体例子百度一大推。 4.stem 同样数字信号处理里出现的。Stem函数用于绘图，它是绘制针状图的好手。 调用格式都为stem(n,x,'filled'); 只需要将需要绘制的数据存放在一个数组中，然后将这个数组作为参数传递给“stem”函数就可以得到输出图形。例如，下面的代码可以绘制正弦函数的图形： n=1:50; %定义序列的长度是50 x=zeros(1,50); %注意：MATLAB中数组下标从1开始 x(1)=1; %冲击函数 stem(x); %绘制函数图形 5.impulse 函数impulse（）将绘出由向量 a 和 b 表示的连续系统在指定时间范围内的冲激响应h(t)的时域波形图，并能求出指定时间范围内冲激响应的数值解。 impulse（）函数有如下四种调用格式： （1）impulse(b,a)：该调用格式以默认方式绘出向量 A和B定义的连续系统的冲激响应的时域波形。 （2）impulse(b,a,t)：绘出系统在 0～t 时间范围内冲激响应的时域波形。 （3）impulse(b,a,t1:p:t2)：绘出在 t1~t2 时间范围内，且以时间间隔 p均匀取样的冲激响应波形。 （4）y=impulse(b,a,t1:p:t2)：不绘出波形，而是求出系统冲激响应的数值解。 6.step step（）函数可绘出连续系统的阶跃响应 g(t)在指定时间范围的时域波形并能求出其数值解，和impulse（）函数一样也有四种调用格式。 （1）step(b,a)：该调用格式以默认方式绘出向量 A和B定义的连续系统的阶跃响应的时域波形。 （2）step(b,a,t)：绘出系统在 0～t 时间范围内阶跃响应的时域波形。 （3）step(b,a,t1:p:t2)：绘出在 t1~t2 时间范围内，且以时间间隔p均匀取样的阶跃响应波形。 （4）y=step(b,a,t1:p:t2)：不绘出波形，而是求出系统阶跃响应的数值解。 惊人相似有木有！impulse 和 step 一定是一家人~~ 先说这么多。最近比较忙。 &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！ &lt;/span&gt;","raw":null,"content":null,"categories":[{"name":"通信工程","slug":"通信工程","permalink":"http://hubojing.github.io/categories/通信工程/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://hubojing.github.io/tags/matlab/"},{"name":"函数","slug":"函数","permalink":"http://hubojing.github.io/tags/函数/"}]},{"title":"hexo优化·年轻就是折腾 | Promotion of the Blog & Young for Try","slug":"hexo优化","date":"2015-11-10T08:06:03.000Z","updated":"2016-11-20T09:28:25.720Z","comments":true,"path":"2015/11/10/hexo优化/","link":"","permalink":"http://hubojing.github.io/2015/11/10/hexo优化/","excerpt":"","text":"&lt;div align=&quot;left&quot;&gt; &lt;img src=&quot;http://7xray0.com1.z0.glb.clouddn.com/16-4-23/6883630.jpg&quot; width=&quot;300&quot; height=&quot;180&quot; alt=&quot;配图&quot; style=&quot;float:right;&quot;/&gt; 说明：本博客会长期优化，因此将之前所写相关文章合并到同一篇中，按倒序编排，以便查询。 (记录繁杂，暂不英译。) &lt;/div&gt; &lt;!--more--&gt; 2016.10.22更新 失踪人口短暂现身… 这么久没有更博内心有愧。其实有不定期更新github。 今天我十分惊讶于博客项目的deploy最近一次记录竟是8月，这说明了我近两个月来的微调都没有部署上来……难怪我的github不绿了！ 在仔细研读了我的config并确保没有问题后，我又一次hexo c,hexo g,hexo d三部曲，然后可怕的事情发生了：Cannot GET / 在搞垮博客几次后的我已经云淡风轻了，只有一个念头：我能修复好。废话不说了，进入正题： 解决方法：将npm重新安装一遍。这两个月一直想做成双语切换样式（目前中英文混编有些凌乱），可能意外删除了nodejs的部分文件，造成不能部署。但英文版各种bug，暂时放下，等考完再战。 npm -v查看npm版本命令。 对博客进行了小的调整： 1.压缩背景图片，每张100KB以内，提高了访问速度。 2.替换了失效的图片链接，去掉了github里项目|collections|里的极简图床，以自身血的教训证明，还是七牛云本身最稳定，不要偷懒，否则失效时眼泪止不住的流（滑稽）。 3.部分文章更新、重新排版。（前期初学markdown写的确实凌乱，中英混排也一并修改） 4.拖欠的友链已添加，失效的友链已更改。 5.为部分没有封面图的文章增添了封面图。 6.降低了封面背景透明度。 7.修改了多说头像CSS。 8.修改了评论框背景图。（快去捕捉一只野生皮卡丘！） 今天算是懂了，要做好前端，一定要懂PS。(可我明明是一个想做后端的人……) 下次更新：提交sitemap给必应。 同步托管至coding 具体操作之前我已另写一篇详细教程：http://hubojing.github.io/2016/04/06/%E5%B0%86hexo-github%E5%8D%9A%E5%AE%A2%E5%90%8C%E6%AD%A5%E6%89%98%E7%AE%A1%E8%87%B3coding/ 修改背景透明度 yelee/source/css/_variables.styl Background Color相关的4个变量，颜色为 RGBA. http://www.w3school.com.cn/cssref/css_colors_legal.asp 12345// Background Colorleft-col-color = rgba(255,255,255,.85)mid-col-color = rgba(255,255,255,.8)article-color = rgba(255,255,255,.45)archives-color = rgba(255,255,255,.4) 左侧背景更换 yelee/source/css/_partial/main.styl 原CSS： 12345678910111213141516171819202122232425.left-col &#123; background-image: url(http://lubiao.b0.upaiyun.com/c/2/2014/5/14/2/11/4d4059067181d8b7fbc9ac8920ff2764.jpg); width: left-col-width; position:fixed; opacity:1; transition:all .2s ease-in; height:100%; overflow-y: auto; .overlay&#123; width: 100%; height: 180px; background-color: black; position: absolute; opacity: 0.7; &#125; .intrude-less &#123; width: 76%; text-align: center; margin: 112px auto 0; &#125; li:hover &#123; background: none; font-weight: bold; &#125;; &#125; 效果图： 现CSS： 1234567891011121314151617181920.left-col &#123; background-image: url(/images/l1.jpg); background-size: cover; width: left-col-width; position:fixed; opacity:1; transition:all .2s ease-in; height:100%; overflow-y: auto; .intrude-less &#123; width: 76%; text-align: center; margin: 112px auto 0; &#125; li:hover &#123; background: none; font-weight: bold; &#125;; &#125; 效果图： 也许您认为之前的更好看，因为时间紧促，我没有花很多时间在图片选取和P图上，只是为了成功实现左边栏背景不同的效果。后期还会不断调试。 2016.4.23更新 提交sitemap给google和百度 目的：使谷歌和百度能够搜索到本博客 测试：可在浏览器中输入 谷歌： site:hubojing.github.io 百度： site:hubojing.coding.me 效果： 说明：百度蜘蛛爬不了github的网址，所以只好将博客同步部署到coding。详细步骤见：将hexo-github博客同步托管至coding 步骤 百度提交sitemap: install if your hexo version is 2.x.x, you should install as follow: 1npm install hexo-generator-baidu-sitemap@0.0.8 --save if version is 3.x.x, you should install as follow: 1npm install hexo-generator-baidu-sitemap@0.1.1 --save Update 12$ npm remove hexo-generator-baidu-sitemap$ npm install hexo-generator-baidu-sitemap --save Options if your hexo version is 2.x.x, you can configure this plugin in _config.yml. 12baidusitemap: path: baidusitemap.xml if version is 3.x.x, you should configure this plugin in _config.yml. 12baidusitemap:path: baidusitemap.xml path - Sitemap path. (Default: baidusitemap.xml) Errors Maybe response is &quot;hexo is not definded&quot;,then you should: 12cd node_modules/hexo-generator-baidu-sitemap/npm install 谷歌的提交方法是类似的。 2016.3.1更新 公共/独立空间评论切换 yelee/layout/_partial/article.ejs, 把 “key: post.path” 改为 “key: post.slug”，主题多说配置 domain: true 这样就恢复到 Yilia 的公共评论了。 将“more”改为“阅读全文” 主题配置_config.yml里更改： 1excerpt_link: 阅读全文 2016.2.28更新 这轮优化很多都挺成功，就是之前的评论都丢失了……桑心。欢迎大家留言安慰我^_^ 主题更换 采取了更为美观的主题，并且有了文章内检索目录，我很喜欢。 记得修改 Hexo 根目录对应配置文件。 theme: yelee 图片插入 对于hexo，有两种方式： 1.使用本地路径：在hexo/source目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时链接即为/img/图片名称。 2.使用微博图床，地址http://weibotuchuang.sinaapp.com ，将图片拖入区域中，会生成图片的URL，这就是链接地址。 以上是查找的资料。 2016.3.1更新 本地图片插入问题解决 效果： 之前本地服务器浏览可以看到图片，但部署上去就无法加载。 这是因为!测试图片是绝对地址。但有相关文章说绝对地址也是可以的，但我一直没有实现，这一点有待考察。上述成功用的是相对地址。!测试图片 后来准备用七牛作图床。～～用极简图床真是特别方便～～ About Page 关于我页面 使用以下代码添加一个新页面： $ hexo new page about Tags Cloud Page 标签云页面 $ hexo new page tags Comment 评论 多说: http://duoshuo.com/create-site/ 登陆你的多说并创建站点，在 &quot;domain&quot; 中填入你设定的域名的前半部分。比如完整域名是: http://ABC.duoshuo.com ，只需填入 ABC 即可。 我之前就没设置站点……不知道还能不能找回来评论？（可以） 主页链接 我把我网易云音乐的主页链接放上来了，欢迎大家和我交流轻音乐。（移动端看不到我的主页，只有PC端可以看到。） 细节 一些细节改变挺多，不知道看过我之前博客样子的访客能找到多少改变之处？欢迎评论。 2015.11.10更新 关于主题 安装 1$ git clone git@github.com:XXX/xxx.git themes/xxx 更新 12$ cd themes/xxx$ git pull 关于统计 两种方法： 1.google/baidu统计 google登不上去，就用百度吧。先去百度统计注册一个账号，把你的域名输入作为被统计的网页。 它会自动生成一段代码，复制下来。 在主题下的_config.yml添加： 1$ baidu_tongji: true 接着，在主题目录下的layout\\ _partial找到head.ejs 打开它，在 &lt; head&gt; 和 &lt; /head&gt; 中粘贴代码即可。 2.不蒜子 不蒜子 两行代码解决。只不过只能显示总人数或每篇文章浏览数。 网站小图标 把.ico图标放入themes主题里的source目录下！ 推荐比特虫，在线制作图标。 同时加入代码。 categories、tags 在主题目录的_config.yml中修改成 XXX: /categories/XXX 或 XXX: /tags/XXX 注意空格和英文的冒号。 更改相关字体、颜色等细节 这个简单，找到hexo\\themes\\light\\source\\css_partial\\main.styl,里面就是基本构架，就是代码有点长，耐心找找。这个级别代码一点都不长…… 搭建问题的解决方案 具体操作之前我已另写一篇详细教程：http://hubojing.github.io/2015/11/06/hexo+github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/ 以上。 参考资料 不蒜子 为hexo主题添加多种图片样式 hexo在github上构建免费的Web应用 极简图床 解决hexo置顶问题 hexo全部模板 比特虫 hexo你的博客 Sitemap generation Hexo ：（三）高级进阶 hexo主题中添加相册功能 &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！ The article has been viewed &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; times.Thank you for your visit! &lt;/span&gt;","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"http://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://hubojing.github.io/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"http://hubojing.github.io/tags/hexo/"},{"name":"优化","slug":"优化","permalink":"http://hubojing.github.io/tags/优化/"}]},{"title":"hexo+github博客搭建中出现的问题及解决方法 | The Solution of Troubles in Establishing My Blog","slug":"hexo+github博客搭建中出现的问题及解决方法","date":"2015-11-06T12:35:37.000Z","updated":"2016-10-23T15:28:34.498Z","comments":true,"path":"2015/11/06/hexo+github博客搭建中出现的问题及解决方法/","link":"","permalink":"http://hubojing.github.io/2015/11/06/hexo+github博客搭建中出现的问题及解决方法/","excerpt":"","text":"&lt;div align=&quot;left&quot;&gt; &lt;img src=&quot;http://7xray0.com1.z0.glb.clouddn.com/hexo+github.png&quot; width=&quot;300&quot; height=&quot;180&quot; alt=&quot;配图&quot; style=&quot;float:right;&quot;/&gt; hexo+github博客搭建中出现的问题及解决方法。 博客优化和高级进阶请看hexo优化·年轻就是折腾! &lt;/div&gt; &lt;!--more--&gt; 2016.8.28更新 Update 插件 plug-in unit 123456789npm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-server --savenpm install hexo-deployer-git --savenpm install hexo-generator-sitemap --savenpm install hexo-generator-feed --savenpm install hexo-git-backup --save hexo插件 2016.4.7更新 Update 每次hexo d之后都要输入密码，很影响心情，于是决定重新设定SSH，这次不再设定密码。现把流程记录下来备忘。 It affects mood to input password everytime I execute hexo d.So I decide to reset SSH and no password.Now write the steps down. 几条重要指令 Several important instructions 查看是否存在SSH文件。 To cheak if SSH file exists. 1ls -al ~/.ssh 存在的话，直接删除.ssh文件夹里面所有文件，同时在github上删除SSH。 Delete all the files if it exist and delete SSH on the github. 1ssh-keygen -t rsa -C \"4177997456@qq.com\" 回车三次（因为密码为空）。 Press enter three times(for keyword is empty). 1ssh-agent -s 1ssh-add ~/.ssh/id_rsa 出错。Something wrong. 换成 Change into 12eval `ssh-agent -s`ssh-add 完成。Finish. 可以直接打开.ssh文件夹里的id_rsa.pub复制全部内容，也可以输入 You can copy id_rsa.pub in the .ssh file,or input 1clip &lt; ~/.ssh/id_rsa.pub 然后在github里设置好SSH即可。 then set SSH on the github. 最后测试一下： Test it finally, 1ssh -T git@github.com 如果出现 证明设置好了。 If it shows that all is done. 然而…… However~ 依！然！报！错！ Still wrong! 这是为什么……在hexo d好几次后的我凌乱在风中…… 但我没有放弃……毕竟不能把博客玩废啊是不是:-D 我想起来昨天把博客同步托管在github和coding上了。 因为我的repo先写的coding，再写的github，所以服务器先连接coding，后连接github！！！ 两个托管网站都要设置好SSH之后，才能顺利部署！ 完工！ 再也不用打密码啦~ WHY?!After several times hexo d,I was messy in the wind~ But I'm never give up~I can't destory my blog after all :D I remind of having got my blog hosted on GitHub and coding yesterday. My repo place coding to the front,so the sever links coding first,then the github!!! Only two host webs be setted SSH,can it be well deployed! Finish! Never using password~ Say goodbye to you~ 2015.11.06更新 Update 今天建好了大体的框架，细节还需不断调整。现把我搭建过程中出现的若干问题以及解决方案写下来，方便自己及读者不再为这些地方犯难。 Today the frame generally build,and details needs improving. Now I note my problems and solutions for the readers no longer to puzzle again. 安装 Install 安装顺序不要错，出现WARN不用管。 我们都知道需要安装git和node.js，然后才能安装hexo。 简单介绍：Hexo 是一个快速、简洁且高效的基于Node的静态博客框架。 按理来说，从官网把软件下载下来安装，一路next就行。 打开git bash命令行，输入： Installation sequence is important,and you can ignore the warning in the process. We know that git and node.js are needed,and then hexo can be installed. In brief,hexo is a fast, simple and efficient static blog framework which bases on Node. Having downloaded the software and installed,and then you just click &quot;next&quot;. Input this in the git bash: 1$ npm install -g hexo-cli 这时会发现，和很多教程所授不同啊！出现了多个WARN。不要慌！WARN可以不用管。我当时查了很久，怎么才能不WARN，后来发现其实不影响之后的搭建。 At this moment you will puzzle that it is different with many tutorials.It turns out some warning!Calm down,guys,you can ignore them.It doesn't matter. 开始建站 Set 建站前直接在目标盘建立一个hexo文档，对hexo右键git bash。 记住一定在目标目录里建站！ 一开始我不清楚，点击桌面上的git bash就输命令，后来都不好找hexo文件在哪，严重影响之后的体验！ 之后同样的，npm加到目标目录中！ At first,you should create a hexo file,and git bash with right click. Remember to set your blog in the target file! I made the mistake that git bash on the desktop,which resulted in the loss of hexo file.It's bad for later set. And then,the same,add npm to the target file! 1$ npm install 就这三步，本地的网站其实就建立好了！看起来好简单！运气不好的话就会像我一样，卡在最开始耽误了很多时间。 Having done these three steps,our local web is already set!Is it really easy?But you may waste much time as I did. 本地预览 Local preview 因为在Hexo 3.0后server被单独出来了,需要安装server,记住打下面一行代码： Because server was divided after hexo 3.0,you should install server,and remember these code, 1$ npm install hexo-server --save 之后是： and then, 1$ hexo server 本地端口已经打开，通过浏览器访问http://localhost:4000/ 可以看到网站。 The local port has set,and you can cheak on http://localhost:4000/ through browser. 注意细节 Pay attention to details 下载一个编辑器，我下载的是Sublime Text 2，一定要有编辑器，否则很多属性不能修改。 找到hexo文件夹，打开_config.yml，这里面就是网站的配置信息。具体配置hexo讲的很明白，我就不解释了。 我刚开始就是胡乱搭建，找不到hexo文件，更不用谈之后的配置。这里要擅用电脑里的文件搜索，有它还是可以方便的找出文件。 Hexo采用markdown语法格式书写博客，其中我们的博文就放在source里的_posts目录。 To download a editor.What I use now is Sublime 2.You need a editor for modify attributes. The _config.yml in the hexo file is the web configuration information.The specific configuration I won't say it here. I structures it at random at first,because I couldn't find hexo file.A good tip is to use file search to find what you want conveniently. Hexo uses markdown grammer to write,and our articles are saved in the _posts file. 写新文章 Create a new article 1$ hexo new title 其中title为你的博文文件的文件名，不一定是博文的标题，只要自己看得懂就行。然后点开source里的_posts目录，打开title.md，我们就可以在里面进行写作了。当然，有一些语法规定及格式要求，我也还在学习中。 The title is your article file name,not your article name,so just you understand is alright. 之后需要静态化页面： 1$ hexo generate hexo部署： 1$ hexo deploy 此时本地站点大体搭建好了。 Now the local site is set. 如果配置_config.yml出错，本地网站是一定搭不好的！ 而_config.yml中比较难发现的就是，每一个红体单词冒号后要空格！！！ If the _config.yml is wrong,your site can't be create. The detail easy to overlook is that there leaves a blank space after colon!!! 接下来把网站部署到github上。 首先去github上注册个账号。 再建立一个新的repositories。名称是username.github.io，这也是最终搭建好的博客的链接地址。 The following thing is to deploy the site on the github. At the beginning,you should have a github account. Then you should create a new repositories,which name is username.github.io,and it is your blog link address. 勿用github自动页面生成器 Do not use the github automatic page generator 尤其初学者！否则之后的hexo博客很难部署上去！ 如果已经用了自动页面生成器，可以删除这一个repositories，再新建一个。 在完成上述操作后，到Hexo文件夹下的_config.yml文件，将最下方的deploy部分修改为 Exspecially a beginer! If you use it already,you can delete this repositories,and create another. After all the steps done,revise the deploy of the _config.yml as 123$ deploy type: git repo: git@github.com:username/username.github.io.git 每个冒号后有一个空格！！！ 到此，github配置完成。 There leaves a blank space after each colon!!!* So much for that,the deploy is done. 现在要把hexo和github联系在一起，还需要SSH。 首先,打开git bash: If hexo links to github,SSH is needed. Open git bash, 12$ git config --global user.name \"XXX\"$ git config --global user.email \"XXXXXX@mail.com\" 邮箱是你注册github的邮箱。 生成密钥： The e-mail is your github e-mail. Create private key, 1$ ssh-keygen -t rsa -C “XXXXXX@mail.com” 然后设置路径，最好不要更改id_rsa和id_rsa.pub的名字。 密码可有可无(最好无)，但输入时你也看不到自己输的密码的。 登录github，在右上角settings（不是repositories里的settings）有SSH keys。 复制你设置路径里的id_rsa.pub用编辑器打开得到的代码，粘贴到SSH keys，标题自定义。 验证： Set path,and don't change id_rsa and id_rsa.pub name. The password is not esstial(none maybe convinent),but you can't see it when you enter the code. Then you sign in the github,and finds SSH keys in the setting(not setting in the repositories). Copy your code in the id_rsa.pub,and paste it to SSH keys.Customizable title is needed. Verity, 1$ ssh -T git@github.com 一般来说，是会报错的。Permission denied (publickey).让多少人揪心的一句话。 Generally,something goes wrong.&quot;Permission denied (publickey)&quot;,may let you not happy. 复制公钥 Copy public key 用计算机搜索文件.ssh文件，找出目标路径，之前设置的id_rsa和id_rsa.pub复制到这里来！ 同时，如果多次设置SSH，最好把其中一个known开头的文件里前几次的公钥清空。 成功的标志： Search .ssh file in the computer,and paste id_rsa and id_rsa.pub to it. If you set SSH many times,you'd better clear the previous public key in the known-start file. The success sign, 1$ Hi username! You've successfully authenticated, but GitHub does not provide shell access. 最后， In the end, 12$ npm install hexo-deployer-git --save$ hexo deploy 基本指令 Basic instructions 每次修改或者发文后，这两条命令一定要打，否则博客不能更新： Everytime you revise or create a article,two instrucions are needed,or your post can't be updated. 12$ hexo generate$ hexo deploy $ hexo server 为在本地端口打开。 (简记abbreviation hexo g hexo s hexo d) 期间还遇到一些小问题，不典型，就不说啦。总之，初学者刚开始搭建一定要有耐心，我仅是node.js就重装了五遍以上，有时候看教程很复杂，其实一步步做不难！不要放弃！跟着一个教程做出现问题时，及时在网上寻求答案，查看其它的教程。我在搭建此博客时，查阅的教程几十种了，很多人的方法很好，也算是走捷径了！ There exists many small problems in the process.In short,the patience is vital during the course.According to me,I reset node.js for more than five times.The tutorial maybe complex,but you can feel easy if you do it step by step!Never give up!When any problem arise,it is useful to search solutions on the internet or looking up in another tutorial.I call the tips a shortcut. 以上，就是我搭建过程中出现的问题及解决方案。 Above,it is the problems and solutions in the process. 参考资料 Reference material 1.hexo与github_pages搭建博客教程 2.hexo你的博客 3.hexo干货系列（一） 4.hexo常见问题解决方案 &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！ The article has been viewed &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; times.Thank you for your visit! &lt;/span&gt;","raw":null,"content":null,"categories":[{"name":"互联网","slug":"互联网","permalink":"http://hubojing.github.io/categories/互联网/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://hubojing.github.io/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"http://hubojing.github.io/tags/hexo/"}]},{"title":"Hello World！","slug":"Hello World","date":"2015-11-06T05:23:40.000Z","updated":"2017-04-22T13:54:55.583Z","comments":true,"path":"2015/11/06/Hello World/","link":"","permalink":"http://hubojing.github.io/2015/11/06/Hello World/","excerpt":"","text":"&lt;div align=&quot;left&quot;&gt; &lt;img src=&quot;http://7xray0.com1.z0.glb.clouddn.com/16-5-13/17269536.jpg&quot; width=&quot;300&quot; height=&quot;180&quot; alt=&quot;配图&quot; style=&quot;float:right;&quot;/&gt; 利用一周零零碎碎的时间搭建起来，使用hexo在github上的个人独立博客初见雏形。 &lt;/div&gt; &lt;!--more--&gt; 作为一名通信人，始终要记住科学技术是第一生产力！ 大三已至，也算入了互联网+通信领域的门。入门不难，深造不易。将把自己在学习中和实践中的技术经验以及点滴收获记录下来，作为自己在技术之路的见证和成长。 读者可以随时在文章下方评论，以及与我联系，欢迎学术交流，难题沟通，批评指正，尤其是专业相关（比如数模电）、数学方面（数学虐我千百遍，我待数学如初恋[笑]）。自觉天资不高，但对于技术，心向往之，但愿各位指点一二。 I manage to find time to build this blog for a week,which used hexo static frame on the github,and it is finished preliminarily. As a Communication man,we should always keep in mind that science and technology are primary productive force! I'm already learn elementary courses since I'm a junior student today. To cross the threshold is not difficult, but mastery is another question.Therefore,I will take notes on the blog through the learning and practice process,to witness my growth on the way. Readers can commit on the bottom of the article,and contact with me.Welcome academic exchange and question communication.You can oblige me with your valuable comments about major related(digital electronic technology or analog electronic technology,for instance),especially math problem(^_^I am fond of mathematic).I'm not talent,but I'm adore of IT.I would appreciate it if you give me some guidance. Talk is cheap,show me the code! Just do IT！ &lt;!--more--&gt; &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文已被阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次。感谢您的点击！ &lt;/span&gt;","raw":null,"content":null,"categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hubojing.github.io/categories/杂谈/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://hubojing.github.io/tags/idea/"}]}]}